export type ExploitTemplateDomain = "PWN" | "CRYPTO";

export interface ExploitTemplateEntry {
  domain: ExploitTemplateDomain;
  id: string;
  title: string;
  body: string;
}

const TEMPLATES: ExploitTemplateEntry[] = [
  {
    domain: "PWN",
    id: "pwntools-skeleton",
    title: "Pwntools exploit skeleton (local/remote)",
    body: [
      "```python",
      "from pwn import *",
      "",
      "context.binary = elf = ELF('./chall')",
      "context.log_level = 'info'",
      "",
      "HOST = '127.0.0.1'",
      "PORT = 1337",
      "",
      "def start(argv=[]):",
      "    if args.REMOTE:",
      "        return remote(HOST, PORT)",
      "    return process([elf.path] + argv)",
      "",
      "io = start()",
      "",
      "# TODO: trigger bug, get primitive (leak/write/control)",
      "# TODO: build payload",
      "",
      "io.interactive()",
      "```",
      "",
      "Run:",
      "- local: python3 exp.py",
      "- remote: python3 exp.py REMOTE",
    ].join("\n"),
  },
  {
    domain: "PWN",
    id: "ret2libc-outline",
    title: "ret2libc outline (leak -> libc base -> system)",
    body: [
      "```text",
      "1) Leak a libc address (puts/printf/read/write) via GOT or stack.",
      "2) Compute libc_base = leaked - libc.symbols[<fn>].",
      "3) system = libc_base + libc.symbols['system'].",
      "4) binsh = libc_base + next(libc.search(b'/bin/sh\\x00')).",
      "5) Build ROP: ret (stack align if needed) -> system(binsh).",
      "6) Verify deterministically: repeat run, then remote parity.",
      "```",
    ].join("\n"),
  },
  {
    domain: "CRYPTO",
    id: "padding-oracle-loop",
    title: "Padding oracle loop skeleton (bytewise)",
    body: [
      "```python",
      "# Skeleton: adapt to your oracle and block mode.",
      "# Goal: recover plaintext or forge a valid ciphertext using a padding oracle.",
      "",
      "def oracle(ciphertext: bytes) -> bool:",
      "    \"\"\"Return True iff padding is valid (or error differs).\"\"\"",
      "    raise NotImplementedError",
      "",
      "def split_blocks(data: bytes, bs: int) -> list[bytes]:",
      "    return [data[i:i+bs] for i in range(0, len(data), bs)]",
      "",
      "# TODO: implement bytewise attack for your protocol",
      "```",
    ].join("\n"),
  },
  {
    domain: "CRYPTO",
    id: "ecb-byte-at-a-time",
    title: "ECB byte-at-a-time outline (oracle)",
    body: [
      "```text",
      "1) Confirm ECB: identical blocks => identical ciphertext blocks.",
      "2) Find block size by measuring ciphertext length steps.",
      "3) For each unknown byte: craft prefix so next unknown byte aligns at block end.",
      "4) Build dictionary of 256 candidates; match oracle output block.",
      "5) Stop-loss: if mismatch, re-check padding/encoding/normalization assumptions.",
      "```",
    ].join("\n"),
  },
];

export function listExploitTemplates(domain?: ExploitTemplateDomain): Array<Omit<ExploitTemplateEntry, "body">> {
  return TEMPLATES.filter((t) => (domain ? t.domain === domain : true)).map(({ body: _body, ...rest }) => rest);
}

export function getExploitTemplate(domain: ExploitTemplateDomain, id: string): ExploitTemplateEntry | null {
  const normalizedId = id.trim();
  if (!normalizedId) {
    return null;
  }
  return TEMPLATES.find((t) => t.domain === domain && t.id === normalizedId) ?? null;
}
